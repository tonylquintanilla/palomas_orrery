{
  "apsidal_markers.get_apsidal_terms": {
    "id": "apsidal_markers.get_apsidal_terms",
    "name": "get_apsidal_terms",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [],
    "source_code": "def get_apsidal_terms(center_body):\n    \"\"\"\n    Get appropriate apsidal terminology for a given central body.\n    \n    Parameters:\n        center_body: Name or ID of the central body (str or int)\n        \n    Returns:\n        tuple: (periapsis_term, apoapsis_term)\n        \n    Examples:\n        >>> get_apsidal_terms('Sun')\n        ('Perihelion', 'Aphelion')\n        >>> get_apsidal_terms('Jupiter')\n        ('Perijove', 'Apojove')\n        >>> get_apsidal_terms('599')  # Jupiter by ID\n        ('Perijove', 'Apojove')\n        >>> get_apsidal_terms('Ceres')  # Unknown body\n        ('Periapsis', 'Apoapsis')\n    \"\"\"\n    # Convert to string if numeric ID\n    center_key = str(center_body)\n    \n    # Try exact match first\n    if center_key in APSIDAL_TERMINOLOGY:\n        return APSIDAL_TERMINOLOGY[center_key]\n    \n    # Try case-insensitive match for names\n    for key, value in APSIDAL_TERMINOLOGY.items():\n        if key.lower() == center_key.lower():\n            return value\n    \n    # Fallback to generic terms for unknown bodies\n    return ('Periapsis', 'Apoapsis')",
    "start_line": 49,
    "end_line": 82,
    "has_docstring": true,
    "docstring": "Get appropriate apsidal terminology for a given central body.\n\nParameters:\n    center_body: Name or ID of the central body (str or int)\n    \nReturns:\n    tuple: (periapsis_term, apoapsis_term)\n    \nExamples:\n    >>> get_apsidal_terms('Sun')\n    ('Perihelion', 'Aphelion')\n    >>> get_apsidal_terms('Jupiter')\n    ('Perijove', 'Apojove')\n    >>> get_apsidal_terms('599')  # Jupiter by ID\n    ('Perijove', 'Apojove')\n    >>> get_apsidal_terms('Ceres')  # Unknown body\n    ('Periapsis', 'Apoapsis')",
    "parameters": [
      "center_body"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_apsidal_terms",
    "component_id": "apsidal_markers.get_apsidal_terms"
  },
  "apsidal_markers.calculate_orbital_angle_shift": {
    "id": "apsidal_markers.calculate_orbital_angle_shift",
    "name": "calculate_orbital_angle_shift",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [],
    "source_code": "def calculate_orbital_angle_shift(ideal_pos, actual_pos):\n    \"\"\"\n    Calculate the angular separation between Keplerian and actual positions.\n    Both positions should be dictionaries with 'x', 'y', 'z' keys.\n    \"\"\"\n    import numpy as np\n    \n    # Convert positions to vectors\n    ideal_vec = np.array([ideal_pos['x'], ideal_pos['y'], ideal_pos['z']])\n    actual_vec = np.array([actual_pos['x'], actual_pos['y'], actual_pos['z']])\n    \n    # Calculate magnitudes (should be similar for perihelion)\n    ideal_r = np.linalg.norm(ideal_vec)\n    actual_r = np.linalg.norm(actual_vec)\n    \n    # Calculate angle between vectors using dot product\n    dot_product = np.dot(ideal_vec, actual_vec)\n    cos_angle = dot_product / (ideal_r * actual_r)\n    \n    # Handle numerical errors\n    cos_angle = np.clip(cos_angle, -1.0, 1.0)\n    \n    # Calculate angle in degrees\n    angle_deg = np.degrees(np.arccos(cos_angle))\n    \n    # Calculate distance difference as well\n    delta_r = abs(actual_r - ideal_r)\n    \n    return angle_deg, delta_r, ideal_r, actual_r",
    "start_line": 84,
    "end_line": 112,
    "has_docstring": true,
    "docstring": "Calculate the angular separation between Keplerian and actual positions.\nBoth positions should be dictionaries with 'x', 'y', 'z' keys.",
    "parameters": [
      "ideal_pos",
      "actual_pos"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_orbital_angle_shift",
    "component_id": "apsidal_markers.calculate_orbital_angle_shift"
  },
  "apsidal_markers.create_enhanced_apsidal_hover_text": {
    "id": "apsidal_markers.create_enhanced_apsidal_hover_text",
    "name": "create_enhanced_apsidal_hover_text",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [
      "apsidal_markers.calculate_orbital_angle_shift"
    ],
    "source_code": "def create_enhanced_apsidal_hover_text(obj_name, marker_type, date, actual_pos, \n                                       ideal_pos=None, params=None, is_perihelion=True,\n                                       center_body='Sun'):\n    \"\"\"\n    Create informative hover text for apsidal markers with perturbation notes.\n    \"\"\"\n    import numpy as np\n    \n    # Base hover text\n    actual_r = np.sqrt(actual_pos['x']**2 + actual_pos['y']**2 + actual_pos['z']**2)\n    \n    hover_text = f\"<b>{obj_name} {marker_type}</b><br>\"\n    hover_text += f\"Date: {date}<br>\"        \n#    hover_text += f\"Distance from {center_body}: {actual_r:.6f} AU<br>\"\n    hover_text += f\"Distance from center: {actual_r:.9f} AU<br>\"\n        \n    # Add distance from surface for perihelion if center body radius is known\n    if is_perihelion and center_body in CENTER_BODY_RADII:\n        center_radius_km = CENTER_BODY_RADII[center_body]\n        center_radius_au = center_radius_km / 149597870.7  # km to AU\n        surface_distance_au = actual_r - center_radius_au\n        surface_distance_km = surface_distance_au * 149597870.7\n        hover_text += f\"Distance from surface: {surface_distance_au:.6f} AU ({surface_distance_km:,.0f} km)<br>\"\n    \n    # DEBUG: Log all conditions for perturbation analysis\n\n    print(f\"[HOVER DEBUG] {obj_name} {marker_type}:\", flush=True)\n    print(f\"  ideal_pos is not None: {ideal_pos is not None}\", flush=True)\n    print(f\"  params is not None: {params is not None}\", flush=True)\n    if params:\n        print(f\"  'epoch' in params: {'epoch' in params}\", flush=True)\n        if 'epoch' in params:\n            print(f\"  epoch value: {params['epoch']}\", flush=True)\n    \n    # Add perturbation analysis if we have ideal position\n    if ideal_pos and params and 'epoch' in params:\n        angle_deg, delta_r, ideal_r, actual_r = calculate_orbital_angle_shift(ideal_pos, actual_pos)\n        print(f\"  angle_deg: {angle_deg:.3f} deg\", flush=True)\n        \n        # Determine if this is significant\n\n        # Determine if this is significant\n        epoch = params.get('epoch', 'unknown')\n        \n        if angle_deg > 0.5:  # Significant perturbation detected\n            hover_text += \"<br><b>Perturbation Analysis:</b><br>\"\n            hover_text += f\"Keplerian orbit epoch: {epoch}<br>\"\n            \n            # Add angular shift\n            if angle_deg > 10:\n                hover_text += f\"<b>Angular shift: {angle_deg:.1f} deg</b> (high)<br>\"\n            elif angle_deg > 5:\n                hover_text += f\"Angular shift: {angle_deg:.1f} deg (moderate)<br>\"\n            else:\n                hover_text += f\"Angular shift: {angle_deg:.3f} deg (low)<br>\"\n            \n            # Add distance comparison\n            hover_text += f\"Keplerian distance: {ideal_r:.6f} AU<br>\"\n            hover_text += f\"Actual distance: {actual_r:.6f} AU<br>\"\n            hover_text += f\"Difference: {delta_r:.6f} AU<br>\"\n            \n            # Add explanation based on time span\n            if is_perihelion and 'TP' in params:\n                from astropy.time import Time\n                tp_time = Time(params['TP'], format='jd')\n                years_from_epoch = (tp_time.datetime.year - int(epoch.split('-')[0]))\n                \n                if years_from_epoch > 20:\n                    hover_text += f\"<br><i>Note: {years_from_epoch} years of perturbations<br>\"\n                    hover_text += \"from Jupiter/Saturn have shifted the orbit</i><br>\"\n                elif years_from_epoch > 5:\n                    hover_text += f\"<br><i>Note: {years_from_epoch} years of accumulated<br>\"\n                    hover_text += \"perturbations since epoch</i><br>\"\n            \n            # Special note for high eccentricity objects\n            if params.get('e', 0) > 0.9:\n                hover_text += \"<br><i>High eccentricity makes this object<br>\"\n                hover_text += \"particularly sensitive to perturbations</i><br>\"\n            \n        else:  # Low deviation at this point\n            hover_text += \"<br><b>Perturbation Analysis:</b><br>\"\n            hover_text += f\"Keplerian orbit epoch: {epoch}<br>\"\n            hover_text += f\"Angular shift: {angle_deg:.3f} deg (low)<br>\"\n            hover_text += f\"Keplerian distance: {ideal_r:.6f} AU<br>\"\n            hover_text += f\"Actual distance: {actual_r:.6f} AU<br>\"\n            hover_text += f\"Difference: {delta_r:.6f} AU<br>\"\n            hover_text += \"<i>Note: Low deviation expected near epoch.<br>\"\n            hover_text += \"Osculating orbit is calibrated to match<br>\"\n            hover_text += \"position & velocity at this moment.</i><br>\"\n\n    return hover_text",
    "start_line": 114,
    "end_line": 204,
    "has_docstring": true,
    "docstring": "Create informative hover text for apsidal markers with perturbation notes.",
    "parameters": [
      "obj_name",
      "marker_type",
      "date",
      "actual_pos",
      "ideal_pos",
      "params",
      "is_perihelion",
      "center_body"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_enhanced_apsidal_hover_text",
    "component_id": "apsidal_markers.create_enhanced_apsidal_hover_text"
  },
  "apsidal_markers.add_actual_apsidal_markers_enhanced": {
    "id": "apsidal_markers.add_actual_apsidal_markers_enhanced",
    "name": "add_actual_apsidal_markers_enhanced",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [
      "apsidal_markers.get_apsidal_terms",
      "apsidal_markers.create_enhanced_apsidal_hover_text"
    ],
    "source_code": "def add_actual_apsidal_markers_enhanced(fig, obj_name, params, date_range, positions_dict, \n                                       color_map, center_body='Sun', is_satellite=False,\n                                       ideal_apsides=None, filter_by_date_range=True):\n    \"\"\"\n    Enhanced version that compares actual vs Keplerian positions.\n    Maintains all original parameters for backward compatibility.\n    \n    Parameters:\n        fig: Plotly figure object\n        obj_name: Name of the object\n        params: Orbital parameters dictionary\n        date_range: Tuple of (start_date, end_date) for filtering\n        positions_dict: Dictionary of positions at apsidal dates\n        color_map: Function to get color for object\n        center_body: Name of central body (Sun, planet, etc.)\n        is_satellite: Boolean indicating if this is a satellite\n        ideal_apsides: Dictionary with 'periapsis' and 'apoapsis' Keplerian positions\n        filter_by_date_range: If False, plot all apsidal dates in positions_dict\n            regardless of date_range (useful for future apsides)\n    \"\"\"\n    from datetime import datetime\n    import plotly.graph_objects as go\n      \n    # Get parent-specific terminology (same as ideal markers)\n#    near_term, far_term = get_apsidal_terms(center_body)\n#    near_label = f\"Actual {near_term}\"\n#    far_label = f\"Actual {far_term}\"\n\n    # Get parent-specific terminology (same as ideal markers)\n    near_term, far_term = get_apsidal_terms(center_body)\n    \n    # Add epoch to label if available\n    epoch = params.get('epoch', '')\n    if epoch:\n        epoch_suffix = f\" (Epoch: {epoch})\"\n    else:\n        epoch_suffix = \"\"\n    \n    near_label = f\"Keplerian {near_term}{epoch_suffix}\"\n    far_label = f\"Keplerian {far_term}{epoch_suffix}\"\n\n    # Use same key names for ALL objects\n    near_dates = params.get('perihelion_dates', [])\n    far_dates = params.get('aphelion_dates', [])\n\n    # Convert date strings to datetime objects for comparison\n    near_dates_dt = []\n    for d in near_dates:\n        try:\n            dt = datetime.strptime(d, '%Y-%m-%d %H:%M:%S')\n        except ValueError:\n            dt = datetime.strptime(d, '%Y-%m-%d')\n        near_dates_dt.append(dt)\n    \n    far_dates_dt = []\n    for d in far_dates:\n        try:\n            dt = datetime.strptime(d, '%Y-%m-%d %H:%M:%S')\n        except ValueError:\n            dt = datetime.strptime(d, '%Y-%m-%d')\n        far_dates_dt.append(dt)\n    \n    # Filter dates if date_range is provided\n#    if date_range:\n    if date_range and filter_by_date_range:\n        start_date, end_date = date_range\n        near_dates_dt = [d for d in near_dates_dt if start_date <= d <= end_date]\n        far_dates_dt = [d for d in far_dates_dt if start_date <= d <= end_date]\n    \n    # Add markers for near points (perihelion/perigee)\n    for date in near_dates_dt:\n        date_key = date.strftime('%Y-%m-%d')\n        \n        if date_key in positions_dict:\n            actual_pos = positions_dict[date_key]\n            \n            # Get ideal position if available\n            ideal_pos = ideal_apsides.get('periapsis') if ideal_apsides else None\n            \n            # Create enhanced hover text\n            hover_text = create_enhanced_apsidal_hover_text(\n                obj_name, \n                near_label,\n                date.strftime('%Y-%m-%d %H:%M:%S'),\n                actual_pos,\n                ideal_pos,\n                params,\n                is_perihelion=True,\n                center_body=center_body\n            )\n            \n            fig.add_trace(go.Scatter3d(\n                x=[actual_pos['x']],\n                y=[actual_pos['y']],\n                z=[actual_pos['z']],\n                mode='markers',\n                marker=dict(\n                    size=8,\n                    color='white',\n                    symbol='square-open'\n                ),\n                name=f\"{obj_name} {near_label}\",\n                text=[hover_text],\n                customdata=[f\"{obj_name} {near_label}\"],  # Added\n                hovertemplate='%{text}<extra></extra>',   # Fixed format\n                showlegend=True\n            ))\n    \n    # Add markers for far points (aphelion/apogee)\n    for date in far_dates_dt:\n        date_key = date.strftime('%Y-%m-%d')\n        \n        if date_key in positions_dict:\n            actual_pos = positions_dict[date_key]\n            \n            # Get ideal position if available\n            ideal_pos = ideal_apsides.get('apoapsis') if ideal_apsides else None\n            \n            hover_text = create_enhanced_apsidal_hover_text(\n                obj_name,\n                far_label, \n                date.strftime('%Y-%m-%d %H:%M:%S'),\n                actual_pos,\n                ideal_pos,\n                params,\n                is_perihelion=False,\n                center_body=center_body\n            )\n            \n            fig.add_trace(go.Scatter3d(\n                x=[actual_pos['x']],\n                y=[actual_pos['y']],\n                z=[actual_pos['z']],\n                mode='markers',\n                marker=dict(\n                    size=8,\n                    color='white',\n                    symbol='square-open'\n                ),\n                name=f\"{obj_name} {far_label}\",\n                text=[hover_text],\n                customdata=[f\"{obj_name} {far_label}\"],  # Added\n                hovertemplate='%{text}<extra></extra>',   # Fixed format\n                showlegend=True\n            ))",
    "start_line": 206,
    "end_line": 350,
    "has_docstring": true,
    "docstring": "Enhanced version that compares actual vs Keplerian positions.\nMaintains all original parameters for backward compatibility.\n\nParameters:\n    fig: Plotly figure object\n    obj_name: Name of the object\n    params: Orbital parameters dictionary\n    date_range: Tuple of (start_date, end_date) for filtering\n    positions_dict: Dictionary of positions at apsidal dates\n    color_map: Function to get color for object\n    center_body: Name of central body (Sun, planet, etc.)\n    is_satellite: Boolean indicating if this is a satellite\n    ideal_apsides: Dictionary with 'periapsis' and 'apoapsis' Keplerian positions\n    filter_by_date_range: If False, plot all apsidal dates in positions_dict\n        regardless of date_range (useful for future apsides)",
    "parameters": [
      "fig",
      "obj_name",
      "params",
      "date_range",
      "positions_dict",
      "color_map",
      "center_body",
      "is_satellite",
      "ideal_apsides",
      "filter_by_date_range"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_actual_apsidal_markers_enhanced",
    "component_id": "apsidal_markers.add_actual_apsidal_markers_enhanced"
  },
  "apsidal_markers.calculate_exact_apsides": {
    "id": "apsidal_markers.calculate_exact_apsides",
    "name": "calculate_exact_apsides",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [
      "planet_visualization_utilities.rotate_points"
    ],
    "source_code": "def calculate_exact_apsides(a, e, i, omega, Omega, rotate_points):\n    \"\"\"\n    Calculate exact apsidal positions at theta=0 (periapsis) and theta=pi (apoapsis).\n    Uses the mathematical fact that periapsis is always at true anomaly = 0\n    and apoapsis is always at true anomaly = pi.\n    \n    Parameters:\n        a: Semi-major axis (AU)\n        e: Eccentricity\n        i: Inclination (degrees)\n        omega: Argument of periapsis (degrees)\n        Omega: Longitude of ascending node (degrees)\n        rotate_points: Function to rotate points in 3D space\n        \n    Returns:\n        dict: {\n            'periapsis': {'x': float, 'y': float, 'z': float, 'distance': float},\n            'apoapsis': {'x': float, 'y': float, 'z': float, 'distance': float} or None\n        }\n    \"\"\"\n    import numpy as np\n    \n    # Convert angles to radians for rotations\n    i_rad = np.radians(i)\n    omega_rad = np.radians(omega)\n    Omega_rad = np.radians(Omega)\n    \n    # ========== CALCULATE PERIAPSIS AT THETA=0 ==========\n    theta_periapsis = 0.0\n    \n    # Calculate radius at periapsis\n    if e < 1:  # Elliptical orbit\n        # r = a(1-e^2)/(1+e*cos(theta)) at theta=0 becomes r = a(1-e^2)/(1+e) = a(1-e)\n        r_periapsis = a * (1 - e)\n    else:  # Hyperbolic orbit (e >= 1)\n        # r = |a|(e^2-1)/(1+e*cos(theta)) at theta=0 becomes r = |a|(e^2-1)/(1+e) = |a|(e-1)\n        r_periapsis = abs(a) * (e - 1)\n    \n    # Position in orbital plane at theta=0\n    x_orbit_peri = r_periapsis  # r * cos(0) = r\n    y_orbit_peri = 0.0          # r * sin(0) = 0\n    z_orbit_peri = 0.0\n    \n    # Apply orbital element rotations to transform from orbital plane to 3D space\n    # 1. Rotate by argument of periapsis (?) around z-axis\n    x_temp, y_temp, z_temp = rotate_points([x_orbit_peri], [y_orbit_peri], [z_orbit_peri], omega_rad, 'z')\n    # 2. Rotate by inclination (i) around x-axis\n    x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n    # 3. Rotate by longitude of ascending node (Omega) around z-axis\n    x_peri, y_peri, z_peri = rotate_points(x_temp, y_temp, z_temp, Omega_rad, 'z')\n    \n    # Extract single point (rotate_points returns arrays)\n    peri_x = x_peri[0]\n    peri_y = y_peri[0]\n    peri_z = z_peri[0]\n    peri_distance = np.sqrt(peri_x**2 + peri_y**2 + peri_z**2)\n    \n    # Create periapsis result\n    periapsis_result = {\n        'x': peri_x,\n        'y': peri_y,\n        'z': peri_z,\n        'distance': peri_distance\n    }\n    \n    # ========== CALCULATE APOAPSIS AT THETA=PI (for elliptical only) ==========\n    apoapsis_result = None\n    \n    if e < 1:  # Only elliptical orbits have apoapsis\n        theta_apoapsis = np.pi  # 180 degrees\n        \n        # Calculate radius at apoapsis\n        # r = a(1-e^2)/(1+e*cos(theta)) at theta=? becomes r = a(1-e^2)/(1-e) = a(1+e)\n        r_apoapsis = a * (1 + e)\n        \n        # Position in orbital plane at theta=pi\n        x_orbit_apo = r_apoapsis * np.cos(theta_apoapsis)  # r * cos(?) = -r\n        y_orbit_apo = r_apoapsis * np.sin(theta_apoapsis)  # r * sin(?) = 0\n        z_orbit_apo = 0.0\n        \n        # Apply orbital element rotations\n        # 1. Rotate by argument of periapsis (?) around z-axis\n        x_temp, y_temp, z_temp = rotate_points([x_orbit_apo], [y_orbit_apo], [z_orbit_apo], omega_rad, 'z')\n        # 2. Rotate by inclination (i) around x-axis\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n        # 3. Rotate by longitude of ascending node (Omega) around z-axis\n        x_apo, y_apo, z_apo = rotate_points(x_temp, y_temp, z_temp, Omega_rad, 'z')\n        \n        # Extract single point\n        apo_x = x_apo[0]\n        apo_y = y_apo[0]\n        apo_z = z_apo[0]\n        apo_distance = np.sqrt(apo_x**2 + apo_y**2 + apo_z**2)\n        \n        # Create apoapsis result\n        apoapsis_result = {\n            'x': apo_x,\n            'y': apo_y,\n            'z': apo_z,\n            'distance': apo_distance\n        }\n    \n    return {\n        'periapsis': periapsis_result,\n        'apoapsis': apoapsis_result\n    }",
    "start_line": 352,
    "end_line": 457,
    "has_docstring": true,
    "docstring": "Calculate exact apsidal positions at theta=0 (periapsis) and theta=pi (apoapsis).\nUses the mathematical fact that periapsis is always at true anomaly = 0\nand apoapsis is always at true anomaly = pi.\n\nParameters:\n    a: Semi-major axis (AU)\n    e: Eccentricity\n    i: Inclination (degrees)\n    omega: Argument of periapsis (degrees)\n    Omega: Longitude of ascending node (degrees)\n    rotate_points: Function to rotate points in 3D space\n    \nReturns:\n    dict: {\n        'periapsis': {'x': float, 'y': float, 'z': float, 'distance': float},\n        'apoapsis': {'x': float, 'y': float, 'z': float, 'distance': float} or None\n    }",
    "parameters": [
      "a",
      "e",
      "i",
      "omega",
      "Omega",
      "rotate_points"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_exact_apsides",
    "component_id": "apsidal_markers.calculate_exact_apsides"
  },
  "apsidal_markers.add_apsidal_range_note": {
    "id": "apsidal_markers.add_apsidal_range_note",
    "name": "add_apsidal_range_note",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [
      "constants_new.color_map"
    ],
    "source_code": "def add_apsidal_range_note(fig, obj_name, perihelion_date, aphelion_date, color_map, fetch_failed=False):\n    \"\"\"\n    Add legend entries explaining why actual apsidal markers aren't shown\n    when dates are outside JPL Horizons' range.\n    Now creates separate legend entries for perihelion and aphelion.\n\n    Parameters:\n        fetch_failed: If True, indicates the fetch failed even though dates may be\n                     within general JPL range (e.g., satellite ephemeris ended earlier)    \n    \"\"\"\n    from datetime import datetime\n    import plotly.graph_objects as go\n    \n    # JPL Horizons data limit\n    JPL_MAX_DATE = datetime(2199, 12, 29)\n    JPL_MIN_DATE = datetime(1900, 1, 1)\n    \n    added_notes = False\n              \n    # Check and add perihelion note separately\n    if perihelion_date:\n        if perihelion_date > JPL_MAX_DATE:\n            date_str = perihelion_date.strftime('%Y-%m-%d')\n            note_text = f\"{obj_name}: Next perihelion: {date_str} (beyond JPL limit)\"\n            \n            # Add an invisible trace for perihelion\n            fig.add_trace(\n                go.Scatter3d(\n                    x=[None],  # No actual points\n                    y=[None],\n                    z=[None],\n                    mode='markers',\n                    marker=dict(\n                        size=6,\n                        color=color_map(obj_name),\n                        symbol='square-open'  # Open square for perihelion\n                    ),\n                    name=note_text,\n                    showlegend=True,\n                    hoverinfo='skip'  # Don't show hover for this invisible trace\n                )\n            )\n            added_notes = True\n        \n        elif fetch_failed:\n            # Fetch failed even though date is within general JPL range\n            # (e.g., satellite ephemeris has shorter coverage)\n            date_str = perihelion_date.strftime('%Y-%m-%d')\n            note_text = f\"{obj_name}: Perihelion: {date_str} (beyond ephemeris limit)\"\n            \n            fig.add_trace(\n                go.Scatter3d(\n                    x=[None],\n                    y=[None],\n                    z=[None],\n                    mode='markers',\n                    marker=dict(\n                        size=6,\n                        color=color_map(obj_name),\n                        symbol='square-open'\n                    ),\n                    name=note_text,\n                    showlegend=True,\n                    hoverinfo='skip'\n                )\n            )\n            added_notes = True\n            \n        elif perihelion_date < JPL_MIN_DATE:\n\n            date_str = perihelion_date.strftime('%Y-%m-%d')\n            note_text = f\"{obj_name}: Perihelion: {date_str} (before JPL limit)\"\n            \n            fig.add_trace(\n                go.Scatter3d(\n                    x=[None],\n                    y=[None],\n                    z=[None],\n                    mode='markers',\n                    marker=dict(\n                        size=6,\n                        color=color_map(obj_name),\n                        symbol='square-open'\n                    ),\n                    name=note_text,\n                    showlegend=True,\n                    hoverinfo='skip'\n                )\n            )\n            added_notes = True\n    \n    # Check and add aphelion note separately\n    if aphelion_date:\n        if aphelion_date > JPL_MAX_DATE:\n            date_str = aphelion_date.strftime('%Y-%m-%d')\n            note_text = f\"{obj_name}: Next aphelion: {date_str} (beyond JPL limit)\"\n            \n            # Add an invisible trace for aphelion\n            fig.add_trace(\n                go.Scatter3d(\n                    x=[None],  # No actual points\n                    y=[None],\n                    z=[None],\n                    mode='markers',\n                    marker=dict(\n                        size=6,\n                        color=color_map(obj_name),\n                        symbol='square-open'  # Solid square for aphelion\n                    ),\n                    name=note_text,\n                    showlegend=True,\n                    hoverinfo='skip'  # Don't show hover for this invisible trace\n                )\n            )\n            added_notes = True\n            \n        elif aphelion_date < JPL_MIN_DATE:\n            date_str = aphelion_date.strftime('%Y-%m-%d')\n            note_text = f\"{obj_name}: Aphelion: {date_str} (before JPL limit)\"\n            \n            fig.add_trace(\n                go.Scatter3d(\n                    x=[None],\n                    y=[None],\n                    z=[None],\n                    mode='markers',\n                    marker=dict(\n                        size=6,\n                        color=color_map(obj_name),\n                        symbol='square-open'\n                    ),\n                    name=note_text,\n                    showlegend=True,\n                    hoverinfo='skip'\n                )\n            )\n            added_notes = True\n    \n    return added_notes",
    "start_line": 460,
    "end_line": 598,
    "has_docstring": true,
    "docstring": "Add legend entries explaining why actual apsidal markers aren't shown\nwhen dates are outside JPL Horizons' range.\nNow creates separate legend entries for perihelion and aphelion.\n\nParameters:\n    fetch_failed: If True, indicates the fetch failed even though dates may be\n                 within general JPL range (e.g., satellite ephemeris ended earlier)    ",
    "parameters": [
      "fig",
      "obj_name",
      "perihelion_date",
      "aphelion_date",
      "color_map",
      "fetch_failed"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_apsidal_range_note",
    "component_id": "apsidal_markers.add_apsidal_range_note"
  },
  "apsidal_markers.estimate_hyperbolic_perihelion_date": {
    "id": "apsidal_markers.estimate_hyperbolic_perihelion_date",
    "name": "estimate_hyperbolic_perihelion_date",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [],
    "source_code": "def estimate_hyperbolic_perihelion_date(current_position, q, e, date):\n    \"\"\"\n    Estimate perihelion date for hyperbolic orbits.\n    \"\"\"\n    if not current_position or 'x' not in current_position or not date:\n        return \"Date unknown\"\n    \n    try:\n        current_dist = np.sqrt(\n            current_position['x']**2 + \n            current_position['y']**2 + \n            current_position['z']**2\n        )\n        \n        if current_dist > q:  # Still approaching perihelion\n            distance_to_go = current_dist - q\n            \n            # Rough velocity estimate for hyperbolic orbit (AU/day)\n            if e > 5:  # Very hyperbolic\n                estimated_velocity = 0.1\n            else:  # Near-parabolic\n                estimated_velocity = 0.05\n            \n            days_to_perihelion = distance_to_go / estimated_velocity\n            \n            if days_to_perihelion < 365:\n                perihelion_date = date + timedelta(days=days_to_perihelion)\n                return perihelion_date.strftime('%Y-%m-%d') + \" (est)\"\n            else:\n                return \"Approaching\"\n        else:\n            return \"Near/Past perihelion\"\n            \n    except Exception as e:\n        print(f\"Error estimating hyperbolic perihelion: {e}\", flush=True)\n        return \"Approaching\"",
    "start_line": 600,
    "end_line": 635,
    "has_docstring": true,
    "docstring": "Estimate perihelion date for hyperbolic orbits.",
    "parameters": [
      "current_position",
      "q",
      "e",
      "date"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function estimate_hyperbolic_perihelion_date",
    "component_id": "apsidal_markers.estimate_hyperbolic_perihelion_date"
  },
  "apsidal_markers.compute_apsidal_dates_from_tp": {
    "id": "apsidal_markers.compute_apsidal_dates_from_tp",
    "name": "compute_apsidal_dates_from_tp",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [],
    "source_code": "def compute_apsidal_dates_from_tp(obj_name, params, current_date=None):\n    \"\"\"\n    Get perihelion from TP and aphelion from Tapo.\n    These are the actual apsidal dates from ephemeris/observations.\n    \"\"\"\n    from astropy.time import Time\n    \n    next_perihelion = None\n    next_aphelion = None\n    \n    # Handle perihelion from TP\n    if 'TP' in params:\n        tp_jd = params['TP']\n        tp_time = Time(tp_jd, format='jd')\n        next_perihelion = tp_time.datetime\n        print(f\"  {obj_name}: Using TP for perihelion: {next_perihelion.strftime('%Y-%m-%d %H:%M:%S')}\", flush=True)\n    \n    # Handle aphelion from Tapo\n    if 'Tapo' in params:\n        tapo_jd = params['Tapo']\n        tapo_time = Time(tapo_jd, format='jd')\n        next_aphelion = tapo_time.datetime\n        print(f\"  {obj_name}: Using Tapo for aphelion: {next_aphelion.strftime('%Y-%m-%d %H:%M:%S')}\", flush=True)\n    elif params.get('e', 0) < 1:\n        # Only print warning for elliptical orbits (which should have aphelion)\n        print(f\"  {obj_name}: No Tapo provided - actual aphelion marker will not be plotted\", flush=True)\n    \n    return next_perihelion, next_aphelion",
    "start_line": 637,
    "end_line": 664,
    "has_docstring": true,
    "docstring": "Get perihelion from TP and aphelion from Tapo.\nThese are the actual apsidal dates from ephemeris/observations.",
    "parameters": [
      "obj_name",
      "params",
      "current_date"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function compute_apsidal_dates_from_tp",
    "component_id": "apsidal_markers.compute_apsidal_dates_from_tp"
  },
  "apsidal_markers.add_actual_apsidal_markers": {
    "id": "apsidal_markers.add_actual_apsidal_markers",
    "name": "add_actual_apsidal_markers",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [],
    "source_code": "def add_actual_apsidal_markers(fig, obj_name, params, date_range, positions_dict, color_map, \n                             center_body='Sun', is_satellite=False):\n    \"\"\"\n    Add markers for actual perihelion/aphelion (or perigee/apogee) dates.\n    \n    Parameters:\n    -----------\n    fig : plotly.graph_objects.Figure\n        The figure to add markers to\n    obj_name : str\n        Name of the celestial object\n    params : dict\n        Orbital parameters including actual apsidal dates\n    date_range : tuple\n        (start_date, end_date) to filter which markers to show\n    positions_dict : dict\n        Dictionary mapping dates to positions {'YYYY-MM-DD': {'x': x, 'y': y, 'z': z}}\n    color_map : function\n        Function to get color for the object\n    center_body : str\n        Name of the central body\n    is_satellite : bool\n        True if object is a satellite (use perigee/apogee instead of perihelion/aphelion)\n    \"\"\"\n    from datetime import datetime\n    import numpy as np\n    import plotly.graph_objects as go\n    \n    # Handle the case where date_range might be None\n    if date_range:\n        start_date, end_date = date_range\n    else:\n        # If no date range, we'll show all markers\n        start_date = None\n        end_date = None\n    \n    # Determine which date lists to use\n    if is_satellite:\n        near_dates = params.get('perigee_dates', [])\n        far_dates = params.get('apogee_dates', [])\n        near_label = 'Perigee'\n        far_label = 'Apogee'\n    else:\n        near_dates = params.get('perihelion_dates', [])\n        far_dates = params.get('aphelion_dates', [])\n        near_label = 'Perihelion'\n        far_label = 'Aphelion'\n    \n    # Convert string dates to datetime objects for processing\n    # Handle both old format (%Y-%m-%d) and new format (%Y-%m-%d %H:%M:%S)\n\n    near_dates_dt = []\n    for d in near_dates:\n        try:\n            # Try full datetime format first\n            dt = datetime.strptime(d, '%Y-%m-%d %H:%M:%S')\n        except ValueError:\n            # Fall back to date-only format\n            dt = datetime.strptime(d, '%Y-%m-%d')\n        near_dates_dt.append(dt)\n\n    far_dates_dt = []\n    for d in far_dates:\n        try:\n            # Try full datetime format first\n            dt = datetime.strptime(d, '%Y-%m-%d %H:%M:%S')\n        except ValueError:\n            # Fall back to date-only format\n            dt = datetime.strptime(d, '%Y-%m-%d')\n        far_dates_dt.append(dt)\n\n    # Add markers for near points (perihelion/perigee)\n    for i, date in enumerate(near_dates_dt):\n#        date_str = near_dates[i]  # Get the original string format\n        \n        # Extract just the date part for position lookup\n        date_key = date.strftime('%Y-%m-%d')\n        \n        if date_key in positions_dict:\n            pos = positions_dict[date_key]\n            \n            # Calculate distance from center\n            distance_au = np.sqrt(pos['x']**2 + pos['y']**2 + pos['z']**2)\n            \n            # Display full datetime if available\n            date_display = date.strftime('%Y-%m-%d %H:%M:%S')\n            \n            fig.add_trace(\n                go.Scatter3d(\n                    x=[pos['x']],\n                    y=[pos['y']],\n                    z=[pos['z']],\n                    mode='markers',                    \n                    marker=dict(\n                        size=8,\n                        color='white',                        \n                        symbol='square-open',  \n                    ),\n\n                    name=f\"{obj_name} Actual {near_label}\",\n                    text=[f\"<b>{obj_name} at {near_label}</b><br>\"\n                        f\"Date: {date_display} UTC<br>\"\n                #        f\"Distance from {center_body}: {distance_au:.6f} AU\"],\n                        f\"Distance from center: {distance_au:.9f} AU\"],\n                    customdata=[f\"{obj_name} Actual {near_label}\"],  \n                    hovertemplate='%{text}<extra></extra>',\n                    showlegend=True\n\n                )\n            )\n\n    # Add markers for far points (aphelion/apogee)\n    for i, date in enumerate(far_dates_dt):\n        date_str = far_dates[i]  # Get the original string format\n        \n        # Extract just the date part for position lookup\n        date_key = date.strftime('%Y-%m-%d')\n        \n        if date_key in positions_dict:\n            pos = positions_dict[date_key]\n            \n            # Calculate distance from center\n            distance_au = np.sqrt(pos['x']**2 + pos['y']**2 + pos['z']**2)\n            \n            # Display full datetime if available\n            date_display = date.strftime('%Y-%m-%d %H:%M:%S')\n            \n            fig.add_trace(\n                go.Scatter3d(\n                    x=[pos['x']],\n                    y=[pos['y']],\n                    z=[pos['z']],\n                    mode='markers',                    \n                    marker=dict(\n                        size=8,\n                        color='white',                        \n                        symbol='square-open',  # open square for actual\n                    ),\n\n                    name=f\"{obj_name} Actual {far_label}\",  # Fixed: far_label\n                    text=[f\"<b>{obj_name} at {far_label}</b><br>\"  # Fixed: far_label\n                        f\"Date: {date_display} UTC<br>\"\n                #        f\"Distance from {center_body}: {distance_au:.6f} AU\"],\n                        f\"Distance from center: {distance_au:.9f} AU\"],\n                    customdata=[f\"{obj_name} Actual {far_label}\"],  # Fixed: far_label                    \n\n                    hovertemplate='%{text}<extra></extra>',\n                    showlegend=True\n\n                )\n            )",
    "start_line": 666,
    "end_line": 816,
    "has_docstring": true,
    "docstring": "Add markers for actual perihelion/aphelion (or perigee/apogee) dates.\n\nParameters:\n-----------\nfig : plotly.graph_objects.Figure\n    The figure to add markers to\nobj_name : str\n    Name of the celestial object\nparams : dict\n    Orbital parameters including actual apsidal dates\ndate_range : tuple\n    (start_date, end_date) to filter which markers to show\npositions_dict : dict\n    Dictionary mapping dates to positions {'YYYY-MM-DD': {'x': x, 'y': y, 'z': z}}\ncolor_map : function\n    Function to get color for the object\ncenter_body : str\n    Name of the central body\nis_satellite : bool\n    True if object is a satellite (use perigee/apogee instead of perihelion/aphelion)",
    "parameters": [
      "fig",
      "obj_name",
      "params",
      "date_range",
      "positions_dict",
      "color_map",
      "center_body",
      "is_satellite"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_actual_apsidal_markers",
    "component_id": "apsidal_markers.add_actual_apsidal_markers"
  },
  "apsidal_markers.fetch_positions_for_apsidal_dates": {
    "id": "apsidal_markers.fetch_positions_for_apsidal_dates",
    "name": "fetch_positions_for_apsidal_dates",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [
      "palomas_orrery.fetch_position"
    ],
    "source_code": "def fetch_positions_for_apsidal_dates(obj_id, params, date_range, center_id='Sun', \n                                    id_type=None, is_satellite=False, fetch_position=None):\n    \"\"\"\n    Fetch actual positions for all apsidal dates within the date range.\n    \n    Returns:\n        dict: Mapping of date strings to position dictionaries\n    \"\"\"\n    from datetime import datetime\n\n    if fetch_position is None:\n        raise ValueError(\"fetch_position function must be provided\")\n\n    positions = {}\n\n    # Remove the line that unpacks date_range since we're not using it\n#    start_date, end_date = date_range\n    \n    # Get all apsidal dates\n#    if is_satellite:\n#        all_dates = params.get('perigee_dates', []) + params.get('apogee_dates', [])\n#    else:\n#        all_dates = params.get('perihelion_dates', []) + params.get('aphelion_dates', [])\n    \n    # Use perihelion/aphelion for all objects (satellites and planets)\n    all_dates = params.get('perihelion_dates', []) + params.get('aphelion_dates', [])\n\n    for date_str in all_dates:\n        try:\n            # Try to parse with time first, then fall back to date-only\n            try:\n                date_obj = datetime.strptime(date_str, '%Y-%m-%d %H:%M:%S')\n            except ValueError:\n                date_obj = datetime.strptime(date_str, '%Y-%m-%d')\n            \n            # Always fetch, no date range check\n            pos_data = fetch_position(obj_id, date_obj, center_id=center_id, id_type=id_type)\n            if pos_data and 'x' in pos_data:\n                # Store with date-only key for compatibility\n                date_key = date_obj.strftime('%Y-%m-%d')\n                positions[date_key] = pos_data\n                print(f\"    Fetched position for {date_str}\", flush=True)\n\n        except Exception as e:\n            print(f\"    Could not fetch position for {date_str}: {e}\", flush=True)                \n    \n    return positions",
    "start_line": 818,
    "end_line": 864,
    "has_docstring": true,
    "docstring": "Fetch actual positions for all apsidal dates within the date range.\n\nReturns:\n    dict: Mapping of date strings to position dictionaries",
    "parameters": [
      "obj_id",
      "params",
      "date_range",
      "center_id",
      "id_type",
      "is_satellite",
      "fetch_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_positions_for_apsidal_dates",
    "component_id": "apsidal_markers.fetch_positions_for_apsidal_dates"
  },
  "apsidal_markers.get_orbital_period_days": {
    "id": "apsidal_markers.get_orbital_period_days",
    "name": "get_orbital_period_days",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [],
    "source_code": "def get_orbital_period_days(body_name, semi_major_axis_au=None):\n    \"\"\"\n    Get orbital period in Earth days for a given body.\n    \n    Parameters:\n    -----------\n    body_name : str\n        Name of the celestial body\n    semi_major_axis_au : float, optional\n        Semi-major axis in AU (used for unknown bodies via Kepler's third law)\n    \n    Returns:\n    --------\n    float\n        Orbital period in Earth days\n    \"\"\"\n    if body_name in KNOWN_ORBITAL_PERIODS:\n        period = KNOWN_ORBITAL_PERIODS[body_name]\n        # Handle special cases (hyperbolic/parabolic objects)\n        if period is None:\n            if semi_major_axis_au:\n                # For hyperbolic/parabolic orbits, use Kepler's third law\n                # This gives a notional period for visualization purposes\n                return 365.25 * np.sqrt(abs(semi_major_axis_au)**3)\n            else:\n                raise ValueError(f\"{body_name} has no defined orbital period (hyperbolic/parabolic orbit)\")\n        return period\n    elif semi_major_axis_au:\n        # Use Kepler's third law as fallback for unknown bodies\n        # P^2 = a (where P is in years and a is in AU)\n        # So P_days = 365.25 * sqrt(a)\n        return 365.25 * np.sqrt(abs(semi_major_axis_au)**3)\n    else:\n        raise ValueError(f\"Unknown body {body_name} and no semi-major axis provided\")",
    "start_line": 866,
    "end_line": 899,
    "has_docstring": true,
    "docstring": "Get orbital period in Earth days for a given body.\n\nParameters:\n-----------\nbody_name : str\n    Name of the celestial body\nsemi_major_axis_au : float, optional\n    Semi-major axis in AU (used for unknown bodies via Kepler's third law)\n\nReturns:\n--------\nfloat\n    Orbital period in Earth days",
    "parameters": [
      "body_name",
      "semi_major_axis_au"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_orbital_period_days",
    "component_id": "apsidal_markers.get_orbital_period_days"
  },
  "apsidal_markers.calculate_true_anomaly_from_position": {
    "id": "apsidal_markers.calculate_true_anomaly_from_position",
    "name": "calculate_true_anomaly_from_position",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [],
    "source_code": "def calculate_true_anomaly_from_position(x, y, z, a, e, i, omega, Omega):\n    \"\"\"\n    Calculate the true anomaly from a position in 3D space.\n    \n    Parameters:\n        x, y, z: Current position in heliocentric/planetocentric coordinates (AU or km)\n        a: Semi-major axis (same units as position)\n        e: Eccentricity\n        i: Inclination (degrees)\n        omega: Argument of periapsis (degrees)\n        Omega: Longitude of ascending node (degrees)\n    \n    Returns:\n        float: True anomaly in radians (0 to 2?)\n    \"\"\"\n    # Convert angles to radians\n    i_rad = np.radians(i)\n    omega_rad = np.radians(omega)\n    Omega_rad = np.radians(Omega)\n    \n    # Reverse rotation transformations to get back to orbital plane\n    # First, reverse the Omega rotation (around z-axis)\n    x1 = x * np.cos(-Omega_rad) - y * np.sin(-Omega_rad)\n    y1 = x * np.sin(-Omega_rad) + y * np.cos(-Omega_rad)\n    z1 = z\n    \n    # Then, reverse the inclination rotation (around x-axis)\n    x2 = x1\n    y2 = y1 * np.cos(-i_rad) - z1 * np.sin(-i_rad)\n    z2 = y1 * np.sin(-i_rad) + z1 * np.cos(-i_rad)\n    \n    # Finally, reverse the omega rotation (around z-axis)\n    x_orbital = x2 * np.cos(-omega_rad) - y2 * np.sin(-omega_rad)\n    y_orbital = x2 * np.sin(-omega_rad) + y2 * np.cos(-omega_rad)\n    \n    # Calculate true anomaly\n    true_anomaly = np.arctan2(y_orbital, x_orbital)\n    \n    # Ensure positive angle (0 to 2?)\n    if true_anomaly < 0:\n        true_anomaly += 2 * np.pi\n    \n    return true_anomaly",
    "start_line": 901,
    "end_line": 943,
    "has_docstring": true,
    "docstring": "Calculate the true anomaly from a position in 3D space.\n\nParameters:\n    x, y, z: Current position in heliocentric/planetocentric coordinates (AU or km)\n    a: Semi-major axis (same units as position)\n    e: Eccentricity\n    i: Inclination (degrees)\n    omega: Argument of periapsis (degrees)\n    Omega: Longitude of ascending node (degrees)\n\nReturns:\n    float: True anomaly in radians (0 to 2?)",
    "parameters": [
      "x",
      "y",
      "z",
      "a",
      "e",
      "i",
      "omega",
      "Omega"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_true_anomaly_from_position",
    "component_id": "apsidal_markers.calculate_true_anomaly_from_position"
  },
  "apsidal_markers.true_to_eccentric_anomaly": {
    "id": "apsidal_markers.true_to_eccentric_anomaly",
    "name": "true_to_eccentric_anomaly",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [],
    "source_code": "def true_to_eccentric_anomaly(true_anomaly, e):\n    \"\"\"\n    Convert true anomaly to eccentric anomaly.\n    \n    Parameters:\n        true_anomaly: True anomaly in radians\n        e: Eccentricity\n    \n    Returns:\n        float: Eccentric anomaly in radians (or hyperbolic eccentric anomaly for e > 1)\n    \"\"\"\n    if e < 1:  # Elliptical orbit\n        # For elliptical orbits\n        cos_E = (e + np.cos(true_anomaly)) / (1 + e * np.cos(true_anomaly))\n        sin_E = np.sqrt(1 - e**2) * np.sin(true_anomaly) / (1 + e * np.cos(true_anomaly))\n        E = np.arctan2(sin_E, cos_E)\n        \n        # Ensure E is positive\n        if E < 0:\n            E += 2 * np.pi\n            \n        return E\n        \n    else:  # Hyperbolic orbit (e > 1)\n        # For hyperbolic orbits, use hyperbolic eccentric anomaly\n        if abs(true_anomaly) > np.arccos(-1/e):\n            # True anomaly is beyond the asymptote - invalid for hyperbolic orbit\n            return float('nan')\n            \n        cosh_F = (e + np.cos(true_anomaly)) / (1 + e * np.cos(true_anomaly))\n        F = np.arccosh(cosh_F)\n        \n        # F should have the same sign as true anomaly\n        if true_anomaly > np.pi:\n            F = -F\n            \n        return F",
    "start_line": 946,
    "end_line": 982,
    "has_docstring": true,
    "docstring": "Convert true anomaly to eccentric anomaly.\n\nParameters:\n    true_anomaly: True anomaly in radians\n    e: Eccentricity\n\nReturns:\n    float: Eccentric anomaly in radians (or hyperbolic eccentric anomaly for e > 1)",
    "parameters": [
      "true_anomaly",
      "e"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function true_to_eccentric_anomaly",
    "component_id": "apsidal_markers.true_to_eccentric_anomaly"
  },
  "apsidal_markers.eccentric_to_mean_anomaly": {
    "id": "apsidal_markers.eccentric_to_mean_anomaly",
    "name": "eccentric_to_mean_anomaly",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [],
    "source_code": "def eccentric_to_mean_anomaly(E, e):\n    \"\"\"\n    Convert eccentric anomaly to mean anomaly.\n    Uses Kepler's equation.\n    \n    Parameters:\n        E: Eccentric anomaly in radians (or hyperbolic eccentric anomaly)\n        e: Eccentricity\n    \n    Returns:\n        float: Mean anomaly in radians\n    \"\"\"\n    if e < 1:  # Elliptical orbit\n        M = E - e * np.sin(E)\n    else:  # Hyperbolic orbit\n        M = e * np.sinh(E) - E  # M = e*sinh(F) - F for hyperbolic\n    return M",
    "start_line": 985,
    "end_line": 1001,
    "has_docstring": true,
    "docstring": "Convert eccentric anomaly to mean anomaly.\nUses Kepler's equation.\n\nParameters:\n    E: Eccentric anomaly in radians (or hyperbolic eccentric anomaly)\n    e: Eccentricity\n\nReturns:\n    float: Mean anomaly in radians",
    "parameters": [
      "E",
      "e"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function eccentric_to_mean_anomaly",
    "component_id": "apsidal_markers.eccentric_to_mean_anomaly"
  },
  "apsidal_markers.calculate_time_to_anomaly": {
    "id": "apsidal_markers.calculate_time_to_anomaly",
    "name": "calculate_time_to_anomaly",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [],
    "source_code": "def calculate_time_to_anomaly(current_M, target_M, orbital_period_days):\n    \"\"\"\n    Calculate time to reach a target mean anomaly from current mean anomaly.\n    \n    Parameters:\n        current_M: Current mean anomaly (radians)\n        target_M: Target mean anomaly (radians)\n        orbital_period_days: Orbital period in days\n    \n    Returns:\n        float: Days until target anomaly is reached\n    \"\"\"\n    # Calculate angular distance (always forward in time)\n    if target_M >= current_M:\n        delta_M = target_M - current_M\n    else:\n        delta_M = (2 * np.pi) + target_M - current_M\n    \n    # Convert to time\n    fraction_of_orbit = delta_M / (2 * np.pi)\n    days_to_target = fraction_of_orbit * orbital_period_days\n    \n    return days_to_target",
    "start_line": 1004,
    "end_line": 1026,
    "has_docstring": true,
    "docstring": "Calculate time to reach a target mean anomaly from current mean anomaly.\n\nParameters:\n    current_M: Current mean anomaly (radians)\n    target_M: Target mean anomaly (radians)\n    orbital_period_days: Orbital period in days\n\nReturns:\n    float: Days until target anomaly is reached",
    "parameters": [
      "current_M",
      "target_M",
      "orbital_period_days"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_time_to_anomaly",
    "component_id": "apsidal_markers.calculate_time_to_anomaly"
  },
  "apsidal_markers.calculate_apsidal_dates": {
    "id": "apsidal_markers.calculate_apsidal_dates",
    "name": "calculate_apsidal_dates",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [
      "apsidal_markers.get_orbital_period_days",
      "apsidal_markers.calculate_true_anomaly_from_position",
      "apsidal_markers.calculate_time_to_anomaly",
      "apsidal_markers.eccentric_to_mean_anomaly",
      "apsidal_markers.true_to_eccentric_anomaly"
    ],
    "source_code": "def calculate_apsidal_dates(date, current_x, current_y, current_z, a, e, i, omega, Omega, body_name=\"Object\"):\n    \"\"\"\n    Calculate dates for perihelion/apohelion (or perigee/apogee for satellites).\n    \n    Parameters:\n        date: Current date (datetime object)\n        current_x, current_y, current_z: Current position\n        a: Semi-major axis\n        e: Eccentricity\n        i: Inclination (degrees)\n        omega: Argument of periapsis (degrees)\n        Omega: Longitude of ascending node (degrees)\n        body_name: Name of the body (for error messages)\n    \n    Returns:\n        tuple: (perihelion_date, apohelion_date) or (None, None) if calculation fails\n    \"\"\"\n    try:\n        # Calculate current true anomaly\n        current_theta = calculate_true_anomaly_from_position(\n            current_x, current_y, current_z, a, e, i, omega, Omega\n        )\n        \n        if e >= 1:  # Hyperbolic orbit\n            # For hyperbolic orbits, apohelion doesn't exist\n            # Check if we're approaching or past perihelion\n            if current_theta < np.pi:\n                # Approaching perihelion - estimate time\n                if current_theta < 0.1:  # Very close\n                    perihelion_date = date\n                else:\n                    # Rough estimate for hyperbolic approach\n                    # This is simplified - proper calculation would be complex\n                    days_estimate = 30 * (1 - current_theta/np.pi)\n                    perihelion_date = date + timedelta(days=days_estimate)\n            else:\n                # Past perihelion\n                perihelion_date = None\n                \n            return perihelion_date, None\n                \n        # For elliptical orbits\n        # Get orbital period using the helper function\n        try:\n            orbital_period_days = get_orbital_period_days(body_name, a)\n        except ValueError:\n            # If body not found and no semi-major axis, use default\n            print(f\"Warning: Using Kepler's law for unknown body {body_name}\", flush=True)\n            orbital_period_days = 365.25 * np.sqrt(abs(a)**3)\n\n        # Convert current position to mean anomaly\n        E_current = true_to_eccentric_anomaly(current_theta, e)\n        M_current = eccentric_to_mean_anomaly(E_current, e)\n        \n        # Perihelion is at M = 0\n        days_to_perihelion = calculate_time_to_anomaly(M_current, 0, orbital_period_days)\n        perihelion_date = date + timedelta(days=days_to_perihelion)\n        \n        # Apohelion is at M = ?\n        days_to_apohelion = calculate_time_to_anomaly(M_current, np.pi, orbital_period_days)\n        apohelion_date = date + timedelta(days=days_to_apohelion)\n        \n        return perihelion_date, apohelion_date\n        \n    except Exception as ex:\n        print(f\"Warning: Could not calculate apsidal dates for {body_name}: {ex}\", flush=True)\n        return None, None",
    "start_line": 1029,
    "end_line": 1095,
    "has_docstring": true,
    "docstring": "Calculate dates for perihelion/apohelion (or perigee/apogee for satellites).\n\nParameters:\n    date: Current date (datetime object)\n    current_x, current_y, current_z: Current position\n    a: Semi-major axis\n    e: Eccentricity\n    i: Inclination (degrees)\n    omega: Argument of periapsis (degrees)\n    Omega: Longitude of ascending node (degrees)\n    body_name: Name of the body (for error messages)\n\nReturns:\n    tuple: (perihelion_date, apohelion_date) or (None, None) if calculation fails",
    "parameters": [
      "date",
      "current_x",
      "current_y",
      "current_z",
      "a",
      "e",
      "i",
      "omega",
      "Omega",
      "body_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_apsidal_dates",
    "component_id": "apsidal_markers.calculate_apsidal_dates"
  },
  "apsidal_markers.add_perihelion_marker": {
    "id": "apsidal_markers.add_perihelion_marker",
    "name": "add_perihelion_marker",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [
      "apsidal_markers.get_apsidal_terms",
      "apsidal_markers.calculate_apsidal_dates",
      "constants_new.color_map"
    ],
    "source_code": "def add_perihelion_marker(fig, x, y, z, obj_name, a, e, date, current_position, \n                        orbital_params, color_map, q=None, center_body='Sun'):\n    \"\"\"\n    Add a perihelion/perigee marker with accurate date calculation.\n    Now handles full datetime precision from TP and uses proper apsidal terminology.\n    \n    Parameters:\n        fig: Plotly figure object\n        x, y, z: Position coordinates in AU\n        obj_name: Name of the orbiting object\n        a: Semi-major axis in AU\n        e: Eccentricity\n        date: Current date for calculation\n        current_position: Dictionary with 'x', 'y', 'z' keys\n        orbital_params: Full orbital parameters dictionary\n        color_map: Function to get color for object\n        q: Periapsis distance (calculated if None)\n        center_body: Name or ID of central body (Sun, Earth, Jupiter, etc.)\n    \"\"\"\n    # Get proper apsidal terminology\n    near_term, far_term = get_apsidal_terms(center_body)\n\n    # Calculate perihelion distance if not provided\n    if q is None:\n        q = a * (1 - e)\n    \n    # Calculate perihelion date\n    perihelion_date_str = \"\"\n    if date is not None and current_position is not None and e < 1:\n        perihelion_date, aphelion_date = calculate_apsidal_dates(\n            date,\n            current_position['x'],\n            current_position['y'],\n            current_position['z'],\n            orbital_params.get('a', a),\n            orbital_params.get('e', e),\n            orbital_params.get('i', 0),\n            orbital_params.get('omega', 0),\n            orbital_params.get('Omega', 0),\n            obj_name\n        )\n        \n        if perihelion_date is not None:\n            # For elliptical orbits with TP, we can calculate precise perihelion time\n            if 'TP' in orbital_params and obj_name in KNOWN_ORBITAL_PERIODS:\n                period_days = KNOWN_ORBITAL_PERIODS[obj_name]\n                if period_days and period_days not in [None, 1e99]:  # Valid period\n                    from astropy.time import Time\n                    from datetime import timedelta\n                    tp_time = Time(orbital_params['TP'], format='jd')\n                    tp_datetime = tp_time.datetime\n                    \n                    # Find the next perihelion after the current date\n                    precise_perihelion = tp_datetime\n                    while precise_perihelion < date:\n                        precise_perihelion += timedelta(days=period_days)\n                    \n                    perihelion_date_str = f\"<br>Date: {precise_perihelion.strftime('%Y-%m-%d %H:%M:%S')} UTC\"\n                else:\n                    # For objects without precise period info\n                    perihelion_date_str = f\"<br>Date: {perihelion_date.strftime('%Y-%m-%d')}\"\n            else:\n                # No TP available, use calculated date\n                perihelion_date_str = f\"<br>Date: {perihelion_date.strftime('%Y-%m-%d')}\"\n\n    # For hyperbolic orbits, use TP if available\n    elif 'TP' in orbital_params and e >= 1:\n        from astropy.time import Time\n        tp_time = Time(orbital_params['TP'], format='jd')\n        tp_datetime = tp_time.datetime\n        perihelion_date_str = f\"<br>Date: {tp_datetime.strftime('%Y-%m-%d %H:%M:%S')} UTC\"\n    elif date is not None:\n        perihelion_date_str = f\"<br>Date: {date.strftime('%Y-%m-%d')}\"\n    \n    # Accuracy note\n    accuracy_note = \"\"\n    if e > 0.15:  # High eccentricity\n        accuracy_note = \"<br><i>Accuracy: +/-0.002 AU (strong perturbations)</i>\"\n    elif e > 0.05:  # Moderate eccentricity\n        accuracy_note = \"<br><i>Accuracy: +/-0.001 AU (moderate perturbations)</i>\"\n    else:  # Low eccentricity\n        accuracy_note = \"<br><i>Accuracy: +/-0.0005 AU (minimal perturbations)</i>\"\n    \n    # SAFETY: Ensure we always have some date string\n    if perihelion_date_str == \"\":\n        perihelion_date_str = \"<br>Date: Not calculated\"\n        print(f\"WARNING: Could not calculate {near_term} date for {obj_name}\", flush=True)\n    \n    # Use proper terminology for this central body\n    label = f\"Keplerian {near_term}\"\n    \n    # Create hover text with all information\n    # Ensure q is properly formatted\n    try:\n        q_str = f\"{q:.6f}\"\n    except:\n        q_str = str(q)\n        print(f\"WARNING: Could not format q value for {obj_name}: {q}\", flush=True)\n    \n    # Calculate distance from surface if center body radius is known\n    surface_distance_text = \"\"\n    print(f\"DEBUG SURFACE: center_body='{center_body}', in CENTER_BODY_RADII={center_body in CENTER_BODY_RADII}\", flush=True)  # TEMP DEBUG\n    if center_body in CENTER_BODY_RADII:\n        center_radius_km = CENTER_BODY_RADII[center_body]\n        center_radius_au = center_radius_km / 149597870.7  # km to AU\n        surface_distance_au = q - center_radius_au\n        surface_distance_km = surface_distance_au * 149597870.7\n        surface_distance_text = f\"<br>Distance from surface: {surface_distance_au:.6f} AU ({surface_distance_km:,.0f} km)\"\n    \n    hover_text = f\"<b>{obj_name} {label}</b>{perihelion_date_str}<br>q={q_str} AU{surface_distance_text}{accuracy_note}\"\n#    hover_text = f\"<b>{obj_name} {label}</b>{perihelion_date_str}<br>q={q_str} AU{accuracy_note}\"\n    \n    # DEBUG: Uncomment these lines to diagnose hover text issues\n    print(f\"DEBUG: {obj_name} {label} hover text: {hover_text}\", flush=True)\n    \n    fig.add_trace(\n        go.Scatter3d(\n            x=[x],\n            y=[y],\n            z=[z],\n            mode='markers',\n            marker=dict(\n                size=6,\n                color=color_map(obj_name),\n                symbol='square-open'\n            ),\n            name=f\"{obj_name} {label}\",\n            text=[hover_text],\n        #    customdata=[label],\n            customdata=[f\"{obj_name} {label}\"],\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    )",
    "start_line": 1098,
    "end_line": 1231,
    "has_docstring": true,
    "docstring": "Add a perihelion/perigee marker with accurate date calculation.\nNow handles full datetime precision from TP and uses proper apsidal terminology.\n\nParameters:\n    fig: Plotly figure object\n    x, y, z: Position coordinates in AU\n    obj_name: Name of the orbiting object\n    a: Semi-major axis in AU\n    e: Eccentricity\n    date: Current date for calculation\n    current_position: Dictionary with 'x', 'y', 'z' keys\n    orbital_params: Full orbital parameters dictionary\n    color_map: Function to get color for object\n    q: Periapsis distance (calculated if None)\n    center_body: Name or ID of central body (Sun, Earth, Jupiter, etc.)",
    "parameters": [
      "fig",
      "x",
      "y",
      "z",
      "obj_name",
      "a",
      "e",
      "date",
      "current_position",
      "orbital_params",
      "color_map",
      "q",
      "center_body"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_perihelion_marker",
    "component_id": "apsidal_markers.add_perihelion_marker"
  },
  "apsidal_markers.add_apohelion_marker": {
    "id": "apsidal_markers.add_apohelion_marker",
    "name": "add_apohelion_marker",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [
      "apsidal_markers.get_apsidal_terms",
      "apsidal_markers.calculate_apsidal_dates",
      "constants_new.color_map"
    ],
    "source_code": "def add_apohelion_marker(fig, x, y, z, obj_name, a, e, date, current_position,\n                        orbital_params, color_map, center_body='Sun'):\n    \"\"\"\n    Add an apohelion/apogee marker to the plot with accurate date calculation.\n    Now handles full datetime precision from TP and uses proper apsidal terminology.\n    \n    Parameters:\n        fig: Plotly figure object\n        x, y, z: Position coordinates in AU\n        obj_name: Name of the orbiting object\n        a: Semi-major axis in AU\n        e: Eccentricity\n        date: Current date for calculation\n        current_position: Dictionary with 'x', 'y', 'z' keys\n        orbital_params: Full orbital parameters dictionary\n        color_map: Function to get color for object\n        center_body: Name or ID of central body (Sun, Earth, Jupiter, etc.)\n    \"\"\"\n    # Get proper apsidal terminology\n    near_term, far_term = get_apsidal_terms(center_body)\n\n    # Calculate aphelion distance\n    if e < 1:\n        Q = a * (1 + e)\n    else:\n        # No aphelion for hyperbolic orbits\n        return\n    \n    # Calculate aphelion date\n    aphelion_date_str = \"\"\n    if date is not None and current_position is not None and e < 1:\n        perihelion_date, aphelion_date = calculate_apsidal_dates(\n            date,\n            current_position['x'],\n            current_position['y'],\n            current_position['z'],\n            orbital_params.get('a', a),\n            orbital_params.get('e', e),\n            orbital_params.get('i', 0),\n            orbital_params.get('omega', 0),\n            orbital_params.get('Omega', 0),\n            obj_name\n        )\n        \n        if aphelion_date is not None:\n            # For elliptical orbits with TP, we can calculate precise aphelion time\n            if 'TP' in orbital_params and obj_name in KNOWN_ORBITAL_PERIODS:\n                period_days = KNOWN_ORBITAL_PERIODS[obj_name]\n                if period_days and period_days != 1e99:  # Not a hyperbolic placeholder\n                    from astropy.time import Time\n                    from datetime import timedelta\n                    tp_time = Time(orbital_params['TP'], format='jd')\n                    tp_datetime = tp_time.datetime\n                    # Aphelion is half period after perihelion\n                    precise_aphelion = tp_datetime + timedelta(days=period_days/2)\n                    # Adjust for multiple orbits if needed\n                    while precise_aphelion < date:\n                        precise_aphelion += timedelta(days=period_days)\n                    aphelion_date_str = f\"<br>Date: {precise_aphelion.strftime('%Y-%m-%d %H:%M:%S')} UTC\"\n                else:\n                    aphelion_date_str = f\"<br>Date: {aphelion_date.strftime('%Y-%m-%d')}\"\n            else:\n                aphelion_date_str = f\"<br>Date: {aphelion_date.strftime('%Y-%m-%d')}\"\n    elif date is not None:\n        aphelion_date_str = f\"<br>Date: {date.strftime('%Y-%m-%d')}\"\n    \n    # Accuracy note\n    accuracy_note = \"\"\n    if e > 0.15:  # High eccentricity\n        accuracy_note = \"<br><i>Accuracy: +/-0.002 AU (strong perturbations)</i>\"\n    elif e > 0.05:  # Moderate eccentricity\n        accuracy_note = \"<br><i>Accuracy: +/-0.001 AU (moderate perturbations)</i>\"\n    else:  # Low eccentricity\n        accuracy_note = \"<br><i>Accuracy: +/-0.0005 AU (minimal perturbations)</i>\"\n    \n    # SAFETY: Ensure we always have some date string\n    if aphelion_date_str == \"\":\n        aphelion_date_str = \"<br>Date: Not calculated\"\n        print(f\"WARNING: Could not calculate {far_term} date for {obj_name}\", flush=True)\n    \n    # Use proper terminology for this central body\n    label = f\"Keplerian {far_term}\"\n        \n\n    \n    # Create hover text\n    # Ensure Q is properly formatted\n    try:\n        Q_str = f\"{Q:.6f}\"\n    except:\n        Q_str = str(Q)\n        print(f\"WARNING: Could not format Q value for {obj_name}: {Q}\", flush=True)\n    \n    # Calculate distance from surface if center body radius is known\n    surface_distance_text = \"\"\n    if center_body in CENTER_BODY_RADII:\n        center_radius_km = CENTER_BODY_RADII[center_body]\n        center_radius_au = center_radius_km / 149597870.7  # km to AU\n        surface_distance_au = Q - center_radius_au\n        surface_distance_km = surface_distance_au * 149597870.7\n        surface_distance_text = f\"<br>Distance from surface: {surface_distance_au:.6f} AU ({surface_distance_km:,.0f} km)\"\n    \n    hover_text = f\"<b>{obj_name} {label}</b>{aphelion_date_str}<br>Q={Q_str} AU{surface_distance_text}{accuracy_note}\"\n#    hover_text = f\"<b>{obj_name} {label}</b>{aphelion_date_str}<br>Q={Q_str} AU{accuracy_note}\"\n\n    # DEBUG: Uncomment these lines to diagnose hover text issues\n    print(f\"DEBUG: {obj_name} {label} hover text: {hover_text}\", flush=True)\n   \n    fig.add_trace(\n        go.Scatter3d(\n            x=[x],\n            y=[y],\n            z=[z],\n            mode='markers',\n            marker=dict(\n                size=6,\n                color=color_map(obj_name),\n                symbol='square-open'\n            ),\n            name=f\"{obj_name} {label}\",\n            text=[hover_text],\n        #    customdata=[label],\n            customdata=[f\"{obj_name} {label}\"],\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    )",
    "start_line": 1234,
    "end_line": 1360,
    "has_docstring": true,
    "docstring": "Add an apohelion/apogee marker to the plot with accurate date calculation.\nNow handles full datetime precision from TP and uses proper apsidal terminology.\n\nParameters:\n    fig: Plotly figure object\n    x, y, z: Position coordinates in AU\n    obj_name: Name of the orbiting object\n    a: Semi-major axis in AU\n    e: Eccentricity\n    date: Current date for calculation\n    current_position: Dictionary with 'x', 'y', 'z' keys\n    orbital_params: Full orbital parameters dictionary\n    color_map: Function to get color for object\n    center_body: Name or ID of central body (Sun, Earth, Jupiter, etc.)",
    "parameters": [
      "fig",
      "x",
      "y",
      "z",
      "obj_name",
      "a",
      "e",
      "date",
      "current_position",
      "orbital_params",
      "color_map",
      "center_body"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_apohelion_marker",
    "component_id": "apsidal_markers.add_apohelion_marker"
  },
  "apsidal_markers.add_closest_approach_marker": {
    "id": "apsidal_markers.add_closest_approach_marker",
    "name": "add_closest_approach_marker",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [
      "apsidal_markers.get_apsidal_terms",
      "constants_new.color_map"
    ],
    "source_code": "def add_closest_approach_marker(fig, positions_dict, obj_name, center_body, color_map, date_range=None, marker_color=None):\n\n    \"\"\"\n    Find and mark the closest plotted approach point from trajectory data.\n    \n    Works for ANY object passing near ANY center body, regardless of whether\n    the object orbits that center. Uses proper astronomical terminology.\n    \n    Parameters:\n        fig: Plotly figure object\n        positions_dict: Dictionary with date keys and position values {'x':, 'y':, 'z':}\n        obj_name: Name of the object\n        center_body: Name or ID of central body (for terminology)\n        color_map: Function to get object color\n        date_range: Optional tuple (start_date, end_date) to filter positions\n    \n    Returns:\n        None (modifies fig in place)\n        \n    Examples:\n        - Comet C/2025 V1 closest plotted point to Earth -> \"Closest Plotted (Perigee)\"\n        - Asteroid flyby of Mars -> \"Closest Plotted (Periareion)\"\n        - Spacecraft encounter with Jupiter -> \"Closest Plotted (Perijove)\"\n    \"\"\"\n    import numpy as np\n    from datetime import datetime\n    \n    if not positions_dict or len(positions_dict) == 0:\n        print(f\"No trajectory data for closest plotted of {obj_name}\", flush=True)\n        return\n    \n    # Get terminology for this center body\n    near_term, far_term = get_apsidal_terms(center_body)\n    \n    # Calculate distances for all positions\n    dates = []\n    distances = []\n    positions = []\n    \n    for date_str, pos in positions_dict.items():\n        if date_range:\n            # Filter by date range if provided\n            try:\n                date = datetime.fromisoformat(date_str)\n                if not (date_range[0] <= date <= date_range[1]):\n                    continue\n            except:\n                pass  # If date parsing fails, include the position\n        \n        dates.append(date_str)\n        distance = np.sqrt(pos['x']**2 + pos['y']**2 + pos['z']**2)\n        distances.append(distance)\n        positions.append(pos)\n    \n    if len(distances) == 0:\n        print(f\"No positions in date range for {obj_name} closest plotted\", flush=True)\n        return\n    \n    # Find closest plotted point\n    closest_idx = np.argmin(distances)\n    closest_date = dates[closest_idx]\n    closest_distance = distances[closest_idx]\n    closest_pos = positions[closest_idx]\n    \n    # Format date nicely\n    try:\n        date_obj = datetime.fromisoformat(closest_date)\n        date_str_formatted = date_obj.strftime('%Y-%m-%d %H:%M:%S UTC')\n    except:\n        date_str_formatted = closest_date\n    \n    # Create label using proper terminology\n#    label = f\"Closest Plotted ({near_term})\"\n    label = f\"Closest Plotted Point\"\n    \n    # Create comprehensive hover text\n    km_distance = closest_distance * 149597870.7  # AU to km\n    \n    # Use appropriate precision based on distance scale\n    if closest_distance < 0.0001:  # Less than ~15,000 km - show scientific notation\n        au_str = f\"{closest_distance:.2e} AU\"\n    elif closest_distance < 0.001:  # Less than ~150,000 km - show 8 decimal places\n        au_str = f\"{closest_distance:.8f} AU\"\n    else:\n        au_str = f\"{closest_distance:.6f} AU\"\n    \n    # Show km with appropriate precision\n    if km_distance < 10:\n        km_str = f\"{km_distance:.2f} km\"\n    elif km_distance < 1000:\n        km_str = f\"{km_distance:.1f} km\"\n    else:\n        km_str = f\"{km_distance:,.0f} km\"\n    \n    hover_text = (\n        f\"<b>{obj_name} {label}</b><br>\"\n        f\"Date: {date_str_formatted}<br>\"\n        f\"Distance from center: {au_str}<br>\"\n        f\"Distance from center: {km_str}\"\n    )\n    \n    # Add marker to plot - using diamond symbol to distinguish from apsidal markers\n    fig.add_trace(\n        go.Scatter3d(\n            x=[closest_pos['x']],\n            y=[closest_pos['y']],\n            z=[closest_pos['z']],\n            mode='markers',\n            marker=dict(\n                size=8,\n        #        color=color_map(obj_name),\n                color=marker_color if marker_color else color_map(obj_name),               \n                symbol='square-open',  # Different from apsidal markers (square-open)\n            ),\n            name=f\"{obj_name} {label}\",\n            text=[hover_text],\n            customdata=[f\"{obj_name} {label}\"],\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    )\n    \n    print(f\"-> Added closest plotted marker for {obj_name} to {center_body}: {closest_distance:.6f} AU on {date_str_formatted}\", flush=True)",
    "start_line": 1363,
    "end_line": 1485,
    "has_docstring": true,
    "docstring": "Find and mark the closest plotted approach point from trajectory data.\n\nWorks for ANY object passing near ANY center body, regardless of whether\nthe object orbits that center. Uses proper astronomical terminology.\n\nParameters:\n    fig: Plotly figure object\n    positions_dict: Dictionary with date keys and position values {'x':, 'y':, 'z':}\n    obj_name: Name of the object\n    center_body: Name or ID of central body (for terminology)\n    color_map: Function to get object color\n    date_range: Optional tuple (start_date, end_date) to filter positions\n\nReturns:\n    None (modifies fig in place)\n    \nExamples:\n    - Comet C/2025 V1 closest plotted point to Earth -> \"Closest Plotted (Perigee)\"\n    - Asteroid flyby of Mars -> \"Closest Plotted (Periareion)\"\n    - Spacecraft encounter with Jupiter -> \"Closest Plotted (Perijove)\"",
    "parameters": [
      "fig",
      "positions_dict",
      "obj_name",
      "center_body",
      "color_map",
      "date_range",
      "marker_color"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_closest_approach_marker",
    "component_id": "apsidal_markers.add_closest_approach_marker"
  },
  "apsidal_markers.solve_kepler_equation": {
    "id": "apsidal_markers.solve_kepler_equation",
    "name": "solve_kepler_equation",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [],
    "source_code": "def solve_kepler_equation(M, e, tolerance=1e-10, max_iterations=100):\n    \"\"\"\n    Solve Kepler's equation M = E - e*sin(E) for eccentric anomaly E.\n    Uses Newton-Raphson iteration.\n    \n    Parameters:\n        M: Mean anomaly in radians\n        e: Eccentricity (must be < 1 for elliptical orbits)\n        tolerance: Convergence tolerance\n        max_iterations: Maximum iterations before giving up\n        \n    Returns:\n        E: Eccentric anomaly in radians\n    \"\"\"\n    import numpy as np\n    \n    # Initial guess (good for small eccentricity)\n    E = M if e < 0.8 else np.pi\n    \n    for _ in range(max_iterations):\n        f = E - e * np.sin(E) - M\n        f_prime = 1 - e * np.cos(E)\n        delta = f / f_prime\n        E = E - delta\n        if abs(delta) < tolerance:\n            break\n    \n    return E",
    "start_line": 1489,
    "end_line": 1516,
    "has_docstring": true,
    "docstring": "Solve Kepler's equation M = E - e*sin(E) for eccentric anomaly E.\nUses Newton-Raphson iteration.\n\nParameters:\n    M: Mean anomaly in radians\n    e: Eccentricity (must be < 1 for elliptical orbits)\n    tolerance: Convergence tolerance\n    max_iterations: Maximum iterations before giving up\n    \nReturns:\n    E: Eccentric anomaly in radians",
    "parameters": [
      "M",
      "e",
      "tolerance",
      "max_iterations"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function solve_kepler_equation",
    "component_id": "apsidal_markers.solve_kepler_equation"
  },
  "apsidal_markers.eccentric_to_true_anomaly": {
    "id": "apsidal_markers.eccentric_to_true_anomaly",
    "name": "eccentric_to_true_anomaly",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [],
    "source_code": "def eccentric_to_true_anomaly(E, e):\n    \"\"\"\n    Convert eccentric anomaly to true anomaly.\n    \n    Parameters:\n        E: Eccentric anomaly in radians\n        e: Eccentricity\n        \n    Returns:\n        theta: True anomaly in radians\n    \"\"\"\n    import numpy as np\n    \n    # Use the half-angle formula for numerical stability\n    theta = 2 * np.arctan2(\n        np.sqrt(1 + e) * np.sin(E / 2),\n        np.sqrt(1 - e) * np.cos(E / 2)\n    )\n    \n    return theta",
    "start_line": 1519,
    "end_line": 1538,
    "has_docstring": true,
    "docstring": "Convert eccentric anomaly to true anomaly.\n\nParameters:\n    E: Eccentric anomaly in radians\n    e: Eccentricity\n    \nReturns:\n    theta: True anomaly in radians",
    "parameters": [
      "E",
      "e"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function eccentric_to_true_anomaly",
    "component_id": "apsidal_markers.eccentric_to_true_anomaly"
  },
  "apsidal_markers.calculate_keplerian_position": {
    "id": "apsidal_markers.calculate_keplerian_position",
    "name": "calculate_keplerian_position",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [
      "apsidal_markers.solve_kepler_equation",
      "apsidal_markers.eccentric_to_true_anomaly",
      "planet_visualization_utilities.rotate_points"
    ],
    "source_code": "def calculate_keplerian_position(orbital_params, current_datetime, rotate_points):\n    \"\"\"\n    Calculate the Keplerian (analytical) position of an object at a given time.\n    \n    This uses the cached osculating elements (a, e, i, omega, Omega, MA, epoch)\n    to compute where the object should be based purely on two-body orbital mechanics.\n    \n    Parameters:\n        orbital_params: Dictionary containing:\n            - a: Semi-major axis (AU)\n            - e: Eccentricity\n            - i: Inclination (degrees)\n            - omega: Argument of periapsis (degrees)  \n            - Omega: Longitude of ascending node (degrees)\n            - MA: Mean anomaly at epoch (degrees)\n            - epoch: Epoch date string (e.g., \"2026-01-10 osc.\")\n        current_datetime: datetime object for the desired time\n        rotate_points: Function to rotate points in 3D space\n        \n    Returns:\n        dict: {'x': float, 'y': float, 'z': float, 'distance': float, \n               'true_anomaly_deg': float, 'calculation_details': str}\n        or None if calculation fails\n    \"\"\"\n    import numpy as np\n    from datetime import datetime\n    from constants_new import KNOWN_ORBITAL_PERIODS\n    \n    try:\n        # Extract orbital elements\n        a = orbital_params.get('a')\n        e = orbital_params.get('e')\n        i = orbital_params.get('i', 0)\n        omega = orbital_params.get('omega', 0)\n        Omega = orbital_params.get('Omega', 0)\n        MA_epoch_deg = orbital_params.get('MA')  # Mean anomaly at epoch in degrees\n        epoch_str = orbital_params.get('epoch', '')\n        \n        # Validate required parameters\n        if a is None or e is None or MA_epoch_deg is None:\n            print(f\"[KEPLERIAN POS] Missing required orbital elements (a={a}, e={e}, MA={MA_epoch_deg})\", flush=True)\n            return None\n        \n        if e >= 1:\n            print(f\"[KEPLERIAN POS] Hyperbolic orbit (e={e}) - position calculation not supported\", flush=True)\n            return None\n        \n        # Parse epoch date\n        # Handle various epoch formats like \"2026-01-10 osc.\" or \"2026-01-10\"\n        epoch_date_str = epoch_str.replace(' osc.', '').strip()\n        try:\n            epoch_datetime = datetime.strptime(epoch_date_str, '%Y-%m-%d')\n        except ValueError:\n            try:\n                epoch_datetime = datetime.strptime(epoch_date_str, '%Y-%m-%d %H:%M:%S')\n            except ValueError:\n                print(f\"[KEPLERIAN POS] Could not parse epoch date: {epoch_str}\", flush=True)\n                return None\n        \n        # Calculate time elapsed since epoch (in days)\n        delta_t_days = (current_datetime - epoch_datetime).total_seconds() / 86400.0\n        \n        # Get orbital period to calculate mean motion\n        # Try to get from params first, then from KNOWN_ORBITAL_PERIODS\n        period_days = orbital_params.get('orbital_period_days')\n        if period_days is None:\n            # Calculate from semi-major axis using Kepler's 3rd law\n            # P^2 = a^3 (for heliocentric, P in years, a in AU)\n            period_years = np.sqrt(a**3)\n            period_days = period_years * 365.25\n        \n        # Calculate mean motion (radians per day)\n        n = 2 * np.pi / period_days\n        \n        # Calculate current mean anomaly\n        MA_epoch_rad = np.radians(MA_epoch_deg)\n        MA_current_rad = (MA_epoch_rad + n * delta_t_days) % (2 * np.pi)\n        \n        # Solve Kepler's equation to get eccentric anomaly\n        E = solve_kepler_equation(MA_current_rad, e)\n        \n        # Convert to true anomaly\n        theta = eccentric_to_true_anomaly(E, e)\n        \n        # Calculate radius at this true anomaly\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        \n        # Position in orbital plane\n        x_orbit = r * np.cos(theta)\n        y_orbit = r * np.sin(theta)\n        z_orbit = 0.0\n        \n        # Convert angles to radians for rotation\n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n        \n        # Apply orbital element rotations (same sequence as calculate_exact_apsides)\n        # 1. Rotate by argument of periapsis (omega) around z-axis\n        x_temp, y_temp, z_temp = rotate_points([x_orbit], [y_orbit], [z_orbit], omega_rad, 'z')\n        # 2. Rotate by inclination (i) around x-axis\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n        # 3. Rotate by longitude of ascending node (Omega) around z-axis\n        x_final, y_final, z_final = rotate_points(x_temp, y_temp, z_temp, Omega_rad, 'z')\n        \n        # Extract single point\n        x = x_final[0]\n        y = y_final[0]\n        z = z_final[0]\n        distance = np.sqrt(x**2 + y**2 + z**2)\n        \n        # Build calculation details for hover text\n        details = (f\"Epoch: {epoch_str}<br>\"\n                   f\"Days since epoch: {delta_t_days:.2f}<br>\"\n                   f\"Mean Anomaly: {np.degrees(MA_current_rad):.2f} deg<br>\"\n                   f\"True Anomaly: {np.degrees(theta):.2f} deg\")\n        \n        return {\n            'x': x,\n            'y': y,\n            'z': z,\n            'distance': distance,\n            'true_anomaly_deg': np.degrees(theta),\n            'calculation_details': details\n        }\n        \n    except Exception as ex:\n        print(f\"[KEPLERIAN POS] Error calculating position: {ex}\", flush=True)\n        return None",
    "start_line": 1541,
    "end_line": 1669,
    "has_docstring": true,
    "docstring": "Calculate the Keplerian (analytical) position of an object at a given time.\n\nThis uses the cached osculating elements (a, e, i, omega, Omega, MA, epoch)\nto compute where the object should be based purely on two-body orbital mechanics.\n\nParameters:\n    orbital_params: Dictionary containing:\n        - a: Semi-major axis (AU)\n        - e: Eccentricity\n        - i: Inclination (degrees)\n        - omega: Argument of periapsis (degrees)  \n        - Omega: Longitude of ascending node (degrees)\n        - MA: Mean anomaly at epoch (degrees)\n        - epoch: Epoch date string (e.g., \"2026-01-10 osc.\")\n    current_datetime: datetime object for the desired time\n    rotate_points: Function to rotate points in 3D space\n    \nReturns:\n    dict: {'x': float, 'y': float, 'z': float, 'distance': float, \n           'true_anomaly_deg': float, 'calculation_details': str}\n    or None if calculation fails",
    "parameters": [
      "orbital_params",
      "current_datetime",
      "rotate_points"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_keplerian_position",
    "component_id": "apsidal_markers.calculate_keplerian_position"
  },
  "apsidal_markers.add_keplerian_position_marker": {
    "id": "apsidal_markers.add_keplerian_position_marker",
    "name": "add_keplerian_position_marker",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\apsidal_markers.py",
    "relative_path": "apsidal_markers.py",
    "depends_on": [
      "apsidal_markers.calculate_keplerian_position"
    ],
    "source_code": "def add_keplerian_position_marker(fig, obj_name, orbital_params, current_datetime, \n                                   rotate_points, center_body='Sun'):\n    \"\"\"\n    Add a Keplerian (analytical) current position marker to the plot.\n    \n    This marker shows where the object should be based purely on two-body\n    orbital mechanics, calculated from cached osculating elements.\n    \n    The marker is:\n    - White color (to distinguish from object's actual color)\n    - Standard circle symbol (consistent with other position markers)\n    - Default visibility: legendonly (user can toggle on)\n    - Label: \"{Object} Keplerian Position\"\n    \n    Parameters:\n        fig: Plotly figure object\n        obj_name: Name of the object\n        orbital_params: Dictionary of orbital elements (from osculating cache)\n        current_datetime: datetime for position calculation\n        rotate_points: Function to rotate points in 3D space\n        center_body: Name of central body (for terminology)\n        \n    Returns:\n        bool: True if marker was added, False otherwise\n    \"\"\"\n    import plotly.graph_objects as go\n    import numpy as np\n    \n    # Calculate the Keplerian position\n    position = calculate_keplerian_position(orbital_params, current_datetime, rotate_points)\n    \n    if position is None:\n        print(f\"[KEPLERIAN POS] Could not calculate position for {obj_name}\", flush=True)\n        return False\n    \n    # Get epoch for label\n    epoch_str = orbital_params.get('epoch', 'unknown')\n    \n    # Format current datetime for hover\n    current_str = current_datetime.strftime('%Y-%m-%d %H:%M:%S UTC')\n    \n    # Build comprehensive hover text\n    hover_text = (\n        f\"<b>{obj_name} Keplerian Position</b><br>\"\n        f\"<i>(Calculated from osculating elements)</i><br>\"\n        f\"<br>\"\n        f\"Current time: {current_str}<br>\"\n        f\"Distance from center: {position['distance']:.6f} AU<br>\"\n        f\"<br>\"\n        f\"<b>Calculation Details:</b><br>\"\n        f\"{position['calculation_details']}<br>\"\n        f\"<br>\"\n        f\"<i>Note: This is the analytically calculated<br>\"\n        f\"position assuming pure two-body motion.<br>\"\n        f\"Compare with actual position to see<br>\"\n        f\"perturbation effects.</i>\"\n    )\n    \n    # Create label\n    label = f\"Keplerian Position (Epoch: {epoch_str})\"\n    \n    # Add marker to plot\n    fig.add_trace(\n        go.Scatter3d(\n            x=[position['x']],\n            y=[position['y']],\n            z=[position['z']],\n            mode='markers',\n            marker=dict(\n                size=8,\n                color='white',  # White to distinguish from object color\n                symbol='circle',  # Standard circle\n                line=dict(color='gray', width=1)  # Subtle outline for visibility\n            ),\n            name=f\"{obj_name} {label}\",\n            text=[hover_text],\n            customdata=[f\"{obj_name} {label}\"],\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True,\n            visible='legendonly'  # Hidden by default, user can toggle on\n        )\n    )\n    \n    print(f\"[KEPLERIAN POS] Added marker for {obj_name} at distance {position['distance']:.6f} AU (TA={position['true_anomaly_deg']:.1f} deg)\", flush=True)\n    return True",
    "start_line": 1672,
    "end_line": 1756,
    "has_docstring": true,
    "docstring": "Add a Keplerian (analytical) current position marker to the plot.\n\nThis marker shows where the object should be based purely on two-body\norbital mechanics, calculated from cached osculating elements.\n\nThe marker is:\n- White color (to distinguish from object's actual color)\n- Standard circle symbol (consistent with other position markers)\n- Default visibility: legendonly (user can toggle on)\n- Label: \"{Object} Keplerian Position\"\n\nParameters:\n    fig: Plotly figure object\n    obj_name: Name of the object\n    orbital_params: Dictionary of orbital elements (from osculating cache)\n    current_datetime: datetime for position calculation\n    rotate_points: Function to rotate points in 3D space\n    center_body: Name of central body (for terminology)\n    \nReturns:\n    bool: True if marker was added, False otherwise",
    "parameters": [
      "fig",
      "obj_name",
      "orbital_params",
      "current_datetime",
      "rotate_points",
      "center_body"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_keplerian_position_marker",
    "component_id": "apsidal_markers.add_keplerian_position_marker"
  },
  "asteroid_belt_visualization_shells.calculate_body_angle": {
    "id": "asteroid_belt_visualization_shells.calculate_body_angle",
    "name": "calculate_body_angle",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\asteroid_belt_visualization_shells.py",
    "relative_path": "asteroid_belt_visualization_shells.py",
    "depends_on": [],
    "source_code": "def calculate_body_angle(x, y):\n    \"\"\"\n    Calculate the orbital angle of a body from its x,y coordinates.\n    \n    Parameters:\n        x (float): x-coordinate in AU\n        y (float): y-coordinate in AU\n        \n    Returns:\n        float: Angle in radians (0 to 2pi)\n    \"\"\"\n    angle = np.arctan2(y, x)\n    # Ensure angle is in range [0, 2pi]\n    if angle < 0:\n        angle += 2 * np.pi\n    return angle",
    "start_line": 17,
    "end_line": 32,
    "has_docstring": true,
    "docstring": "Calculate the orbital angle of a body from its x,y coordinates.\n\nParameters:\n    x (float): x-coordinate in AU\n    y (float): y-coordinate in AU\n    \nReturns:\n    float: Angle in radians (0 to 2pi)",
    "parameters": [
      "x",
      "y"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_body_angle",
    "component_id": "asteroid_belt_visualization_shells.calculate_body_angle"
  },
  "asteroid_belt_visualization_shells.get_jupiter_angle_from_data": {
    "id": "asteroid_belt_visualization_shells.get_jupiter_angle_from_data",
    "name": "get_jupiter_angle_from_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\asteroid_belt_visualization_shells.py",
    "relative_path": "asteroid_belt_visualization_shells.py",
    "depends_on": [
      "asteroid_belt_visualization_shells.calculate_body_angle"
    ],
    "source_code": "def get_jupiter_angle_from_data(ephemeris_data, date_index=0):\n    \"\"\"\n    Extract Jupiter's angle from ephemeris data.\n    \n    Parameters:\n        ephemeris_data (dict): Dictionary containing ephemeris data\n        date_index (int): Index of the date to use (0 for first date)\n        \n    Returns:\n        float: Jupiter's orbital angle in radians, or 0 if not found\n    \"\"\"\n    try:\n        # Look for Jupiter in the ephemeris data\n        if 'Jupiter' in ephemeris_data:\n            jupiter_data = ephemeris_data['Jupiter']\n            if 'x' in jupiter_data and 'y' in jupiter_data:\n                x = jupiter_data['x'][date_index]\n                y = jupiter_data['y'][date_index]\n                return calculate_body_angle(x, y)\n    except (KeyError, IndexError, TypeError):\n        pass\n    \n    # Return default angle if data not available\n    return 0.0",
    "start_line": 35,
    "end_line": 58,
    "has_docstring": true,
    "docstring": "Extract Jupiter's angle from ephemeris data.\n\nParameters:\n    ephemeris_data (dict): Dictionary containing ephemeris data\n    date_index (int): Index of the date to use (0 for first date)\n    \nReturns:\n    float: Jupiter's orbital angle in radians, or 0 if not found",
    "parameters": [
      "ephemeris_data",
      "date_index"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_jupiter_angle_from_data",
    "component_id": "asteroid_belt_visualization_shells.get_jupiter_angle_from_data"
  },
  "asteroid_belt_visualization_shells.estimate_jupiter_angle_from_date": {
    "id": "asteroid_belt_visualization_shells.estimate_jupiter_angle_from_date",
    "name": "estimate_jupiter_angle_from_date",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\asteroid_belt_visualization_shells.py",
    "relative_path": "asteroid_belt_visualization_shells.py",
    "depends_on": [],
    "source_code": "def estimate_jupiter_angle_from_date(date_str):\n    \"\"\"\n    Estimate Jupiter's orbital angle from a date string.\n    Jupiter's orbital period is ~11.86 years.\n    \n    Parameters:\n        date_str (str): Date in format 'YYYY-MM-DD'\n        \n    Returns:\n        float: Estimated angle in radians\n    \"\"\"\n    from datetime import datetime\n    \n    try:\n        # Parse date\n        date = datetime.strptime(date_str, '%Y-%m-%d')\n        \n        # Reference: Jupiter at angle 0 on Jan 1, 2000\n        ref_date = datetime(2000, 1, 1)\n        days_elapsed = (date - ref_date).days\n        \n        # Jupiter's orbital period in days\n        jupiter_period = 11.86 * 365.25\n        \n        # Calculate angle (radians)\n        angle = (2 * np.pi * days_elapsed / jupiter_period) % (2 * np.pi)\n        \n        return angle\n    except:\n        return 0.0",
    "start_line": 61,
    "end_line": 90,
    "has_docstring": true,
    "docstring": "Estimate Jupiter's orbital angle from a date string.\nJupiter's orbital period is ~11.86 years.\n\nParameters:\n    date_str (str): Date in format 'YYYY-MM-DD'\n    \nReturns:\n    float: Estimated angle in radians",
    "parameters": [
      "date_str"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function estimate_jupiter_angle_from_date",
    "component_id": "asteroid_belt_visualization_shells.estimate_jupiter_angle_from_date"
  },
  "asteroid_belt_visualization_shells.create_main_asteroid_belt": {
    "id": "asteroid_belt_visualization_shells.create_main_asteroid_belt",
    "name": "create_main_asteroid_belt",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\asteroid_belt_visualization_shells.py",
    "relative_path": "asteroid_belt_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator"
    ],
    "source_code": "def create_main_asteroid_belt(center_position=(0, 0, 0)):\n    \"\"\"\n    Creates a visualization of the main asteroid belt with density variations and Kirkwood gaps.\n    \n    Parameters:\n        center_position (tuple): (x, y, z) position of the Sun\n        \n    Returns:\n        list: Plotly trace objects for the main belt\n    \"\"\"\n    center_x, center_y, center_z = center_position\n    \n    # Create multiple density rings to show the structure\n    n_particles = 8000  # Total particles to distribute\n    n_rings = 30  # Number of radial rings\n    \n    belt_x = []\n    belt_y = []\n    belt_z = []\n    belt_colors = []\n    belt_sizes = []\n    \n    for i in range(n_rings):\n        # Calculate radius for this ring\n        radius = MAIN_BELT_INNER + (MAIN_BELT_OUTER - MAIN_BELT_INNER) * (i / (n_rings - 1))\n        \n        # Calculate density based on distance from peak and Kirkwood gaps\n        # Gaussian peak around 2.7 AU\n        density = np.exp(-((radius - MAIN_BELT_PEAK) ** 2) / (0.3 ** 2))\n        \n        # Apply Kirkwood gap reductions\n        for gap in KIRKWOOD_GAPS:\n            gap_factor = np.exp(-((radius - gap) ** 2) / (0.05 ** 2))\n            density *= (1 - 0.7 * gap_factor)  # 70% reduction in gaps\n        \n        # Number of particles in this ring based on density\n        n_in_ring = max(int(n_particles * density / n_rings), 5)\n        \n        # Generate particles in this ring\n        for j in range(n_in_ring):\n            angle = np.random.uniform(0, 2 * np.pi)\n            \n            # Add some radial jitter\n            r_jitter = np.random.normal(0, 0.05)\n            r = radius + r_jitter\n            \n            # Position in orbital plane with some inclination\n            x = r * np.cos(angle)\n            y = r * np.sin(angle)\n            \n            # Vertical thickness - gets thicker farther from peak\n            z_scale = 0.1 + 0.2 * abs(radius - MAIN_BELT_PEAK) / (MAIN_BELT_OUTER - MAIN_BELT_INNER)\n            z = np.random.normal(0, z_scale)\n            \n            belt_x.append(x)\n            belt_y.append(y)\n            belt_z.append(z)\n            \n            # Color gradient: inner belt (reddish-brown) to outer belt (gray-brown)\n            color_factor = (radius - MAIN_BELT_INNER) / (MAIN_BELT_OUTER - MAIN_BELT_INNER)\n            r_color = int(180 + 30 * (1 - color_factor))\n            g_color = int(140 + 20 * (1 - color_factor))\n            b_color = int(100 + 30 * color_factor)\n            belt_colors.append(f'rgb({r_color}, {g_color}, {b_color})')\n            \n            # Size variation\n            belt_sizes.append(np.random.uniform(0.8, 2.0))\n    \n    # Apply center position offset\n    belt_x = np.array(belt_x) + center_x\n    belt_y = np.array(belt_y) + center_y\n    belt_z = np.array(belt_z) + center_z\n    \n    # Create the main belt hover text\n    belt_text = [\"Main Asteroid Belt: Rocky debris between Mars and Jupiter (2.2-3.2 AU).<br>\"\n                 \"Contains millions of asteroids with distinct Kirkwood gaps caused by<br>\"\n                 \"Jupiter's gravitational resonances. Peak density at ~2.7 AU.\"] * len(belt_x)\n    belt_customdata = ['Main Asteroid Belt'] * len(belt_x)\n    \n    traces = [\n        go.Scatter3d(\n            x=belt_x,\n            y=belt_y,\n            z=belt_z,\n            mode='markers',\n            marker=dict(\n                size=belt_sizes,\n                color=belt_colors,\n                opacity=0.4\n            ),\n            name='Main Asteroid Belt',\n            text=belt_text,\n            customdata=belt_customdata,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position,\n        shell_radius=MAIN_BELT_PEAK\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n    \n    return traces",
    "start_line": 124,
    "end_line": 229,
    "has_docstring": true,
    "docstring": "Creates a visualization of the main asteroid belt with density variations and Kirkwood gaps.\n\nParameters:\n    center_position (tuple): (x, y, z) position of the Sun\n    \nReturns:\n    list: Plotly trace objects for the main belt",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_main_asteroid_belt",
    "component_id": "asteroid_belt_visualization_shells.create_main_asteroid_belt"
  },
  "asteroid_belt_visualization_shells.create_hilda_group": {
    "id": "asteroid_belt_visualization_shells.create_hilda_group",
    "name": "create_hilda_group",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\asteroid_belt_visualization_shells.py",
    "relative_path": "asteroid_belt_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator"
    ],
    "source_code": "def create_hilda_group(center_position=(0, 0, 0)):\n    \"\"\"\n    Creates a visualization of the Hilda asteroid group showing triangular structure.\n    \n    Parameters:\n        center_position (tuple): (x, y, z) position of the Sun\n        \n    Returns:\n        list: Plotly trace objects for Hilda group\n    \"\"\"\n    center_x, center_y, center_z = center_position\n    \n    # Hildas form three concentrations 120 degrees apart\n    # These correspond to stable points in the 3:2 resonance\n    concentration_angles = [0, 2*np.pi/3, 4*np.pi/3]  # 0 deg, 120 deg, 240 deg\n    \n    hilda_x = []\n    hilda_y = []\n    hilda_z = []\n    \n    n_per_concentration = 800  # Asteroids per concentration point\n    \n    for base_angle in concentration_angles:\n        for i in range(n_per_concentration):\n            # Angular spread around each concentration\n            angle = base_angle + np.random.normal(0, 0.3)  # ~17 degree spread\n            \n            # Radial distance with some variation\n            radius = HILDA_DISTANCE + np.random.normal(0, 0.08)\n            \n            # Position\n            x = radius * np.cos(angle)\n            y = radius * np.sin(angle)\n            z = np.random.normal(0, 0.05)  # Small vertical spread\n            \n            hilda_x.append(x)\n            hilda_y.append(y)\n            hilda_z.append(z)\n    \n    # Apply center position offset\n    hilda_x = np.array(hilda_x) + center_x\n    hilda_y = np.array(hilda_y) + center_y\n    hilda_z = np.array(hilda_z) + center_z\n    \n    # Create hover text\n    hilda_text = [\"Hilda Family: Asteroids in 3:2 resonance with Jupiter at ~3.97 AU.<br>\"\n                  \"Forms distinctive triangular pattern with three main concentrations<br>\"\n                  \"120 deg apart. Mostly D-type (dark, reddish) asteroids.\"] * len(hilda_x)\n    hilda_customdata = ['Hilda Family'] * len(hilda_x)\n    \n    traces = [\n        go.Scatter3d(\n            x=hilda_x,\n            y=hilda_y,\n            z=hilda_z,\n            mode='markers',\n            marker=dict(\n                size=1.5,\n                color='rgb(200, 170, 100)',  # Golden-yellow\n                opacity=0.5\n            ),\n            name='Hilda Family',\n            text=hilda_text,\n            customdata=hilda_customdata,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position,\n        shell_radius=HILDA_DISTANCE\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n    \n    return traces",
    "start_line": 245,
    "end_line": 321,
    "has_docstring": true,
    "docstring": "Creates a visualization of the Hilda asteroid group showing triangular structure.\n\nParameters:\n    center_position (tuple): (x, y, z) position of the Sun\n    \nReturns:\n    list: Plotly trace objects for Hilda group",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_hilda_group",
    "component_id": "asteroid_belt_visualization_shells.create_hilda_group"
  },
  "asteroid_belt_visualization_shells.create_jupiter_trojans_greeks": {
    "id": "asteroid_belt_visualization_shells.create_jupiter_trojans_greeks",
    "name": "create_jupiter_trojans_greeks",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\asteroid_belt_visualization_shells.py",
    "relative_path": "asteroid_belt_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator"
    ],
    "source_code": "def create_jupiter_trojans_greeks(center_position=(0, 0, 0), jupiter_angle=0):\n    \"\"\"\n    Creates a visualization of Jupiter's L4 Trojan asteroids (Greek camp).\n    \n    Parameters:\n        center_position (tuple): (x, y, z) position of the Sun\n        jupiter_angle (float): Current angle of Jupiter in radians (for positioning L4 correctly)\n        \n    Returns:\n        list: Plotly trace objects for L4 Trojans\n    \"\"\"\n    center_x, center_y, center_z = center_position\n    \n    # L4 point is 60 degrees ahead of Jupiter\n    l4_angle = jupiter_angle + np.pi/3\n    \n    trojan_x = []\n    trojan_y = []\n    trojan_z = []\n    \n    n_asteroids = 1500  # Number of asteroids in Greek camp\n    \n    for i in range(n_asteroids):\n        # Create a cloud around the L4 point\n        # Angular spread\n        angle = l4_angle + np.random.normal(0, 0.4)  # ~23 degree spread\n        \n        # Radial spread around Jupiter's orbit\n        radius = TROJAN_DISTANCE + np.random.normal(0, 0.15)\n        \n        # Position\n        x = radius * np.cos(angle)\n        y = radius * np.sin(angle)\n        z = np.random.normal(0, 0.2)  # Vertical spread\n        \n        trojan_x.append(x)\n        trojan_y.append(y)\n        trojan_z.append(z)\n    \n    # Apply center position offset\n    trojan_x = np.array(trojan_x) + center_x\n    trojan_y = np.array(trojan_y) + center_y\n    trojan_z = np.array(trojan_z) + center_z\n    \n    # Create hover text\n    trojan_text = [\"Jupiter Trojans (L4 - Greeks): Asteroids trapped at Jupiter's leading<br>\"\n                   \"Lagrange point (L4), 60 deg ahead. Called 'Greek camp' after Iliad heroes.<br>\"\n                   \"Contains thousands of D-type asteroids, targets of NASA's Lucy mission.\"] * len(trojan_x)\n    trojan_customdata = ['Jupiter Trojans (Greeks - L4)'] * len(trojan_x)\n    \n    traces = [\n        go.Scatter3d(\n            x=trojan_x,\n            y=trojan_y,\n            z=trojan_z,\n            mode='markers',\n            marker=dict(\n                size=1.5,\n                color='rgb(180, 100, 100)',  # Reddish\n                opacity=0.5\n            ),\n            name='Jupiter Trojans (Greeks - L4)',\n            text=trojan_text,\n            customdata=trojan_customdata,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position,\n        shell_radius=TROJAN_DISTANCE\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n    \n    return traces",
    "start_line": 338,
    "end_line": 414,
    "has_docstring": true,
    "docstring": "Creates a visualization of Jupiter's L4 Trojan asteroids (Greek camp).\n\nParameters:\n    center_position (tuple): (x, y, z) position of the Sun\n    jupiter_angle (float): Current angle of Jupiter in radians (for positioning L4 correctly)\n    \nReturns:\n    list: Plotly trace objects for L4 Trojans",
    "parameters": [
      "center_position",
      "jupiter_angle"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_jupiter_trojans_greeks",
    "component_id": "asteroid_belt_visualization_shells.create_jupiter_trojans_greeks"
  },
  "asteroid_belt_visualization_shells.create_jupiter_trojans_trojans": {
    "id": "asteroid_belt_visualization_shells.create_jupiter_trojans_trojans",
    "name": "create_jupiter_trojans_trojans",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\asteroid_belt_visualization_shells.py",
    "relative_path": "asteroid_belt_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator"
    ],
    "source_code": "def create_jupiter_trojans_trojans(center_position=(0, 0, 0), jupiter_angle=0):\n    \"\"\"\n    Creates a visualization of Jupiter's L5 Trojan asteroids (Trojan camp).\n    \n    Parameters:\n        center_position (tuple): (x, y, z) position of the Sun\n        jupiter_angle (float): Current angle of Jupiter in radians (for positioning L5 correctly)\n        \n    Returns:\n        list: Plotly trace objects for L5 Trojans\n    \"\"\"\n    center_x, center_y, center_z = center_position\n    \n    # L5 point is 60 degrees behind Jupiter\n    l5_angle = jupiter_angle - np.pi/3\n    \n    trojan_x = []\n    trojan_y = []\n    trojan_z = []\n    \n    n_asteroids = 1200  # Slightly fewer than L4 (observed asymmetry)\n    \n    for i in range(n_asteroids):\n        # Create a cloud around the L5 point\n        # Angular spread\n        angle = l5_angle + np.random.normal(0, 0.4)  # ~23 degree spread\n        \n        # Radial spread around Jupiter's orbit\n        radius = TROJAN_DISTANCE + np.random.normal(0, 0.15)\n        \n        # Position\n        x = radius * np.cos(angle)\n        y = radius * np.sin(angle)\n        z = np.random.normal(0, 0.2)  # Vertical spread\n        \n        trojan_x.append(x)\n        trojan_y.append(y)\n        trojan_z.append(z)\n    \n    # Apply center position offset\n    trojan_x = np.array(trojan_x) + center_x\n    trojan_y = np.array(trojan_y) + center_y\n    trojan_z = np.array(trojan_z) + center_z\n    \n    # Create hover text\n    trojan_text = [\"Jupiter Trojans (L5 - Trojans): Asteroids trapped at Jupiter's trailing<br>\"\n                   \"Lagrange point (L5), 60 deg behind. Called 'Trojan camp' after Iliad heroes.<br>\"\n                   \"Slightly less populated than L4, contains D-type asteroids.\"] * len(trojan_x)\n    trojan_customdata = ['Jupiter Trojans (Trojans - L5)'] * len(trojan_x)\n    \n    traces = [\n        go.Scatter3d(\n            x=trojan_x,\n            y=trojan_y,\n            z=trojan_z,\n            mode='markers',\n            marker=dict(\n                size=1.5,\n                color='rgb(160, 80, 80)',  # Slightly darker reddish\n                opacity=0.5\n            ),\n            name='Jupiter Trojans (Trojans - L5)',\n            text=trojan_text,\n            customdata=trojan_customdata,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position,\n        shell_radius=TROJAN_DISTANCE\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n    \n    return traces",
    "start_line": 430,
    "end_line": 506,
    "has_docstring": true,
    "docstring": "Creates a visualization of Jupiter's L5 Trojan asteroids (Trojan camp).\n\nParameters:\n    center_position (tuple): (x, y, z) position of the Sun\n    jupiter_angle (float): Current angle of Jupiter in radians (for positioning L5 correctly)\n    \nReturns:\n    list: Plotly trace objects for L5 Trojans",
    "parameters": [
      "center_position",
      "jupiter_angle"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_jupiter_trojans_trojans",
    "component_id": "asteroid_belt_visualization_shells.create_jupiter_trojans_trojans"
  },
  "catalog_selection.select_stars": {
    "id": "catalog_selection.select_stars",
    "name": "select_stars",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\catalog_selection.py",
    "relative_path": "catalog_selection.py",
    "depends_on": [
      "data_processing.estimate_vmag_from_gaia"
    ],
    "source_code": "def select_stars(hip_data, gaia_data, mode='magnitude', limit_value=None):\n    \"\"\"\n    Unified star selection function applying consistent catalog separation logic.\n    \n    Parameters:\n        hip_data (astropy.table.Table): Hipparcos catalog data\n        gaia_data (astropy.table.Table): Gaia catalog data\n        mode (str): 'magnitude' or 'distance'\n        limit_value (float): Maximum distance in light-years or magnitude limit\n            \n    Returns:\n        tuple: (combined_data, counts)\n            - combined_data: astropy Table with selected stars\n            - counts: dictionary with star counts by category\n    \"\"\"\n    print(f\"\\nSelecting stars by {mode}...\")\n    \n    all_selected_stars = []\n    counts = {\n        'hip_bright_count': 0,\n        'hip_mid_count': 0,\n        'gaia_mid_count': 0,\n        'gaia_faint_count': 0,\n        'total_stars': 0,\n        'plottable_count': 0,\n        'missing_temp_only': 0,  # Initialize with defaults\n        'missing_lum_only': 0,   # Initialize with defaults\n        'source_counts': {},      # Initialize empty dict for source counts\n        'estimation_results': {}  # Initialize empty dict for estimation results\n    }\n    \n    if hip_data is not None:\n        if mode == 'distance':\n            primary_mask = hip_data['Distance_ly'] <= limit_value\n        else:  # magnitude mode\n            primary_mask = hip_data['Vmag'] <= limit_value\n            \n        # Always apply magnitude-based catalog separation for Hipparcos\n        magnitude_mask = hip_data['Vmag'] <= 4.0  # Only use Hipparcos for Vmag <= 4.0\n        \n        # Combine masks\n        hip_stars = hip_data[primary_mask & magnitude_mask]\n        \n        if len(hip_stars) > 0:\n            # Count categories\n            bright_mask = hip_stars['Vmag'] <= 1.73\n            mid_mask = (hip_stars['Vmag'] > 1.73) & (hip_stars['Vmag'] <= 4.0)\n            \n            hip_stars['Source_Catalog'] = 'Hipparcos'\n            hip_stars['Apparent_Magnitude'] = hip_stars['Vmag']\n            \n            counts['hip_bright_count'] = int(np.sum(bright_mask))\n            counts['hip_mid_count'] = int(np.sum(mid_mask))\n            \n            all_selected_stars.append(hip_stars)\n            print(f\"Selected {len(hip_stars)} Hipparcos stars\")\n    \n    if gaia_data is not None:\n        if mode == 'distance':\n            primary_mask = gaia_data['Distance_ly'] <= limit_value\n        else:  # magnitude mode\n            if 'Estimated_Vmag' not in gaia_data.colnames:\n                gaia_data['Estimated_Vmag'] = estimate_vmag_from_gaia(gaia_data)\n            primary_mask = gaia_data['Estimated_Vmag'] <= limit_value\n            \n        gaia_stars = gaia_data[primary_mask]\n        \n        if len(gaia_stars) > 0:\n            # Ensure Estimated_Vmag is present\n            if 'Estimated_Vmag' not in gaia_stars.colnames:\n                gaia_stars['Estimated_Vmag'] = estimate_vmag_from_gaia(gaia_stars)\n                \n            gaia_stars['Source_Catalog'] = 'Gaia'\n            gaia_stars['Apparent_Magnitude'] = gaia_stars['Estimated_Vmag']\n            \n            # Always apply magnitude-based catalog separation for Gaia\n            magnitude_mask = gaia_stars['Apparent_Magnitude'] > 4.0\n            gaia_stars = gaia_stars[magnitude_mask]\n            \n            if len(gaia_stars) > 0:\n                counts['gaia_faint_count'] = len(gaia_stars)\n                all_selected_stars.append(gaia_stars)\n                print(f\"Selected {len(gaia_stars)} Gaia stars\")\n    \n    # Combine selected stars\n    if not all_selected_stars:\n        print(f\"No stars found within specified {mode} limit\")\n        return None, counts\n        \n    combined_data = vstack(all_selected_stars)\n    counts['total_stars'] = len(combined_data)\n    \n    # Print summary\n    print(\"\\nFinal Selection Summary:\")\n    print(f\"Hipparcos bright stars (Vmag <= 1.73): {counts['hip_bright_count']}\")\n    print(f\"Hipparcos mid-range stars (1.73 < Vmag <= 4.0): {counts['hip_mid_count']}\")\n    print(f\"Gaia faint stars (Vmag > 4.0): {counts['gaia_faint_count']}\")\n    print(f\"Total stars: {counts['total_stars']}\")\n    \n    return combined_data, counts",
    "start_line": 5,
    "end_line": 104,
    "has_docstring": true,
    "docstring": "Unified star selection function applying consistent catalog separation logic.\n\nParameters:\n    hip_data (astropy.table.Table): Hipparcos catalog data\n    gaia_data (astropy.table.Table): Gaia catalog data\n    mode (str): 'magnitude' or 'distance'\n    limit_value (float): Maximum distance in light-years or magnitude limit\n        \nReturns:\n    tuple: (combined_data, counts)\n        - combined_data: astropy Table with selected stars\n        - counts: dictionary with star counts by category",
    "parameters": [
      "hip_data",
      "gaia_data",
      "mode",
      "limit_value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function select_stars",
    "component_id": "catalog_selection.select_stars"
  },
  "celestial_coordinates.format_ra_dec_string": {
    "id": "celestial_coordinates.format_ra_dec_string",
    "name": "format_ra_dec_string",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\celestial_coordinates.py",
    "relative_path": "celestial_coordinates.py",
    "depends_on": [],
    "source_code": "def format_ra_dec_string(ra_hours, ra_minutes, ra_seconds, \n                         dec_degrees, dec_arcmin, dec_arcsec,\n                         precision_ra_sec=2, precision_dec_arcsec=1):\n    \"\"\"\n    Format RA/Dec values into standard astronomical notation strings.\n    \n    Parameters:\n        ra_hours, ra_minutes, ra_seconds: Right Ascension components\n        dec_degrees, dec_arcmin, dec_arcsec: Declination components\n        precision_ra_sec: Number of decimal places for RA seconds\n        precision_dec_arcsec: Number of decimal places for Dec arcseconds\n        \n    Returns:\n        tuple: (ra_string, dec_string)\n    \"\"\"\n    # Format RA string (HH:MM:SS.SS)\n    ra_string = f\"{ra_hours:02d}h {ra_minutes:02d}m {ra_seconds:0{4+precision_ra_sec}.{precision_ra_sec}f}s\"\n    \n    # Format Dec string (+/-DD deg MM' SS.S\")\n    dec_sign = '+' if dec_degrees >= 0 else ''\n    if dec_degrees < 0 and dec_arcmin == 0 and dec_arcsec < 1:\n        # Handle case where declination is slightly negative but rounds to 0\n        dec_sign = '-'\n        dec_string = f\"{dec_sign}{abs(dec_degrees):02d} deg {dec_arcmin:02d}' {dec_arcsec:0{3+precision_dec_arcsec}.{precision_dec_arcsec}f}\\\"\"\n    else:\n        dec_string = f\"{dec_sign}{dec_degrees:02d} deg {abs(dec_arcmin):02d}' {abs(dec_arcsec):0{3+precision_dec_arcsec}.{precision_dec_arcsec}f}\\\"\"\n    \n    return ra_string, dec_string",
    "start_line": 11,
    "end_line": 38,
    "has_docstring": true,
    "docstring": "Format RA/Dec values into standard astronomical notation strings.\n\nParameters:\n    ra_hours, ra_minutes, ra_seconds: Right Ascension components\n    dec_degrees, dec_arcmin, dec_arcsec: Declination components\n    precision_ra_sec: Number of decimal places for RA seconds\n    precision_dec_arcsec: Number of decimal places for Dec arcseconds\n    \nReturns:\n    tuple: (ra_string, dec_string)",
    "parameters": [
      "ra_hours",
      "ra_minutes",
      "ra_seconds",
      "dec_degrees",
      "dec_arcmin",
      "dec_arcsec",
      "precision_ra_sec",
      "precision_dec_arcsec"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function format_ra_dec_string",
    "component_id": "celestial_coordinates.format_ra_dec_string"
  },
  "celestial_coordinates.format_ra_dec_decimal": {
    "id": "celestial_coordinates.format_ra_dec_decimal",
    "name": "format_ra_dec_decimal",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\celestial_coordinates.py",
    "relative_path": "celestial_coordinates.py",
    "depends_on": [],
    "source_code": "def format_ra_dec_decimal(ra_decimal_hours, dec_decimal_degrees, precision=6):\n    \"\"\"\n    Format RA/Dec in decimal format.\n    \n    Parameters:\n        ra_decimal_hours: Right Ascension in decimal hours\n        dec_decimal_degrees: Declination in decimal degrees\n        precision: Number of decimal places\n        \n    Returns:\n        tuple: (ra_string, dec_string)\n    \"\"\"\n    ra_string = f\"{ra_decimal_hours:.{precision}f}h\"\n    dec_sign = '+' if dec_decimal_degrees >= 0 else ''\n    dec_string = f\"{dec_sign}{dec_decimal_degrees:.{precision}f} deg\"\n    \n    return ra_string, dec_string",
    "start_line": 41,
    "end_line": 57,
    "has_docstring": true,
    "docstring": "Format RA/Dec in decimal format.\n\nParameters:\n    ra_decimal_hours: Right Ascension in decimal hours\n    dec_decimal_degrees: Declination in decimal degrees\n    precision: Number of decimal places\n    \nReturns:\n    tuple: (ra_string, dec_string)",
    "parameters": [
      "ra_decimal_hours",
      "dec_decimal_degrees",
      "precision"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function format_ra_dec_decimal",
    "component_id": "celestial_coordinates.format_ra_dec_decimal"
  },
  "celestial_coordinates.extract_jpl_radec": {
    "id": "celestial_coordinates.extract_jpl_radec",
    "name": "extract_jpl_radec",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\celestial_coordinates.py",
    "relative_path": "celestial_coordinates.py",
    "depends_on": [],
    "source_code": "def extract_jpl_radec(obj_data):\n    \"\"\"Extract RA/Dec from JPL Horizons data if available.\"\"\"\n    if 'ra' in obj_data and 'dec' in obj_data and obj_data['ra'] is not None:\n        ra_deg = obj_data['ra']\n        dec_deg = obj_data['dec']\n        \n        # Convert RA from degrees to hours/minutes/seconds\n        ra_hours_decimal = ra_deg / 15.0  # 360 degrees = 24 hours\n        ra_hours = int(ra_hours_decimal)\n        ra_minutes_decimal = (ra_hours_decimal - ra_hours) * 60\n        ra_minutes = int(ra_minutes_decimal)\n        ra_seconds = (ra_minutes_decimal - ra_minutes) * 60\n        \n        # Convert Dec to degrees/arcminutes/arcseconds\n        dec_sign = 1 if dec_deg >= 0 else -1\n        dec_deg_abs = abs(dec_deg)\n        dec_degrees = int(dec_deg_abs) * dec_sign\n        dec_arcmin_decimal = (dec_deg_abs - abs(dec_degrees)) * 60\n        dec_arcmin = int(dec_arcmin_decimal)\n        dec_arcsec = (dec_arcmin_decimal - dec_arcmin) * 60\n        \n        # Format with high precision since this is from JPL\n        ra_string = f\"{ra_hours:02d}h {ra_minutes:02d}m {ra_seconds:06.3f}s\"\n        dec_string = f\"{'+' if dec_degrees >= 0 else ''}{dec_degrees:02d} deg {abs(dec_arcmin):02d}' {abs(dec_arcsec):05.2f}\\\"\"\n        \n        return ra_string, dec_string\n    \n    return None, None",
    "start_line": 60,
    "end_line": 87,
    "has_docstring": true,
    "docstring": "Extract RA/Dec from JPL Horizons data if available.",
    "parameters": [
      "obj_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extract_jpl_radec",
    "component_id": "celestial_coordinates.extract_jpl_radec"
  },
  "celestial_coordinates.calculate_radec_for_position": {
    "id": "celestial_coordinates.calculate_radec_for_position",
    "name": "calculate_radec_for_position",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\celestial_coordinates.py",
    "relative_path": "celestial_coordinates.py",
    "depends_on": [
      "celestial_coordinates.extract_jpl_radec"
    ],
    "source_code": "def calculate_radec_for_position(obj_data, obj_name=None):\n    \"\"\"Extract RA/Dec from JPL Horizons data.\"\"\"\n    result = {\n        'ra_string': None,\n        'dec_string': None,\n        'source': 'JPL Horizons',\n        'reference_frame': 'ICRF, Earth-centered'\n    }\n    \n    ra_jpl, dec_jpl = extract_jpl_radec(obj_data)\n    if ra_jpl and dec_jpl:\n        result['ra_string'] = ra_jpl\n        result['dec_string'] = dec_jpl\n        return result\n    \n    # If no JPL data, return None (don't calculate)\n    return result",
    "start_line": 89,
    "end_line": 105,
    "has_docstring": true,
    "docstring": "Extract RA/Dec from JPL Horizons data.",
    "parameters": [
      "obj_data",
      "obj_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_radec_for_position",
    "component_id": "celestial_coordinates.calculate_radec_for_position"
  },
  "celestial_coordinates.add_radec_to_hover_text": {
    "id": "celestial_coordinates.add_radec_to_hover_text",
    "name": "add_radec_to_hover_text",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\celestial_coordinates.py",
    "relative_path": "celestial_coordinates.py",
    "depends_on": [
      "celestial_coordinates.calculate_radec_for_position"
    ],
    "source_code": "def add_radec_to_hover_text(hover_text, obj_data, obj_name=None, insert_after_line=2):\n    \"\"\"Add RA/Dec to hover text - always Earth-centered.\"\"\"\n    \n    # Get RA/Dec info\n    radec_info = calculate_radec_for_position(obj_data, obj_name)\n    \n    if radec_info['ra_string'] and radec_info['dec_string']:\n        # Always show as Earth-centered ICRF\n        radec_line = f\"RA: {radec_info['ra_string']}, Dec: {radec_info['dec_string']} (ICRF)\"\n        \n        # Split hover text into lines\n        lines = hover_text.split('<br>')\n        \n        # Insert coordinates after specified line\n        if len(lines) > insert_after_line:\n            lines.insert(insert_after_line, radec_line)\n        else:\n            lines.append(radec_line)\n        \n        # Rejoin lines\n        return '<br>'.join(lines)\n    \n    return hover_text",
    "start_line": 107,
    "end_line": 129,
    "has_docstring": true,
    "docstring": "Add RA/Dec to hover text - always Earth-centered.",
    "parameters": [
      "hover_text",
      "obj_data",
      "obj_name",
      "insert_after_line"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_radec_to_hover_text",
    "component_id": "celestial_coordinates.add_radec_to_hover_text"
  },
  "celestial_coordinates.get_precision_note": {
    "id": "celestial_coordinates.get_precision_note",
    "name": "get_precision_note",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\celestial_coordinates.py",
    "relative_path": "celestial_coordinates.py",
    "depends_on": [],
    "source_code": "def get_precision_note(obj_data, obj_name=None):\n    \"\"\"\n    Get precision estimate - prefer actual JPL uncertainties, \n    then use known values for major bodies, finally fall back to estimates.\n    \n    Parameters:\n        obj_data (dict): Object data containing possible uncertainty values\n        obj_name (str): Name of the object (optional but recommended)\n        \n    Returns:\n        str: Formatted precision string (e.g., \"+/-0.5 arcsec\" or \"+/-10 arcsec\")\n    \"\"\"\n    \n    # 1. Check for actual 3-sigma uncertainties from JPL\n    if 'ra_3sigma' in obj_data and obj_data['ra_3sigma'] is not None:\n        ra_sigma = obj_data['ra_3sigma']  # in arcseconds\n        dec_sigma = obj_data.get('dec_3sigma', ra_sigma)  # in arcseconds\n        \n        # Use the larger of the two for a conservative estimate\n        max_sigma = max(ra_sigma, dec_sigma) if dec_sigma is not None else ra_sigma\n        \n        # Format based on magnitude\n        if max_sigma < 0.001:\n            return f\"+/-{max_sigma:.4f} arcsec\"\n        elif max_sigma < 0.01:\n            return f\"+/-{max_sigma:.3f} arcsec\"\n        elif max_sigma < 0.1:\n            return f\"+/-{max_sigma:.2f} arcsec\"\n        elif max_sigma < 1:\n            return f\"+/-{max_sigma:.2f} arcsec\"\n        elif max_sigma < 10:\n            return f\"+/-{max_sigma:.1f} arcsec\"\n        else:\n            return f\"+/-{max_sigma:.0f} arcsec\"\n    \n    # 2. Check if this is a known major body\n    if obj_name and obj_name in MAJOR_BODY_UNCERTAINTIES:\n        uncertainty = MAJOR_BODY_UNCERTAINTIES[obj_name]\n        \n        # Format based on magnitude\n        if uncertainty < 0.001:\n            return f\"+/-{uncertainty:.4f} arcsec\"\n        elif uncertainty < 0.01:\n            return f\"+/-{uncertainty:.3f} arcsec\"\n        elif uncertainty < 0.1:\n            return f\"+/-{uncertainty:.2f} arcsec\"\n        elif uncertainty < 1:\n            return f\"+/-{uncertainty:.1f} arcsec\"\n        else:\n            return f\"+/-{uncertainty:.0f} arcsec\"\n    \n    # 3. Fallback to type-based estimates\n    obj_type = obj_data.get('object_type', 'unknown')\n    \n    if obj_type == 'satellite':\n        return \"+/-0.1 arcsec\"  # Most moons are well-tracked\n    elif obj_type == 'orbital':\n        # Check if it might be an asteroid/comet by name pattern\n        if obj_name:\n            # Common patterns for minor bodies\n            if any(char.isdigit() for char in obj_name[:4]):  # Starts with number (e.g., \"2023 FY\")\n                return \"+/-10 arcsec\"  # New discovery uncertainty\n            elif '/' in obj_name:  # Comet designation (e.g., \"C/2023 A1\")\n                return \"+/-5 arcsec\"\n        return \"+/-1 arcsec\"  # Default for established orbital bodies\n    elif obj_type == 'trajectory':\n        return \"+/-5 arcsec\"  # Spacecraft, comets\n    else:\n        return \"+/-10 arcsec\"  # Unknown/other",
    "start_line": 383,
    "end_line": 451,
    "has_docstring": true,
    "docstring": "Get precision estimate - prefer actual JPL uncertainties, \nthen use known values for major bodies, finally fall back to estimates.\n\nParameters:\n    obj_data (dict): Object data containing possible uncertainty values\n    obj_name (str): Name of the object (optional but recommended)\n    \nReturns:\n    str: Formatted precision string (e.g., \"+/-0.5 arcsec\" or \"+/-10 arcsec\")",
    "parameters": [
      "obj_data",
      "obj_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_precision_note",
    "component_id": "celestial_coordinates.get_precision_note"
  },
  "celestial_coordinates.format_radec_hover_component": {
    "id": "celestial_coordinates.format_radec_hover_component",
    "name": "format_radec_hover_component",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\celestial_coordinates.py",
    "relative_path": "celestial_coordinates.py",
    "depends_on": [
      "celestial_coordinates.extract_jpl_radec",
      "celestial_coordinates.get_precision_note"
    ],
    "source_code": "def format_radec_hover_component(obj_data, obj_name=None, compact=False):\n    \"\"\"\n    Format RA/Dec for hover text with actual uncertainties when available.\n    \n    Parameters:\n        obj_data (dict): Object data possibly containing JPL uncertainties\n        obj_name (str): Name of the object (optional but recommended)\n        compact (bool): Whether to use compact formatting\n        \n    Returns:\n        str: Formatted RA/Dec string for hover text\n    \"\"\"\n    \n    ra_string, dec_string = extract_jpl_radec(obj_data)\n    \n    if not ra_string or not dec_string:\n        return \"\"\n    \n    # Get precision note - will check JPL data, then major body lookup, then estimates\n    precision_note = get_precision_note(obj_data, obj_name)\n    \n    # Add source indicator for transparency\n    source_note = \"\"\n    if 'ra_3sigma' in obj_data and obj_data['ra_3sigma'] is not None:\n        source_note = \", JPL Horizons 3-sigma\"\n    elif obj_name and obj_name in MAJOR_BODY_UNCERTAINTIES:\n        source_note = \", JPL DE440/441 ephemeris\"\n    else:\n        source_note = \", typical\"\n    \n    if compact:\n        return f\"RA/Dec: {ra_string}, {dec_string} (apparent, {precision_note}{source_note})\"\n    else:\n        return (f\"Right Ascension: {ra_string} (apparent, {precision_note}{source_note})<br>\"\n                f\"Declination: {dec_string} (apparent, {precision_note}{source_note})\")",
    "start_line": 454,
    "end_line": 488,
    "has_docstring": true,
    "docstring": "Format RA/Dec for hover text with actual uncertainties when available.\n\nParameters:\n    obj_data (dict): Object data possibly containing JPL uncertainties\n    obj_name (str): Name of the object (optional but recommended)\n    compact (bool): Whether to use compact formatting\n    \nReturns:\n    str: Formatted RA/Dec string for hover text",
    "parameters": [
      "obj_data",
      "obj_name",
      "compact"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function format_radec_hover_component",
    "component_id": "celestial_coordinates.format_radec_hover_component"
  },
  "celestial_coordinates.determine_coordinate_precision": {
    "id": "celestial_coordinates.determine_coordinate_precision",
    "name": "determine_coordinate_precision",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\celestial_coordinates.py",
    "relative_path": "celestial_coordinates.py",
    "depends_on": [],
    "source_code": "def determine_coordinate_precision(obj_data, obj_name):\n    \"\"\"\n    Determine appropriate precision for RA/Dec display based on object type and data source.\n    \n    Parameters:\n        obj_data (dict): Object data\n        obj_name (str): Name of the object\n        \n    Returns:\n        tuple: (ra_seconds_precision, dec_arcsec_precision)\n    \"\"\"\n    # Default precision\n    ra_sec_precision = 2\n    dec_arcsec_precision = 1\n    \n    # Higher precision for certain objects\n    if any(keyword in obj_name.lower() for keyword in ['voyager', 'pioneer', 'new horizons', 'cassini']):\n        # Spacecraft need higher precision\n        ra_sec_precision = 3\n        dec_arcsec_precision = 2\n    elif 'asteroid' in obj_name.lower() or 'comet' in obj_name.lower():\n        # Small bodies may need higher precision\n        ra_sec_precision = 3\n        dec_arcsec_precision = 1\n    elif any(planet in obj_name for planet in ['Mercury', 'Venus', 'Mars']):\n        # Inner planets move faster, need more precision\n        ra_sec_precision = 3\n        dec_arcsec_precision = 1\n    \n    # Check if we have high-precision data from JPL\n    if 'ra' in obj_data and 'dec' in obj_data:\n        # If JPL provided the data, we can use higher precision\n        if 'source' in obj_data and 'horizons' in obj_data['source'].lower():\n            ra_sec_precision = min(ra_sec_precision + 1, 4)\n            dec_arcsec_precision = min(dec_arcsec_precision + 1, 3)\n    \n    return ra_sec_precision, dec_arcsec_precision",
    "start_line": 491,
    "end_line": 527,
    "has_docstring": true,
    "docstring": "Determine appropriate precision for RA/Dec display based on object type and data source.\n\nParameters:\n    obj_data (dict): Object data\n    obj_name (str): Name of the object\n    \nReturns:\n    tuple: (ra_seconds_precision, dec_arcsec_precision)",
    "parameters": [
      "obj_data",
      "obj_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function determine_coordinate_precision",
    "component_id": "celestial_coordinates.determine_coordinate_precision"
  },
  "celestial_objects.build_objects_list": {
    "id": "celestial_objects.build_objects_list",
    "name": "build_objects_list",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\celestial_objects.py",
    "relative_path": "celestial_objects.py",
    "depends_on": [],
    "source_code": "def build_objects_list(definitions, vars_dict, color_map_func):\n    \"\"\"\n    Build the runtime objects list from definitions.\n    \n    Args:\n        definitions: OBJECT_DEFINITIONS list\n        vars_dict: Dictionary mapping var_name strings to tk.IntVar instances\n        color_map_func: The color_map function from constants_new\n    \n    Returns:\n        List of object dictionaries with 'var' and 'color' resolved\n    \"\"\"\n    objects = []\n    for defn in definitions:\n        obj = defn.copy()\n        \n        # Resolve var reference\n        var_name = obj.pop('var_name', None)\n        if var_name and var_name in vars_dict:\n            obj['var'] = vars_dict[var_name]\n        \n        # Resolve color\n        color_key = obj.pop('color_key', obj.get('name', 'default'))\n        obj['color'] = color_map_func(color_key)\n        \n        objects.append(obj)\n    \n    return objects",
    "start_line": 1170,
    "end_line": 1197,
    "has_docstring": true,
    "docstring": "Build the runtime objects list from definitions.\n\nArgs:\n    definitions: OBJECT_DEFINITIONS list\n    vars_dict: Dictionary mapping var_name strings to tk.IntVar instances\n    color_map_func: The color_map function from constants_new\n\nReturns:\n    List of object dictionaries with 'var' and 'color' resolved",
    "parameters": [
      "definitions",
      "vars_dict",
      "color_map_func"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function build_objects_list",
    "component_id": "celestial_objects.build_objects_list"
  },
  "celestial_objects.get_all_var_names": {
    "id": "celestial_objects.get_all_var_names",
    "name": "get_all_var_names",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\celestial_objects.py",
    "relative_path": "celestial_objects.py",
    "depends_on": [],
    "source_code": "def get_all_var_names():\n    \"\"\"Return list of all var_name strings needed for IntVar creation.\"\"\"\n    return [d.get('var_name') for d in OBJECT_DEFINITIONS if d.get('var_name')]",
    "start_line": 1200,
    "end_line": 1202,
    "has_docstring": true,
    "docstring": "Return list of all var_name strings needed for IntVar creation.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_all_var_names",
    "component_id": "celestial_objects.get_all_var_names"
  },
  "celestial_objects.get_shell_var_names": {
    "id": "celestial_objects.get_shell_var_names",
    "name": "get_shell_var_names",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\celestial_objects.py",
    "relative_path": "celestial_objects.py",
    "depends_on": [],
    "source_code": "def get_shell_var_names():\n    \"\"\"Return list of all shell var_name strings needed for IntVar creation.\"\"\"\n    var_names = []\n    for body, shells in SHELL_DEFINITIONS.items():\n        body_prefix = body.lower().replace(' ', '')  # 'Planet 9' -> 'planet9'\n        for shell in shells:\n            var_names.append(f\"{body_prefix}_{shell['var_suffix']}_var\")\n    return var_names",
    "start_line": 1322,
    "end_line": 1329,
    "has_docstring": true,
    "docstring": "Return list of all shell var_name strings needed for IntVar creation.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_shell_var_names",
    "component_id": "celestial_objects.get_shell_var_names"
  },
  "celestial_objects.get_shell_tooltip_names": {
    "id": "celestial_objects.get_shell_tooltip_names",
    "name": "get_shell_tooltip_names",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\celestial_objects.py",
    "relative_path": "celestial_objects.py",
    "depends_on": [],
    "source_code": "def get_shell_tooltip_names():\n    \"\"\"Return list of all shell tooltip info variable names.\"\"\"\n    tooltip_names = []\n    for body, shells in SHELL_DEFINITIONS.items():\n        body_prefix = body.lower().replace(' ', '')\n        for shell in shells:\n            tooltip_names.append(f\"{body_prefix}_{shell['var_suffix']}_info\")\n    return tooltip_names",
    "start_line": 1332,
    "end_line": 1339,
    "has_docstring": true,
    "docstring": "Return list of all shell tooltip info variable names.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_shell_tooltip_names",
    "component_id": "celestial_objects.get_shell_tooltip_names"
  },
  "celestial_objects.build_shell_checkboxes": {
    "id": "celestial_objects.build_shell_checkboxes",
    "name": "build_shell_checkboxes",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\celestial_objects.py",
    "relative_path": "celestial_objects.py",
    "depends_on": [
      "palomas_orrery.CreateToolTip"
    ],
    "source_code": "def build_shell_checkboxes(body_name, parent_frame, vars_dict, tooltips_dict, tk_module, CreateToolTip):\n    \"\"\"\n    Build shell checkboxes for a single body.\n    \n    Args:\n        body_name: Name of the body (e.g., 'Mercury', 'Venus')\n        parent_frame: The parent tk.Frame (usually celestial_frame)\n        vars_dict: Dictionary mapping var_name strings to tk.IntVar instances\n        tooltips_dict: Dictionary mapping tooltip_name strings to info text\n        tk_module: The tkinter module (pass tk)\n        CreateToolTip: The CreateToolTip class\n    \n    Returns:\n        The shell_options_frame created, or None if body has no shells\n    \"\"\"\n    if body_name not in SHELL_DEFINITIONS:\n        return None\n    \n    shells = SHELL_DEFINITIONS[body_name]\n    body_prefix = body_name.lower().replace(' ', '')\n    \n    # Create indented frame for shell options\n    shell_frame = tk_module.Frame(parent_frame)\n    shell_frame.pack(padx=(20, 0), anchor='w')\n    \n    # Create checkboxes for each shell\n    for shell in shells:\n        var_name = f\"{body_prefix}_{shell['var_suffix']}_var\"\n        tooltip_name = f\"{body_prefix}_{shell['var_suffix']}_info\"\n        \n        var = vars_dict.get(var_name)\n        tooltip_text = tooltips_dict.get(tooltip_name, \"No information available\")\n        \n        if var is not None:\n            cb = tk_module.Checkbutton(shell_frame, text=shell['label'], variable=var)\n            cb.pack(anchor='w')\n            CreateToolTip(cb, tooltip_text)\n    \n    return shell_frame",
    "start_line": 1342,
    "end_line": 1380,
    "has_docstring": true,
    "docstring": "Build shell checkboxes for a single body.\n\nArgs:\n    body_name: Name of the body (e.g., 'Mercury', 'Venus')\n    parent_frame: The parent tk.Frame (usually celestial_frame)\n    vars_dict: Dictionary mapping var_name strings to tk.IntVar instances\n    tooltips_dict: Dictionary mapping tooltip_name strings to info text\n    tk_module: The tkinter module (pass tk)\n    CreateToolTip: The CreateToolTip class\n\nReturns:\n    The shell_options_frame created, or None if body has no shells",
    "parameters": [
      "body_name",
      "parent_frame",
      "vars_dict",
      "tooltips_dict",
      "tk_module",
      "CreateToolTip"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function build_shell_checkboxes",
    "component_id": "celestial_objects.build_shell_checkboxes"
  },
  "climate_cache_manager.update_climate_data": {
    "id": "climate_cache_manager.update_climate_data",
    "name": "update_climate_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\climate_cache_manager.py",
    "relative_path": "climate_cache_manager.py",
    "depends_on": [],
    "source_code": "def update_climate_data(status_callback=None):\n    \"\"\"\n    Update all climate datasets by importing and calling fetch functions directly.\n    Returns: (success, message, details)\n    \"\"\"\n    def status(msg):\n        if status_callback:\n            status_callback(msg)\n        print(msg)\n    \n    print(\"\\n\" + \"=\"*70)\n    print(\"CLIMATE DATA UPDATE\")\n    print(\"=\"*70)\n    \n    try:\n        # Try to import the fetch module\n        status(\"Attempting to import fetch_climate_data module...\")\n        import fetch_climate_data\n        status(\"[OK] Successfully loaded fetch_climate_data module\")\n    except ImportError as e:\n        error_msg = f\"Could not import fetch_climate_data: {e}\"\n        status(f\"[FAIL] {error_msg}\")\n        return False, error_msg, {}\n    \n    results = {\n        'co2': {'success': False},\n        'temperature': {'success': False},\n        'ice': {'success': False}\n    }\n    \n    # ========== FETCH CO2 DATA ==========\n    print(\"\\n\" + \"=\"*60)\n    print(\"1. Fetching Mauna Loa CO2 monthly data...\")\n    print(\"=\"*60)\n    \n    try:\n        status(\"Downloading CO2 data from NOAA...\")\n        \n        # fetch_mauna_loa_co2 returns just records (not a tuple)\n        co2_records = fetch_climate_data.fetch_mauna_loa_co2()\n        \n        if not co2_records:\n            raise Exception(\"No CO2 data returned\")\n        \n        status(f\"[OK] Fetched {len(co2_records)} CO2 records\")\n        \n        # save_cache expects: (filename, records, metadata_func)\n        # Pass the function, not the result\n        if fetch_climate_data.save_cache(CO2_OUTPUT_FILE, co2_records, fetch_climate_data.create_co2_metadata):\n            latest = co2_records[-1]\n            co2_value = latest.get('co2_ppm', latest.get('average', 0))\n            status(f\"[OK] CO2 updated: {co2_value:.2f} ppm\")\n            \n            results['co2'] = {\n                'success': True,\n                'records': len(co2_records),\n                'latest': co2_value\n            }\n        else:\n            raise Exception(\"Failed to save CO2 data\")\n        \n    except Exception as e:\n        error_msg = str(e)\n        status(f\"[FAIL] CO2 fetch failed: {error_msg}\")\n        results['co2'] = {'success': False, 'error': error_msg}\n    \n    # ========== FETCH TEMPERATURE DATA ==========\n    print(\"\\n\" + \"=\"*60)\n    print(\"2. Fetching NASA GISS temperature anomaly data...\")\n    print(\"=\"*60)\n    \n    try:\n        status(\"Downloading temperature data from NASA GISS...\")\n        \n        # fetch_nasa_giss_temperature returns (records, metadata) tuple\n        temp_records, temp_metadata = fetch_climate_data.fetch_nasa_giss_temperature()\n        \n        if not temp_records:\n            raise Exception(\"No temperature data returned\")\n        \n        status(f\"[OK] Fetched {len(temp_records)} temperature records\")\n        \n        # For temperature, we already have metadata, so pass it as a lambda\n        if fetch_climate_data.save_cache(TEMP_OUTPUT_FILE, temp_records, lambda r: temp_metadata):\n            latest = temp_records[-1]\n            temp_value = latest.get('anomaly_c', latest.get('anomaly_celsius', 0))\n            status(f\"[OK] Temperature updated: {temp_value:+.2f} deg C\")\n            \n            results['temperature'] = {\n                'success': True,\n                'records': len(temp_records),\n                'latest': temp_value\n            }\n        else:\n            raise Exception(\"Failed to save temperature data\")\n        \n    except Exception as e:\n        error_msg = str(e)\n        status(f\"[FAIL] Temperature fetch failed: {error_msg}\")\n        results['temperature'] = {'success': False, 'error': error_msg}\n    \n    # ========== FETCH ARCTIC ICE DATA ==========\n    print(\"\\n\" + \"=\"*60)\n    print(\"3. Fetching Arctic sea ice extent data...\")\n    print(\"=\"*60)\n    \n    try:\n        status(\"Downloading Arctic ice data from NSIDC...\")\n        \n        # Function is fetch_arctic_ice (not fetch_arctic_sea_ice)\n        # Returns just records (like CO2)\n        ice_records = fetch_climate_data.fetch_arctic_ice()\n        \n        if not ice_records:\n            raise Exception(\"No ice data returned\")\n        \n        status(f\"[OK] Fetched {len(ice_records)} ice records\")\n        \n        # Use create_ice_metadata function if it exists, otherwise create inline\n        if hasattr(fetch_climate_data, 'create_ice_metadata'):\n            metadata_func = fetch_climate_data.create_ice_metadata\n        else:\n            # Inline metadata function\n            def metadata_func(records):\n                return {\n                    'source': 'NSIDC Sea Ice Index V4',\n                    'url': 'https://nsidc.org/data/seaice_index',\n                    'units': 'million km^2',\n                    'records': len(records)\n                }\n        \n        if fetch_climate_data.save_cache(ICE_OUTPUT_FILE, ice_records, metadata_func):\n            latest = ice_records[-1]\n            ice_value = latest.get('extent', latest.get('extent_million_km2', 0))\n            status(f\"[OK] Arctic ice updated: {ice_value:.2f} million km^2\")\n            \n            results['ice'] = {\n                'success': True,\n                'records': len(ice_records),\n                'latest': ice_value\n            }\n        else:\n            raise Exception(\"Failed to save ice data\")\n        \n    except Exception as e:\n        error_msg = str(e)\n        status(f\"[FAIL] Arctic ice fetch failed: {error_msg}\")\n        results['ice'] = {'success': False, 'error': error_msg}\n    \n    # ========== SUMMARY ==========\n    print(\"\\n\" + \"=\"*60)\n    print(\"SUMMARY\")\n    print(\"=\"*60)\n    \n    success_count = sum(1 for r in results.values() if r.get('success', False))\n    total_count = len(results)\n    \n    for dataset, result in results.items():\n        status_str = '[OK]' if result.get('success', False) else '[FAIL]'\n        print(f\"{status_str} {dataset.upper()}: \", end='')\n        if result.get('success'):\n            print(f\"SUCCESS\")\n            print(f\"    Records: {result.get('records', 'N/A')}\")\n            print(f\"    Latest: {result.get('latest', 'N/A')}\")\n        else:\n            print(f\"FAILED - {result.get('error', 'Unknown error')}\")\n    \n    all_success = success_count == total_count\n    \n    if all_success:\n        message = \"All datasets updated successfully!\"\n        status(f\"[OK] {message}\")\n    else:\n        message = f\"{success_count}/{total_count} datasets updated\"\n        status(f\"[WARN] {message}\")\n    \n    print(f\"\\nFinal result: {'SUCCESS' if all_success else 'PARTIAL'}\")\n    print(f\"Message: {message}\")\n    \n    return all_success, message, results",
    "start_line": 18,
    "end_line": 197,
    "has_docstring": true,
    "docstring": "Update all climate datasets by importing and calling fetch functions directly.\nReturns: (success, message, details)",
    "parameters": [
      "status_callback"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function update_climate_data",
    "component_id": "climate_cache_manager.update_climate_data"
  },
  "climate_cache_manager.status": {
    "id": "climate_cache_manager.status",
    "name": "status",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\climate_cache_manager.py",
    "relative_path": "climate_cache_manager.py",
    "depends_on": [],
    "source_code": "    def status(msg):\n        if status_callback:\n            status_callback(msg)\n        print(msg)",
    "start_line": 23,
    "end_line": 26,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "msg"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function status",
    "component_id": "climate_cache_manager.status"
  },
  "climate_cache_manager.metadata_func": {
    "id": "climate_cache_manager.metadata_func",
    "name": "metadata_func",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\climate_cache_manager.py",
    "relative_path": "climate_cache_manager.py",
    "depends_on": [],
    "source_code": "            def metadata_func(records):\n                return {\n                    'source': 'NSIDC Sea Ice Index V4',\n                    'url': 'https://nsidc.org/data/seaice_index',\n                    'units': 'million km^2',\n                    'records': len(records)\n                }",
    "start_line": 141,
    "end_line": 147,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "records"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function metadata_func",
    "component_id": "climate_cache_manager.metadata_func"
  },
  "comet_visualization_shells.calculate_tail_activity_factor": {
    "id": "comet_visualization_shells.calculate_tail_activity_factor",
    "name": "calculate_tail_activity_factor",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\comet_visualization_shells.py",
    "relative_path": "comet_visualization_shells.py",
    "depends_on": [],
    "source_code": "def calculate_tail_activity_factor(current_distance_au, perihelion_distance_au, max_active_distance_au=3.0):\n    \"\"\"\n    Calculate how active the comet is based on solar distance.\n    \n    Activity increases as comet approaches the Sun, peaks around perihelion,\n    and decreases as it moves away. Uses inverse square law approximation.\n    \n    Parameters:\n    -----------\n    current_distance_au : float\n        Current distance from Sun in AU\n    perihelion_distance_au : float\n        Perihelion distance in AU\n    max_active_distance_au : float\n        Distance beyond which comet becomes essentially inactive\n        \n    Returns:\n    --------\n    float : Activity factor from 0 (inactive) to 1 (peak activity)\n    \"\"\"\n    if current_distance_au > max_active_distance_au:\n        return 0.0\n    \n    # Activity roughly follows inverse square law but with a minimum\n    # Activity = 1 at perihelion, decreases with distance\n    activity = min(1.0, (perihelion_distance_au / current_distance_au) ** 1.5)\n    \n    # Add distance fade-out beyond max_active_distance\n    if current_distance_au > perihelion_distance_au:\n        fade_factor = 1.0 - ((current_distance_au - perihelion_distance_au) / \n                             (max_active_distance_au - perihelion_distance_au))\n        activity *= max(0.0, fade_factor)\n    \n    return min(1.0, activity)",
    "start_line": 222,
    "end_line": 255,
    "has_docstring": true,
    "docstring": "Calculate how active the comet is based on solar distance.\n\nActivity increases as comet approaches the Sun, peaks around perihelion,\nand decreases as it moves away. Uses inverse square law approximation.\n\nParameters:\n-----------\ncurrent_distance_au : float\n    Current distance from Sun in AU\nperihelion_distance_au : float\n    Perihelion distance in AU\nmax_active_distance_au : float\n    Distance beyond which comet becomes essentially inactive\n    \nReturns:\n--------\nfloat : Activity factor from 0 (inactive) to 1 (peak activity)",
    "parameters": [
      "current_distance_au",
      "perihelion_distance_au",
      "max_active_distance_au"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_tail_activity_factor",
    "component_id": "comet_visualization_shells.calculate_tail_activity_factor"
  },
  "comet_visualization_shells.create_comet_nucleus": {
    "id": "comet_visualization_shells.create_comet_nucleus",
    "name": "create_comet_nucleus",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\comet_visualization_shells.py",
    "relative_path": "comet_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_comet_nucleus(center_position=(0, 0, 0), nucleus_size_km=5, comet_name=\"Generic\"):\n    \"\"\"\n    Creates a comet nucleus visualization as a single point.\n    \n    The nucleus is far too small to render at scale with the coma,\n    so we represent it as a single visible marker.\n    \n    Parameters:\n    -----------\n    center_position : tuple\n        (x, y, z) position in AU\n    nucleus_size_km : float\n        Diameter of nucleus in kilometers (for info only, not visual scale)\n    comet_name : str\n        Name of the comet for labeling\n    \"\"\"\n    description = (\n        f\"Nucleus of {comet_name}<br>\"\n        f\"Approximate size: {nucleus_size_km} km<br>\"\n        f\"Cometary nuclei are 'dirty snowballs' - irregular chunks of ice, rock, and dust.<br>\"\n        f\"As they approach the Sun, surface ice sublimates, releasing gas and dust.<br>\"\n        f\"Note: The nucleus is far too small to show at scale with the coma.\"\n    )\n    \n    trace = go.Scatter3d(\n        x=[center_position[0]],\n        y=[center_position[1]],\n        z=[center_position[2]],\n        mode='markers',\n        marker=dict(\n            size=4,\n            color='rgb(50, 50, 50)',  # Very dark gray, almost black\n            opacity=0.9,\n            line=dict(color='white', width=1)  # Subtle white outline for visibility\n        ),\n        name=f'{comet_name}: Nucleus',\n        text=[description],\n        customdata=[f'{comet_name}: Nucleus'], \n        hovertemplate='%{text}<extra></extra>',\n        showlegend=True\n    )\n    \n    return [trace]",
    "start_line": 258,
    "end_line": 300,
    "has_docstring": true,
    "docstring": "Creates a comet nucleus visualization as a single point.\n\nThe nucleus is far too small to render at scale with the coma,\nso we represent it as a single visible marker.\n\nParameters:\n-----------\ncenter_position : tuple\n    (x, y, z) position in AU\nnucleus_size_km : float\n    Diameter of nucleus in kilometers (for info only, not visual scale)\ncomet_name : str\n    Name of the comet for labeling",
    "parameters": [
      "center_position",
      "nucleus_size_km",
      "comet_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_comet_nucleus",
    "component_id": "comet_visualization_shells.create_comet_nucleus"
  },
  "comet_visualization_shells.create_comet_coma": {
    "id": "comet_visualization_shells.create_comet_coma",
    "name": "create_comet_coma",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\comet_visualization_shells.py",
    "relative_path": "comet_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_comet_coma(center_position=(0, 0, 0), coma_radius_km=100000, \n                      activity_factor=1.0, comet_name=\"Generic\"):\n    \"\"\"\n    Creates the coma (atmosphere) around the nucleus.\n    \n    Parameters:\n    -----------\n    center_position : tuple\n        (x, y, z) position in AU\n    coma_radius_km : float\n        Radius of coma in kilometers\n    activity_factor : float\n        0-1, scales the coma size and brightness\n    comet_name : str\n        Name of the comet\n    \"\"\"\n    if activity_factor < 0.1:\n        return []  # No visible coma if inactive\n    \n    # Scale coma by activity\n    effective_radius_km = coma_radius_km * activity_factor\n    coma_radius_au = effective_radius_km / KM_PER_AU\n    \n    # Create spherical coma with radial density gradient\n    n_particles = 300\n    coma_points_x = []\n    coma_points_y = []\n    coma_points_z = []\n    \n    for i in range(n_particles):\n        # Random spherical distribution, biased toward center\n        r = coma_radius_au * (np.random.random() ** 0.5)  # Square root gives denser center\n        theta = np.random.uniform(0, 2 * np.pi)\n        phi = np.random.uniform(0, np.pi)\n        \n        x = r * np.sin(phi) * np.cos(theta)\n        y = r * np.sin(phi) * np.sin(theta)\n        z = r * np.cos(phi)\n        \n        coma_points_x.append(center_position[0] + x)\n        coma_points_y.append(center_position[1] + y)\n        coma_points_z.append(center_position[2] + z)\n    \n\n# Get comet-specific color\n    comet_data = HISTORICAL_TAIL_DATA.get(comet_name, HISTORICAL_TAIL_DATA['default'])\n    coma_color_name = comet_data.get('coma_color', 'green')\n    color_palette = COMET_COLOR_PALETTES.get(coma_color_name, COMET_COLOR_PALETTES['green'])\n    base_r, base_g, base_b = color_palette['base_rgb']\n    \n    # Enhanced color with better visibility\n    colors = []\n    for i in range(n_particles):\n        # Increased alpha for better visibility: 0.5-0.9 instead of 0.3\n        alpha = (0.5 + 0.4 * activity_factor) * np.random.uniform(0.7, 1.0)\n        # Slight color variation for natural look\n        r = int(base_r * np.random.uniform(0.9, 1.0))\n        g = int(base_g * np.random.uniform(0.9, 1.0))\n        b = int(base_b * np.random.uniform(0.9, 1.0))\n        colors.append(f'rgba({r}, {g}, {b}, {alpha:.3f})')\n\n    \n    description = (\n        f\"Coma of {comet_name}<br>\"\n        f\"Radius: ~{effective_radius_km/1000:.0f} thousand km<br>\"\n        f\"The coma is the fuzzy atmosphere of gas and dust surrounding the nucleus.<br>\"\n        f\"It glows from reflected sunlight and fluorescence of gases like C2 (green).\"\n    )\n    \n    trace = go.Scatter3d(\n        x=coma_points_x, y=coma_points_y, z=coma_points_z,\n        mode='markers',\n        marker=dict(\n            size=3.0,\n            color=colors,\n            opacity=1.0\n        ),\n        name=f'{comet_name}: Coma',\n        text=[description] * len(coma_points_x),\n        customdata=[f'{comet_name}: Coma'] * len(coma_points_x), \n        hovertemplate='%{text}<extra></extra>',\n        showlegend=True\n    )\n    \n    return [trace]",
    "start_line": 303,
    "end_line": 387,
    "has_docstring": true,
    "docstring": "Creates the coma (atmosphere) around the nucleus.\n\nParameters:\n-----------\ncenter_position : tuple\n    (x, y, z) position in AU\ncoma_radius_km : float\n    Radius of coma in kilometers\nactivity_factor : float\n    0-1, scales the coma size and brightness\ncomet_name : str\n    Name of the comet",
    "parameters": [
      "center_position",
      "coma_radius_km",
      "activity_factor",
      "comet_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_comet_coma",
    "component_id": "comet_visualization_shells.create_comet_coma"
  },
  "comet_visualization_shells.create_comet_dust_tail": {
    "id": "comet_visualization_shells.create_comet_dust_tail",
    "name": "create_comet_dust_tail",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\comet_visualization_shells.py",
    "relative_path": "comet_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_comet_dust_tail(center_position=(0, 0, 0), velocity_vector=(0, 0, 0),\n                           max_tail_length_mkm=10, activity_factor=1.0, \n                           comet_name=\"Generic\", num_particles=800):\n    \"\"\"\n    Creates the dust tail (Type II tail).\n    \n    The dust tail is curved, yellowish, and follows the comet's orbital path.\n    Dust particles are pushed by solar radiation pressure but retain orbital momentum.\n    \n    Parameters:\n    -----------\n    center_position : tuple\n        (x, y, z) position in AU\n    velocity_vector : tuple\n        (vx, vy, vz) velocity vector for curved tail direction\n    max_tail_length_mkm : float\n        Maximum tail length in millions of kilometers\n    activity_factor : float\n        0-1, scales tail brightness and length\n    comet_name : str\n        Name of the comet\n    num_particles : int\n        Number of particles to render\n    \"\"\"\n    if activity_factor < 0.05:\n        return []  # No visible tail if very inactive\n    \n    # Scale tail by activity\n    effective_length_km = max_tail_length_mkm * 1e6 * activity_factor\n    max_tail_length_au = effective_length_km / KM_PER_AU\n    \n    # Calculate anti-solar direction\n    center_x, center_y, center_z = center_position\n    sun_distance = math.sqrt(center_x**2 + center_y**2 + center_z**2)\n    \n    if sun_distance < 1e-10:\n        return []  # Can't compute at Sun's location\n    \n    # Anti-solar direction (away from Sun)\n    anti_solar_x = center_x / sun_distance\n    anti_solar_y = center_y / sun_distance\n    anti_solar_z = center_z / sun_distance\n    \n    # Orbital velocity direction (for curve)\n    vel_x, vel_y, vel_z = velocity_vector\n    vel_mag = math.sqrt(vel_x**2 + vel_y**2 + vel_z**2)\n    \n    if vel_mag > 1e-10:\n        vel_x /= vel_mag\n        vel_y /= vel_mag\n        vel_z /= vel_mag\n    else:\n        # No velocity info, make straight tail\n        vel_x, vel_y, vel_z = 0, 0, 0\n    \n    # Dust tail curves backward along orbital path\n    # Blend anti-solar direction with negative velocity direction\n    curve_factor = 0.3  # How much the tail curves\n    tail_dir_x = anti_solar_x - curve_factor * vel_x\n    tail_dir_y = anti_solar_y - curve_factor * vel_y\n    tail_dir_z = anti_solar_z - curve_factor * vel_z\n    \n    # Normalize\n    tail_mag = math.sqrt(tail_dir_x**2 + tail_dir_y**2 + tail_dir_z**2)\n    if tail_mag > 1e-10:\n        tail_dir_x /= tail_mag\n        tail_dir_y /= tail_mag\n        tail_dir_z /= tail_mag\n    else:\n        tail_dir_x, tail_dir_y, tail_dir_z = anti_solar_x, anti_solar_y, anti_solar_z\n    \n    # Create tail particles\n    tail_points_x = []\n    tail_points_y = []\n    tail_points_z = []\n    \n    for i in range(num_particles):\n        # Distance along tail (0 to max_tail_length_au)\n        tail_distance = (i / num_particles) * max_tail_length_au\n        \n        # Dust tail has a broader cone angle than ion tail\n        max_radius = tail_distance * math.tan(math.radians(15))  # ~15 degree opening\n        \n        # Random position within cone cross-section\n        theta = np.random.uniform(0, 2 * math.pi)\n        r = np.random.uniform(0, max_radius) * np.random.random()**0.3  # Bias toward center\n        \n        # Create perpendicular vectors\n        if abs(tail_dir_z) < 0.9:\n            perp1_x = -tail_dir_y\n            perp1_y = tail_dir_x\n            perp1_z = 0\n        else:\n            perp1_x = 1\n            perp1_y = 0\n            perp1_z = -tail_dir_x / tail_dir_z if abs(tail_dir_z) > 1e-10 else 0\n        \n        # Normalize perp1\n        perp1_len = math.sqrt(perp1_x**2 + perp1_y**2 + perp1_z**2)\n        if perp1_len > 1e-10:\n            perp1_x /= perp1_len\n            perp1_y /= perp1_len\n            perp1_z /= perp1_len\n        \n        # Cross product for second perpendicular\n        perp2_x = tail_dir_y * perp1_z - tail_dir_z * perp1_y\n        perp2_y = tail_dir_z * perp1_x - tail_dir_x * perp1_z\n        perp2_z = tail_dir_x * perp1_y - tail_dir_y * perp1_x\n        \n        # Position in tail with slight curve\n        curve_amount = (tail_distance / max_tail_length_au) ** 1.5 * curve_factor * 0.5\n        x = center_x + tail_distance * tail_dir_x + r * (math.cos(theta) * perp1_x + math.sin(theta) * perp2_x)\n        y = center_y + tail_distance * tail_dir_y + r * (math.cos(theta) * perp1_y + math.sin(theta) * perp2_y)\n        z = center_z + tail_distance * tail_dir_z + r * (math.cos(theta) * perp1_z + math.sin(theta) * perp2_z)\n        \n        # Add curve in velocity direction\n        x -= curve_amount * vel_x * tail_distance\n        y -= curve_amount * vel_y * tail_distance\n        z -= curve_amount * vel_z * tail_distance\n        \n        tail_points_x.append(x)\n        tail_points_y.append(y)\n        tail_points_z.append(z)\n    \n# Get comet-specific color\n    comet_data = HISTORICAL_TAIL_DATA.get(comet_name, HISTORICAL_TAIL_DATA['default'])\n    dust_color_name = comet_data.get('dust_tail_color', 'yellow')\n    color_palette = COMET_COLOR_PALETTES.get(dust_color_name, COMET_COLOR_PALETTES['yellow'])\n    base_r, base_g, base_b = color_palette['base_rgb']\n    \n    # Enhanced color with distance fade\n    colors = []\n    for i in range(num_particles):\n        distance_factor = 1 - (i / num_particles)\n        # Increased alpha: 0.7-0.95 at base, fading with distance\n        alpha = (0.7 + 0.25 * activity_factor) * (distance_factor ** 1.2)\n        alpha = max(alpha, 0.05)  # Minimum visibility\n        # Color fades slightly with distance\n        fade = 0.85 + 0.15 * distance_factor\n        r = int(base_r * fade)\n        g = int(base_g * fade)\n        b = int(base_b * fade)\n        colors.append(f'rgba({r}, {g}, {b}, {alpha:.3f})')\n\n    \n    description = (\n        f\"Dust Tail (Type II) of {comet_name}<br>\"\n        f\"Maximum length: ~{max_tail_length_mkm * activity_factor:.1f} million km<br>\"\n        f\"The dust tail is composed of small dust particles pushed by solar radiation pressure.<br>\"\n        f\"It curves slightly along the comet's orbital path and appears yellowish from reflected sunlight.<br>\"\n        f\"Dust particles are larger and slower than ions, creating the characteristic curved shape.\"\n    )\n    \n    trace = go.Scatter3d(\n        x=tail_points_x, y=tail_points_y, z=tail_points_z,\n        mode='markers',\n        marker=dict(\n            size=2.0,\n            color=colors,\n            opacity=1.0\n        ),\n        name=f'{comet_name}: Dust Tail',\n        text=[description] * len(tail_points_x),\n        customdata=[f'{comet_name}: Dust Tail'] * len(tail_points_x),\n        hovertemplate='%{text}<extra></extra>',\n        showlegend=True\n    )\n    \n    return [trace]",
    "start_line": 390,
    "end_line": 558,
    "has_docstring": true,
    "docstring": "Creates the dust tail (Type II tail).\n\nThe dust tail is curved, yellowish, and follows the comet's orbital path.\nDust particles are pushed by solar radiation pressure but retain orbital momentum.\n\nParameters:\n-----------\ncenter_position : tuple\n    (x, y, z) position in AU\nvelocity_vector : tuple\n    (vx, vy, vz) velocity vector for curved tail direction\nmax_tail_length_mkm : float\n    Maximum tail length in millions of kilometers\nactivity_factor : float\n    0-1, scales tail brightness and length\ncomet_name : str\n    Name of the comet\nnum_particles : int\n    Number of particles to render",
    "parameters": [
      "center_position",
      "velocity_vector",
      "max_tail_length_mkm",
      "activity_factor",
      "comet_name",
      "num_particles"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_comet_dust_tail",
    "component_id": "comet_visualization_shells.create_comet_dust_tail"
  },
  "comet_visualization_shells.create_comet_ion_tail": {
    "id": "comet_visualization_shells.create_comet_ion_tail",
    "name": "create_comet_ion_tail",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\comet_visualization_shells.py",
    "relative_path": "comet_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_comet_ion_tail(center_position=(0, 0, 0), max_tail_length_mkm=20,\n                          activity_factor=1.0, comet_name=\"Generic\", num_particles=600):\n    \"\"\"\n    Creates the ion tail (Type I tail, plasma tail).\n    \n    The ion tail is straight, bluish, and points directly away from the Sun.\n    Ionized gas is swept away by the solar wind at high speeds.\n    \n    Parameters:\n    -----------\n    center_position : tuple\n        (x, y, z) position in AU\n    max_tail_length_mkm : float\n        Maximum tail length in millions of kilometers\n    activity_factor : float\n        0-1, scales tail brightness and length\n    comet_name : str\n        Name of the comet\n    num_particles : int\n        Number of particles to render\n    \"\"\"\n    if activity_factor < 0.05:\n        return []  # No visible tail if very inactive\n    \n    # Scale tail by activity\n    effective_length_km = max_tail_length_mkm * 1e6 * activity_factor\n    max_tail_length_au = effective_length_km / KM_PER_AU\n    \n    # Calculate anti-solar direction (ion tail points directly away from Sun)\n    center_x, center_y, center_z = center_position\n    sun_distance = math.sqrt(center_x**2 + center_y**2 + center_z**2)\n    \n    if sun_distance < 1e-10:\n        return []  # Can't compute at Sun's location\n    \n    dir_x = center_x / sun_distance\n    dir_y = center_y / sun_distance\n    dir_z = center_z / sun_distance\n    \n    # Create tail particles - narrow cone, straighter than dust tail\n    tail_points_x = []\n    tail_points_y = []\n    tail_points_z = []\n    \n    for i in range(num_particles):\n        # Distance along tail\n        tail_distance = (i / num_particles) * max_tail_length_au\n        \n        # Ion tail is narrower - only ~3-5 degree opening\n        max_radius = tail_distance * math.tan(math.radians(4))\n        \n        # Random position within narrow cone\n        theta = np.random.uniform(0, 2 * math.pi)\n        r = np.random.uniform(0, max_radius) * np.random.random()**0.5\n        \n        # Create perpendicular vectors\n        if abs(dir_z) < 0.9:\n            perp1_x = -dir_y\n            perp1_y = dir_x\n            perp1_z = 0\n        else:\n            perp1_x = 1\n            perp1_y = 0\n            perp1_z = -dir_x / dir_z if abs(dir_z) > 1e-10 else 0\n        \n        # Normalize perp1\n        perp1_len = math.sqrt(perp1_x**2 + perp1_y**2 + perp1_z**2)\n        if perp1_len > 1e-10:\n            perp1_x /= perp1_len\n            perp1_y /= perp1_len\n            perp1_z /= perp1_len\n        \n        # Cross product for second perpendicular\n        perp2_x = dir_y * perp1_z - dir_z * perp1_y\n        perp2_y = dir_z * perp1_x - dir_x * perp1_z\n        perp2_z = dir_x * perp1_y - dir_y * perp1_x\n        \n        # Position in tail (straight line)\n        x = center_x + tail_distance * dir_x + r * (math.cos(theta) * perp1_x + math.sin(theta) * perp2_x)\n        y = center_y + tail_distance * dir_y + r * (math.cos(theta) * perp1_y + math.sin(theta) * perp2_y)\n        z = center_z + tail_distance * dir_z + r * (math.cos(theta) * perp1_z + math.sin(theta) * perp2_z)\n        \n        tail_points_x.append(x)\n        tail_points_y.append(y)\n        tail_points_z.append(z)\n    \n# Get comet-specific color\n    comet_data = HISTORICAL_TAIL_DATA.get(comet_name, HISTORICAL_TAIL_DATA['default'])\n    ion_color_name = comet_data.get('ion_tail_color', 'blue')\n    color_palette = COMET_COLOR_PALETTES.get(ion_color_name, COMET_COLOR_PALETTES['blue'])\n    base_r, base_g, base_b = color_palette['base_rgb']\n    \n    # Enhanced color with distance fade\n    colors = []\n    for i in range(num_particles):\n        distance_factor = 1 - (i / num_particles)\n        # Increased alpha: 0.8-0.95 at base, fading with distance\n        alpha = (0.8 + 0.15 * activity_factor) * (distance_factor ** 1.0)\n        alpha = max(alpha, 0.1)  # Minimum visibility\n        # Slight brightening toward nucleus\n        brightness = 0.9 + 0.1 * distance_factor\n        r = int(base_r * brightness)\n        g = int(base_g * brightness)\n        b = int(base_b * brightness)\n        colors.append(f'rgba({r}, {g}, {b}, {alpha:.3f})')\n\n    description = (\n        f\"Ion Tail (Type I, Plasma Tail) of {comet_name}<br>\"\n        f\"Maximum length: ~{max_tail_length_mkm * activity_factor:.1f} million km<br>\"\n        f\"The ion tail is composed of ionized gas molecules (CO+, H2O+, etc.) swept away by the solar wind.<br>\"\n        f\"It points directly away from the Sun and appears bluish from fluorescence of ionized gases.<br>\"\n        f\"The ion tail is typically straighter and longer than the dust tail, reaching millions of km in length.\"\n    )\n    \n    trace = go.Scatter3d(\n        x=tail_points_x, y=tail_points_y, z=tail_points_z,\n        mode='markers',\n        marker=dict(\n            size=1.8,\n            color=colors,\n            opacity=1.0\n        ),\n        name=f'{comet_name}: Ion Tail',\n        text=[description] * len(tail_points_x),\n        customdata=[f'{comet_name}: Ion Tail'] * len(tail_points_x),\n        hovertemplate='%{text}<extra></extra>',\n        showlegend=True\n    )\n    \n    return [trace]",
    "start_line": 561,
    "end_line": 690,
    "has_docstring": true,
    "docstring": "Creates the ion tail (Type I tail, plasma tail).\n\nThe ion tail is straight, bluish, and points directly away from the Sun.\nIonized gas is swept away by the solar wind at high speeds.\n\nParameters:\n-----------\ncenter_position : tuple\n    (x, y, z) position in AU\nmax_tail_length_mkm : float\n    Maximum tail length in millions of kilometers\nactivity_factor : float\n    0-1, scales tail brightness and length\ncomet_name : str\n    Name of the comet\nnum_particles : int\n    Number of particles to render",
    "parameters": [
      "center_position",
      "max_tail_length_mkm",
      "activity_factor",
      "comet_name",
      "num_particles"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_comet_ion_tail",
    "component_id": "comet_visualization_shells.create_comet_ion_tail"
  },
  "comet_visualization_shells.create_complete_comet_visualization": {
    "id": "comet_visualization_shells.create_complete_comet_visualization",
    "name": "create_complete_comet_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\comet_visualization_shells.py",
    "relative_path": "comet_visualization_shells.py",
    "depends_on": [
      "comet_visualization_shells.create_comet_ion_tail",
      "comet_visualization_shells.calculate_tail_activity_factor",
      "comet_visualization_shells.create_comet_dust_tail",
      "comet_visualization_shells.create_comet_nucleus",
      "shared_utilities.create_sun_direction_indicator",
      "comet_visualization_shells.create_comet_coma"
    ],
    "source_code": "def create_complete_comet_visualization(comet_name='Halley', center_position=(0, 0, 0),\n                                       velocity_vector=(0, 0, 0), current_distance_au=None):\n    \"\"\"\n    Creates a complete comet visualization with nucleus, coma, and both tails.\n    \n    Parameters:\n    -----------\n    comet_name : str\n        Name of the comet (must be in HISTORICAL_TAIL_DATA or will use 'default')\n    center_position : tuple\n        Current (x, y, z) position in AU\n    velocity_vector : tuple\n        Current (vx, vy, vz) velocity for tail curvature\n    current_distance_au : float or None\n        Current distance from Sun in AU. If None, computed from center_position\n        \n    Returns:\n    --------\n    list : List of Plotly traces for all comet components\n    \"\"\"\n    # Get comet data\n    if comet_name not in HISTORICAL_TAIL_DATA:\n        print(f\"Warning: {comet_name} not found in database, using default parameters\")\n        comet_name_key = 'default'\n    else:\n        comet_name_key = comet_name\n    \n    comet_data = HISTORICAL_TAIL_DATA[comet_name_key]\n    nucleus_size = COMET_NUCLEUS_SIZES.get(comet_name, COMET_NUCLEUS_SIZES['default'])\n    \n    # Calculate current distance if not provided\n    if current_distance_au is None:\n        cx, cy, cz = center_position\n        current_distance_au = math.sqrt(cx**2 + cy**2 + cz**2)\n    \n    # Calculate activity factor based on distance\n    perihelion_distance = comet_data['perihelion_distance_au']\n    activity_factor = calculate_tail_activity_factor(current_distance_au, perihelion_distance)\n    \n    # Create all components\n    traces = []\n    \n    # 1. Nucleus\n    traces.extend(create_comet_nucleus(center_position, nucleus_size, comet_name))\n    \n    # 2. Coma (only if somewhat active)\n    if activity_factor > 0.1:\n        # Coma size scales with activity, typical range 50,000 - 200,000 km\n        coma_size = 50000 + 150000 * activity_factor\n        traces.extend(create_comet_coma(center_position, coma_size, activity_factor, comet_name))\n    \n    # 3. Dust tail\n    dust_length = comet_data['max_dust_tail_length_mkm']\n    traces.extend(create_comet_dust_tail(center_position, velocity_vector, dust_length, \n                                        activity_factor, comet_name))\n    \n    # 4. Ion tail\n    ion_length = comet_data['max_ion_tail_length_mkm']\n    traces.extend(create_comet_ion_tail(center_position, ion_length, activity_factor, comet_name))\n    \n    # 5. Sun direction indicator\n    max_tail = max(dust_length, ion_length) * 1e6 / KM_PER_AU  # Convert to AU\n    sun_traces = create_sun_direction_indicator(center_position, max_tail * activity_factor)\n    traces.extend(sun_traces)\n    \n    return traces",
    "start_line": 693,
    "end_line": 758,
    "has_docstring": true,
    "docstring": "Creates a complete comet visualization with nucleus, coma, and both tails.\n\nParameters:\n-----------\ncomet_name : str\n    Name of the comet (must be in HISTORICAL_TAIL_DATA or will use 'default')\ncenter_position : tuple\n    Current (x, y, z) position in AU\nvelocity_vector : tuple\n    Current (vx, vy, vz) velocity for tail curvature\ncurrent_distance_au : float or None\n    Current distance from Sun in AU. If None, computed from center_position\n    \nReturns:\n--------\nlist : List of Plotly traces for all comet components",
    "parameters": [
      "comet_name",
      "center_position",
      "velocity_vector",
      "current_distance_au"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_complete_comet_visualization",
    "component_id": "comet_visualization_shells.create_complete_comet_visualization"
  },
  "comet_visualization_shells.add_comet_tails_to_figure": {
    "id": "comet_visualization_shells.add_comet_tails_to_figure",
    "name": "add_comet_tails_to_figure",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\comet_visualization_shells.py",
    "relative_path": "comet_visualization_shells.py",
    "depends_on": [
      "comet_visualization_shells.create_comet_ion_tail",
      "comet_visualization_shells.calculate_tail_activity_factor",
      "comet_visualization_shells.create_comet_dust_tail",
      "comet_visualization_shells.create_comet_nucleus",
      "shared_utilities.create_sun_direction_indicator",
      "comet_visualization_shells.create_comet_coma"
    ],
    "source_code": "def add_comet_tails_to_figure(fig, comet_name, position_data, center_object_name='Sun'):\n    \"\"\"\n    Add comet visualization to figure with feature-specific thresholds.\n    \n    Always shows nucleus. Coma, dust tail, and ion tail appear based on distance from Sun.\n    Missing features are shown as gray entries in the legend.\n    \n    Parameters:\n    -----------\n    fig : plotly Figure\n        The figure to add traces to\n    comet_name : str\n        Name of the comet (e.g., 'Halley', 'NEOWISE', '3I/ATLAS')\n    position_data : dict\n        Position data with 'x', 'y', 'z' keys (in AU) and optionally 'velocity' or 'vx', 'vy', 'vz'\n    center_object_name : str\n        Name of the center object (for coordinate adjustment), default 'Sun'\n    \n    Returns:\n    --------\n    fig : plotly Figure\n        Figure with comet visualization traces added\n    \"\"\"\n    import math\n    import numpy as np\n    import plotly.graph_objs as go\n    \n    \n# Look up comet in database, use 'default' if not found\n    # This automatically handles any comet name without manual mapping\n    if comet_name in HISTORICAL_TAIL_DATA:\n        db_name = comet_name\n    else:\n        db_name = 'default'\n        print(f\"[COMET VIZ] {comet_name} not in database, using default parameters\")\n\n    # Check if position data is valid\n    if position_data is None:\n        print(f\"[COMET VIZ] Warning: No position data available for {comet_name}, skipping visualization\")\n        return fig\n\n    # Get position\n    pos_x = position_data.get('x', 0)\n    pos_y = position_data.get('y', 0)\n    pos_z = position_data.get('z', 0)\n    position_au = (pos_x, pos_y, pos_z)\n    \n    # Calculate distance from Sun\n    distance_au = math.sqrt(pos_x**2 + pos_y**2 + pos_z**2)\n    \n    # Get velocity if available\n    velocity_km_s = position_data.get('velocity', None)\n    \n    # Handle both tuples and NumPy arrays for velocity\n    velocity_is_zero = False\n    if velocity_km_s is None:\n        velocity_is_zero = True\n    elif isinstance(velocity_km_s, np.ndarray):\n        velocity_is_zero = np.allclose(velocity_km_s, 0)\n    elif hasattr(velocity_km_s, '__iter__'):\n        velocity_is_zero = all(v == 0 for v in velocity_km_s)\n    else:\n        velocity_is_zero = True\n    \n    if velocity_is_zero:\n        vx = position_data.get('vx', 0)\n        vy = position_data.get('vy', 0)\n        vz = position_data.get('vz', 0)\n        if vx != 0 or vy != 0 or vz != 0:\n            velocity_km_s = (vx, vy, vz)\n        else:\n            velocity_km_s = (0, 40, 0)\n    \n    # Determine which features are visible at this distance\n    features_visible = {\n        'nucleus': True,\n        'coma': distance_au <= COMET_FEATURE_THRESHOLDS['coma'],\n        'dust_tail': distance_au <= COMET_FEATURE_THRESHOLDS['dust_tail'],\n        'ion_tail': distance_au <= COMET_FEATURE_THRESHOLDS['ion_tail']\n    }\n    \n    # Print diagnostic info\n    print(f\"\\n[COMET VIZ] {comet_name} at {distance_au:.2f} AU from Sun\")\n    print(f\"  Nucleus: [OK] Always visible\")\n    \n    if features_visible['coma']:\n        print(f\"  Coma: [OK] Visible\")\n    else:\n        print(f\"  Coma: [FAIL] Too far (needs <{COMET_FEATURE_THRESHOLDS['coma']} AU)\")\n    \n    if features_visible['dust_tail']:\n        print(f\"  Dust tail: [OK] Visible\")\n    else:\n        print(f\"  Dust tail: [FAIL] Too far (needs <{COMET_FEATURE_THRESHOLDS['dust_tail']} AU)\")\n    \n    if features_visible['ion_tail']:\n        print(f\"  Ion tail: [OK] Visible\")\n    else:\n        print(f\"  Ion tail: [FAIL] Too far (needs <{COMET_FEATURE_THRESHOLDS['ion_tail']} AU)\")\n    \n    # If comet is very far, show nucleus + legend entries for missing features\n    if distance_au > COMET_FEATURE_THRESHOLDS['coma']:\n        nucleus_size = COMET_NUCLEUS_SIZES.get(db_name, COMET_NUCLEUS_SIZES['default'])\n        nucleus_traces = create_comet_nucleus(position_au, nucleus_size, comet_name)\n        for trace in nucleus_traces:\n            fig.add_trace(trace)\n        \n        # Add invisible legend entries for missing features\n        fig.add_trace(go.Scatter3d(\n            x=[None], y=[None], z=[None],\n            mode='markers',\n            marker=dict(size=0, color='gray'),\n            name=f'{comet_name}: Coma (inactive, >{COMET_FEATURE_THRESHOLDS[\"coma\"]:.1f} AU)',\n            showlegend=True,\n            hoverinfo='skip'\n        ))\n        \n        fig.add_trace(go.Scatter3d(\n            x=[None], y=[None], z=[None],\n            mode='markers',\n            marker=dict(size=0, color='gray'),\n            name=f'{comet_name}: Dust Tail (inactive, >{COMET_FEATURE_THRESHOLDS[\"dust_tail\"]:.1f} AU)',\n            showlegend=True,\n            hoverinfo='skip'\n        ))\n        \n        fig.add_trace(go.Scatter3d(\n            x=[None], y=[None], z=[None],\n            mode='markers',\n            marker=dict(size=0, color='gray'),\n            name=f'{comet_name}: Ion Tail (inactive, >{COMET_FEATURE_THRESHOLDS[\"ion_tail\"]:.1f} AU)',\n            showlegend=True,\n            hoverinfo='skip'\n        ))\n        \n        print(f\"  [OK] Added nucleus only with legend entries for missing features\")\n        return fig\n    \n    # Comet is active - create visualization with available features\n    try:\n        comet_data = HISTORICAL_TAIL_DATA.get(db_name, HISTORICAL_TAIL_DATA['default'])\n        nucleus_size = COMET_NUCLEUS_SIZES.get(db_name, COMET_NUCLEUS_SIZES['default'])\n        perihelion_distance = comet_data['perihelion_distance_au']\n        activity_factor = calculate_tail_activity_factor(distance_au, perihelion_distance)\n        \n        traces = []\n        \n        # 1. Nucleus (always)\n        traces.extend(create_comet_nucleus(position_au, nucleus_size, comet_name))\n        \n        # 2. Coma (if close enough and active)\n        if features_visible['coma'] and activity_factor > 0.1:\n            coma_size = 50000 + 150000 * activity_factor\n            traces.extend(create_comet_coma(position_au, coma_size, activity_factor, comet_name))\n        \n        # 3. Dust tail (if close enough)\n        if features_visible['dust_tail']:\n            dust_length = comet_data['max_dust_tail_length_mkm']\n            traces.extend(create_comet_dust_tail(\n                position_au, velocity_km_s, dust_length, activity_factor, comet_name\n            ))\n        \n        # 4. Ion tail (if close enough)\n        if features_visible['ion_tail']:\n            ion_length = comet_data['max_ion_tail_length_mkm']\n            traces.extend(create_comet_ion_tail(\n                position_au, ion_length, activity_factor, comet_name\n            ))\n        \n        # 5. Sun direction indicator (if any tail is visible)\n        if features_visible['dust_tail'] or features_visible['ion_tail']:\n            max_tail = max(\n                comet_data['max_dust_tail_length_mkm'] if features_visible['dust_tail'] else 0,\n                comet_data['max_ion_tail_length_mkm'] if features_visible['ion_tail'] else 0\n            )\n            max_tail_au = max_tail * 1e6 / KM_PER_AU\n            sun_traces = create_sun_direction_indicator(position_au, max_tail_au * activity_factor)\n            traces.extend(sun_traces)\n        \n        # Add all traces to figure\n        for trace in traces:\n            fig.add_trace(trace)\n        \n        # Add invisible legend entries for missing features\n        if not features_visible['coma']:\n            fig.add_trace(go.Scatter3d(\n                x=[None], y=[None], z=[None],\n                mode='markers',\n                marker=dict(size=0, color='gray'),\n                name=f'{comet_name}: Coma (inactive, >{COMET_FEATURE_THRESHOLDS[\"coma\"]:.1f} AU)',\n                showlegend=True,\n                hoverinfo='skip'\n            ))\n        \n        if not features_visible['dust_tail']:\n            fig.add_trace(go.Scatter3d(\n                x=[None], y=[None], z=[None],\n                mode='markers',\n                marker=dict(size=0, color='gray'),\n                name=f'{comet_name}: Dust Tail (inactive, >{COMET_FEATURE_THRESHOLDS[\"dust_tail\"]:.1f} AU)',\n                showlegend=True,\n                hoverinfo='skip'\n            ))\n        \n        if not features_visible['ion_tail']:\n            fig.add_trace(go.Scatter3d(\n                x=[None], y=[None], z=[None],\n                mode='markers',\n                marker=dict(size=0, color='gray'),\n                name=f'{comet_name}: Ion Tail (inactive, >{COMET_FEATURE_THRESHOLDS[\"ion_tail\"]:.1f} AU)',\n                showlegend=True,\n                hoverinfo='skip'\n            ))\n        \n        print(f\"  [OK] Activity factor: {activity_factor:.1%}\")\n        print(f\"  [OK] Added {len(traces)} visualization traces\")\n        \n    except Exception as e:\n        print(f\"  [FAIL] Error creating comet visualization: {e}\")\n        import traceback\n        traceback.print_exc()\n    \n    return fig",
    "start_line": 837,
    "end_line": 1059,
    "has_docstring": true,
    "docstring": "Add comet visualization to figure with feature-specific thresholds.\n\nAlways shows nucleus. Coma, dust tail, and ion tail appear based on distance from Sun.\nMissing features are shown as gray entries in the legend.\n\nParameters:\n-----------\nfig : plotly Figure\n    The figure to add traces to\ncomet_name : str\n    Name of the comet (e.g., 'Halley', 'NEOWISE', '3I/ATLAS')\nposition_data : dict\n    Position data with 'x', 'y', 'z' keys (in AU) and optionally 'velocity' or 'vx', 'vy', 'vz'\ncenter_object_name : str\n    Name of the center object (for coordinate adjustment), default 'Sun'\n\nReturns:\n--------\nfig : plotly Figure\n    Figure with comet visualization traces added",
    "parameters": [
      "fig",
      "comet_name",
      "position_data",
      "center_object_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_comet_tails_to_figure",
    "component_id": "comet_visualization_shells.add_comet_tails_to_figure"
  },
  "constants_new.color_map": {
    "id": "constants_new.color_map",
    "name": "color_map",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\constants_new.py",
    "relative_path": "constants_new.py",
    "depends_on": [],
    "source_code": "def color_map(planet):\n    colors = {\n        'Sun': 'rgb(102, 187, 106)',      # chlorophyll green\n    #    'Sun': 'rgb(255, 249, 240)',  # Slightly warm white to represent 6000K at the Sun's surface. The inner corona is 2M K.\n        'Mercury': 'rgb(128, 128, 128)',   # Description: Dark Gray reflecting Mercury's rocky and heavily cratered surface.\n        'Venus': 'rgb(255, 255, 224)',\n        'Earth': 'rgb(0, 102, 204)',\n        'Moon': 'rgb(211, 211, 211)',\n        'Mars': 'rgb(188, 39, 50)',\n        'Phobos': 'rgb(139, 0, 0)',\n        'Deimos': 'rgb(105, 105, 105)',\n        'Ceres': 'rgb(105, 105, 105)',\n\n        'Jupiter': 'rgb(255, 165, 0)',\n        'Io': 'rgb(255, 140, 0)',\n        'Europa': 'rgb(173, 216, 230)',\n        'Ganymede': 'rgb(150, 75, 0)',\n        'Callisto': 'rgb(169, 169, 169)',\n        'Metis': 'rgb(180, 120, 100)',    # Reddish-brown\n        'Adrastea': 'rgb(190, 150, 130)',  # Light reddish-brown\n        'Amalthea': 'rgb(200, 60, 50)',    # Red\n        'Thebe': 'rgb(170, 110, 90)',       # Dark reddish-brown\n\n        'Saturn': 'rgb(210, 180, 140)',\n        'Titan': 'rgb(255, 215, 0)',\n        'Enceladus': 'rgb(192, 192, 192)',\n        'Rhea': 'rgb(211, 211, 211)',\n        'Dione': 'rgb(255, 182, 193)',\n        'Tethys': 'rgb(173, 216, 230)',\n        'Mimas': 'rgb(105, 105, 105)',\n        'Pan': 'rgb(180, 180, 180)',            # (Light Gray)\n        'Daphnis': 'rgb(190, 190, 190)',        # (Slightly lighter gray)\n        'Prometheus': 'rgb(170, 170, 170)',     # (Medium Gray)\n        'Pandora': 'rgb(185, 185, 185)',        # (Light-Medium Gray)\n        'Hyperion': 'rgb(160, 100, 80)',        # (Dark reddish-brown)\n        'Iapetus': 'rgb(220, 220, 220)',        # Trailing Hemisphere: (220, 220, 220) (Light Gray/Whitish); \n                                                # Leading Hemisphere (Cassini Regio): (50, 50, 50) (Very dark gray/almost black) \n        'Phoebe': 'cyan',\n\n        'Uranus': 'rgb(173, 216, 230)',\n        'Titania': 'rgb(221, 160, 221)',         \n        'Oberon': 'rgb(128, 0, 128)',\n        'Umbriel': 'rgb(148, 0, 211)',    \n        'Ariel': 'rgb(144, 238, 144)',\n        'Miranda': 'rgb(0, 128, 0)',\n        'Portia': 'rgb(150, 150, 150)',\n        'Mab': 'rgb(100, 100, 120)',\n\n        'Neptune': 'rgb(0, 0, 255)',\n        'Triton': 'rgb(0, 255, 255)',\n        'Despina': 'rgb(175, 175, 175)',\n        'Galatea': 'rgb(175, 175, 175)',\n\n        'Pluto': 'rgb(205, 92, 92)',\n        'Charon': 'rgb(169, 169, 169)',\n        'Styx': 'rgb(180, 180, 180)',\n        'Nix': 'rgb(200, 200, 200)',  \n        'Kerberos': 'rgb(170, 170, 170)',      \n        'Hydra': 'rgb(190, 190, 190)', \n\n        'Planet 9': 'grey',  # grey\n       \n        'Voyager 1': 'white',\n        'Voyager 2': 'gold',\n        'Cassini': 'green',\n        'New Horizons': 'cyan',\n        'Arrokoth': 'red',\n        'Juno': 'cyan',\n        'Galileo': 'white',\n        'Apollo 11 S-IVB': 'cyan',        \n        'Pioneer 10': 'red',\n        'Pioneer 11': 'green',\n        'Clipper': 'red',\n        'JUICE': 'blue', \n        'OSIRIS': 'cyan',\n        'Parker': 'white',\n        'JWST': 'gold',\n        'Rosetta': 'white',\n        'BepiColombo': 'red',\n        'SolO': 'red',\n        'SOHO': 'green',\n        'Akatsuki': 'cyan',\n        'MarsRover': 'white',\n\n        'EM-L1': 'cyan',        \n        'EM-L2': 'white',\n        'EM-L3': 'green',\n        'EM-L4': 'gold',\n        'EM-L5': 'red',\n        'L1': 'cyan',        \n        'L2': 'white',\n        'L3': 'green',\n        'L4': 'gold',\n        'L5': 'red',\n\n        'Kamo oalewa': 'cyan',\n        '2025 PN7': 'gold',        \n        '2024 PT5': 'red',\n        '2025 PY1': 'white',\n        '2023 JF': 'white',\n        '2024 DW': 'gold',        \n        '2024 YR4': 'green',\n\n        'Apophis': 'red',\n        'Vesta': 'cyan',\n        'Bennu': 'white',\n        'Lutetia': 'green',\n        'Steins': 'red',  \n\n        '1I/Oumuamua': 'gold',\n        '3I/ATLAS': 'red',\n        'Ikeya-Seki': 'green',\n        'West': 'red',\n        'Halley': 'cyan',\n        'Hyakutake': 'white',\n        'Hale-Bopp': 'gold',\n        'McNaught': 'green',\n        'NEOWISE': 'red',\n        'C/2025_K1': 'cyan',\n        'Borisov': 'green',        \n        'Tsuchinshan': 'cyan',\n        'ATLAS': 'white',\n        'Churyumov': 'gold',\n        '2I/Borisov': 'red',\n        'SWAN': 'gold',\n        'PANSTARRS': 'green',\n        '6AC4721': 'cyan',\n        'MAPS': 'cyan',\n        'Lemmon': 'green',        \n\n        'SOHO': 'white',\n        'JamesWebb': 'gold',\n        'Ryugu': 'gold',\n        'Eros': 'green',\n        'Dinkinesh': 'white',\n        'Donaldjohanson': 'red',\n        'Eurybates': 'green',\n        'Patroclus': 'white',\n        'Menoetius': 'red',\n        'Leucus': 'gold',\n        'Polymele': 'cyan',\n        'Orus': 'pink',\n        'Itokawa': 'red',\n        'MarsRover': 'white',\n        'DART': 'gold',\n        'Lucy': 'green',\n        'Gaia': 'red',\n        'Hayabusa2': 'cyan',  \n        'Quaoar': 'rgb(244, 164, 96)',\n        'Dysnomia': 'white',\n        'Xiangliu': 'rgb(210, 105, 30)',\n        'Vanth': 'rgb(169, 169, 169)',\n        'Weywot': 'rgb(205, 133, 63)',\n        \"Hi'iaka\": 'rgb(200, 180, 220)',    # Light purple (Haumea family)\n        'Namaka': 'rgb(180, 160, 200)',     # Slightly darker purple\n        'MK2': 'rgb(80, 80, 80)',           # Very dark (low albedo)        \n        'Chariklo': 'rgb(100, 50, 50)',\n        'Orcus': 'rgb(0, 100, 0)',\n        'Varuna': 'rgb(218, 165, 32)',\n        'Ixion': 'rgb(218, 165, 32)',\n        'GV9': 'rgb(128, 0, 128)',\n        'Mani': 'rgb(255, 0, 0)',  \n        'Gonggong': 'red',    \n        'Haumea': 'rgb(128, 0, 128)',\n        'Makemake': 'rgb(255, 192, 203)',\n        'Eris': 'rgb(240, 240, 240)',\n        'Ammonite': 'rgb(255, 0, 0)', \n        'Sedna': 'rgb(135, 206, 235)',\n        'Leleakuhonua': 'cyan',\n        '2017 OF201': 'rgb(150, 90, 60)',                       \n    }\n    return colors.get(planet, 'goldenrod')",
    "start_line": 454,
    "end_line": 625,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "planet"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function color_map",
    "component_id": "constants_new.color_map"
  },
  "convert_hot_ph_to_json.find_hot_data_file": {
    "id": "convert_hot_ph_to_json.find_hot_data_file",
    "name": "find_hot_data_file",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\convert_hot_ph_to_json.py",
    "relative_path": "convert_hot_ph_to_json.py",
    "depends_on": [],
    "source_code": "def find_hot_data_file():\n    \"\"\"Find HOT data file - try multiple possible filenames\"\"\"\n    import os\n    \n    # List of possible filenames (in order of preference)\n    possible_files = [\n        'data/3773_v3_niskin_hot001_yr01_to_hot348_yr35.csv',  # Current BCO-DMO filename\n#        'hot_carbonate_data.txt',  # Legacy/manual download name\n#        'hot_carbonate_data.csv',\n    ]\n    \n    # Also check for any file matching the pattern\n    for file in os.listdir('.'):\n        if 'niskin' in file.lower() and 'hot' in file.lower() and file.endswith('.csv'):\n            if file not in possible_files:\n                possible_files.insert(0, file)\n    \n    # Find first existing file\n    for filename in possible_files:\n        if os.path.exists(filename):\n            return filename\n    \n    return None",
    "start_line": 10,
    "end_line": 32,
    "has_docstring": true,
    "docstring": "Find HOT data file - try multiple possible filenames",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function find_hot_data_file",
    "component_id": "convert_hot_ph_to_json.find_hot_data_file"
  },
  "convert_hot_ph_to_json.parse_hot_ph_csv": {
    "id": "convert_hot_ph_to_json.parse_hot_ph_csv",
    "name": "parse_hot_ph_csv",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\convert_hot_ph_to_json.py",
    "relative_path": "convert_hot_ph_to_json.py",
    "depends_on": [],
    "source_code": "def parse_hot_ph_csv(filename):\n    \"\"\"\n    Parse HOT carbonate chemistry CSV from BCO-DMO\n    Format: CSV with ISO datetime and pH columns\n    \"\"\"\n    print(f\"Parsing {filename}...\")\n    \n    monthly_data = defaultdict(list)  # (year, month) -> [ph_values]\n    total_rows = 0\n    ph_rows = 0\n    surface_rows = 0\n    \n    with open(filename, 'r', encoding='utf-8') as f:\n        reader = csv.DictReader(f)\n        \n        for row in reader:\n            total_rows += 1\n            \n            # Get date\n            date_str = row.get('Sampling_ISO_DateTime_UTC', '')\n            if not date_str:\n                continue\n            \n            # Parse ISO datetime: 2023-12-30T20:36Z\n            try:\n                dt = datetime.fromisoformat(date_str.replace('Z', '+00:00'))\n                year = dt.year\n                month = dt.month\n            except (ValueError, AttributeError):\n                continue\n            \n            # Get pH value\n            ph_str = row.get('pH', '').strip()\n            if not ph_str:\n                continue\n            \n            try:\n                ph_value = float(ph_str)\n            except ValueError:\n                continue\n            \n            # Validate pH range\n            if not (7.0 < ph_value < 9.0):\n                continue\n            \n            ph_rows += 1\n            \n            # Get depth/pressure - prioritize surface measurements\n            depth_str = row.get('CTDPRS', '').strip()\n            \n            # Filter for surface measurements (< 50 meters pressure/depth)\n            # This gets the surface ocean pH we want\n            try:\n                if depth_str:\n                    depth = float(depth_str)\n                    if depth > 50:  # Skip deep measurements\n                        continue\n            except ValueError:\n                pass  # If no depth, still include it\n            \n            surface_rows += 1\n            \n            # Add to monthly data\n            key = (year, month)\n            monthly_data[key].append(ph_value)\n    \n    print(f\"  Total rows: {total_rows}\")\n    print(f\"  Rows with pH: {ph_rows}\")\n    print(f\"  Surface rows (< 50m): {surface_rows}\")\n    print(f\"  Unique months: {len(monthly_data)}\")\n    \n    # Calculate monthly averages\n    records = []\n    for (year, month), ph_values in sorted(monthly_data.items()):\n        avg_ph = sum(ph_values) / len(ph_values)\n        record = {\n            'year': year,\n            'month': month,\n            'date': f\"{year}-{month:02d}\",\n            'ph_total': round(avg_ph, 4),\n            'num_measurements': len(ph_values),\n            'source': 'HOT Station ALOHA'\n        }\n        records.append(record)\n    \n    print(f\"\\n Created {len(records)} monthly average pH records\")\n    \n    if records:\n        print(f\"  Date range: {records[0]['date']} to {records[-1]['date']}\")\n        print(f\"  pH range: {min(r['ph_total'] for r in records):.4f} to {max(r['ph_total'] for r in records):.4f}\")\n    \n    return records",
    "start_line": 34,
    "end_line": 125,
    "has_docstring": true,
    "docstring": "Parse HOT carbonate chemistry CSV from BCO-DMO\nFormat: CSV with ISO datetime and pH columns",
    "parameters": [
      "filename"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parse_hot_ph_csv",
    "component_id": "convert_hot_ph_to_json.parse_hot_ph_csv"
  },
  "convert_hot_ph_to_json.create_metadata": {
    "id": "convert_hot_ph_to_json.create_metadata",
    "name": "create_metadata",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\convert_hot_ph_to_json.py",
    "relative_path": "convert_hot_ph_to_json.py",
    "depends_on": [],
    "source_code": "def create_metadata(records):\n    \"\"\"Create metadata for the pH dataset\"\"\"\n    if not records:\n        return {}\n    \n    first = records[0]\n    latest = records[-1]\n    ph_change = latest['ph_total'] - first['ph_total']\n    years_span = latest['year'] - first['year']\n    \n    return {\n        'dataset_name': 'data/ocean_ph_hot_monthly',\n        'description': 'Ocean surface pH measurements from Hawaii Ocean Time-series',\n        'source': {\n            'organization': 'BCO-DMO (Biological and Chemical Oceanography Data Management Office)',\n            'data_source': 'Hawaii Ocean Time-series (HOT) Program',\n            'station': 'Station ALOHA (2245\\'N, 158W)',\n            'url': 'https://www.bco-dmo.org/dataset/3773',\n            'hot_program_url': 'https://hahana.soest.hawaii.edu/hot/',\n            'citation': 'Hawaii Ocean Time-series (HOT), University of Hawaii. Data accessed via BCO-DMO dataset 3773.'\n        },\n        'parameters': {\n            'measurement': 'pH (total scale)',\n            'location': 'Surface ocean (< 50m depth)',\n            'frequency': 'Monthly sampling',\n            'method': 'Spectrophotometric',\n            'aggregation': 'Monthly averages of surface measurements'\n        },\n        'time_range': {\n            'start': first['date'],\n            'end': latest['date'],\n            'record_count': len(records)\n        },\n        'statistics': {\n            'first_ph': first['ph_total'],\n            'latest_ph': latest['ph_total'],\n            'ph_change': round(ph_change, 4),\n            'years_span': years_span,\n            'annual_rate': round(ph_change / years_span, 6) if years_span > 0 else 0\n        },\n        'context': {\n            'pre_industrial_ph': 8.2,\n            'current_decline': 0.1,\n            'threat': 'Ocean acidification threatens marine ecosystems',\n            'impact': 'pH is logarithmic: 0.1 unit drop = 30% increase in acidity',\n            'rate': 'Faster than any time in 300 million years'\n        },\n        'last_updated': datetime.now().isoformat(),\n        'cache_file': 'data/ocean_ph_hot_monthly.json'\n    }",
    "start_line": 127,
    "end_line": 176,
    "has_docstring": true,
    "docstring": "Create metadata for the pH dataset",
    "parameters": [
      "records"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_metadata",
    "component_id": "convert_hot_ph_to_json.create_metadata"
  },
  "convert_hot_ph_to_json.main": {
    "id": "convert_hot_ph_to_json.main",
    "name": "main",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\convert_hot_ph_to_json.py",
    "relative_path": "convert_hot_ph_to_json.py",
    "depends_on": [
      "convert_hot_ph_to_json.find_hot_data_file",
      "convert_hot_ph_to_json.parse_hot_ph_csv",
      "convert_hot_ph_to_json.create_metadata"
    ],
    "source_code": "def main():\n    \"\"\"Main conversion workflow\"\"\"\n    print(\"=\" * 70)\n    print(\"  HOT Ocean pH Data Converter\")\n    print(\"  Converting carbonate chemistry data to JSON\")\n    print(\"=\" * 70)\n    print()\n    \n    # Find input file\n    input_file = find_hot_data_file()\n    \n    if not input_file:\n        print(\" No HOT data file found!\")\n        print()\n        print(\"Please download the data first:\")\n        print(\"1. Go to: https://www.bco-dmo.org/dataset/3773\")\n        print(\"2. Click the download button for the CSV file\")\n        print(\"3. Save it to this directory (any filename is fine)\")\n        print()\n        print(\"Looking for files matching:\")\n        print(\"  - data/3773_v3_niskin_hot001_yr01_to_hot348_yr35.csv\")\n    #    print(\"  - hot_carbonate_data.txt\")\n    #    print(\"  - hot_carbonate_data.csv\")\n        print(\"  - Any file with 'niskin' and 'hot' in the name\")\n        return\n    \n    print(f\"Found data file: {input_file}\\n\")\n    \n    # Parse the file\n    records = parse_hot_ph_csv(input_file)\n    \n    if not records:\n        print(\"\\n No valid pH records found!\")\n        print(\"Please check the file format.\")\n        return\n    \n    # Create output structure\n    output = {\n        'metadata': create_metadata(records),\n        'records': records\n    }\n    \n    # Save to JSON\n    output_file = 'data/ocean_ph_hot_monthly.json'\n    with open(output_file, 'w') as f:\n        json.dump(output, f, indent=2)\n    \n    print(f\"\\n Saved {len(records)} records to {output_file}\")\n    print()\n    print(f\"Latest ocean pH: {records[-1]['ph_total']:.4f} (from {records[-1]['num_measurements']} measurements)\")\n    print(f\"{records[-1]['year'] - records[0]['year']}-year change: {records[-1]['ph_total'] - records[0]['ph_total']:+.4f} pH units\")\n    print()\n    print(\"You can now run the visualization!\")\n    print(\"=\" * 70)",
    "start_line": 178,
    "end_line": 231,
    "has_docstring": true,
    "docstring": "Main conversion workflow",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "convert_hot_ph_to_json.main"
  },
  "coordinate_system_guide.create_coordinate_system_diagram": {
    "id": "coordinate_system_guide.create_coordinate_system_diagram",
    "name": "create_coordinate_system_diagram",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\coordinate_system_guide.py",
    "relative_path": "coordinate_system_guide.py",
    "depends_on": [],
    "source_code": "def create_coordinate_system_diagram():\n    \"\"\"\n    Create an interactive 3D diagram showing the J2000 Ecliptic coordinate system.\n    \n    Returns:\n        plotly.graph_objects.Figure: Interactive 3D plot\n    \"\"\"\n    \n    fig = go.Figure()\n    \n    # Axis length\n    axis_length = 2.0\n    \n    # Define colors\n    x_color = 'red'\n    y_color = 'green'\n    z_color = 'blue'\n    ecliptic_color = 'rgba(200, 200, 255, 0.3)'\n    \n    # +X Axis (Vernal Equinox direction)\n    fig.add_trace(go.Scatter3d(\n        x=[0, axis_length],\n        y=[0, 0],\n        z=[0, 0],\n        mode='lines+text',\n        line=dict(color=x_color, width=8),\n        text=['', '+X<br>Vernal Equinox'],\n        textposition='top center',\n        textfont=dict(size=14, color=x_color),\n        name='+X Axis',\n        hovertemplate='<b>+X Axis</b><br>Points to Vernal Equinox ()<br>Celestial Longitude 0<extra></extra>',\n        showlegend=True\n    ))\n    \n    # +Y Axis (90 ahead)\n    fig.add_trace(go.Scatter3d(\n        x=[0, 0],\n        y=[0, axis_length],\n        z=[0, 0],\n        mode='lines+text',\n        line=dict(color=y_color, width=8),\n        text=['', '+Y<br>90 Ahead'],\n        textposition='top center',\n        textfont=dict(size=14, color=y_color),\n        name='+Y Axis',\n        hovertemplate='<b>+Y Axis</b><br>90 ahead of vernal equinox<br>Direction of Earth\\'s motion<extra></extra>',\n        showlegend=True\n    ))\n    \n    # +Z Axis (North Ecliptic Pole)\n    fig.add_trace(go.Scatter3d(\n        x=[0, 0],\n        y=[0, 0],\n        z=[0, axis_length],\n        mode='lines+text',\n        line=dict(color=z_color, width=8),\n        text=['', '+Z<br>Ecliptic North'],\n        textposition='top center',\n        textfont=dict(size=14, color=z_color),\n        name='+Z Axis',\n        hovertemplate='<b>+Z Axis</b><br>Ecliptic North Pole<br>Perpendicular to ecliptic plane<extra></extra>',\n        showlegend=True\n    ))\n    \n    # Draw the ecliptic plane (XY plane)\n    plane_size = 1.5\n    n_points = 2\n    x_plane = np.linspace(-plane_size, plane_size, n_points)\n    y_plane = np.linspace(-plane_size, plane_size, n_points)\n    x_grid, y_grid = np.meshgrid(x_plane, y_plane)\n    z_grid = np.zeros_like(x_grid)\n    \n    fig.add_trace(go.Surface(\n        x=x_grid,\n        y=y_grid,\n        z=z_grid,\n        colorscale=[[0, ecliptic_color], [1, ecliptic_color]],\n        showscale=False,\n        name='Ecliptic Plane',\n        hovertemplate='<b>Ecliptic Plane (XY Plane)</b><br>Earth\\'s orbital plane<extra></extra>',\n        opacity=0.3,\n        showlegend=True\n    ))\n    \n    # Add Earth's orbit as a circle in the XY plane\n    theta = np.linspace(0, 2*np.pi, 100)\n    orbit_radius = 1.0\n    earth_x = orbit_radius * np.cos(theta)\n    earth_y = orbit_radius * np.sin(theta)\n    earth_z = np.zeros_like(theta)\n    \n    fig.add_trace(go.Scatter3d(\n        x=earth_x,\n        y=earth_y,\n        z=earth_z,\n        mode='lines',\n        line=dict(color='cyan', width=4, dash='dash'),\n        name='Earth\\'s Orbit',\n        hovertemplate='<b>Earth\\'s Orbit</b><br>Circular path in XY plane<br>Radius = 1 AU<extra></extra>',\n        showlegend=True\n    ))\n    \n    # Add the Sun at origin\n    fig.add_trace(go.Scatter3d(\n        x=[0],\n        y=[0],\n        z=[0],\n        mode='markers+text',\n        marker=dict(size=15, color='yellow', symbol='circle',\n                   line=dict(color='orange', width=2)),\n        text=['Sun'],\n        textposition='bottom center',\n        textfont=dict(size=12, color='orange'),\n        name='Sun',\n        hovertemplate='<b>Sun</b><br>Origin (0, 0, 0)<extra></extra>',\n        showlegend=True\n    ))\n    \n    # Add Earth at vernal equinox position (X = -1, Y = 0, Z = 0)\n    # At vernal equinox (March 20), Earth is at X=-1 because the Sun's direction \n    # FROM Earth points to +X (the vernal equinox direction in the sky)\n    fig.add_trace(go.Scatter3d(\n        x=[-1.0],\n        y=[0],\n        z=[0],\n        mode='markers+text',\n        marker=dict(size=10, color='blue', symbol='circle'),\n        text=['Earth<br>(at Vernal Equinox)'],\n        textposition='top center',\n        textfont=dict(size=10, color='blue'),\n        name='Earth Position',\n        hovertemplate='<b>Earth</b><br>Position at Vernal Equinox<br>(X=-1 AU, Y=0, Z=0)<br>Sun direction from Earth points to +X<extra></extra>',\n        showlegend=True\n    ))\n    \n    # Add an inclined orbit example (e.g., at 30 inclination)\n    inclination = 30  # degrees\n    inc_rad = np.radians(inclination)\n    inclined_x = orbit_radius * np.cos(theta)\n    inclined_y = orbit_radius * np.sin(theta) * np.cos(inc_rad)\n    inclined_z = orbit_radius * np.sin(theta) * np.sin(inc_rad)\n    \n    fig.add_trace(go.Scatter3d(\n        x=inclined_x,\n        y=inclined_y,\n        z=inclined_z,\n        mode='lines',\n        line=dict(color='magenta', width=3, dash='dot'),\n        name=f'Inclined Orbit (i={inclination})',\n        hovertemplate=f'<b>Inclined Orbit</b><br>Inclination = {inclination}<br>Tilted relative to ecliptic<extra></extra>',\n        showlegend=True\n    ))\n    \n    # Update layout - NO HEIGHT SPECIFIED (let it fill container)\n    fig.update_layout(\n        scene=dict(\n            xaxis=dict(\n                title='X (AU)',\n                range=[-2, 2],\n                showgrid=True,\n                gridcolor='lightgray',\n                zeroline=True,\n                zerolinecolor='black'\n            ),\n            yaxis=dict(\n                title='Y (AU)',\n                range=[-2, 2],\n                showgrid=True,\n                gridcolor='lightgray',\n                zeroline=True,\n                zerolinecolor='black'\n            ),\n            zaxis=dict(\n                title='Z (AU)',\n                range=[-2, 2],\n                showgrid=True,\n                gridcolor='lightgray',\n                zeroline=True,\n                zerolinecolor='black'\n            ),\n            aspectmode='cube',\n            camera=dict(\n                eye=dict(x=1.5, y=1.5, z=1.2),\n                center=dict(x=0, y=0, z=-0.2)\n        #        center=dict(x=0, y=0, z=-0.5)\n            )\n        ),\n        title=dict(\n            text=\"<b>J2000 Ecliptic Coordinate System</b><br><sub>Interactive 3D Reference Diagram</sub>\",\n            x=0.5,\n            xanchor='center',\n            font=dict(size=16)\n        ),\n        showlegend=True,\n        legend=dict(\n            x=0.02,\n            y=0.98,\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='black',\n            borderwidth=1,\n            font=dict(size=10)\n        ),\n    #    margin=dict(l=0, r=0, t=80, b=0)\n        margin=dict(l=0, r=0, t=80, b=0)\n        # NO height parameter - let it be controlled by CSS\n    )\n    \n    return fig",
    "start_line": 18,
    "end_line": 225,
    "has_docstring": true,
    "docstring": "Create an interactive 3D diagram showing the J2000 Ecliptic coordinate system.\n\nReturns:\n    plotly.graph_objects.Figure: Interactive 3D plot",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_coordinate_system_diagram",
    "component_id": "coordinate_system_guide.create_coordinate_system_diagram"
  },
  "coordinate_system_guide.create_coordinate_system_guide": {
    "id": "coordinate_system_guide.create_coordinate_system_guide",
    "name": "create_coordinate_system_guide",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\coordinate_system_guide.py",
    "relative_path": "coordinate_system_guide.py",
    "depends_on": [
      "coordinate_system_guide.create_coordinate_system_diagram"
    ],
    "source_code": "def create_coordinate_system_guide():\n    \"\"\"\n    Create and open an HTML file with 3D visualization and reference text side by side.\n    \"\"\"\n    \n    # Create the 3D diagram\n    fig = create_coordinate_system_diagram()\n    \n    # Generate the Plotly HTML as a string without the full document wrapper\n    plotly_html = fig.to_html(\n        include_plotlyjs='cdn',\n        div_id='plotly-div',\n        config={'responsive': True, 'displayModeBar': True},\n        full_html=False  # KEY FIX: Don't generate full HTML, just the div\n    )\n    \n    # Reference text content (kept in a separate variable for readability)\n    reference_text = \"\"\"\n<div style=\"font-family: 'Courier New', monospace; font-size: 11px; line-height: 1.5; padding: 20px; background-color: #F5F5F5;\">\n\n<h2 style=\"color: #2C3E50; border-bottom: 2px solid #3498DB;\">J2000 ECLIPTIC COORDINATE SYSTEM</h2>\n<p style=\"font-style: italic; color: #555;\">Used Throughout Paloma's Orrery</p>\n\n<p style=\"background-color: #FFE6CC; padding: 10px; border-left: 4px solid #FF9800;\">\n<b> INTERACT WITH THE 3D DIAGRAM (LEFT) AS YOU READ </b><br>\n<b>Rotate:</b> Click and drag | <b>Zoom:</b> Scroll wheel | <b>Pan:</b> Right-click and drag\n</p>\n\n<hr style=\"border: 1px solid #BDC3C7;\">\n\n<h3 style=\"color: #2980B9;\">WHAT IS THE J2000 ECLIPTIC COORDINATE SYSTEM?</h3>\n\n<p>The J2000 Ecliptic coordinate system is the standard reference frame used in modern astronomy for describing positions of celestial objects in our solar system.</p>\n\n<p>Think of it as the <b>\"GPS coordinates\"</b> of the solar system - just as we use latitude, longitude, and altitude on Earth, astronomers use this 3D coordinate system (X, Y, Z) to specify where everything is in space.</p>\n\n<p style=\"background-color: #E8F4F8; padding: 8px; border-left: 3px solid #3498DB;\">\n<b> IN THE DIAGRAM:</b> You see the three colored axes (red, green, blue) emanating from the yellow Sun at the origin.\n</p>\n\n<hr style=\"border: 1px solid #BDC3C7;\">\n\n<h3 style=\"color: #2980B9;\">THE THREE AXES EXPLAINED</h3>\n\n<h4 style=\"color: #C0392B;\">+X AXIS (RED): Points Toward the Vernal Equinox ()</h4>\n\n<ul>\n<li>The vernal equinox (also called the \"First Point of Aries\" ) is where the Sun's apparent path across the sky (the ecliptic) crosses the celestial equator while moving from south to north.</li>\n\n<li>This happens around March 20 each year, marking spring in the Northern Hemisphere.</li>\n\n<li>On J2000.0 (Jan 1, 2000, 12:00 TT), astronomers \"froze\" this direction to create a stable reference.</li>\n\n<li>This serves as <b>celestial longitude 0</b> - think of it as \"cosmic east,\" the universal starting direction.</li>\n</ul>\n\n<p style=\"background-color: #E8F4F8; padding: 8px; border-left: 3px solid #C0392B;\">\n<b> IN THE DIAGRAM:</b> The <span style=\"color: #C0392B; font-weight: bold;\">RED</span> axis points right. Earth is shown at the <b>-X</b> position during the vernal equinox because the Sun's direction <i>from Earth</i> points to <b>+X</b> (toward the vernal equinox in the sky).\n</p>\n\n<h4 style=\"color: #27AE60;\">+Y AXIS (GREEN): 90 Ahead in Earth's Orbit</h4>\n\n<ul>\n<li>The +Y axis is 90 ahead of +X in the ecliptic plane.</li>\n\n<li>It points in the direction of Earth's motion through space at the vernal equinox.</li>\n\n<li>This completes the right-handed coordinate system where X  Y = Z (cross product).</li>\n</ul>\n\n<p style=\"background-color: #E8F4F8; padding: 8px; border-left: 3px solid #27AE60;\">\n<b> IN THE DIAGRAM:</b> The <span style=\"color: #27AE60; font-weight: bold;\">GREEN</span> axis points forward. Earth would be here 3 months after the vernal equinox (around June 20).\n</p>\n\n<h4 style=\"color: #2E86C1;\">+Z AXIS (BLUE): Points Toward the Ecliptic North Pole</h4>\n\n<ul>\n<li>The +Z axis points perpendicular to Earth's orbital plane (the ecliptic), toward the north side.</li>\n\n<li><b>Defined using the right-hand rule:</b> Curl your right hand fingers in the direction of Earth's orbit (counter-clockwise from above), your thumb points +Z.</li>\n\n<li>This is <b>\"cosmic north\"</b> - perpendicular to Earth's orbit.</li>\n\n<li>Objects with positive Z are \"above\" the ecliptic plane (north), negative Z are \"below\" (south).</li>\n</ul>\n\n<p style=\"background-color: #E8F4F8; padding: 8px; border-left: 3px solid #2E86C1;\">\n<b> IN THE DIAGRAM:</b> The <span style=\"color: #2E86C1; font-weight: bold;\">BLUE</span> axis points upward. Notice how the inclined orbit (magenta) goes above and below the ecliptic plane.\n</p>\n\n<hr style=\"border: 1px solid #BDC3C7;\">\n\n<h3 style=\"color: #2980B9;\">THE XY PLANE: EARTH'S ORBITAL PLANE (THE ECLIPTIC)</h3>\n\n<ul>\n<li>The XY plane is the <b>ecliptic itself</b> - the plane of Earth's orbit around the Sun.</li>\n\n<li>This is the fundamental \"reference table\" for measuring positions of all solar system objects.</li>\n\n<li>Most planets orbit close to this plane (within a few degrees) because the solar system formed from a rotating disk.</li>\n</ul>\n\n<p style=\"background-color: #E8F4F8; padding: 8px; border-left: 3px solid #8E44AD;\">\n<b> IN THE DIAGRAM:</b> The blue semi-transparent plane is the ecliptic. The <span style=\"color: cyan; font-weight: bold;\">cyan circle</span> shows Earth's orbit lying flat in this plane.\n</p>\n\n<hr style=\"border: 1px solid #BDC3C7;\">\n\n<h3 style=\"color: #2980B9;\">ORBITAL DIRECTION: PROGRADE VS RETROGRADE</h3>\n\n<h4>PROGRADE ORBITS (inclination i &lt; 90):</h4>\n<ul>\n<li>Objects orbit in the same direction as Earth - counter-clockwise when viewed from above the North Pole.</li>\n<li>Most planets, asteroids, and many comets have prograde orbits.</li>\n</ul>\n\n<p style=\"background-color: #E8F4F8; padding: 8px; border-left: 3px solid #16A085;\">\n<b> IN THE DIAGRAM:</b> Earth's orbit (cyan) goes counter-clockwise. The magenta inclined orbit is also prograde.\n</p>\n\n<h4>RETROGRADE ORBITS (inclination i &gt; 90):</h4>\n<ul>\n<li>Objects orbit opposite to Earth - clockwise when viewed from above the North Pole.</li>\n<li>Some comets and captured moons have retrograde orbits.</li>\n</ul>\n\n<hr style=\"border: 1px solid #BDC3C7;\">\n\n<h3 style=\"color: #2980B9;\">THE J2000.0 REFERENCE EPOCH</h3>\n\n<h4>WHAT IS J2000.0?</h4>\n<ul>\n<li><b>J2000.0 = January 1, 2000, at 12:00 Terrestrial Time (TT)</b></li>\n<li>The \"J\" stands for Julian epoch, \"2000.0\" is the year</li>\n</ul>\n\n<h4>WHY DO WE NEED A REFERENCE EPOCH?</h4>\n<ul>\n<li>Earth's axis wobbles slowly (<b>precession</b>), causing the vernal equinox to drift ~50 arcseconds per year.</li>\n\n<li>By \"freezing\" the coordinate system at J2000.0, we have a stable reference frame that doesn't change.</li>\n\n<li>All modern astronomical data uses J2000.0 as the standard reference.</li>\n</ul>\n\n<hr style=\"border: 1px solid #BDC3C7;\">\n\n<h3 style=\"color: #2980B9;\">HOW THIS APPLIES TO PALOMA'S ORRERY</h3>\n\n<h4>ORBITAL POSITIONS:</h4>\n<ul>\n<li>Every object in Paloma's Orrery has its position calculated in J2000 Ecliptic coordinates.</li>\n<li>When you see \"X = 1.5 AU, Y = 0.3 AU, Z = 0.1 AU,\" these are distances along the three axes.</li>\n</ul>\n\n<h4>KEPLERIAN ORBITAL ELEMENTS:</h4>\n<ul>\n<li><b>i (inclination):</b> Angle between orbital plane and XY plane (ecliptic)</li>\n<li><b> (longitude of ascending node):</b> Angle from +X axis to where orbit crosses ecliptic going northward</li>\n<li><b> (argument of periapsis):</b> Angle within orbital plane from ascending node to periapsis</li>\n</ul>\n\n<p style=\"background-color: #E8F4F8; padding: 8px; border-left: 3px solid #E74C3C;\">\n<b> IN THE DIAGRAM:</b> The inclined orbit (<span style=\"color: magenta; font-weight: bold;\">magenta</span>) shows how an orbit with i  0 is tilted relative to the ecliptic.\n</p>\n\n<hr style=\"border: 1px solid #BDC3C7;\">\n\n<h3 style=\"color: #2980B9;\">PRACTICAL EXAMPLES</h3>\n\n<h4>EARTH'S POSITION:</h4>\n<ul>\n<li>Earth orbits in the XY plane, so Z  0 always</li>\n<li>At vernal equinox (March 20): Earth is at X  -1 AU, Y  0, with the Sun's direction from Earth pointing to +X (the vernal equinox in the sky)</li>\n<li>Three months later (June 21): X  0, Y  -1 AU</li>\n<li>Six months later (Sept 22): X  +1 AU, Y  0</li>\n<li>Nine months later (Dec 21): X  0, Y  +1 AU</li>\n</ul>\n\n<p style=\"background-color: #E8F4F8; padding: 8px; border-left: 3px solid #3498DB;\">\n<b> IN THE DIAGRAM:</b> Follow the <span style=\"color: cyan; font-weight: bold;\">cyan circle</span> to see Earth's circular path in the XY plane.\n</p>\n\n<h4>PLUTO'S TILTED ORBIT:</h4>\n<ul>\n<li>Pluto has inclination i = 17, so its orbit is tilted significantly</li>\n<li>Maximum Z value: sin(17)  40 AU  12 AU above/below ecliptic</li>\n</ul>\n\n<p style=\"background-color: #E8F4F8; padding: 8px; border-left: 3px solid #9B59B6;\">\n<b> IN THE DIAGRAM:</b> Imagine the <span style=\"color: magenta; font-weight: bold;\">magenta orbit</span> stretched much larger - that's similar to Pluto's tilted orbit.\n</p>\n\n<h4>HALLEY'S COMET:</h4>\n<ul>\n<li>Inclination i = 162 means retrograde orbit</li>\n<li>Orbits \"backwards\" and far out of ecliptic plane</li>\n</ul>\n\n<hr style=\"border: 1px solid #BDC3C7;\">\n\n<h3 style=\"color: #2980B9;\">COMMON MISCONCEPTIONS</h3>\n\n<table style=\"width: 100%; border-collapse: collapse; margin: 10px 0;\">\n<tr style=\"background-color: #FADBD8;\">\n<td style=\"padding: 8px; border: 1px solid #ccc;\"><b> MISCONCEPTION</b></td>\n<td style=\"padding: 8px; border: 1px solid #ccc;\"><b> REALITY</b></td>\n</tr>\n<tr>\n<td style=\"padding: 8px; border: 1px solid #ccc;\">\"The ecliptic is Earth's equator.\"</td>\n<td style=\"padding: 8px; border: 1px solid #ccc;\">FALSE. The ecliptic is Earth's ORBITAL plane. Earth's equator is tilted 23.4 relative to it (causes seasons)</td>\n</tr>\n<tr>\n<td style=\"padding: 8px; border: 1px solid #ccc;\">\"The +X axis points toward Aries.\"</td>\n<td style=\"padding: 8px; border: 1px solid #ccc;\">MISLEADING. Called \"First Point of Aries\" historically, but due to precession it now points toward Pisces.</td>\n</tr>\n<tr>\n<td style=\"padding: 8px; border: 1px solid #ccc;\">\"J2000 coordinates become outdated.\"</td>\n<td style=\"padding: 8px; border: 1px solid #ccc;\">FALSE. J2000 is FIXED at the epoch. It never becomes outdated.</td>\n</tr>\n<tr>\n<td style=\"padding: 8px; border: 1px solid #ccc;\">\"All objects orbit in the ecliptic plane.\"</td>\n<td style=\"padding: 8px; border: 1px solid #ccc;\">FALSE. Many comets and asteroids have high inclinations (30, 60, or more).</td>\n</tr>\n</table>\n\n<p style=\"background-color: #E8F4F8; padding: 8px; border-left: 3px solid #E67E22;\">\n<b> IN THE DIAGRAM:</b> Compare the cyan orbit (i=0, in ecliptic) with the magenta orbit (i=30, tilted).\n</p>\n\n<hr style=\"border: 1px solid #BDC3C7;\">\n\n<h3 style=\"color: #2980B9;\">INTERACTIVE EXPLORATION TIPS</h3>\n\n<p><b> THINGS TO TRY IN THE 3D DIAGRAM:</b></p>\n\n<ol>\n<li><b>ROTATE THE VIEW:</b> Click and drag to see the coordinate system from different angles</li>\n\n<li><b>ZOOM IN/OUT:</b> Use scroll wheel to examine details</li>\n\n<li><b>HOVER OVER ELEMENTS:</b> See descriptions of each component</li>\n\n<li><b>COMPARE ORBITS:</b> Notice how the cyan orbit (i=0) stays in the XY plane while the magenta orbit (i=30) crosses above and below it</li>\n\n<li><b>FIND THE SUN:</b> The yellow marker at the origin (0,0,0)</li>\n\n<li><b>LOCATE EARTH:</b> The blue marker on the -X axis at the vernal equinox position</li>\n\n<li><b>WATCH HOW INCLINATION TILTS ORBITS:</b> Compare the flat cyan circle with the tilted magenta orbit</li>\n\n<li><b>OBSERVE THE LINE OF NODES:</b> Where the inclined orbit crosses the ecliptic plane</li>\n</ol>\n\n<hr style=\"border: 1px solid #BDC3C7;\">\n\n<h3 style=\"color: #2980B9;\">FURTHER LEARNING</h3>\n\n<h4>TO VISUALIZE ORBITAL MECHANICS:</h4>\n<ul>\n<li>Use the <b>Orbital Parameter Transformation Visualization</b> to see how orbits rotate from perifocal to ecliptic frame</li>\n<li>Explore the <b>Interactive Orbital Eccentricity Visualization</b> to understand orbital shapes</li>\n</ul>\n\n<h4>RESOURCES:</h4>\n<ul>\n<li><b>JPL Horizons System:</b> <a href=\"https://ssd.jpl.nasa.gov/horizons/\" target=\"_blank\">https://ssd.jpl.nasa.gov/horizons/</a><br>\nThe source of orbital data for Paloma's Orrery</li>\n\n<li><b>Explanatory Supplement to the Astronomical Almanac</b><br>\nThe definitive reference for coordinate systems in astronomy</li>\n\n<li><b>NASA's Coordinate Systems documentation</b><br>\nPractical guide for understanding different reference frames</li>\n</ul>\n\n<hr style=\"border: 1px solid #BDC3C7;\">\n\n<h3 style=\"color: #2980B9;\">SUMMARY</h3>\n\n<div style=\"background-color: #D5F4E6; padding: 15px; border-radius: 5px; border: 2px solid #27AE60; margin-bottom: 20px;\">\n<p><b>The J2000 Ecliptic coordinate system provides a universal, stable framework for describing positions and motions throughout the solar system:</b></p>\n\n<ul style=\"margin: 10px 0;\">\n<li><b style=\"color: #C0392B;\">+X axis (RED)</b>  Vernal Equinox (), celestial longitude 0</li>\n<li><b style=\"color: #27AE60;\">+Y axis (GREEN)</b>  90 ahead, Earth's motion direction</li>\n<li><b style=\"color: #2E86C1;\">+Z axis (BLUE)</b>  North Ecliptic Pole, perpendicular to ecliptic</li>\n<li><b>XY plane</b>  The ecliptic (Earth's orbital plane around the Sun)</li>\n<li><b>Origin</b>  The Sun (or solar system barycenter for high precision)</li>\n</ul>\n\n<p><b>This coordinate system is used consistently throughout Paloma's Orrery for:</b></p>\n<ul style=\"margin: 10px 0;\">\n<li> Plotting object positions in 3D space</li>\n<li> Calculating orbital paths</li>\n<li> Defining Keplerian orbital elements</li>\n<li> Transforming between reference frames</li>\n</ul>\n\n<p style=\"margin-top: 15px;\"><b>Understanding this coordinate system is key to interpreting all the visualizations in Paloma's Orrery!</b></p>\n</div>\n\n</div>\n\"\"\"\n    \n    # Create HTML with side-by-side layout\n    html_content = f\"\"\"\n<!DOCTYPE html>\n<html>\n<head>\n    <title>J2000 Ecliptic Coordinate System Reference</title>\n    <script src=\"https://cdn.plot.ly/plotly-2.26.0.min.js\" charset=\"utf-8\"></script>\n    <style>\n        * {{\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }}\n        html, body {{\n            height: 100%;\n            width: 100%;\n            overflow: hidden;\n            font-family: Arial, sans-serif;\n        }}\n        h1 {{\n            text-align: center;\n            background-color: #2C3E50;\n            color: white;\n            padding: 15px;\n            height: 50px;\n            line-height: 20px;\n        }}\n        #container {{\n            display: flex;\n            height: calc(100vh - 50px);\n            width: 100vw;\n        }}\n        #plot-container {{\n            flex: 0 0 60%;\n            height: 100%;\n            width: 60%;\n            position: relative;\n            overflow: hidden;\n        }}\n        #plotly-div {{\n            width: 100% !important;\n            height: 100% !important;\n        }}\n        #text-container {{\n            flex: 0 0 40%;\n            width: 40%;\n            height: 100%;\n            overflow-y: auto;\n            overflow-x: hidden;\n            border-left: 2px solid #34495E;\n        }}\n        /* Custom scrollbar styling */\n        #text-container::-webkit-scrollbar {{\n            width: 12px;\n        }}\n        #text-container::-webkit-scrollbar-track {{\n            background: #f1f1f1;\n        }}\n        #text-container::-webkit-scrollbar-thumb {{\n            background: #888;\n            border-radius: 6px;\n        }}\n        #text-container::-webkit-scrollbar-thumb:hover {{\n            background: #555;\n        }}\n    </style>\n</head>\n<body>\n    <h1>J2000 Ecliptic Coordinate System Reference Guide</h1>\n    <div id=\"container\">\n        <div id=\"plot-container\">\n            {plotly_html}\n        </div>\n        <div id=\"text-container\">\n            {reference_text}\n        </div>\n    </div>\n</body>\n</html>\n\"\"\"\n    \n# Save to temporary file and open in browser\n    temp_file = tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.html', encoding='utf-8')\n    temp_file.write(html_content)\n    temp_file.close()\n    \n    # Open in default browser\n    webbrowser.open('file://' + temp_file.name)\n    print(f\"Coordinate System Reference Guide opened in browser: {temp_file.name}\")\n    \n    # Offer save dialog (skip on macOS worker thread)\n    in_main_thread = threading.current_thread() is threading.main_thread()\n    if platform.system() == 'Darwin' and not in_main_thread:\n        print(\"Save dialog skipped (macOS thread safety) - use File > Save As in browser\")\n        return\n    \n    root = None\n    try:\n        root = tk.Tk()\n        root.withdraw()\n        root.attributes('-topmost', True)\n        \n        save_response = messagebox.askyesno(\n            \"Save Reference Guide\",\n            \"Would you like to save this reference guide?\",\n            parent=root\n        )\n        \n        if save_response:\n            file_path = filedialog.asksaveasfilename(\n                parent=root,\n                initialfile=\"coordinate_system_guide.html\",\n                defaultextension=\".html\",\n                filetypes=[(\"HTML files\", \"*.html\")]\n            )\n            if file_path:\n                with open(file_path, 'w', encoding='utf-8') as f:\n                    f.write(html_content)\n                print(f\"Reference guide saved to: {file_path}\")\n    except Exception as e:\n        print(f\"Error during save: {e}\")\n    finally:\n        if root:\n            try:\n                root.destroy()\n            except:\n                pass",
    "start_line": 228,
    "end_line": 659,
    "has_docstring": true,
    "docstring": "Create and open an HTML file with 3D visualization and reference text side by side.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_coordinate_system_guide",
    "component_id": "coordinate_system_guide.create_coordinate_system_guide"
  },
  "create_ephemeris_database.parse_horizons_header": {
    "id": "create_ephemeris_database.parse_horizons_header",
    "name": "parse_horizons_header",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\create_ephemeris_database.py",
    "relative_path": "create_ephemeris_database.py",
    "depends_on": [],
    "source_code": "def parse_horizons_header(filename: str) -> Dict:\n    \"\"\"\n    Parse orbital elements from JPL Horizons ephemeris file header.\n    \n    Returns dict with orbital elements found in the file.\n    \"\"\"\n    orbital_data = {}\n    \n    try:\n        with open(filename, 'r') as f:\n            content = f.read()\n            \n        # Find the satellite data section\n        # Look for patterns like \"Semi-major axis, a (km) = 9.3772(10^3)\"\n        \n        # Semi-major axis\n        sma_match = re.search(r'Semi-major axis.*?=\\s*([\\d.]+)\\s*\\(10\\^3\\)', content)\n        if not sma_match:\n            sma_match = re.search(r'Semi-major axis.*?=\\s*([\\d.]+)', content)\n        if sma_match:\n            value = float(sma_match.group(1))\n            # Check if it needs to be multiplied by 1000 (if in 10^3 km)\n            if '(10^3)' in content[sma_match.start():sma_match.end() + 20]:\n                value *= 1000\n            orbital_data['semi_major_axis_km'] = value\n            \n        # Eccentricity\n        ecc_match = re.search(r'Eccentricity.*?=\\s*([\\d.]+)', content)\n        if ecc_match:\n            orbital_data['eccentricity'] = float(ecc_match.group(1))\n            \n        # Inclination\n        inc_match = re.search(r'Inclination.*?\\(deg\\).*?=\\s*([\\d.]+)', content)\n        if inc_match:\n            orbital_data['inclination_deg'] = float(inc_match.group(1))\n            \n        # Orbital period\n        period_match = re.search(r'Orbital period.*?=\\s*([\\d.]+)\\s*d', content)\n        if period_match:\n            orbital_data['orbital_period_days'] = float(period_match.group(1))\n            \n        # Physical properties\n        radius_match = re.search(r'Radius.*?=\\s*([\\d.]+)\\s*x\\s*([\\d.]+)\\s*x\\s*([\\d.]+)', content)\n        if radius_match:\n            orbital_data['radius_km'] = {\n                'x': float(radius_match.group(1)),\n                'y': float(radius_match.group(2)),\n                'z': float(radius_match.group(3))\n            }\n            \n        # Density\n        density_match = re.search(r'Density.*?=\\s*([\\d.]+)', content)\n        if density_match:\n            orbital_data['density_g_cm3'] = float(density_match.group(1))\n            \n        # Mass\n        mass_match = re.search(r'Mass.*?=\\s*([\\d.]+).*?\\(10\\^(\\d+)', content)\n        if mass_match:\n            base = float(mass_match.group(1))\n            exponent = int(mass_match.group(2))\n            orbital_data['mass_kg'] = base * (10 ** exponent)\n            \n        print(f\"Parsed {filename}: found {len(orbital_data)} parameters\")\n        \n    except FileNotFoundError:\n        print(f\"Warning: {filename} not found\")\n        \n    return orbital_data",
    "start_line": 16,
    "end_line": 83,
    "has_docstring": true,
    "docstring": "Parse orbital elements from JPL Horizons ephemeris file header.\n\nReturns dict with orbital elements found in the file.",
    "parameters": [
      "filename"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parse_horizons_header",
    "component_id": "create_ephemeris_database.parse_horizons_header"
  },
  "create_ephemeris_database.get_idealized_orbits_data": {
    "id": "create_ephemeris_database.get_idealized_orbits_data",
    "name": "get_idealized_orbits_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\create_ephemeris_database.py",
    "relative_path": "create_ephemeris_database.py",
    "depends_on": [],
    "source_code": "def get_idealized_orbits_data() -> Dict:\n    \"\"\"\n    Import orbital parameters from idealized_orbits.py if available.\n    \"\"\"\n    try:\n        from idealized_orbits import planetary_params\n        print(f\"Loaded orbital parameters for {len(planetary_params)} objects from idealized_orbits.py\")\n        return planetary_params\n    except ImportError:\n        print(\"Warning: Could not import idealized_orbits.py\")\n        return {}",
    "start_line": 86,
    "end_line": 96,
    "has_docstring": true,
    "docstring": "Import orbital parameters from idealized_orbits.py if available.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_idealized_orbits_data",
    "component_id": "create_ephemeris_database.get_idealized_orbits_data"
  },
  "create_ephemeris_database.create_satellite_ephemerides": {
    "id": "create_ephemeris_database.create_satellite_ephemerides",
    "name": "create_satellite_ephemerides",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\create_ephemeris_database.py",
    "relative_path": "create_ephemeris_database.py",
    "depends_on": [
      "create_ephemeris_database.get_idealized_orbits_data",
      "create_ephemeris_database.parse_horizons_header"
    ],
    "source_code": "def create_satellite_ephemerides():\n    \"\"\"\n    Create comprehensive satellite ephemeris database from all available sources.\n    \"\"\"\n    \n    # Initialize database structure\n    database = {\n        \"metadata\": {\n            \"version\": \"1.1\",\n            \"created\": datetime.now().isoformat(),\n            \"last_updated\": datetime.now().isoformat(),\n            \"sources\": {\n                \"idealized_orbits\": \"Local orbital parameters file\",\n                \"jpl_horizons\": \"JPL Horizons ephemeris files\"\n            },\n            \"description\": \"Satellite orbital elements for refined orbit calculations\",\n            \"units\": {\n                \"distance\": \"kilometers\",\n                \"angles\": \"degrees\",\n                \"time\": \"days\",\n                \"mass\": \"kilograms\"\n            }\n        },\n        \"satellites\": {}\n    }\n    \n    # Step 1: Load data from idealized_orbits.py\n    idealized_params = get_idealized_orbits_data()\n    \n    # Step 2: Convert idealized_orbits data to our format\n    # Note: idealized_orbits.py uses AU, we need km\n    AU_TO_KM = 149597870.7\n    \n    for sat_name, params in idealized_params.items():\n        # Skip non-satellite objects\n        if sat_name in ['Sun', 'Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', \n                        'Saturn', 'Uranus', 'Neptune', 'Pluto', 'Eris']:\n            continue\n            \n        # Determine primary body\n        primary = None\n        if sat_name == 'Moon':\n            primary = 'Earth'\n        elif sat_name in ['Phobos', 'Deimos']:\n            primary = 'Mars'\n        elif sat_name in ['Io', 'Europa', 'Ganymede', 'Callisto']:\n            primary = 'Jupiter'\n        elif sat_name in ['Titan', 'Enceladus', 'Rhea', 'Dione', 'Tethys', 'Mimas', 'Phoebe']:\n            primary = 'Saturn'\n        elif sat_name in ['Miranda', 'Ariel', 'Umbriel', 'Titania', 'Oberon']:\n            primary = 'Uranus'\n        elif sat_name in ['Triton']:\n            primary = 'Neptune'\n        elif sat_name in ['Charon', 'Styx', 'Nix', 'Kerberos', 'Hydra']:\n            primary = 'Pluto'\n        elif sat_name == 'Dysnomia':\n            primary = 'Eris'\n            \n        if primary:\n            key = f\"{primary.lower()}_{sat_name.lower()}\"\n            \n            # Convert orbital elements\n            orbital_elements = {}\n            \n            # Semi-major axis (convert from AU to km)\n            if 'a' in params:\n                orbital_elements['semi_major_axis_km'] = params['a'] * AU_TO_KM\n                \n            if 'e' in params:\n                orbital_elements['eccentricity'] = params['e']\n                \n            if 'i' in params:\n                orbital_elements['inclination_deg'] = params['i']\n                \n            if 'omega' in params:\n                orbital_elements['argument_of_periapsis_deg'] = params['omega']\n                \n            if 'Omega' in params:\n                orbital_elements['longitude_ascending_node_deg'] = params['Omega']\n            \n            database[\"satellites\"][key] = {\n                \"name\": sat_name,\n                \"primary\": primary,\n                \"source\": \"idealized_orbits.py\",\n                \"last_updated\": datetime.now().isoformat(),\n                \"orbital_elements\": orbital_elements\n            }\n    \n    # Step 3: Update with Horizons data (more accurate)\n    horizons_files = {\n        'mars_phobos': 'horizons_phobos_heliocentric.txt',\n        'mars_deimos': 'horizons_deimos_heliocentric.txt',\n        'saturn_phoebe': 'horizons_phoebe_heliocentric.txt',\n        # Add more as you download them:\n        # 'jupiter_io': 'horizons_io.txt',\n        # 'earth_moon': 'horizons_moon.txt',\n        # etc.\n    }\n    \n    for sat_key, filename in horizons_files.items():\n        if os.path.exists(filename):\n            print(f\"\\nProcessing Horizons file: {filename}\")\n            horizons_data = parse_horizons_header(filename)\n            \n            if horizons_data and sat_key in database[\"satellites\"]:\n                # Update with Horizons data (more accurate)\n                sat_entry = database[\"satellites\"][sat_key]\n                \n                # Update orbital elements\n                for key, value in horizons_data.items():\n                    if key in ['semi_major_axis_km', 'eccentricity', 'inclination_deg', \n                             'orbital_period_days']:\n                        sat_entry[\"orbital_elements\"][key] = value\n                    elif key in ['radius_km', 'density_g_cm3', 'mass_kg']:\n                        if \"physical_properties\" not in sat_entry:\n                            sat_entry[\"physical_properties\"] = {}\n                        sat_entry[\"physical_properties\"][key] = value\n                \n                sat_entry[\"source\"] = \"JPL Horizons (updated)\"\n                sat_entry[\"horizons_file\"] = filename\n                sat_entry[\"last_updated\"] = datetime.now().isoformat()\n                \n                print(f\"Updated {sat_key} with Horizons data\")\n        else:\n            print(f\"Horizons file not found: {filename}\")\n    \n    # Step 4: Add any manual corrections or additional data\n    # For example, adding specific values we know from the Horizons headers\n    if \"mars_phobos\" in database[\"satellites\"]:\n        phobos = database[\"satellites\"][\"mars_phobos\"]\n        # From your Horizons file header\n        phobos[\"orbital_elements\"][\"semi_major_axis_km\"] = 9377.2\n        phobos[\"orbital_elements\"][\"eccentricity\"] = 0.0151\n        phobos[\"orbital_elements\"][\"inclination_deg\"] = 1.082\n        phobos[\"orbital_elements\"][\"orbital_period_days\"] = 0.319\n        phobos[\"revision_date\"] = \"2025-06-02\"\n        \n    if \"mars_deimos\" in database[\"satellites\"]:\n        deimos = database[\"satellites\"][\"mars_deimos\"]\n        # From your Horizons file header\n        deimos[\"orbital_elements\"][\"semi_major_axis_km\"] = 23463.2\n        deimos[\"orbital_elements\"][\"eccentricity\"] = 0.00033\n        deimos[\"orbital_elements\"][\"inclination_deg\"] = 1.791\n        deimos[\"orbital_elements\"][\"orbital_period_days\"] = 1.263\n        deimos[\"revision_date\"] = \"2025-06-02\"\n    \n    # Save to JSON file\n    with open('satellite_ephemerides.json', 'w') as f:\n        json.dump(database, f, indent=2)\n    \n    # Print summary\n    print(\"\\n\" + \"=\"*60)\n    print(\"Created satellite_ephemerides.json\")\n    print(f\"Total satellites: {len(database['satellites'])}\")\n    print(\"\\nSatellites by source:\")\n    \n    idealized_count = sum(1 for s in database['satellites'].values() \n                         if 'idealized' in s.get('source', ''))\n    horizons_count = sum(1 for s in database['satellites'].values() \n                        if 'Horizons' in s.get('source', ''))\n    \n    print(f\"  From idealized_orbits.py: {idealized_count}\")\n    print(f\"  Updated with JPL Horizons: {horizons_count}\")\n    \n    print(\"\\nSatellites with refined data:\")\n    for key, sat in database['satellites'].items():\n        if 'Horizons' in sat.get('source', ''):\n            elements = sat['orbital_elements']\n            print(f\"\\n{sat['name']} ({sat['primary']}):\")\n            print(f\"  Semi-major axis: {elements.get('semi_major_axis_km', 'N/A'):,.1f} km\")\n            print(f\"  Inclination: {elements.get('inclination_deg', 'N/A'):.3f} deg\")\n            print(f\"  Source: {sat['source']}\")",
    "start_line": 99,
    "end_line": 270,
    "has_docstring": true,
    "docstring": "Create comprehensive satellite ephemeris database from all available sources.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_satellite_ephemerides",
    "component_id": "create_ephemeris_database.create_satellite_ephemerides"
  },
  "create_ephemeris_database.download_instructions": {
    "id": "create_ephemeris_database.download_instructions",
    "name": "download_instructions",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\create_ephemeris_database.py",
    "relative_path": "create_ephemeris_database.py",
    "depends_on": [],
    "source_code": "def download_instructions():\n    \"\"\"Print instructions for downloading more ephemerides.\"\"\"\n    print(\"\\n\" + \"=\"*60)\n    print(\"To add more satellites:\")\n    print(\"1. Go to https://ssd.jpl.nasa.gov/horizons/\")\n    print(\"2. Select your satellite (e.g., 'Io')\")\n    print(\"3. Set:\")\n    print(\"   - Ephemeris Type: OBSERVER\")\n    print(\"   - Target Body: [Your satellite]\")\n    print(\"   - Observer Location: '@' + primary body code (e.g., '@599' for Jupiter)\")\n    print(\"   - Time Specification: Your date range\")\n    print(\"   - Table Settings: Default is fine\")\n    print(\"4. Download and save as 'horizons_[satellite]_heliocentric.txt'\")\n    print(\"5. Add to horizons_files dict in this script\")\n    print(\"6. Re-run this script\")\n    print(\"=\"*60)",
    "start_line": 273,
    "end_line": 288,
    "has_docstring": true,
    "docstring": "Print instructions for downloading more ephemerides.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function download_instructions",
    "component_id": "create_ephemeris_database.download_instructions"
  },
  "data_acquisition.calculate_parallax_limit": {
    "id": "data_acquisition.calculate_parallax_limit",
    "name": "calculate_parallax_limit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_acquisition.py",
    "relative_path": "data_acquisition.py",
    "depends_on": [],
    "source_code": "def calculate_parallax_limit(max_light_years):\n    \"\"\"Calculate minimum parallax for a given distance in light-years.\"\"\"\n    max_distance_pc = max_light_years / 3.26156\n    return (1 / max_distance_pc) * 1000  # parallax in mas",
    "start_line": 27,
    "end_line": 30,
    "has_docstring": true,
    "docstring": "Calculate minimum parallax for a given distance in light-years.",
    "parameters": [
      "max_light_years"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_parallax_limit",
    "component_id": "data_acquisition.calculate_parallax_limit"
  },
  "data_acquisition.initialize_vizier": {
    "id": "data_acquisition.initialize_vizier",
    "name": "initialize_vizier",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_acquisition.py",
    "relative_path": "data_acquisition.py",
    "depends_on": [],
    "source_code": "def initialize_vizier(timeout=120):\n    \"\"\"\n    Initialize Vizier with no row limit and a set of columns you actually need.\n    Increase 'timeout' if queries time out frequently.\n    \"\"\"\n    try:\n        # Example: only request key columns from each catalog. \n        # This greatly reduces the data volume for large queries.\n        # You can add or remove fields depending on what your code actually needs.\n        v = Vizier(\n            columns=[\n                '*',  # Or list columns explicitly, e.g. \"Vmag\", \"B-V\", \"HIP\", \"Plx\", \"phot_g_mean_mag\", ...\n            ],\n            row_limit=-1,\n            timeout=timeout\n        )\n        return v\n    except Exception as e:\n        raise RuntimeError(f\"Failed to initialize Vizier: {e}\")",
    "start_line": 32,
    "end_line": 50,
    "has_docstring": true,
    "docstring": "Initialize Vizier with no row limit and a set of columns you actually need.\nIncrease 'timeout' if queries time out frequently.",
    "parameters": [
      "timeout"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function initialize_vizier",
    "component_id": "data_acquisition.initialize_vizier"
  },
  "data_acquisition.load_or_fetch_hipparcos_data": {
    "id": "data_acquisition.load_or_fetch_hipparcos_data",
    "name": "load_or_fetch_hipparcos_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_acquisition.py",
    "relative_path": "data_acquisition.py",
    "depends_on": [],
    "source_code": "def load_or_fetch_hipparcos_data(v, hip_data_file, mode='distance',\n                                 mag_limit=None, parallax_constraint=None):\n    \"\"\"\n    Load or fetch Hipparcos data.\n    - If mode == 'magnitude', we apply Vmag <= mag_limit.\n    - If mode == 'distance', we apply Plx >= parallax_constraint.\n    - We skip strict file-size or bright-star validations to avoid repeated fetches.\n    \"\"\"\n    if os.path.exists(hip_data_file):\n        # Just load the file if it exists. No size-based checks.\n        try:\n            print(f\"Loading existing Hipparcos file: {hip_data_file}\")\n            data = Table.read(hip_data_file, format='votable')\n            print(f\"Hipparcos data loaded: {len(data)} entries.\")\n            return data\n        except Exception as e:\n            print(f\"Error reading {hip_data_file}: {e}\")\n            # Fall back to fetching if file is corrupt.\n    \n    print(f\"Fetching Hipparcos data from Vizier ({mode} mode)...\")\n    try:\n        constraints = {}\n        if mode == 'magnitude' and mag_limit is not None:\n            constraints['Vmag'] = f\"<={mag_limit}\"\n        elif mode == 'distance' and parallax_constraint is not None:\n            constraints['Plx'] = parallax_constraint\n\n        result = v.query_constraints(catalog=\"I/239/hip_main\", **constraints)\n        if not result:\n            print(\"No data found in Hipparcos catalog for these constraints.\")\n            return None\n\n        hip_data = result[0]\n        print(f\"Number of Hipparcos entries fetched: {len(hip_data)}\")\n        # Save to disk\n        hip_data.write(hip_data_file, format='votable', overwrite=True)\n        print(f\"Saved Hipparcos data to {hip_data_file}\")\n        return hip_data\n\n    except Exception as e:\n        print(f\"Error fetching Hipparcos data: {e}\")\n        return None",
    "start_line": 52,
    "end_line": 93,
    "has_docstring": true,
    "docstring": "Load or fetch Hipparcos data.\n- If mode == 'magnitude', we apply Vmag <= mag_limit.\n- If mode == 'distance', we apply Plx >= parallax_constraint.\n- We skip strict file-size or bright-star validations to avoid repeated fetches.",
    "parameters": [
      "v",
      "hip_data_file",
      "mode",
      "mag_limit",
      "parallax_constraint"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_or_fetch_hipparcos_data",
    "component_id": "data_acquisition.load_or_fetch_hipparcos_data"
  },
  "data_acquisition.load_or_fetch_gaia_data": {
    "id": "data_acquisition.load_or_fetch_gaia_data",
    "name": "load_or_fetch_gaia_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_acquisition.py",
    "relative_path": "data_acquisition.py",
    "depends_on": [],
    "source_code": "def load_or_fetch_gaia_data(v, gaia_data_file, mode='distance',\n                            mag_limit=None, parallax_constraint=None):\n    \"\"\"\n    Load or fetch Gaia data.\n    - If mode == 'magnitude', we apply Gmag <= mag_limit + 0.5 (common offset).\n    - If mode == 'distance', we apply Plx >= parallax_constraint.\n    - We skip strict file-size checks to avoid repeated fetches.\n    \"\"\"\n    if os.path.exists(gaia_data_file):\n        # Just load the file if it exists. \n        try:\n            print(f\"Loading existing Gaia file: {gaia_data_file}\")\n            data = Table.read(gaia_data_file, format='votable')\n            print(f\"Gaia data loaded: {len(data)} entries.\")\n            return data\n        except Exception as e:\n            print(f\"Error reading {gaia_data_file}: {e}\")\n            # Fall back to fetching if file is corrupt.\n\n    print(f\"Fetching Gaia data from Vizier ({mode} mode)...\")\n    try:\n        constraints = {}\n        if mode == 'magnitude' and mag_limit is not None:\n            adjusted_limit = min(11.0, mag_limit + 0.5)\n            constraints['Gmag'] = f\"<={adjusted_limit}\"\n        elif mode == 'distance' and parallax_constraint is not None:\n            constraints['Plx'] = parallax_constraint\n            # Optionally enforce parallax error <2 mas, if desired:\n            # constraints['e_Plx'] = '<2'\n\n        result = v.query_constraints(catalog=\"I/350/gaiaedr3\", **constraints)\n        if not result:\n            print(\"No data found in Gaia EDR3 for these constraints.\")\n            return None\n\n        gaia_data = result[0]\n        print(f\"Number of Gaia entries fetched: {len(gaia_data)}\")\n        # Save to disk\n        gaia_data.write(gaia_data_file, format='votable', overwrite=True)\n        print(f\"Saved Gaia data to {gaia_data_file}\")\n        return gaia_data\n\n    except Exception as e:\n        print(f\"Error fetching Gaia data: {e}\")\n        return None",
    "start_line": 95,
    "end_line": 139,
    "has_docstring": true,
    "docstring": "Load or fetch Gaia data.\n- If mode == 'magnitude', we apply Gmag <= mag_limit + 0.5 (common offset).\n- If mode == 'distance', we apply Plx >= parallax_constraint.\n- We skip strict file-size checks to avoid repeated fetches.",
    "parameters": [
      "v",
      "gaia_data_file",
      "mode",
      "mag_limit",
      "parallax_constraint"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_or_fetch_gaia_data",
    "component_id": "data_acquisition.load_or_fetch_gaia_data"
  },
  "data_acquisition.estimate_vmag_from_gaia": {
    "id": "data_acquisition.estimate_vmag_from_gaia",
    "name": "estimate_vmag_from_gaia",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_acquisition.py",
    "relative_path": "data_acquisition.py",
    "depends_on": [],
    "source_code": "def estimate_vmag_from_gaia(gaia_data):\n    \"\"\"Convert Gaia G magnitudes (plus BP-RP) to an approximate Johnson V magnitude.\"\"\"\n    vmag = np.full(len(gaia_data), np.nan)\n    if all(col in gaia_data.colnames for col in ['Gmag', 'BP-RP']):\n        bp_rp = gaia_data['BP-RP']\n        valid_mask = ~np.isnan(gaia_data['Gmag']) & ~np.isnan(bp_rp)\n        # Polynomial approximation\n        vmag[valid_mask] = (\n            gaia_data['Gmag'][valid_mask]\n            - (\n                -0.0257\n                - 0.0924 * bp_rp[valid_mask]\n                - 0.1623 * bp_rp[valid_mask] ** 2\n                + 0.0090 * bp_rp[valid_mask] ** 3\n            )\n        )\n    return vmag",
    "start_line": 141,
    "end_line": 157,
    "has_docstring": true,
    "docstring": "Convert Gaia G magnitudes (plus BP-RP) to an approximate Johnson V magnitude.",
    "parameters": [
      "gaia_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function estimate_vmag_from_gaia",
    "component_id": "data_acquisition.estimate_vmag_from_gaia"
  },
  "data_acquisition.align_coordinate_systems": {
    "id": "data_acquisition.align_coordinate_systems",
    "name": "align_coordinate_systems",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_acquisition.py",
    "relative_path": "data_acquisition.py",
    "depends_on": [],
    "source_code": "def align_coordinate_systems(hip_data):\n    \"\"\"Align coordinate systems by ensuring RA_ICRS, DE_ICRS exist in the table.\"\"\"\n    if hip_data is None:\n        return None\n    try:\n        if 'RA_ICRS' not in hip_data.colnames:\n            if 'RAICRS' in hip_data.colnames:\n                hip_data.rename_column('RAICRS', 'RA_ICRS')\n            elif 'RAhms' in hip_data.colnames:\n                hip_data['RA_ICRS'] = Angle(hip_data['RAhms'], unit='hourangle').degree\n        if 'DE_ICRS' not in hip_data.colnames:\n            if 'DEICRS' in hip_data.colnames:\n                hip_data.rename_column('DEICRS', 'DE_ICRS')\n            elif 'DEdms' in hip_data.colnames:\n                hip_data['DE_ICRS'] = Angle(hip_data['DEdms'], unit='deg').degree\n        return hip_data\n    except Exception as e:\n        raise RuntimeError(f\"Error aligning coordinate systems: {e}\")",
    "start_line": 159,
    "end_line": 176,
    "has_docstring": true,
    "docstring": "Align coordinate systems by ensuring RA_ICRS, DE_ICRS exist in the table.",
    "parameters": [
      "hip_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function align_coordinate_systems",
    "component_id": "data_acquisition.align_coordinate_systems"
  },
  "data_acquisition.process_distance_data": {
    "id": "data_acquisition.process_distance_data",
    "name": "process_distance_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_acquisition.py",
    "relative_path": "data_acquisition.py",
    "depends_on": [],
    "source_code": "def process_distance_data(data, max_light_years):\n    \"\"\"\n    Convert parallax to distance (pc, ly) and filter out anything beyond max_light_years.\n    This mimics the old data_acquisition_distance.py logic.\n    \"\"\"\n    if data is None or 'Plx' not in data.colnames:\n        return None\n    parallax_mas = data['Plx']\n    parallax_arcsec = parallax_mas / 1000.0\n    distance_pc = 1 / parallax_arcsec\n    distance_ly = distance_pc * 3.26156\n    data['Distance_pc'] = distance_pc\n    data['Distance_ly'] = distance_ly\n\n    # Filter\n    mask = (np.isfinite(distance_ly) & (distance_ly > 0) & (distance_ly <= max_light_years))\n    data = data[mask]\n    return data",
    "start_line": 178,
    "end_line": 195,
    "has_docstring": true,
    "docstring": "Convert parallax to distance (pc, ly) and filter out anything beyond max_light_years.\nThis mimics the old data_acquisition_distance.py logic.",
    "parameters": [
      "data",
      "max_light_years"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function process_distance_data",
    "component_id": "data_acquisition.process_distance_data"
  },
  "data_acquisition.load_stellar_data": {
    "id": "data_acquisition.load_stellar_data",
    "name": "load_stellar_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_acquisition.py",
    "relative_path": "data_acquisition.py",
    "depends_on": [
      "data_acquisition.load_or_fetch_gaia_data",
      "data_acquisition.load_or_fetch_hipparcos_data",
      "data_acquisition.calculate_parallax_limit",
      "data_acquisition.initialize_vizier",
      "data_acquisition.estimate_vmag_from_gaia",
      "data_acquisition.align_coordinate_systems",
      "data_acquisition.process_distance_data"
    ],
    "source_code": "def load_stellar_data(mode='distance', max_value=20.0, \n                      hip_file='hipparcos_data.vot', gaia_file='gaia_data.vot'):\n    \"\"\"\n    Main function to load or fetch data from Hipparcos and Gaia, either for a distance-based\n    or magnitude-based query. Integrates old distance logic plus optional magnitude logic.\n\n    Args:\n        mode: 'distance' or 'magnitude'\n        max_value: e.g. 100.0 light-years (distance mode) or 6.0 (magnitude mode)\n        hip_file, gaia_file: local filenames to cache results\n    Returns:\n        (hip_data, gaia_data): Two astropy Tables\n    \"\"\"\n    v = initialize_vizier(timeout=300)  # longer timeout for big queries\n\n    # Build constraints\n    if mode == 'distance':\n        parallax_constraint = f\">={calculate_parallax_limit(max_value)}\"\n        hip_data = load_or_fetch_hipparcos_data(\n            v, hip_data_file=hip_file, mode='distance',\n            parallax_constraint=parallax_constraint\n        )\n        gaia_data = load_or_fetch_gaia_data(\n            v, gaia_file, mode='distance',\n            parallax_constraint=parallax_constraint\n        )\n\n        # Post-process distances\n        hip_data = process_distance_data(hip_data, max_value)\n        if hip_data is not None:\n            hip_data = align_coordinate_systems(hip_data)\n        if gaia_data is not None:\n            gaia_data = process_distance_data(gaia_data, max_value)\n            # Estimate V from G for Gaia\n            gaia_data['Estimated_Vmag'] = estimate_vmag_from_gaia(gaia_data)\n        return hip_data, gaia_data\n\n    else:  # magnitude mode\n        hip_data = load_or_fetch_hipparcos_data(\n            v, hip_file, mode='magnitude', mag_limit=max_value\n        )\n        gaia_data = load_or_fetch_gaia_data(\n            v, gaia_file, mode='magnitude', mag_limit=max_value\n        )\n        # You can do extra processing if needed-like distance calculation if 'Plx' is present\n        if gaia_data is not None:\n            gaia_data['Estimated_Vmag'] = estimate_vmag_from_gaia(gaia_data)\n        return hip_data, gaia_data",
    "start_line": 197,
    "end_line": 244,
    "has_docstring": true,
    "docstring": "Main function to load or fetch data from Hipparcos and Gaia, either for a distance-based\nor magnitude-based query. Integrates old distance logic plus optional magnitude logic.\n\nArgs:\n    mode: 'distance' or 'magnitude'\n    max_value: e.g. 100.0 light-years (distance mode) or 6.0 (magnitude mode)\n    hip_file, gaia_file: local filenames to cache results\nReturns:\n    (hip_data, gaia_data): Two astropy Tables",
    "parameters": [
      "mode",
      "max_value",
      "hip_file",
      "gaia_file"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_stellar_data",
    "component_id": "data_acquisition.load_stellar_data"
  },
  "data_acquisition_distance.initialize_vizier": {
    "id": "data_acquisition_distance.initialize_vizier",
    "name": "initialize_vizier",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_acquisition_distance.py",
    "relative_path": "data_acquisition_distance.py",
    "depends_on": [],
    "source_code": "def initialize_vizier():\n    \"\"\"Initialize Vizier with unlimited rows and all columns.\"\"\"\n    try:\n        vizier = Vizier(columns=['*'], row_limit=-1)\n        return vizier\n    except Exception as e:\n        raise RuntimeError(f\"Failed to initialize Vizier: {e}\")",
    "start_line": 9,
    "end_line": 15,
    "has_docstring": true,
    "docstring": "Initialize Vizier with unlimited rows and all columns.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function initialize_vizier",
    "component_id": "data_acquisition_distance.initialize_vizier"
  },
  "data_acquisition_distance.calculate_parallax_limit": {
    "id": "data_acquisition_distance.calculate_parallax_limit",
    "name": "calculate_parallax_limit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_acquisition_distance.py",
    "relative_path": "data_acquisition_distance.py",
    "depends_on": [],
    "source_code": "def calculate_parallax_limit(max_light_years):\n    \"\"\"Calculate minimum parallax for given distance in light-years.\"\"\"\n    max_distance_pc = max_light_years / 3.26156\n    min_parallax_mas = (1 / max_distance_pc) * 1000\n    return min_parallax_mas",
    "start_line": 17,
    "end_line": 21,
    "has_docstring": true,
    "docstring": "Calculate minimum parallax for given distance in light-years.",
    "parameters": [
      "max_light_years"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_parallax_limit",
    "component_id": "data_acquisition_distance.calculate_parallax_limit"
  },
  "data_acquisition_distance.fetch_gaia_data": {
    "id": "data_acquisition_distance.fetch_gaia_data",
    "name": "fetch_gaia_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_acquisition_distance.py",
    "relative_path": "data_acquisition_distance.py",
    "depends_on": [
      "vot_cache_manager.VOTCacheManager"
    ],
    "source_code": "def fetch_gaia_data(vizier, gaia_data_file, min_parallax_mas):\n    \"\"\"Fetch stars from Gaia EDR3 catalog.\"\"\"\n    try:\n        print(f\"Fetching Gaia stars with parallax >= {min_parallax_mas} mas...\")\n        gaia_result = vizier.query_constraints(\n            catalog=\"I/350/gaiaedr3\",\n            parallax=f\">={min_parallax_mas}\"\n        )\n        if not gaia_result:\n            return None\n            \n        gaia_data = gaia_result[0]\n        print(f\"Found {len(gaia_data)} Gaia stars\")\n        \n        # Save the data\n    #    gaia_data.write(gaia_data_file, format='votable', overwrite=True)\n        # Use safe save with protection against overwriting comprehensive caches\n        vot_mgr = VOTCacheManager()\n        vot_mgr.safe_save_vot(gaia_data, gaia_data_file)\n\n        print(f\"Saved Gaia data to {gaia_data_file}\")\n        \n        return gaia_data\n    except Exception as e:\n        raise RuntimeError(f\"Error fetching Gaia data: {e}\")",
    "start_line": 23,
    "end_line": 47,
    "has_docstring": true,
    "docstring": "Fetch stars from Gaia EDR3 catalog.",
    "parameters": [
      "vizier",
      "gaia_data_file",
      "min_parallax_mas"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_gaia_data",
    "component_id": "data_acquisition_distance.fetch_gaia_data"
  },
  "data_acquisition_distance.fetch_hipparcos_data": {
    "id": "data_acquisition_distance.fetch_hipparcos_data",
    "name": "fetch_hipparcos_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_acquisition_distance.py",
    "relative_path": "data_acquisition_distance.py",
    "depends_on": [
      "vot_cache_manager.VOTCacheManager"
    ],
    "source_code": "def fetch_hipparcos_data(vizier, hip_data_file, min_parallax_mas):\n    \"\"\"Fetch stars from Hipparcos catalog.\"\"\"\n    try:\n        print(f\"Fetching Hipparcos stars with parallax >= {min_parallax_mas} mas...\")\n        hip_result = vizier.query_constraints(\n            catalog=\"I/239/hip_main\",\n            Plx=f\">={min_parallax_mas}\"\n        )\n        if not hip_result:\n            return None\n            \n        hip_data = hip_result[0]\n        print(f\"Found {len(hip_data)} Hipparcos stars\")\n        \n        # Save the data\n    #    hip_data.write(hip_data_file, format='votable', overwrite=True)\n        # Use safe save with protection against overwriting comprehensive caches\n        vot_mgr = VOTCacheManager()\n        vot_mgr.safe_save_vot(hip_data, hip_data_file)\n\n        print(f\"Saved Hipparcos data to {hip_data_file}\")\n        \n        return hip_data\n    except Exception as e:\n        raise RuntimeError(f\"Error fetching Hipparcos data: {e}\")",
    "start_line": 49,
    "end_line": 73,
    "has_docstring": true,
    "docstring": "Fetch stars from Hipparcos catalog.",
    "parameters": [
      "vizier",
      "hip_data_file",
      "min_parallax_mas"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_hipparcos_data",
    "component_id": "data_acquisition_distance.fetch_hipparcos_data"
  },
  "data_acquisition_distance.process_gaia_data": {
    "id": "data_acquisition_distance.process_gaia_data",
    "name": "process_gaia_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_acquisition_distance.py",
    "relative_path": "data_acquisition_distance.py",
    "depends_on": [
      "data_processing.estimate_vmag_from_gaia"
    ],
    "source_code": "def process_gaia_data(gaia_data, max_light_years):\n    \"\"\"Process Gaia data and calculate distances.\"\"\"\n    if gaia_data is None:\n        return None\n        \n    try:\n        # Calculate distances\n        parallax_mas = gaia_data['Plx']\n        parallax_arcsec = parallax_mas / 1000.0\n        distance_pc = 1 / parallax_arcsec\n        distance_ly = distance_pc * 3.26156\n        \n        # Add distance columns\n        gaia_data['Distance_pc'] = distance_pc\n        gaia_data['Distance_ly'] = distance_ly\n        \n        # Filter by distance and validity\n        mask = (np.isfinite(distance_ly) & \n                (distance_ly > 0) & \n                (distance_ly <= max_light_years))\n        \n        gaia_data = gaia_data[mask]\n        \n        # Estimate V magnitudes\n        gaia_data['Estimated_Vmag'] = estimate_vmag_from_gaia(gaia_data)\n        \n        return gaia_data\n    except Exception as e:\n        raise RuntimeError(f\"Error processing Gaia data: {e}\")",
    "start_line": 75,
    "end_line": 103,
    "has_docstring": true,
    "docstring": "Process Gaia data and calculate distances.",
    "parameters": [
      "gaia_data",
      "max_light_years"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function process_gaia_data",
    "component_id": "data_acquisition_distance.process_gaia_data"
  },
  "data_acquisition_distance.process_hipparcos_data": {
    "id": "data_acquisition_distance.process_hipparcos_data",
    "name": "process_hipparcos_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_acquisition_distance.py",
    "relative_path": "data_acquisition_distance.py",
    "depends_on": [],
    "source_code": "def process_hipparcos_data(hip_data, max_light_years):\n    \"\"\"Process Hipparcos data and calculate distances.\"\"\"\n    if hip_data is None:\n        return None\n        \n    try:\n        # Calculate distances\n        parallax_mas = hip_data['Plx']\n        parallax_arcsec = parallax_mas / 1000.0\n        distance_pc = 1 / parallax_arcsec\n        distance_ly = distance_pc * 3.26156\n        \n        # Add distance columns\n        hip_data['Distance_pc'] = distance_pc\n        hip_data['Distance_ly'] = distance_ly\n        \n        # Filter by distance and validity\n        mask = (np.isfinite(distance_ly) & \n                (distance_ly > 0) & \n                (distance_ly <= max_light_years))\n        \n        hip_data = hip_data[mask]\n        \n        # Verify V magnitudes exist\n        if 'Vmag' not in hip_data.colnames:\n            return None\n            \n        return hip_data\n    except Exception as e:\n        raise RuntimeError(f\"Error processing Hipparcos data: {e}\")",
    "start_line": 105,
    "end_line": 134,
    "has_docstring": true,
    "docstring": "Process Hipparcos data and calculate distances.",
    "parameters": [
      "hip_data",
      "max_light_years"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function process_hipparcos_data",
    "component_id": "data_acquisition_distance.process_hipparcos_data"
  },
  "data_acquisition_distance.align_coordinate_systems": {
    "id": "data_acquisition_distance.align_coordinate_systems",
    "name": "align_coordinate_systems",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_acquisition_distance.py",
    "relative_path": "data_acquisition_distance.py",
    "depends_on": [],
    "source_code": "def align_coordinate_systems(hip_data):\n    \"\"\"Align coordinate systems between catalogs.\"\"\"\n    if hip_data is None:\n        return None\n        \n    try:\n        if 'RA_ICRS' not in hip_data.colnames:\n            if 'RAICRS' in hip_data.colnames:\n                hip_data.rename_column('RAICRS', 'RA_ICRS')\n            elif 'RAhms' in hip_data.colnames:\n                ra_hms = hip_data['RAhms']\n                hip_data['RA_ICRS'] = Angle(ra_hms, unit='hourangle').degree\n        \n        if 'DE_ICRS' not in hip_data.colnames:\n            if 'DEICRS' in hip_data.colnames:\n                hip_data.rename_column('DEICRS', 'DE_ICRS')\n            elif 'DEdms' in hip_data.colnames:\n                dec_dms = hip_data['DEdms']\n                hip_data['DE_ICRS'] = Angle(dec_dms, unit='deg').degree\n                \n        return hip_data\n    except Exception as e:\n        raise RuntimeError(f\"Error aligning coordinate systems: {e}\")",
    "start_line": 136,
    "end_line": 158,
    "has_docstring": true,
    "docstring": "Align coordinate systems between catalogs.",
    "parameters": [
      "hip_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function align_coordinate_systems",
    "component_id": "data_acquisition_distance.align_coordinate_systems"
  },
  "data_acquisition_distance.estimate_vmag_from_gaia": {
    "id": "data_acquisition_distance.estimate_vmag_from_gaia",
    "name": "estimate_vmag_from_gaia",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_acquisition_distance.py",
    "relative_path": "data_acquisition_distance.py",
    "depends_on": [],
    "source_code": "def estimate_vmag_from_gaia(gaia_data):\n    \"\"\"Convert Gaia G magnitudes to Johnson V magnitudes.\"\"\"\n    vmag = np.full(len(gaia_data), np.nan)\n    \n    if all(col in gaia_data.colnames for col in ['Gmag', 'BP-RP']):\n        bp_rp = gaia_data['BP-RP']\n        mask = ~np.isnan(gaia_data['Gmag']) & ~np.isnan(bp_rp)\n        vmag[mask] = (gaia_data['Gmag'][mask] - \n                     (-0.0257 - 0.0924*bp_rp[mask] - \n                      0.1623*bp_rp[mask]**2 + \n                      0.0090*bp_rp[mask]**3))\n    return vmag",
    "start_line": 160,
    "end_line": 171,
    "has_docstring": true,
    "docstring": "Convert Gaia G magnitudes to Johnson V magnitudes.",
    "parameters": [
      "gaia_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function estimate_vmag_from_gaia",
    "component_id": "data_acquisition_distance.estimate_vmag_from_gaia"
  },
  "data_acquisition_distance.fetch_stellar_data": {
    "id": "data_acquisition_distance.fetch_stellar_data",
    "name": "fetch_stellar_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_acquisition_distance.py",
    "relative_path": "data_acquisition_distance.py",
    "depends_on": [
      "data_acquisition_distance.initialize_vizier",
      "data_acquisition_distance.fetch_hipparcos_data",
      "data_acquisition_distance.process_hipparcos_data",
      "data_acquisition_distance.process_gaia_data",
      "catalog_selection.select_stars",
      "data_acquisition_distance.align_coordinate_systems",
      "data_acquisition_distance.fetch_gaia_data",
      "data_acquisition_distance.calculate_parallax_limit"
    ],
    "source_code": "def fetch_stellar_data(max_light_years):\n    \"\"\"\n    Main function to fetch stellar data within specified distance.\n    \n    Args:\n        max_light_years (float): Maximum distance in light-years\n        \n    Returns:\n        astropy.table.Table: Combined stellar data\n    \"\"\"\n    try:\n        # Initialize Vizier\n        vizier = initialize_vizier()\n        \n        # Calculate parallax limit\n        min_parallax_mas = calculate_parallax_limit(max_light_years)\n        \n        # Define data files\n#        hip_data_file = 'hipparcos_data_distance.vot'\n#        gaia_data_file = 'gaia_data_distance.vot'\n        \n        hip_data_file = 'star_data/hipparcos_data_distance.vot'\n        gaia_data_file = 'star_data/gaia_data_distance.vot'\n\n        # Fetch data from both catalogs\n        hip_data = fetch_hipparcos_data(vizier, hip_data_file, min_parallax_mas)\n        gaia_data = fetch_gaia_data(vizier, gaia_data_file, min_parallax_mas)\n        \n        # Process data\n        hip_data = process_hipparcos_data(hip_data, max_light_years)\n        gaia_data = process_gaia_data(gaia_data, max_light_years)\n        hip_data = align_coordinate_systems(hip_data)\n        \n        # Combine data with proper selection logic\n        from catalog_selection import select_stars\n        combined_data, _ = select_stars(hip_data, gaia_data, 'distance', max_light_years)\n        \n        return combined_data\n        \n    except Exception as e:\n        raise RuntimeError(f\"Error fetching stellar data: {e}\")",
    "start_line": 173,
    "end_line": 213,
    "has_docstring": true,
    "docstring": "Main function to fetch stellar data within specified distance.\n\nArgs:\n    max_light_years (float): Maximum distance in light-years\n    \nReturns:\n    astropy.table.Table: Combined stellar data",
    "parameters": [
      "max_light_years"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_stellar_data",
    "component_id": "data_acquisition_distance.fetch_stellar_data"
  },
  "data_processing.convert_icrs_to_radec_strings": {
    "id": "data_processing.convert_icrs_to_radec_strings",
    "name": "convert_icrs_to_radec_strings",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_processing.py",
    "relative_path": "data_processing.py",
    "depends_on": [],
    "source_code": "def convert_icrs_to_radec_strings(data):\n    \"\"\"\n    Convert ICRS coordinates (decimal degrees) to formatted RA/Dec strings.\n    Works with astropy Table objects (not pandas DataFrames).\n    \n    Adds two new columns:\n    - ra_str: Right Ascension in format \"HHh MMm SS.SSs\"\n    - dec_str: Declination in format \"+/-DD deg MM' SS.S\"\"\n    \n    Args:\n        data: Astropy Table with RA_ICRS and DE_ICRS columns\n    \n    Returns:\n        data: Same Table with added ra_str and dec_str columns\n    \"\"\"\n    import numpy as np\n    from astropy.table import Column\n    \n    # Check if ICRS coordinates exist\n    if 'RA_ICRS' not in data.colnames or 'DE_ICRS' not in data.colnames:\n        print(\"Warning: No ICRS coordinates found in data\")\n        return data\n    \n    # Initialize lists for new columns\n    ra_strings = []\n    dec_strings = []\n    \n    # Process each row (astropy Table iteration)\n    valid_coords = 0\n    for row in data:  # Just iterate directly over the table, no .iterrows()\n        ra_deg = row['RA_ICRS']\n        dec_deg = row['DE_ICRS']\n        \n        # Check for valid coordinates (not masked or NaN)\n        if (not np.ma.is_masked(ra_deg) and not np.ma.is_masked(dec_deg) and\n            np.isfinite(ra_deg) and np.isfinite(dec_deg)):\n            \n            # Convert RA from degrees to hours:minutes:seconds\n            ra_hours = ra_deg / 15.0\n            ra_h = int(ra_hours)\n            ra_m = int((ra_hours - ra_h) * 60)\n            ra_s = ((ra_hours - ra_h) * 60 - ra_m) * 60\n            \n            # Convert Dec from degrees to degrees:arcminutes:arcseconds\n            dec_sign = '+' if dec_deg >= 0 else '-'\n            dec_deg_abs = abs(dec_deg)\n            dec_d = int(dec_deg_abs)\n            dec_m = int((dec_deg_abs - dec_d) * 60)\n            dec_s = ((dec_deg_abs - dec_d) * 60 - dec_m) * 60\n            \n            # Format the strings\n            ra_strings.append(f\"{ra_h:02d}h {ra_m:02d}m {ra_s:05.2f}s\")\n            dec_strings.append(f\"{dec_sign}{dec_d:02d} deg {dec_m:02d}' {dec_s:04.1f}\\\"\")\n            valid_coords += 1\n        else:\n            ra_strings.append('')\n            dec_strings.append('')\n    \n    # Add columns to the astropy Table\n    data['ra_str'] = Column(ra_strings, dtype='U20')  # Unicode string, max 20 chars\n    data['dec_str'] = Column(dec_strings, dtype='U20')\n\n# Python objects (strings in this case), which pandas handles much better -- except this fix does not work\n#    data['ra_str'] = Column(ra_strings, dtype=object)\n#    data['dec_str'] = Column(dec_strings, dtype=object)\n    \n    print(f\"Added RA/Dec strings for {valid_coords} objects\")\n    return data",
    "start_line": 11,
    "end_line": 78,
    "has_docstring": true,
    "docstring": "Convert ICRS coordinates (decimal degrees) to formatted RA/Dec strings.\nWorks with astropy Table objects (not pandas DataFrames).\n\nAdds two new columns:\n- ra_str: Right Ascension in format \"HHh MMm SS.SSs\"\n- dec_str: Declination in format \"+/-DD deg MM' SS.S\"\"\n\nArgs:\n    data: Astropy Table with RA_ICRS and DE_ICRS columns\n\nReturns:\n    data: Same Table with added ra_str and dec_str columns",
    "parameters": [
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function convert_icrs_to_radec_strings",
    "component_id": "data_processing.convert_icrs_to_radec_strings"
  },
  "data_processing.estimate_vmag_from_gaia": {
    "id": "data_processing.estimate_vmag_from_gaia",
    "name": "estimate_vmag_from_gaia",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_processing.py",
    "relative_path": "data_processing.py",
    "depends_on": [],
    "source_code": "def estimate_vmag_from_gaia(gaia_data):\n    \"\"\"\n    Estimate V magnitude from Gaia G magnitude and BP-RP color.\n    \"\"\"\n    vmag = np.full(len(gaia_data), np.nan)\n    if all(col in gaia_data.colnames for col in ['Gmag', 'BP-RP']):\n        bp_rp = gaia_data['BP-RP']\n        valid_mask = ~np.isnan(gaia_data['Gmag']) & ~np.isnan(bp_rp)\n        vmag[valid_mask] = (\n            gaia_data['Gmag'][valid_mask]\n            - (-0.0257 - 0.0924 * bp_rp[valid_mask]\n               - 0.1623 * bp_rp[valid_mask] ** 2\n               + 0.0090 * bp_rp[valid_mask] ** 3)\n        )\n    return vmag",
    "start_line": 81,
    "end_line": 95,
    "has_docstring": true,
    "docstring": "Estimate V magnitude from Gaia G magnitude and BP-RP color.",
    "parameters": [
      "gaia_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function estimate_vmag_from_gaia",
    "component_id": "data_processing.estimate_vmag_from_gaia"
  },
  "data_processing.calculate_distances": {
    "id": "data_processing.calculate_distances",
    "name": "calculate_distances",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_processing.py",
    "relative_path": "data_processing.py",
    "depends_on": [],
    "source_code": "def calculate_distances(data):\n    \"\"\"Calculate distances in parsecs and light-years from parallax.\"\"\"\n    if data is not None and 'Plx' in data.colnames:\n        with np.errstate(divide='ignore', invalid='ignore'):\n            parallax_mas = data['Plx']\n            parallax_arcsec = parallax_mas / 1000.0\n            distance_pc = 1 / parallax_arcsec\n            data['Distance_pc'] = distance_pc\n            data['Distance_ly'] = distance_pc * 3.26156\n            \n        # Filter out clearly invalid distances\n        valid_dist = ~np.isnan(data['Distance_ly']) & (data['Distance_ly'] > 0)\n        return data[valid_dist]\n    return data",
    "start_line": 379,
    "end_line": 392,
    "has_docstring": true,
    "docstring": "Calculate distances in parsecs and light-years from parallax.",
    "parameters": [
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_distances",
    "component_id": "data_processing.calculate_distances"
  },
  "data_processing.align_coordinate_systems": {
    "id": "data_processing.align_coordinate_systems",
    "name": "align_coordinate_systems",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_processing.py",
    "relative_path": "data_processing.py",
    "depends_on": [],
    "source_code": "def align_coordinate_systems(hip_data):\n    \"\"\"Ensure RA and Dec columns are consistent and in degrees.\"\"\"\n    if 'RA_ICRS' not in hip_data.colnames:\n        if 'RAICRS' in hip_data.colnames:\n            hip_data.rename_column('RAICRS', 'RA_ICRS')\n        elif 'RAhms' in hip_data.colnames:\n            ra_hms = hip_data['RAhms']\n            ra_deg_hip = Angle(ra_hms, unit='hourangle').degree\n            hip_data['RA_ICRS'] = ra_deg_hip\n    if 'DE_ICRS' not in hip_data.colnames:\n        if 'DEICRS' in hip_data.colnames:\n            hip_data.rename_column('DEICRS', 'DE_ICRS')\n        elif 'DEdms' in hip_data.colnames:\n            dec_dms = hip_data['DEdms']\n            dec_deg_hip = Angle(dec_dms, unit='deg').degree\n            hip_data['DE_ICRS'] = dec_deg_hip\n    return hip_data",
    "start_line": 111,
    "end_line": 127,
    "has_docstring": true,
    "docstring": "Ensure RA and Dec columns are consistent and in degrees.",
    "parameters": [
      "hip_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function align_coordinate_systems",
    "component_id": "data_processing.align_coordinate_systems"
  },
  "data_processing.generate_unique_ids": {
    "id": "data_processing.generate_unique_ids",
    "name": "generate_unique_ids",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_processing.py",
    "relative_path": "data_processing.py",
    "depends_on": [],
    "source_code": "def generate_unique_ids(stars, catalog='Hipparcos'):\n    \"\"\"\n    Generate unique IDs for stars based on their catalog.\n    For Hipparcos: \"HIP {HIP_number}\"\n    For Gaia: \"Gaia DR3 {source_id}\"\n    \"\"\"\n    unique_ids = []\n    if catalog == 'Hipparcos':\n        for star in stars:\n            if 'HIP' in stars.colnames and not np.ma.is_masked(star['HIP']):\n                unique_ids.append(f\"HIP {star['HIP']}\")\n            else:\n                # Fallback if no HIP ID, use a combo of coords?\n                # Ideally you always have HIP IDs for Hipparcos stars.\n                ra, dec = star['RA_ICRS'], star['DE_ICRS']\n                unique_ids.append(f\"HIP-noID-{ra:.6f}-{dec:.6f}\")\n    else:  # Gaia\n        if 'source_id' in stars.colnames:\n            for star in stars:\n                unique_ids.append(f\"Gaia DR3 {star['source_id']}\")\n        else:\n            # Fallback if no Gaia source_id, use coords as last resort\n            for star in stars:\n                ra, dec = star['RA_ICRS'], star['DE_ICRS']\n                unique_ids.append(f\"Gaia-noID-{ra:.6f}-{dec:.6f}\")\n\n    return unique_ids",
    "start_line": 129,
    "end_line": 155,
    "has_docstring": true,
    "docstring": "Generate unique IDs for stars based on their catalog.\nFor Hipparcos: \"HIP {HIP_number}\"\nFor Gaia: \"Gaia DR3 {source_id}\"",
    "parameters": [
      "stars",
      "catalog"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate_unique_ids",
    "component_id": "data_processing.generate_unique_ids"
  },
  "data_processing.select_stars_by_magnitude": {
    "id": "data_processing.select_stars_by_magnitude",
    "name": "select_stars_by_magnitude",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_processing.py",
    "relative_path": "data_processing.py",
    "depends_on": [
      "data_processing.estimate_vmag_from_gaia"
    ],
    "source_code": "def select_stars_by_magnitude(hip_data, gaia_data, mag_limit):\n    \"\"\"\n    Select stars based on a clean separation:\n    For stars brighter than Vmag ~ 3, Hipparcos may still be valuable if Gaia's measurements are flagged as unreliable due to \n    saturation effects. For stars in the range Vmag ~ 4 to 10, Gaia should be the preferred source due to its superior accuracy.\n    For stars fainter than Vmag ~ 10, Gaia is far more accurate and essentially replaces Hipparcos. There are no Gaia stars below Vmag 1.73.\n\n    - Vmag <= 4: Hipparcos exclusively (no overlap with Gaia) \n    - Vmag > 4: Gaia exclusively\n    \n    Parameters:\n        hip_data: astropy Table containing Hipparcos star data\n        gaia_data: astropy Table containing Gaia star data\n        mag_limit: float, maximum apparent magnitude to include\n    \n    Returns:\n        combined_data: astropy Table of selected stars\n        counts: dict summarizing star counts\n    \"\"\"\n    print(\"\\nSelecting stars with clean separation by Vmag...\")\n\n    all_selected_stars = []\n\n    # --- 1. Hipparcos stars (Vmag <= 4) ---\n    if hip_data is not None:\n#        bright_mask = hip_data['Vmag'] <= 4  # No need to compare with mag_limit here\n        bright_mask = (hip_data['Vmag'] <= 4) & (hip_data['Vmag'] <= mag_limit)\n        bright_stars = hip_data[bright_mask]\n        if len(bright_stars) > 0:\n            bright_stars['Source_Catalog'] = 'Hipparcos'\n            bright_stars['Apparent_Magnitude'] = bright_stars['Vmag']\n            all_selected_stars.append(bright_stars)\n            print(f\"Selected {len(bright_stars)} bright Hipparcos stars (Vmag <= 4)\")\n\n    # --- 2. Gaia stars (Vmag > 4) ---\n    if gaia_data is not None:\n        if 'Estimated_Vmag' not in gaia_data.colnames:\n            gaia_data['Estimated_Vmag'] = estimate_vmag_from_gaia(gaia_data)\n\n        faint_mask = (gaia_data['Estimated_Vmag'] > 4) & (gaia_data['Estimated_Vmag'] <= mag_limit)\n        faint_stars = gaia_data[faint_mask]\n        if len(faint_stars) > 0:\n            faint_stars['Source_Catalog'] = 'Gaia'\n            faint_stars['Apparent_Magnitude'] = faint_stars['Estimated_Vmag']\n            all_selected_stars.append(faint_stars)\n            print(f\"Selected {len(faint_stars)} faint Gaia stars (4 < Vmag <= {mag_limit})\")\n\n    # Combine all selected stars\n    if not all_selected_stars:\n        print(f\"No stars found within magnitude limit {mag_limit}\")\n        return None, {}\n\n    combined_data = vstack(all_selected_stars)\n\n    # Calculate final counts\n    hip_count = np.sum(combined_data['Source_Catalog'] == 'Hipparcos')\n    gaia_count = np.sum(combined_data['Source_Catalog'] == 'Gaia')\n\n    print(\"\\nFinal Selection Summary:\")\n    print(f\"Hipparcos stars (Vmag <= 4): {hip_count}\")\n    print(f\"Gaia stars (Vmag > 4): {gaia_count}\")\n    print(f\"Total stars: {len(combined_data)}\")\n\n    counts = {\n        'hip_count': hip_count,\n        'gaia_count': gaia_count\n    }\n\n    return combined_data, counts",
    "start_line": 157,
    "end_line": 225,
    "has_docstring": true,
    "docstring": "Select stars based on a clean separation:\nFor stars brighter than Vmag ~ 3, Hipparcos may still be valuable if Gaia's measurements are flagged as unreliable due to \nsaturation effects. For stars in the range Vmag ~ 4 to 10, Gaia should be the preferred source due to its superior accuracy.\nFor stars fainter than Vmag ~ 10, Gaia is far more accurate and essentially replaces Hipparcos. There are no Gaia stars below Vmag 1.73.\n\n- Vmag <= 4: Hipparcos exclusively (no overlap with Gaia) \n- Vmag > 4: Gaia exclusively\n\nParameters:\n    hip_data: astropy Table containing Hipparcos star data\n    gaia_data: astropy Table containing Gaia star data\n    mag_limit: float, maximum apparent magnitude to include\n\nReturns:\n    combined_data: astropy Table of selected stars\n    counts: dict summarizing star counts",
    "parameters": [
      "hip_data",
      "gaia_data",
      "mag_limit"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function select_stars_by_magnitude",
    "component_id": "data_processing.select_stars_by_magnitude"
  },
  "data_processing.analyze_additional_stars": {
    "id": "data_processing.analyze_additional_stars",
    "name": "analyze_additional_stars",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_processing.py",
    "relative_path": "data_processing.py",
    "depends_on": [],
    "source_code": "def analyze_additional_stars(new_data, old_data):\n    \"\"\"Analyze properties of stars present in new data but not in old\"\"\"\n    # Compare magnitude distributions\n    print(\"\\nMagnitude Distribution Analysis of Additional Stars:\")\n    mag_bins = np.arange(4.0, 9.0, 0.5)\n    new_mags = new_data['Estimated_Vmag']\n    hist, bins = np.histogram(new_mags, bins=mag_bins)\n    \n    for i in range(len(hist)):\n        print(f\"V mag {bins[i]:.1f}-{bins[i+1]:.1f}: {hist[i]} stars\")\n        \n    # Analyze parallax quality\n    parallax_rel_error = new_data['e_Plx'] / new_data['Plx']\n    print(f\"\\nParallax Quality:\")\n    print(f\"Median relative error: {np.median(parallax_rel_error):.3f}\")\n    print(f\"95th percentile error: {np.percentile(parallax_rel_error, 95):.3f}\")\n    \n    # Check G-V conversion reasonableness\n    g_v_diff = new_data['Gmag'] - new_data['Estimated_Vmag']\n    print(f\"\\nG-V Magnitude Difference:\")\n    print(f\"Mean difference: {np.mean(g_v_diff):.3f}\")\n    print(f\"Standard deviation: {np.std(g_v_diff):.3f}\")\n\n    # Position on HR diagram\n    print(\"\\nHR Diagram Statistics:\")\n    print(f\"Temperature range: {np.min(new_data['Temperature']):.0f}K - {np.max(new_data['Temperature']):.0f}K\")\n    print(f\"Luminosity range: {np.min(new_data['Luminosity']):.3f} - {np.max(new_data['Luminosity']):.3f} Lsun\")",
    "start_line": 227,
    "end_line": 253,
    "has_docstring": true,
    "docstring": "Analyze properties of stars present in new data but not in old",
    "parameters": [
      "new_data",
      "old_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function analyze_additional_stars",
    "component_id": "data_processing.analyze_additional_stars"
  },
  "data_processing.examine_outliers": {
    "id": "data_processing.examine_outliers",
    "name": "examine_outliers",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_processing.py",
    "relative_path": "data_processing.py",
    "depends_on": [
      "data_processing.print_star_details"
    ],
    "source_code": "def examine_outliers(data):\n    \"\"\"Print details of potential outlier stars\"\"\"\n    # Look at stars with extreme values\n    high_lum = data[data['Luminosity'] > 100]\n    low_lum = data[data['Luminosity'] < 0.001]\n    extreme_temp = data[(data['Temperature'] > 30000) | (data['Temperature'] < 2000)]\n    \n    print(\"\\nHigh Luminosity Stars:\")\n    for _, star in high_lum.iterrows():\n        print_star_details(star)\n        \n    print(\"\\nLow Luminosity Stars:\")\n    for _, star in low_lum.iterrows():\n        print_star_details(star)\n        \n    print(\"\\nExtreme Temperature Stars:\")\n    for _, star in extreme_temp.iterrows():\n        print_star_details(star)",
    "start_line": 255,
    "end_line": 272,
    "has_docstring": true,
    "docstring": "Print details of potential outlier stars",
    "parameters": [
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function examine_outliers",
    "component_id": "data_processing.examine_outliers"
  },
  "data_processing.print_star_details": {
    "id": "data_processing.print_star_details",
    "name": "print_star_details",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_processing.py",
    "relative_path": "data_processing.py",
    "depends_on": [],
    "source_code": "def print_star_details(star):\n    \"\"\"Print relevant details for a single star\"\"\"\n    print(f\"\\nStar: {star['Star_Name']}\")\n    print(f\"Gmag: {star['Gmag']:.2f}\")\n    print(f\"Estimated Vmag: {star['Estimated_Vmag']:.2f}\")\n    print(f\"Parallax: {star['Plx']:.3f} +/- {star['e_Plx']:.3f} mas\")\n    print(f\"Temperature: {star['Temperature']:.0f}K\")\n    print(f\"Luminosity: {star['Luminosity']:.3f} Lsun\")",
    "start_line": 274,
    "end_line": 281,
    "has_docstring": true,
    "docstring": "Print relevant details for a single star",
    "parameters": [
      "star"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function print_star_details",
    "component_id": "data_processing.print_star_details"
  },
  "data_processing.select_stars_by_distance": {
    "id": "data_processing.select_stars_by_distance",
    "name": "select_stars_by_distance",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_processing.py",
    "relative_path": "data_processing.py",
    "depends_on": [],
    "source_code": "def select_stars_by_distance(hip_data, gaia_data, max_light_years):\n    \"\"\"\n    Select stars based on distance criteria while maintaining clean catalog separation:\n    - Hipparcos: primary source for bright stars (Vmag <= 4.0)\n    - Gaia: primary source for faint stars (Vmag > 4.0)\n    Both constrained by the specified distance.\n    \n    Parameters:\n        hip_data: astropy Table containing Hipparcos star data\n        gaia_data: astropy Table containing Gaia star data\n        max_light_years: float, maximum distance to include\n    \n    Returns:\n        combined_data: astropy Table of selected stars\n        counts: dict summarizing star counts\n    \"\"\"\n    print(\"\\nSelecting stars by distance...\")\n    \n    all_selected_stars = []\n    hip_bright_count = 0  # Vmag <= 1.73\n    hip_mid_count = 0     # 1.73 < Vmag <= 4.0\n    gaia_mid_count = 0    # 1.73 < Vmag <= 4.0\n    gaia_faint_count = 0  # Vmag > 4.0\n    \n    # Process Hipparcos stars (for bright and mid-range stars)\n    if hip_data is not None:\n        # First filter by distance\n        distance_mask = hip_data['Distance_ly'] <= max_light_years\n        mag_mask = hip_data['Vmag'] <= 4.0  # Hipparcos for Vmag <= 4.0 only\n        hip_stars = hip_data[distance_mask & mag_mask]\n        \n        if len(hip_stars) > 0:\n            # Add source catalog and apparent magnitude\n            hip_stars['Source_Catalog'] = 'Hipparcos'\n            hip_stars['Apparent_Magnitude'] = hip_stars['Vmag']\n            \n            # Count by magnitude ranges\n            bright_mask = hip_stars['Vmag'] <= 1.73\n            mid_mask = (hip_stars['Vmag'] > 1.73) & (hip_stars['Vmag'] <= 4.0)\n            \n            hip_bright_count = np.sum(bright_mask)\n            hip_mid_count = np.sum(mid_mask)\n            \n            all_selected_stars.append(hip_stars)\n            print(f\"Selected {len(hip_stars)} Hipparcos stars within {max_light_years} light-years\")\n    \n    # Process Gaia stars (for faint stars)\n    if gaia_data is not None:\n        # First filter by distance\n        distance_mask = gaia_data['Distance_ly'] <= max_light_years\n        mag_mask = gaia_data['Estimated_Vmag'] > 4.0  # Gaia for Vmag > 4.0 only\n        gaia_stars = gaia_data[distance_mask & mag_mask]\n        \n        if len(gaia_stars) > 0:\n            # Add source catalog and apparent magnitude\n            gaia_stars['Source_Catalog'] = 'Gaia'\n            gaia_stars['Apparent_Magnitude'] = gaia_stars['Estimated_Vmag']\n            \n            # Count by magnitude ranges\n            mid_mask = (gaia_stars['Apparent_Magnitude'] > 1.73) & (gaia_stars['Apparent_Magnitude'] <= 4.0)\n            faint_mask = gaia_stars['Apparent_Magnitude'] > 4.0\n            \n            gaia_mid_count = np.sum(mid_mask)\n            gaia_faint_count = np.sum(faint_mask)\n            \n            all_selected_stars.append(gaia_stars)\n            print(f\"Selected {len(gaia_stars)} Gaia stars within {max_light_years} light-years\")\n    \n    if not all_selected_stars:\n        print(f\"No stars found within {max_light_years} light-years\")\n        return None, {}\n    \n    # Combine selected stars\n    from astropy.table import vstack\n    combined_data = vstack(all_selected_stars)\n    \n    # Prepare counts dictionary\n    counts = {\n        'hip_bright_count': hip_bright_count,\n        'hip_mid_count': hip_mid_count,\n        'gaia_mid_count': gaia_mid_count,\n        'gaia_faint_count': gaia_faint_count,\n        'total_stars': len(combined_data)\n    }\n    \n    print(\"\\nFinal Selection Summary:\")\n    print(f\"Hipparcos bright stars (Vmag <= 1.73): {hip_bright_count}\")\n    print(f\"Hipparcos mid-range stars (1.73 < Vmag <= 4.0): {hip_mid_count}\")\n    print(f\"Gaia mid-range stars (1.73 < Vmag <= 4.0): {gaia_mid_count}\")\n    print(f\"Gaia faint stars (Vmag > 4.0): {gaia_faint_count}\")\n    print(f\"Total stars: {len(combined_data)}\")\n    \n    return combined_data, counts",
    "start_line": 285,
    "end_line": 377,
    "has_docstring": true,
    "docstring": "Select stars based on distance criteria while maintaining clean catalog separation:\n- Hipparcos: primary source for bright stars (Vmag <= 4.0)\n- Gaia: primary source for faint stars (Vmag > 4.0)\nBoth constrained by the specified distance.\n\nParameters:\n    hip_data: astropy Table containing Hipparcos star data\n    gaia_data: astropy Table containing Gaia star data\n    max_light_years: float, maximum distance to include\n\nReturns:\n    combined_data: astropy Table of selected stars\n    counts: dict summarizing star counts",
    "parameters": [
      "hip_data",
      "gaia_data",
      "max_light_years"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function select_stars_by_distance",
    "component_id": "data_processing.select_stars_by_distance"
  },
  "data_processing.calculate_cartesian_coordinates": {
    "id": "data_processing.calculate_cartesian_coordinates",
    "name": "calculate_cartesian_coordinates",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_processing.py",
    "relative_path": "data_processing.py",
    "depends_on": [
      "data_processing.convert_icrs_to_radec_strings"
    ],
    "source_code": "def calculate_cartesian_coordinates(data):\n    \"\"\"Calculate x, y, z coordinates from RA, Dec, and distance.\"\"\"\n    if data is None:\n        return None\n\n    print(\"\\nCalculating cartesian coordinates...\")\n    \n    # Create mask for Messier objects (which may have different coordinate handling)\n    is_messier = data['Is_Messier'] if 'Is_Messier' in data.colnames else np.zeros(len(data), dtype=bool)\n    \n    # Process regular stellar objects\n    stellar_mask = ~is_messier\n    if np.any(stellar_mask):\n        ra_deg = data['RA_ICRS'][stellar_mask]\n        dec_deg = data['DE_ICRS'][stellar_mask]\n        distance = data['Distance_ly'][stellar_mask]\n        \n        ra_rad = np.radians(ra_deg)\n        dec_rad = np.radians(dec_deg)\n        \n        # Initialize coordinate arrays\n        x = np.zeros(len(data))\n        y = np.zeros(len(data))\n        z = np.zeros(len(data))\n        \n        # Calculate coordinates for stellar objects\n        x[stellar_mask] = distance * np.cos(dec_rad) * np.cos(ra_rad)\n        y[stellar_mask] = distance * np.cos(dec_rad) * np.sin(ra_rad)\n        z[stellar_mask] = distance * np.sin(dec_rad)\n        \n        print(f\"Processed coordinates for {np.sum(stellar_mask)} stellar objects\")\n    \n    # Process Messier objects\n    messier_mask = is_messier\n    if np.any(messier_mask):\n        print(f\"Processing {np.sum(messier_mask)} Messier objects...\")\n        \n        # Extract coordinates for Messier objects\n        from astropy.coordinates import SkyCoord\n        import astropy.units as u\n        \n        for i, row in enumerate(data[messier_mask]):\n            try:\n                coords = SkyCoord(\n                    ra=row['RA_ICRS'],\n                    dec=row['DE_ICRS'],\n                    unit=(u.deg, u.deg),\n                    distance=row['Distance_ly'] * u.lyr\n                )\n                \n                # Convert to cartesian coordinates\n                cartesian = coords.cartesian\n                x[i] = cartesian.x.value\n                y[i] = cartesian.y.value\n                z[i] = cartesian.z.value\n                \n            except Exception as e:\n                print(f\"Error calculating coordinates for {row['Star_Name']}: {e}\")\n                x[i] = np.nan\n                y[i] = np.nan\n                z[i] = np.nan\n    \n    # Add calculated coordinates to the data\n    data['x'] = x\n    data['y'] = y\n    data['z'] = z\n    \n    data = convert_icrs_to_radec_strings(data)\n\n    return data",
    "start_line": 394,
    "end_line": 463,
    "has_docstring": true,
    "docstring": "Calculate x, y, z coordinates from RA, Dec, and distance.",
    "parameters": [
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_cartesian_coordinates",
    "component_id": "data_processing.calculate_cartesian_coordinates"
  },
  "data_processing.validate_coordinates": {
    "id": "data_processing.validate_coordinates",
    "name": "validate_coordinates",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_processing.py",
    "relative_path": "data_processing.py",
    "depends_on": [],
    "source_code": "def validate_coordinates(data):\n    \"\"\"Validate calculated coordinates and report any issues.\"\"\"\n    if data is None:\n        return False\n        \n    invalid_mask = (\n        np.isnan(data['x']) | \n        np.isnan(data['y']) | \n        np.isnan(data['z'])\n    )\n    \n    if np.any(invalid_mask):\n        print(\"\\nWarning: Found objects with invalid coordinates:\")\n        for row in data[invalid_mask]:\n            print(f\"  {row['Star_Name']}: ({row['x']}, {row['y']}, {row['z']})\")\n            if row['Is_Messier']:\n                print(f\"    Distance: {row['Distance_ly']} ly\")\n                print(f\"    RA, Dec: {row['RA_ICRS']}, {row['DE_ICRS']}\")\n        return False\n    \n    return True",
    "start_line": 465,
    "end_line": 485,
    "has_docstring": true,
    "docstring": "Validate calculated coordinates and report any issues.",
    "parameters": [
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function validate_coordinates",
    "component_id": "data_processing.validate_coordinates"
  },
  "data_processing.filter_by_mag_limit": {
    "id": "data_processing.filter_by_mag_limit",
    "name": "filter_by_mag_limit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_processing.py",
    "relative_path": "data_processing.py",
    "depends_on": [],
    "source_code": "def filter_by_mag_limit(combined_data, mag_limit):\n    \"\"\"Filter the combined data to include only stars within the specified mag_limit.\"\"\"\n    mask = combined_data['Apparent_Magnitude'] <= mag_limit\n    filtered_data = combined_data[mask]\n    return filtered_data",
    "start_line": 487,
    "end_line": 491,
    "has_docstring": true,
    "docstring": "Filter the combined data to include only stars within the specified mag_limit.",
    "parameters": [
      "combined_data",
      "mag_limit"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function filter_by_mag_limit",
    "component_id": "data_processing.filter_by_mag_limit"
  },
  "data_processing.update_counts": {
    "id": "data_processing.update_counts",
    "name": "update_counts",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\data_processing.py",
    "relative_path": "data_processing.py",
    "depends_on": [],
    "source_code": "def update_counts(filtered_data, mag_limit):\n    \"\"\"Update counts of stars in each category based on the filtered data.\"\"\"\n    hip_bright_count = len(filtered_data[(filtered_data['Source_Catalog'] == 'Hipparcos') &\n                                         (filtered_data['Apparent_Magnitude'] <= min(1.73, mag_limit))])\n    hip_mid_count = len(filtered_data[(filtered_data['Source_Catalog'] == 'Hipparcos') &\n                                      (filtered_data['Apparent_Magnitude'] > 1.73) &\n                                      (filtered_data['Apparent_Magnitude'] <= min(4.0, mag_limit))])\n    gaia_mid_count = len(filtered_data[(filtered_data['Source_Catalog'] == 'Gaia') &\n                                       (filtered_data['Apparent_Magnitude'] > 1.73) &\n                                       (filtered_data['Apparent_Magnitude'] <= min(4.0, mag_limit))])\n    gaia_faint_count = len(filtered_data[(filtered_data['Source_Catalog'] == 'Gaia') &\n                                         (filtered_data['Apparent_Magnitude'] > 4.0) &\n                                         (filtered_data['Apparent_Magnitude'] <= mag_limit)])\n\n    counts = {\n        'hip_bright_count': hip_bright_count,\n        'hip_mid_count': hip_mid_count,\n        'gaia_mid_count': gaia_mid_count,\n        'gaia_faint_count': gaia_faint_count,\n    }\n\n    return counts",
    "start_line": 493,
    "end_line": 514,
    "has_docstring": true,
    "docstring": "Update counts of stars in each category based on the filtered data.",
    "parameters": [
      "filtered_data",
      "mag_limit"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function update_counts",
    "component_id": "data_processing.update_counts"
  },
  "diagnose_bcodmo.examine_bcodmo_data": {
    "id": "diagnose_bcodmo.examine_bcodmo_data",
    "name": "examine_bcodmo_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\diagnose_bcodmo.py",
    "relative_path": "diagnose_bcodmo.py",
    "depends_on": [],
    "source_code": "def examine_bcodmo_data():\n    \"\"\"Download and examine the structure of BCO-DMO pH data\"\"\"\n    \n    api_url = \"https://www.bco-dmo.org/dataset/3773.csv\"\n    \n    try:\n        print(\"Downloading BCO-DMO data...\")\n        response = requests.get(api_url, timeout=30)\n        response.raise_for_status()\n        \n        lines = response.text.split('\\n')\n        print(f\"\\n Downloaded {len(lines)} lines\\n\")\n        \n        # Show first 20 lines to understand structure\n        print(\"=\" * 80)\n        print(\"FIRST 20 LINES:\")\n        print(\"=\" * 80)\n        for i, line in enumerate(lines[:20]):\n            print(f\"{i:3d}: {line}\")\n        \n        # Find the header line\n        print(\"\\n\" + \"=\" * 80)\n        print(\"LOOKING FOR HEADER:\")\n        print(\"=\" * 80)\n        \n        for i, line in enumerate(lines[:50]):\n            if 'ph' in line.lower() or 'date' in line.lower() or 'year' in line.lower():\n                print(f\"Line {i}: {line}\")\n        \n        # Check for common delimiters\n        print(\"\\n\" + \"=\" * 80)\n        print(\"DELIMITER ANALYSIS:\")\n        print(\"=\" * 80)\n        \n        sample_line = None\n        for line in lines:\n            if line.strip() and not line.startswith('#') and not line.startswith('!'):\n                sample_line = line\n                break\n        \n        if sample_line:\n            print(f\"Sample data line: {sample_line[:100]}...\")\n            print(f\"Commas: {sample_line.count(',')}\")\n            print(f\"Tabs: {sample_line.count(chr(9))}\")\n            print(f\"Pipes: {sample_line.count('|')}\")\n            print(f\"Semicolons: {sample_line.count(';')}\")\n        \n        # Try to find actual data lines with pH values\n        print(\"\\n\" + \"=\" * 80)\n        print(\"SEARCHING FOR pH VALUES (7.0-9.0):\")\n        print(\"=\" * 80)\n        \n        count = 0\n        for i, line in enumerate(lines):\n            if count >= 5:\n                break\n            parts = line.replace('\\t', ',').split(',')\n            for part in parts:\n                try:\n                    val = float(part.strip())\n                    if 7.0 < val < 9.0:\n                        print(f\"Line {i}: {line[:150]}\")\n                        count += 1\n                        break\n                except ValueError:\n                    continue\n        \n        return lines\n        \n    except Exception as e:\n        print(f\"Error: {e}\")\n        return None",
    "start_line": 6,
    "end_line": 77,
    "has_docstring": true,
    "docstring": "Download and examine the structure of BCO-DMO pH data",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function examine_bcodmo_data",
    "component_id": "diagnose_bcodmo.examine_bcodmo_data"
  },
  "earth_system_controller.MissionControlApp": {
    "id": "earth_system_controller.MissionControlApp",
    "name": "MissionControlApp",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_controller.py",
    "relative_path": "earth_system_controller.py",
    "depends_on": [],
    "source_code": "class MissionControlApp:\n    def __init__(self, root):\n        self.root = root\n        self.root.title(\"Paloma's Orrery: Earth System Controller\")\n        self.root.geometry(\"500x350\")\n        \n        self.layer_files = []\n        \n        # Define default data path\n        self.data_dir = os.path.join(os.getcwd(), 'data')\n\n        # Header\n        header = tk.Label(root, text=\"Earth System Visualization\", font=(\"Helvetica\", 16, \"bold\"))\n        header.pack(pady=15)\n\n        # Requirement note\n        req_label = tk.Label(root, text=\"Requires: Google Earth Pro (free download)\", \n                             font=(\"Helvetica\", 9, \"italic\"), fg=\"gray\")\n        req_label.pack()\n\n        # Listbox\n        self.listbox = tk.Listbox(root, selectmode=tk.MULTIPLE, width=60, height=8)\n        self.listbox.pack(pady=5)\n\n        # Buttons\n        btn_frame = tk.Frame(root)\n        btn_frame.pack(pady=10)\n\n        self.btn_add = tk.Button(btn_frame, text=\"Add KML Layers\", command=self.add_files, bg=\"#dddddd\")\n        self.btn_add.pack(side=tk.LEFT, padx=10)\n\n        self.btn_clear = tk.Button(btn_frame, text=\"Clear List\", command=self.clear_list, bg=\"#dddddd\")\n        self.btn_clear.pack(side=tk.LEFT, padx=10)\n\n        self.btn_launch = tk.Button(root, text=\"LAUNCH SELECTED LAYERS\", \n                                    command=self.launch_layers, \n                                    bg=\"#ffcccc\", fg=\"darkred\", font=(\"Helvetica\", 12, \"bold\"))\n        self.btn_launch.pack(pady=15, fill=tk.X, padx=50)\n\n        self.status = tk.Label(root, text=\"Ready.\", bd=1, relief=tk.SUNKEN, anchor=tk.W)\n        self.status.pack(side=tk.BOTTOM, fill=tk.X)\n\n    def add_files(self):\n        filenames = filedialog.askopenfilenames(\n            title=\"Select KML Layers\",\n            initialdir=self.data_dir, \n            filetypes=[(\"Google Earth Files\", \"*.kml *.kmz\")]\n        )\n        for f in filenames:\n            if f not in self.layer_files:\n                self.layer_files.append(f)\n                self.listbox.insert(tk.END, os.path.basename(f))\n        \n        self.status.config(text=f\"{len(self.layer_files)} layers ready.\")\n\n    def clear_list(self):\n        self.layer_files = []\n        self.listbox.delete(0, tk.END)\n        self.status.config(text=\"List cleared.\")\n\n    def launch_layers(self):\n        selected_indices = self.listbox.curselection()\n        if not selected_indices:\n            files_to_launch = self.layer_files\n        else:\n            files_to_launch = [self.layer_files[i] for i in selected_indices]\n\n        if not files_to_launch:\n            messagebox.showwarning(\"No Layers\", \"Please add KML files first.\")\n            return\n\n        self.status.config(text=f\"Launching {len(files_to_launch)} layers...\")\n        for filepath in files_to_launch:\n            self.open_file(filepath)\n\n    def open_file(self, filepath):\n        if platform.system() == 'Darwin':       \n            subprocess.call(('open', filepath))\n        elif platform.system() == 'Windows':    \n            os.startfile(filepath)\n        else:                                   \n            subprocess.call(('xdg-open', filepath))",
    "start_line": 7,
    "end_line": 88,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class MissionControlApp",
    "component_id": "earth_system_controller.MissionControlApp"
  },
  "earth_system_generator.MissionSelector": {
    "id": "earth_system_generator.MissionSelector",
    "name": "MissionSelector",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_generator.py",
    "relative_path": "earth_system_generator.py",
    "depends_on": [],
    "source_code": "class MissionSelector:\n    def __init__(self):\n        self.selected_mission = None\n        self.root = tk.Tk()\n        self.root.title(\"Scenario Generator v5.2\")\n        self.root.geometry(\"450x500\")\n        \n        style = ttk.Style()\n        style.configure(\"TButton\", font=(\"Helvetica\", 11), padding=10)\n        \n        lbl = tk.Label(self.root, text=\"Select Simulation Scenario\", font=(\"Helvetica\", 14, \"bold\"))\n        lbl.pack(pady=15)\n\n        self.listbox = tk.Listbox(self.root, height=12, font=(\"Helvetica\", 11))\n        self.listbox.pack(padx=20, pady=5, fill=tk.X)\n        \n        self.scenario_keys = list(SCENARIOS.keys())\n        for name in self.scenario_keys:\n            self.listbox.insert(tk.END, name)\n            \n        self.desc_label = tk.Label(self.root, text=\"Select a scenario to view details.\", \n                                   fg=\"gray\", wraplength=400)\n        self.desc_label.pack(pady=10)\n        \n        self.listbox.bind('<<ListboxSelect>>', self.update_desc)\n\n        btn = tk.Button(self.root, text=\"GENERATE GOOGLE EARTH KML LAYER\", \n                        bg=\"#d1e7dd\", fg=\"#0f5132\", font=(\"Helvetica\", 11, \"bold\"),\n                        command=self.confirm_selection)\n        btn.pack(pady=20, fill=tk.X, padx=50)\n\n    def update_desc(self, event):\n        selection = self.listbox.curselection()\n        if selection:\n            name = self.scenario_keys[selection[0]]\n            desc = SCENARIOS[name][\"description\"]\n            date = SCENARIOS[name][\"date\"]\n            self.desc_label.config(text=f\"{desc}\\nTarget Date: {date}\", fg=\"black\")\n\n    def confirm_selection(self):\n        selection = self.listbox.curselection()\n        if not selection:\n            messagebox.showwarning(\"No Selection\", \"Please select a scenario.\")\n            return\n        \n        name = self.scenario_keys[selection[0]]\n        self.selected_mission = SCENARIOS[name]\n        self.root.destroy() \n\n    def run(self):\n        self.root.mainloop()\n        return self.selected_mission",
    "start_line": 697,
    "end_line": 748,
    "has_docstring": false,
    "docstring": "",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class MissionSelector",
    "component_id": "earth_system_generator.MissionSelector"
  },
  "earth_system_generator.calculate_wet_bulb": {
    "id": "earth_system_generator.calculate_wet_bulb",
    "name": "calculate_wet_bulb",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_generator.py",
    "relative_path": "earth_system_generator.py",
    "depends_on": [],
    "source_code": "def calculate_wet_bulb(T, RH):\n    tw = (T * np.arctan(0.151977 * (RH + 8.313659)**0.5) +\n          np.arctan(T + RH) - np.arctan(RH - 1.676331) +\n          0.00391838 * (RH)**1.5 * np.arctan(0.023101 * RH) -\n          4.686035)\n    return tw",
    "start_line": 754,
    "end_line": 759,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "T",
      "RH"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_wet_bulb",
    "component_id": "earth_system_generator.calculate_wet_bulb"
  },
  "earth_system_generator.get_cache_path": {
    "id": "earth_system_generator.get_cache_path",
    "name": "get_cache_path",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_generator.py",
    "relative_path": "earth_system_generator.py",
    "depends_on": [],
    "source_code": "def get_cache_path(date_str):\n    return os.path.join(DATA_DIR, f\"weather_cache_{date_str}.json\")",
    "start_line": 761,
    "end_line": 762,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "date_str"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_cache_path",
    "component_id": "earth_system_generator.get_cache_path"
  },
  "earth_system_generator.load_cache": {
    "id": "earth_system_generator.load_cache",
    "name": "load_cache",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_generator.py",
    "relative_path": "earth_system_generator.py",
    "depends_on": [],
    "source_code": "def load_cache(path):\n    if os.path.exists(path):\n        print(f\"Loading database: {path}\")\n        with open(path, 'r') as f:\n            return json.load(f)\n    return {}",
    "start_line": 764,
    "end_line": 769,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "path"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_cache",
    "component_id": "earth_system_generator.load_cache"
  },
  "earth_system_generator.save_cache": {
    "id": "earth_system_generator.save_cache",
    "name": "save_cache",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_generator.py",
    "relative_path": "earth_system_generator.py",
    "depends_on": [],
    "source_code": "def save_cache(path, data):\n    with open(path, 'w') as f:\n        json.dump(data, f)",
    "start_line": 771,
    "end_line": 773,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "path",
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function save_cache",
    "component_id": "earth_system_generator.save_cache"
  },
  "earth_system_generator.generate_popup_html": {
    "id": "earth_system_generator.generate_popup_html",
    "name": "generate_popup_html",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_generator.py",
    "relative_path": "earth_system_generator.py",
    "depends_on": [],
    "source_code": "def generate_popup_html(val, lat, lon):\n    if val >= 31: \n        risk_color, risk_text = \"#000000\", \"LETHAL (Vecellio et al.)\"\n        desc = \"<b>UNCOMPENSABLE HEAT STRESS:</b><br>Core body temperature will rise continuously. Physiological cooling failed. Fatal without aggressive intervention.\"\n    elif val >= 28: \n        risk_color, risk_text = \"#800080\", \"EXTREME (Raymond et al.)\"\n        desc = \"<b>CRITICAL RISK:</b><br>Heat stroke imminent for outdoor laborers. Society-wide cooling infrastructure required.\"\n    elif val >= 26:\n        risk_color, risk_text = \"#FF0000\", \"HIGH RISK (Carter/Foster)\"\n        desc = \"<b>SEVERE STRESS:</b><br>Continuous physical activity dangerous (Foster). Vulnerable hearts fail (Carter).\"\n    else:\n        risk_color, risk_text = \"#FFA500\", \"CAUTION\"\n        desc = \"<b>ELEVATED STRESS:</b><br>Prolonged exposure may cause fatigue.\"\n\n    percent = min(100, max(0, (val - 22) / (31 - 22) * 100))\n    \n    html = f\"\"\"\n    <div style=\"font-family: Arial, sans-serif; width: 300px; padding: 10px;\">\n        <h2 style=\"margin: 0; color: {risk_color};\">{val:.1f}C</h2>\n        <h4 style=\"margin: 0; color: #555;\">WET BULB TEMPERATURE</h4>\n        <hr>\n        <p style=\"font-weight: bold; color: {risk_color};\">{risk_text}</p>\n        <p style=\"font-size: 13px;\">{desc}</p>\n        <div style=\"background-color: #ddd; height: 15px; width: 100%; border-radius: 5px; margin-top: 10px;\">\n            <div style=\"background-color: {risk_color}; height: 100%; width: {percent}%; border-radius: 5px;\"></div>\n        </div>\n        <p style=\"font-size: 10px; color: #666; text-align: right;\">Bio-Limit: 31C (Vecellio et al.)</p>\n    </div>\n    \"\"\"\n    return html",
    "start_line": 775,
    "end_line": 804,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "val",
      "lat",
      "lon"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate_popup_html",
    "component_id": "earth_system_generator.generate_popup_html"
  },
  "earth_system_generator.create_legend_card": {
    "id": "earth_system_generator.create_legend_card",
    "name": "create_legend_card",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_generator.py",
    "relative_path": "earth_system_generator.py",
    "depends_on": [],
    "source_code": "def create_legend_card():\n    filename = \"legend_risk_index_cited.png\"\n    filepath = os.path.join(DATA_DIR, filename)\n    fig = plt.figure(figsize=(3.2, 3.5), dpi=120)\n    \n    # ADJUSTED TRANSPARENCY: 0.7\n    fig.patch.set_facecolor('white')\n    fig.patch.set_alpha(0.7)\n    \n    ax = fig.add_subplot(111)\n    ax.axis('off')\n    \n    legend_elements = [\n        mpatches.Patch(color='#000000', label='> 31C: Lethal (Vecellio)'),\n        mpatches.Patch(color='#800080', label='28-31C: Extreme (Raymond)'),\n        mpatches.Patch(color='#FF0000', label='26-28C: High Risk (Carter)'),\n        mpatches.Patch(color='#FFA500', label='24-26C: Caution (Foster)'),\n        mpatches.Patch(color='#008000', label='< 24C: Safe'),\n    ]\n    ax.legend(handles=legend_elements, loc='upper center', bbox_to_anchor=(0.5, 0.93), frameon=False, fontsize=9)\n    plt.text(0.5, 0.97, \"Wet Bulb Bio-Limits\", ha='center', va='center', transform=ax.transAxes, fontweight='bold', fontsize=11)\n    \n    citations = (\n        \"EVIDENCE BASE:\\n\"\n        \"1. Vecellio et al. (2022): 31C uncompensable limit.\\n\"\n        \"2. Raymond et al. (2020): 28C+ societal breakdown.\\n\"\n        \"3. Carter et al. (2023): Heart strain onset.\\n\"\n        \"4. Foster et al. (2021): Labor capacity loss.\"\n    )\n    plt.text(0.5, 0.05, citations, ha='center', va='bottom', transform=ax.transAxes, fontsize=7, color='#333', style='italic')\n    \n    plt.savefig(filepath, bbox_inches='tight', pad_inches=0.1, transparent=False)\n    plt.close()\n    return filename",
    "start_line": 806,
    "end_line": 839,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_legend_card",
    "component_id": "earth_system_generator.create_legend_card"
  },
  "earth_system_generator.create_intel_card": {
    "id": "earth_system_generator.create_intel_card",
    "name": "create_intel_card",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_generator.py",
    "relative_path": "earth_system_generator.py",
    "depends_on": [],
    "source_code": "def create_intel_card(mission):\n    filename = f\"{mission['date']}_intel_{mission['id']}.png\"\n    filepath = os.path.join(DATA_DIR, filename)\n    \n    fig = plt.figure(figsize=(4, 3.0), dpi=120) \n    \n    # ADJUSTED TRANSPARENCY: 0.7\n    fig.patch.set_facecolor('#f8f9fa')\n    fig.patch.set_alpha(0.7)\n    \n    ax = fig.add_subplot(111)\n    ax.axis('off')\n    \n    plt.text(0.05, 0.9, f\"HEAT WAVE: {mission['id'].upper()}\", transform=ax.transAxes, fontsize=10, fontweight='bold', color='#333')\n    plt.text(0.05, 0.82, f\"DATE: {mission['date']}\", transform=ax.transAxes, fontsize=9, fontfamily='monospace', color='#555')\n    plt.plot([0.05, 0.95], [0.78, 0.78], color='black', linewidth=1, transform=ax.transAxes)\n    \n    briefing = textwrap.fill(mission.get('briefing', \"No intel available.\"), width=40)\n    plt.text(0.05, 0.72, briefing, transform=ax.transAxes, fontsize=8, va='top', ha='left', color='#222')\n    \n    plt.text(0.05, 0.05, \"METEO DATA: ERA5 Reanalysis via Open-Meteo API\", \n             transform=ax.transAxes, fontsize=6, color='#777', style='italic')\n\n    plt.savefig(filepath, bbox_inches='tight', pad_inches=0.1, transparent=False)\n    plt.close()\n    return filename",
    "start_line": 841,
    "end_line": 866,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "mission"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_intel_card",
    "component_id": "earth_system_generator.create_intel_card"
  },
  "earth_system_generator.create_pop_legend_card": {
    "id": "earth_system_generator.create_pop_legend_card",
    "name": "create_pop_legend_card",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_generator.py",
    "relative_path": "earth_system_generator.py",
    "depends_on": [],
    "source_code": "def create_pop_legend_card():\n    filename = \"legend_impact_pop.png\"\n    filepath = os.path.join(DATA_DIR, filename)\n    \n    fig = plt.figure(figsize=(2.5, 3.0), dpi=120)\n    fig.patch.set_facecolor('white')\n    fig.patch.set_alpha(0.8)\n    \n    ax = fig.add_subplot(111)\n    ax.axis('off')\n    ax.set_aspect('equal')\n    ax.set_xlim(0, 10)\n    ax.set_ylim(0, 12)\n\n    # Red Circle (Megacity)\n    c_mega = mpatches.Circle((5, 9), 1.5, facecolor='#ff000066', edgecolor='red', linewidth=1.5)\n    ax.add_patch(c_mega)\n    plt.text(5, 7.2, \"Megacity (>5M)\", ha='center', fontsize=7, fontweight='bold')\n\n    # Orange Circle (Major)\n    c_major = mpatches.Circle((2.5, 5), 1.2, facecolor='#ffa50066', edgecolor='orange', linewidth=1.5)\n    ax.add_patch(c_major)\n    plt.text(2.5, 3.5, \"Major (>1M)\", ha='center', fontsize=7)\n\n    # Yellow Circle (Regional)\n    c_reg = mpatches.Circle((7.5, 5), 0.9, facecolor='#ffff0066', edgecolor='#cccc00', linewidth=1.5)\n    ax.add_patch(c_reg)\n    plt.text(7.5, 3.5, \"Region (>500k)\", ha='center', fontsize=7)\n\n    plt.text(5, 11, \"Population Exposure\", ha='center', fontweight='bold', fontsize=9)\n    \n    plt.savefig(filepath, bbox_inches='tight', pad_inches=0.1, transparent=False)\n    plt.close()\n    return filename",
    "start_line": 868,
    "end_line": 901,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_pop_legend_card",
    "component_id": "earth_system_generator.create_pop_legend_card"
  },
  "earth_system_generator.create_circle_polygon": {
    "id": "earth_system_generator.create_circle_polygon",
    "name": "create_circle_polygon",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_generator.py",
    "relative_path": "earth_system_generator.py",
    "depends_on": [],
    "source_code": "def create_circle_polygon(lat, lon, radius_km):\n    coords = []\n    for angle in range(0, 361, 10):\n        dx = radius_km * math.cos(math.radians(angle))\n        dy = radius_km * math.sin(math.radians(angle))\n        dlat = dy / 111.32\n        dlon = dx / (40075 * math.cos(math.radians(lat)) / 360)\n        coords.append((lon + dlon, lat + dlat))\n    return coords",
    "start_line": 904,
    "end_line": 912,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "lat",
      "lon",
      "radius_km"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_circle_polygon",
    "component_id": "earth_system_generator.create_circle_polygon"
  },
  "earth_system_generator.run_pipeline": {
    "id": "earth_system_generator.run_pipeline",
    "name": "run_pipeline",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_generator.py",
    "relative_path": "earth_system_generator.py",
    "depends_on": [
      "earth_system_generator.generate_popup_html",
      "earth_system_generator.create_pop_legend_card",
      "earth_system_generator.create_intel_card",
      "earth_system_generator.create_circle_polygon",
      "earth_system_generator.load_cache",
      "earth_system_generator.save_cache",
      "earth_system_generator.get_cache_path",
      "earth_system_generator.calculate_wet_bulb",
      "earth_system_generator.create_legend_card"
    ],
    "source_code": "def run_pipeline(mission):\n    date = mission[\"date\"]\n    mission_id = mission[\"id\"]\n    cache_path = get_cache_path(date)\n    \n    # --- CRASH FIX: Initialize variables ---\n    spike_filename = \"Not Generated\"\n    heat_filename = \"Not Generated\"\n    impact_filename = \"Not Generated\"\n    \n    print(f\"\\n--- INITIALIZING SCENARIO: {mission_id.upper()} [{date}] ---\")\n    legend_file = create_legend_card()\n    intel_file = create_intel_card(mission)\n    pop_legend_file = create_pop_legend_card() \n    \n    db = load_cache(cache_path)\n    points_to_fetch = []\n    all_points = [(lat, lon) for lat in mission[\"lat_range\"] for lon in mission[\"lon_range\"]]\n    for lat, lon in all_points:\n        if f\"{lat}_{lon}\" not in db: points_to_fetch.append((lat, lon))\n            \n    if points_to_fetch:\n        print(f\"Status: Missing {len(points_to_fetch)} points. Engaging download...\")\n        batch_size = 40\n        current_lats, current_lons = [], []\n        for i, (lat, lon) in enumerate(points_to_fetch):\n            current_lats.append(lat)\n            current_lons.append(lon)\n            if len(current_lats) >= batch_size or i == len(points_to_fetch) - 1:\n                try:\n                    url = \"https://archive-api.open-meteo.com/v1/archive\"\n                    params = {\"latitude\": \",\".join(map(str, current_lats)), \"longitude\": \",\".join(map(str, current_lons)),\n                              \"start_date\": date, \"end_date\": date, \"hourly\": \"temperature_2m,relative_humidity_2m\", \"timezone\": \"GMT\"}\n                    r = requests.get(url, params=params)\n                    if r.status_code == 429: break\n                    r.raise_for_status()\n                    data = r.json()\n                    if isinstance(data, dict): data = [data]\n                    for j, loc_data in enumerate(data):\n                        if \"hourly\" not in loc_data: continue\n                        temps = np.array(loc_data[\"hourly\"][\"temperature_2m\"])\n                        rhs = np.array(loc_data[\"hourly\"][\"relative_humidity_2m\"])\n                        max_tw = float(np.max(calculate_wet_bulb(temps, rhs)))\n                        db[f\"{current_lats[j]}_{current_lons[j]}\"] = max_tw\n                    save_cache(cache_path, db)\n                    current_lats, current_lons = [], []\n                    time.sleep(1.5)\n                except Exception: break\n    \n    # --- CRASH FIX: Check if database is empty ---\n    if not db:\n        messagebox.showerror(\"Data Error\", f\"No data retrieved for {date}.\\nNote: ERA5 archive begins in 1940.\")\n        return\n\n    print(\"Generating Bio-Corrected Spikes and Impact Layer...\")\n    \n    # 1. SPIKES FILE\n    spike_filename = os.path.join(DATA_DIR, f\"{date}_spikes_{mission_id}.kml\")\n    kml_spikes = simplekml.Kml()\n    kml_spikes.document.name = f\"{mission_id} Spikes ({date})\"\n    \n    screen_legend = kml_spikes.newscreenoverlay(name=\"Legend\")\n    screen_legend.icon.href = legend_file\n    screen_legend.overlayxy = simplekml.OverlayXY(x=0, y=0.1, xunits=simplekml.Units.fraction, yunits=simplekml.Units.fraction)\n    screen_legend.screenxy = simplekml.ScreenXY(x=0, y=0.1, xunits=simplekml.Units.fraction, yunits=simplekml.Units.fraction)\n\n    screen_intel = kml_spikes.newscreenoverlay(name=\"Scenario Intel\")\n    screen_intel.icon.href = intel_file\n    screen_intel.overlayxy = simplekml.OverlayXY(x=0, y=1, xunits=simplekml.Units.fraction, yunits=simplekml.Units.fraction)\n    screen_intel.screenxy = simplekml.ScreenXY(x=0, y=1, xunits=simplekml.Units.fraction, yunits=simplekml.Units.fraction)\n\n    # 2. IMPACT FILE\n    impact_filename = os.path.join(DATA_DIR, f\"{date}_impact_{mission_id}.kml\")\n    kml_impact = simplekml.Kml()\n    kml_impact.document.name = f\"{mission_id} Impact ({date})\"\n\n    screen_pop = kml_impact.newscreenoverlay(name=\"Population Legend\")\n    screen_pop.icon.href = pop_legend_file\n    screen_pop.overlayxy = simplekml.OverlayXY(x=1, y=0.1, xunits=simplekml.Units.fraction, yunits=simplekml.Units.fraction)\n    screen_pop.screenxy = simplekml.ScreenXY(x=1, y=0.1, xunits=simplekml.Units.fraction, yunits=simplekml.Units.fraction)\n\n    if mission_id in POPULATION_HUBS:\n        for city in POPULATION_HUBS[mission_id]:\n            pop = city['pop']\n            \n            # Dynamic Sizing & Coloring\n            radius = math.sqrt(pop) / 75\n            \n            # KML Color Format: aabbggrr (Hex)\n            if pop > 5000000:\n                color_fill = \"660000ff\"  # Red (40% opacity)\n                color_line = \"ff0000ff\"  # Red (100% opacity)\n                scale_desc = \"MEGACITY (>5M)\"\n            elif pop > 1000000:\n                color_fill = \"6600a5ff\"  # Orange\n                color_line = \"ff00a5ff\"\n                scale_desc = \"MAJOR HUB (>1M)\"\n            elif pop > 500000:\n                color_fill = \"6600ffff\"  # Yellow\n                color_line = \"ff00ffff\"\n                scale_desc = \"REGIONAL (>500k)\"\n            else:\n                color_fill = \"66ffffff\"  # White\n                color_line = \"ffffffff\"\n                scale_desc = \"LOCAL\"\n\n            poly = kml_impact.newpolygon(name=f\"{city['name']} ({pop:,})\")\n            poly.outerboundaryis = create_circle_polygon(city['lat'], city['lon'], radius)\n            poly.style.polystyle.color = color_fill\n            poly.style.linestyle.color = color_line\n            poly.style.linestyle.width = 2\n            \n            # Add description for click-intel\n            poly.description = f\"<b>{city['name']}</b><br>Population: {pop:,}<br>Class: {scale_desc}\"\n    \n    kml_impact.save(impact_filename)\n\n    # Populate Spikes\n    min_val = mission[\"focus_val_min\"]\n    for key, val in db.items():\n        if val < min_val: continue\n        lat, lon = map(float, key.split('_'))\n        pnt = kml_spikes.newpoint(name=f\"{val:.1f}\")\n        pnt.coords = [(lon, lat)]\n        pnt.description = generate_popup_html(val, lat, lon)\n        \n        height = (val - (min_val - 2)) * 15000 \n        pnt.altitudemode = simplekml.AltitudeMode.relativetoground\n        pnt.extrude = 1\n        pnt.altitude = height\n        \n        if val >= 31: \n            pnt.style.iconstyle.color = \"ff000000\" \n            pnt.style.linestyle.color = \"ff000000\"\n        elif val >= 28:\n            pnt.style.iconstyle.color = \"ff800080\"\n            pnt.style.linestyle.color = \"ff800080\"\n        elif val >= 26: \n            pnt.style.iconstyle.color = \"ff0000ff\"\n            pnt.style.linestyle.color = \"ff0000ff\"\n        else:\n            pnt.style.iconstyle.color = \"ff00a5ff\"\n            pnt.style.linestyle.color = \"ff00a5ff\"\n            \n    kml_spikes.save(spike_filename)\n    print(f\"Saved Spikes: {spike_filename}\")\n    print(f\"Saved Impact: {impact_filename}\")\n\n    # 3. HEATMAP FILE\n    print(\"Generating Heatmap...\")\n    lats, lons, values = [], [], []\n    for key, val in db.items():\n        if val < 20: continue \n        lat, lon = map(float, key.split('_'))\n        lats.append(lat)\n        lons.append(lon)\n        values.append(val)\n    \n    # --- CRASH FIX: Check if data exists for heatmap ---\n    if lats:\n        grid_lat = np.linspace(min(lats), max(lats), 300)\n        grid_lon = np.linspace(min(lons), max(lons), 600)\n        grid_x, grid_y = np.meshgrid(grid_lon, grid_lat)\n        grid_z = griddata((lons, lats), np.array(values), (grid_x, grid_y), method='linear')\n        \n        img_name = f\"{date}_heatmap_{mission_id}.png\"\n        img_path = os.path.join(DATA_DIR, img_name)\n        \n        dpi = 150\n        fig = plt.figure(figsize=(10, 5), dpi=dpi, frameon=False)\n        ax = plt.Axes(fig, [0., 0., 1., 1.])\n        ax.set_axis_off()\n        fig.add_axes(ax)\n        levels = np.arange(20, 38, 1)\n        ax.contourf(grid_x, grid_y, grid_z, levels=levels, cmap='inferno_r', alpha=0.35)\n        ax.contour(grid_x, grid_y, grid_z, levels=levels, colors='black', linewidths=0.5, alpha=0.5)\n        plt.savefig(img_path, transparent=True, bbox_inches='tight', pad_inches=0)\n        plt.close()\n\n        kml_heat = simplekml.Kml()\n        kml_heat.document.name = f\"{mission_id} Heatmap ({date})\"\n        ground = kml_heat.newgroundoverlay(name=\"Thermal Overlay\")\n        ground.icon.href = img_name\n        ground.latlonbox.north = max(lats)\n        ground.latlonbox.south = min(lats)\n        ground.latlonbox.east = max(lons)\n        ground.latlonbox.west = min(lons)\n        \n        heat_filename = os.path.join(DATA_DIR, f\"{date}_heatmap_{mission_id}.kml\")\n        kml_heat.save(heat_filename)\n        print(f\"Saved Heatmap: {heat_filename}\")\n    else:\n        print(\"Warning: Insufficient data for heatmap generation.\")\n\n    messagebox.showinfo(\"Success\", f\"Scenario Generated!\\n\\nFiles Created:\\n1. {spike_filename}\\n2. {heat_filename}\\n3. {impact_filename}\")",
    "start_line": 914,
    "end_line": 1108,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "mission"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function run_pipeline",
    "component_id": "earth_system_generator.run_pipeline"
  },
  "earth_system_visualization_gui.load_co2_data": {
    "id": "earth_system_visualization_gui.load_co2_data",
    "name": "load_co2_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [],
    "source_code": "def load_co2_data():\n    \"\"\"Load Mauna Loa CO2 data from cache\"\"\"\n    try:\n        with open(CO2_DATA_FILE, 'r') as f:\n            data = json.load(f)\n        return data\n    except FileNotFoundError:\n        return None\n    except json.JSONDecodeError:\n        return None",
    "start_line": 46,
    "end_line": 55,
    "has_docstring": true,
    "docstring": "Load Mauna Loa CO2 data from cache",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_co2_data",
    "component_id": "earth_system_visualization_gui.load_co2_data"
  },
  "earth_system_visualization_gui.load_temperature_data": {
    "id": "earth_system_visualization_gui.load_temperature_data",
    "name": "load_temperature_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [],
    "source_code": "def load_temperature_data():\n    \"\"\"Load NASA GISS temperature data from cache\"\"\"\n    try:\n        with open(TEMP_DATA_FILE, 'r') as f:\n            data = json.load(f)\n        return data\n    except FileNotFoundError:\n        return None\n    except json.JSONDecodeError:\n        return None",
    "start_line": 57,
    "end_line": 66,
    "has_docstring": true,
    "docstring": "Load NASA GISS temperature data from cache",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_temperature_data",
    "component_id": "earth_system_visualization_gui.load_temperature_data"
  },
  "earth_system_visualization_gui.load_ice_data": {
    "id": "earth_system_visualization_gui.load_ice_data",
    "name": "load_ice_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [],
    "source_code": "def load_ice_data():\n    \"\"\"Load Arctic sea ice extent data from cache\"\"\"\n    try:\n        with open(ICE_DATA_FILE, 'r') as f:\n            data = json.load(f)\n        return data\n    except FileNotFoundError:\n        return None\n    except json.JSONDecodeError:\n        return None",
    "start_line": 68,
    "end_line": 77,
    "has_docstring": true,
    "docstring": "Load Arctic sea ice extent data from cache",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_ice_data",
    "component_id": "earth_system_visualization_gui.load_ice_data"
  },
  "earth_system_visualization_gui.create_keeling_curve": {
    "id": "earth_system_visualization_gui.create_keeling_curve",
    "name": "create_keeling_curve",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "earth_system_visualization_gui.load_co2_data"
    ],
    "source_code": "def create_keeling_curve():\n    \"\"\"Create interactive Keeling Curve visualization\"\"\"\n    data = load_co2_data()\n    if not data:\n        return None\n    \n    records = data['data']\n    metadata = data['metadata']\n    \n    # Extract data\n    dates = [r['decimal_date'] for r in records]\n    co2_values = [r['co2_ppm'] for r in records]\n    \n    # Create figure\n    fig = go.Figure()\n    \n    # Add main CO2 trend line\n    fig.add_trace(go.Scatter(\n        x=dates,\n        y=co2_values,\n        mode='lines',\n        name='Atmospheric CO2',\n        line=dict(color='#2E86AB', width=2),\n        hovertemplate='Date: %{x:.2f}<br>CO2: %{y:.2f} ppm<extra></extra>'\n    ))\n    \n    # Add current value marker\n    latest = records[-1]\n    fig.add_trace(go.Scatter(\n        x=[latest['decimal_date']],\n        y=[latest['co2_ppm']],\n        mode='markers',\n        name='Current',\n        marker=dict(color='#C1121F', size=10, symbol='diamond'),\n        hovertemplate=f\"Current: {latest['co2_ppm']:.2f} ppm<extra></extra>\"\n    ))\n    \n    # Add reference lines\n    fig.add_hline(y=350, line_dash=\"dash\", line_color=\"green\", \n                  annotation_text=\"Pre-industrial safe zone (~350 ppm)\",\n                  annotation_position=\"left\")\n    fig.add_hline(y=450, line_dash=\"dash\", line_color=\"orange\",\n                  annotation_text=\"Danger threshold (>450 ppm)\",\n                  annotation_position=\"left\")\n    \n    # Calculate statistics\n    first_record = records[0]\n    years = latest['year'] - first_record['year']\n    increase = latest['co2_ppm'] - first_record['co2_ppm']\n    rate = increase / years\n    \n    # Add info box\n    info_text = (\n        f\"<b>The Keeling Curve</b><br>\"\n        f\"Current: {latest['co2_ppm']:.2f} ppm<br>\"\n        f\"Start ({first_record['year']}): {first_record['co2_ppm']:.2f} ppm<br>\"\n        f\"{years}-year increase: +{increase:.2f} ppm<br>\"\n        f\"Rate: +{rate:.2f} ppm/year\"\n    )\n    \n    fig.add_annotation(\n        text=info_text,\n        xref=\"paper\", yref=\"paper\",\n        x=0.02, y=0.98,\n        xanchor=\"left\", yanchor=\"top\",\n        bgcolor=\"rgba(255,255,255,0.8)\",\n        bordercolor=\"#2E86AB\",\n        borderwidth=2,\n        borderpad=10,\n        showarrow=False,\n        font=dict(size=11)\n    )\n    \n    # Add threat warning\n    threat_text = (\n        \"Mauna Loa Observatory threatened with closure (Aug 2025)<br>\"\n        \"Data preservation is climate action\"\n    )\n    \n    fig.add_annotation(\n        text=threat_text,\n        xref=\"paper\", yref=\"paper\",\n        x=0.98, y=0.02,\n        xanchor=\"right\", yanchor=\"bottom\",\n        bgcolor=\"rgba(255,200,200,0.8)\",\n        bordercolor=\"#C1121F\",\n        borderwidth=2,\n        borderpad=8,\n        showarrow=False,\n        font=dict(size=9, color=\"#C1121F\")\n    )\n    \n    # Layout\n    fig.update_layout(\n        title={\n            'text': \"The Keeling Curve: Atmospheric CO2 at Mauna Loa Observatory (1958-2025)\",\n            'x': 0.5,\n            'xanchor': 'center',\n            'font': {'size': 16, 'color': '#1a1a1a'}\n        },\n        xaxis_title=\"Year\",\n        yaxis_title=\"CO2 Concentration (ppm)\",\n        template=\"plotly_white\",\n        width=1200,\n        height=700,\n        hovermode='x unified',\n        showlegend=True,\n        legend=dict(x=0.02, y=0.5, bgcolor=\"rgba(255,255,255,0.8)\")\n    )\n    \n    # Add footer with source\n    fig.add_annotation(\n        text=f\"Data Source: {metadata['source']['organization']} | <a href=\\\"{metadata['source']['url']}\\\">{metadata['source']['url']}</a>\",\n        xref=\"paper\", yref=\"paper\",\n        x=0.5, y=-0.12,\n        xanchor=\"center\", yanchor=\"top\",\n        showarrow=False,\n        font=dict(size=9, color='gray')\n    )\n    \n    return fig",
    "start_line": 79,
    "end_line": 199,
    "has_docstring": true,
    "docstring": "Create interactive Keeling Curve visualization",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_keeling_curve",
    "component_id": "earth_system_visualization_gui.create_keeling_curve"
  },
  "earth_system_visualization_gui.create_temperature_viz": {
    "id": "earth_system_visualization_gui.create_temperature_viz",
    "name": "create_temperature_viz",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "earth_system_visualization_gui.load_temperature_data"
    ],
    "source_code": "def create_temperature_viz():\n    \"\"\"Create interactive temperature anomaly visualization\"\"\"\n    data = load_temperature_data()\n    if not data:\n        return None\n    \n    records = data['data']\n    metadata = data['metadata']\n    \n    # Extract data - create decimal dates\n    dates = [r['year'] + (r['month'] - 0.5) / 12 for r in records]\n    anomalies = [r['anomaly_c'] for r in records]\n    \n    # Create figure\n    fig = go.Figure()\n    \n    # Add temperature trend line\n    fig.add_trace(go.Scatter(\n        x=dates,\n        y=anomalies,\n        mode='lines',\n        name='Temperature Anomaly',\n        line=dict(color='#C1121F', width=2),\n        hovertemplate='Date: %{x:.2f}<br>Anomaly: %{y:.2f} degC<extra></extra>'\n    ))\n    \n    # Add current value marker\n    latest = records[-1]\n    latest_date = latest['year'] + (latest['month'] - 0.5) / 12\n    fig.add_trace(go.Scatter(\n        x=[latest_date],\n        y=[latest['anomaly_c']],\n        mode='markers',\n        name='Current',\n        marker=dict(color='#8B0000', size=10, symbol='diamond'),\n        hovertemplate=f\"Current: +{latest['anomaly_c']:.2f} degC<extra></extra>\"\n    ))\n    \n    # Add baseline and reference lines\n    fig.add_hline(y=0, line_dash=\"solid\", line_color=\"gray\", line_width=2,\n                  annotation_text=\"1951-1980 baseline\",\n                  annotation_position=\"top right\")\n            #      annotation=dict(yshift=-10, xshift=5))\n    \n    fig.add_hline(y=-0.3, line_dash=\"dot\", line_color=\"green\", line_width=1,\n                  annotation_text=\"Pre-industrial (~1850-1900)\",\n                  annotation_position=\"top right\")\n            #      annotation=dict(yshift=-10, xshift=5))\n    \n    fig.add_hline(y=1.5, line_dash=\"dash\", line_color=\"orange\",\n                  annotation_text=\"Paris Agreement 1.5 degC target\",\n                  annotation_position=\"top right\")\n    \n    fig.add_hline(y=2.0, line_dash=\"dash\", line_color=\"red\",\n                  annotation_text=\"Paris Agreement 2.0 degC limit\",\n                  annotation_position=\"top right\")\n    \n    # Calculate statistics\n    first_record = records[0]\n    years = latest['year'] - first_record['year']\n    warming = latest['anomaly_c'] - first_record['anomaly_c']\n    vs_preindustrial = latest['anomaly_c'] + 0.3\n    progress_15 = (vs_preindustrial / 1.5) * 100\n    progress_20 = (vs_preindustrial / 2.0) * 100\n    \n    # Add info box\n    info_text = (\n        f\"<b>Global Temperature</b><br>\"\n        f\"Current: +{latest['anomaly_c']:.2f} degC<br>\"\n        f\"vs Pre-industrial: +{vs_preindustrial:.2f} degC<br>\"\n        f\"{years}-yr warming: +{warming:.2f} degC<br>\"\n        f\"Progress to 1.5 degC: {progress_15:.0f}%<br>\"\n        f\"Progress to 2.0 degC: {progress_20:.0f}%<br>\"\n        f\"(Baseline: 1951-1980 avg)\"\n    )\n    \n    fig.add_annotation(\n        text=info_text,\n        xref=\"paper\", yref=\"paper\",\n        x=0.25, y=0.45,\n        xanchor=\"right\", yanchor=\"bottom\",\n        bgcolor=\"rgba(255,255,255,0.8)\",\n        bordercolor=\"#C1121F\",\n        borderwidth=2,\n        borderpad=10,\n        showarrow=False,\n        font=dict(size=11)\n    )\n    \n    # Add threat warning\n    threat_text = (\n        \"NASA GISS faces 52% budget cuts & institutional uncertainty<br>\"\n        \"James Hansen's 145-year legacy dataset at risk\"\n    )\n    \n    fig.add_annotation(\n        text=threat_text,\n        xref=\"paper\", yref=\"paper\",\n        x=0.70, y=0.02,\n        xanchor=\"left\", yanchor=\"bottom\",\n        bgcolor=\"rgba(255,200,200,0.8)\",\n        bordercolor=\"#C1121F\",\n        borderwidth=2,\n        borderpad=8,\n        showarrow=False,\n        font=dict(size=9, color=\"#C1121F\")\n    )\n    \n    # Layout\n    fig.update_layout(\n        title={\n            'text': \"Global Mean Surface Temperature Anomaly (1880-2025)<br><sub>1951-1980 baseline is ~0.3 degC warmer than pre-industrial (1850-1900). Aerosol masking effect visible 1950-1980. Data updates monthly with 1-2 month lag for quality control.</sub>\",\n            'x': 0.5,\n            'xanchor': 'center',\n            'font': {'size': 14, 'color': '#1a1a1a'}\n        },\n        xaxis_title=\"Year (decimal notation: 2024.96 = late December)\",\n        yaxis_title=\"Temperature Anomaly ( degC)\",\n        template=\"plotly_white\",\n        width=1200,\n        height=700,\n        hovermode='x unified',\n        showlegend=True,\n        legend=dict(x=0.50, y=0.70, bgcolor=\"rgba(255,255,255,0.8)\"),\n        margin=dict(t=120, b=120)\n    )\n    \n    # Add footer with source\n    fig.add_annotation(\n        text=f\"Data Source: {metadata['source']['organization']} | <a href=\\\"{metadata['source']['url']}\\\">{metadata['source']['url']}</a> | {metadata['source']['citation']}\",\n        xref=\"paper\", yref=\"paper\",\n        x=0.5, y=-0.15,\n        xanchor=\"center\", yanchor=\"top\",\n        showarrow=False,\n        font=dict(size=9, color='gray')\n    )\n    \n    return fig",
    "start_line": 201,
    "end_line": 338,
    "has_docstring": true,
    "docstring": "Create interactive temperature anomaly visualization",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_temperature_viz",
    "component_id": "earth_system_visualization_gui.create_temperature_viz"
  },
  "earth_system_visualization_gui.create_monthly_temperature_lines": {
    "id": "earth_system_visualization_gui.create_monthly_temperature_lines",
    "name": "create_monthly_temperature_lines",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "earth_system_visualization_gui.load_temperature_data"
    ],
    "source_code": "def create_monthly_temperature_lines():\n    \"\"\"\n    Create year-over-year monthly temperature visualization (line chart).\n    Shows all years from 1880-2025 with color spectrum.\n    \"\"\"\n    # Load data\n    data = load_temperature_data()\n    \n    if not data:\n        return None\n    \n    records = data['data']\n    metadata = data['metadata']\n    \n    # Organize data by year and month\n    years_data = {}\n    for r in records:\n        year = r['year']\n        month = r['month']\n        if year not in years_data:\n            years_data[year] = {}\n        years_data[year][month] = r['anomaly_c']\n    \n    # All years\n    all_years = sorted(years_data.keys())\n    selected_years = all_years  # Show all years\n    \n    # Create figure\n    fig = go.Figure()\n    \n    # Generate color spectrum from blue (cold) to red (hot)\n    import colorsys\n    n_years = len(all_years)\n    \n    def get_temperature_color(index, total):\n        \"\"\"Generate color from blue (cold) through green/yellow to red (hot).\"\"\"\n        hue = 240 - (index / total * 240)  # 240 deg (blue) to 0 deg (red)\n        hue = hue / 360.0\n        saturation = 0.85\n        value = 0.9\n        r, g, b = colorsys.hsv_to_rgb(hue, saturation, value)\n        return f'rgb({int(r*255)}, {int(g*255)}, {int(b*255)})'\n    \n    # Add traces for each year\n    for i, year in enumerate(selected_years):\n        months = list(range(1, 13))\n        anomalies = [years_data[year].get(m, None) for m in months]\n        \n        year_index = all_years.index(year)\n        color = get_temperature_color(year_index, n_years)\n        \n        # Check if partial year\n        has_data = [a for a in anomalies if a is not None]\n        is_partial = len(has_data) < 12\n        \n        fig.add_trace(go.Scatter(\n            x=months,\n            y=anomalies,\n            mode='lines',\n            name=f'{year}' + (' (partial)' if is_partial else ''),\n            line=dict(color=color, width=2, dash='dot' if is_partial else 'solid'),\n            opacity=1.0,\n            showlegend=True,\n            hovertemplate='<b>Year:</b> %{fullData.name}<br>' +\n                          '<b>Month:</b> %{x}<br>' +\n                          '<b>Anomaly:</b> %{y:.2f} degC<br>' +\n                          '<extra></extra>'\n        ))\n    \n    # Layout\n    fig.update_layout(\n        title=dict(\n            text=\"Monthly Temperature Anomalies: Historical Context (1880-2025)<br>\" +\n                 \"<sub>Color spectrum: Blue (cooler) -> Red (warmer) showing warming trend over time</sub><br>\" +\n                 f\"<sub>Data Source: {metadata['source']['organization']} | Baseline: 1951-1980</sub>\",\n            x=0.5,\n            xanchor='center',\n            font=dict(size=16)\n        ),\n        xaxis=dict(\n            title=\"Month\",\n            tickmode='array',\n            tickvals=list(range(1, 13)),\n            ticktext=['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', \n                     'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n            showgrid=True,\n            gridwidth=1,\n            gridcolor='rgba(128, 128, 128, 0.2)'\n        ),\n        yaxis=dict(\n            title=\"Temperature Anomaly ( degC)\",\n            showgrid=True,\n            gridwidth=1,\n            gridcolor='rgba(128, 128, 128, 0.2)'\n        ),\n        hovermode='closest',\n        legend=dict(\n            x=1.02,\n            y=0.98,\n            bgcolor='rgba(255,255,255,0.9)',\n            bordercolor='black',\n            borderwidth=1,\n            font=dict(size=9),\n            yanchor='top',\n            xanchor='left',\n            traceorder='reversed'\n        ),\n        plot_bgcolor='rgba(240, 240, 240, 0.5)',\n        width=1450,\n        height=700,\n        margin=dict(r=200, l=80, t=120, b=80)\n    )\n    \n    # Add zero line\n    fig.add_hline(\n        y=0,\n        line_dash=\"dash\",\n        line_color=\"black\",\n        opacity=1.0,\n        annotation_text=\"1951-1980 baseline\",\n        annotation_position=\"top left\"\n    )\n    \n    return fig",
    "start_line": 342,
    "end_line": 465,
    "has_docstring": true,
    "docstring": "Create year-over-year monthly temperature visualization (line chart).\nShows all years from 1880-2025 with color spectrum.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_monthly_temperature_lines",
    "component_id": "earth_system_visualization_gui.create_monthly_temperature_lines"
  },
  "earth_system_visualization_gui.get_temperature_color": {
    "id": "earth_system_visualization_gui.get_temperature_color",
    "name": "get_temperature_color",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [],
    "source_code": "    def get_temperature_color(index, total):\n        \"\"\"Generate color from blue (cold) through green/yellow to red (hot).\"\"\"\n        hue = 240 - (index / total * 240)  # 240 deg (blue) to 0 deg (red)\n        hue = hue / 360.0\n        saturation = 0.85\n        value = 0.9\n        r, g, b = colorsys.hsv_to_rgb(hue, saturation, value)\n        return f'rgb({int(r*255)}, {int(g*255)}, {int(b*255)})'",
    "start_line": 376,
    "end_line": 383,
    "has_docstring": true,
    "docstring": "Generate color from blue (cold) through green/yellow to red (hot).",
    "parameters": [
      "index",
      "total"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_temperature_color",
    "component_id": "earth_system_visualization_gui.get_temperature_color"
  },
  "earth_system_visualization_gui.create_warming_stripes": {
    "id": "earth_system_visualization_gui.create_warming_stripes",
    "name": "create_warming_stripes",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "earth_system_visualization_gui.load_temperature_data"
    ],
    "source_code": "def create_warming_stripes():\n    \"\"\"\n    Create Ed Hawkins style warming stripes visualization (heatmap).\n    Shows all years 1880-2025.\n    \"\"\"\n    # Load data\n    data = load_temperature_data()\n    \n    if not data:\n        return None\n    \n    records = data['data']\n    metadata = data['metadata']\n    \n    # Organize data by year and month\n    years_data = {}\n    for r in records:\n        year = r['year']\n        month = r['month']\n        if year not in years_data:\n            years_data[year] = [None] * 12\n        years_data[year][month - 1] = r['anomaly_c']\n    \n    # All years\n    start_year = min(years_data.keys())\n    end_year = max(years_data.keys())\n    years = list(range(start_year, end_year + 1))\n    \n    # Build matrix\n    z_data = []\n    year_labels = []\n    \n    for year in years:\n        if year in years_data:\n            z_data.append(years_data[year])\n            year_labels.append(str(year))\n    \n    month_labels = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', \n                    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n    \n    # Create heatmap\n    fig = go.Figure(data=go.Heatmap(\n        z=z_data,\n        x=month_labels,\n        y=year_labels,\n        colorscale='RdBu_r',  # Red-Blue reversed (red = hot)\n        zmid=0,\n        colorbar=dict(\n            title=\"Anomaly ( degC)\",\n            titleside=\"right\",\n            tickmode=\"linear\",\n            tick0=-1,\n            dtick=0.5\n        ),\n        zmin=-1.0,\n        zmax=1.5,\n        hovertemplate='<b>Year:</b> %{y}<br>' +\n                      '<b>Month:</b> %{x}<br>' +\n                      '<b>Anomaly:</b> %{z:.2f} degC<br>' +\n                      '<extra></extra>'\n    ))\n    \n    # Layout\n    fig.update_layout(\n        title=dict(\n            text=\"Warming Stripes: Monthly Temperature Anomalies (1880-2025)<br>\" +\n                 \"<sub>Inspired by #ShowYourStripes (Prof. Ed Hawkins, 2018)</sub><br>\" +\n                 f\"<sub>Data Source: {metadata['source']['organization']} | \" +\n                 f\"Baseline: 1951-1980 | Blue = Cool, Red = Hot</sub>\",\n            x=0.5,\n            xanchor='center',\n            font=dict(size=16)\n        ),\n        xaxis=dict(\n            side='top'\n        ),\n        yaxis=dict(\n            title=\"Year\",\n            autorange=True\n        ),\n        width=1200,\n        height=1400,\n        margin=dict(r=80, l=80, t=140, b=80)\n    )\n    \n    return fig",
    "start_line": 468,
    "end_line": 553,
    "has_docstring": true,
    "docstring": "Create Ed Hawkins style warming stripes visualization (heatmap).\nShows all years 1880-2025.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_warming_stripes",
    "component_id": "earth_system_visualization_gui.create_warming_stripes"
  },
  "earth_system_visualization_gui.open_monthly_temp_lines": {
    "id": "earth_system_visualization_gui.open_monthly_temp_lines",
    "name": "open_monthly_temp_lines",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "earth_system_visualization_gui.create_monthly_temperature_lines",
      "save_utils.save_plot"
    ],
    "source_code": "def open_monthly_temp_lines():\n    \"\"\"Open the monthly temperature year-over-year line chart.\"\"\"\n    try:\n        fig = create_monthly_temperature_lines()\n        if fig:\n            fig.show()\n            save_plot(fig, \"monthly_temperature_lines\")\n        else:\n            messagebox.showerror(\"Data Not Found\",\n                \"Temperature data file not found.\\n\"\n                \"Please run fetch_climate_data.py first.\")\n    except Exception as e:\n        messagebox.showerror(\"Error\", \n            f\"Failed to create monthly temperature visualization:\\n{str(e)}\")",
    "start_line": 558,
    "end_line": 571,
    "has_docstring": true,
    "docstring": "Open the monthly temperature year-over-year line chart.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function open_monthly_temp_lines",
    "component_id": "earth_system_visualization_gui.open_monthly_temp_lines"
  },
  "earth_system_visualization_gui.open_warming_stripes": {
    "id": "earth_system_visualization_gui.open_warming_stripes",
    "name": "open_warming_stripes",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "earth_system_visualization_gui.create_warming_stripes",
      "save_utils.save_plot"
    ],
    "source_code": "def open_warming_stripes():\n    \"\"\"Open the Ed Hawkins warming stripes heatmap.\"\"\"\n    try:\n        fig = create_warming_stripes()\n        if fig:\n            fig.show()\n            save_plot(fig, \"warming_stripes\")\n        else:\n            messagebox.showerror(\"Data Not Found\",\n                \"Temperature data file not found.\\n\"\n                \"Please run fetch_climate_data.py first.\")\n    except Exception as e:\n        messagebox.showerror(\"Error\",\n            f\"Failed to create warming stripes visualization:\\n{str(e)}\")",
    "start_line": 574,
    "end_line": 587,
    "has_docstring": true,
    "docstring": "Open the Ed Hawkins warming stripes heatmap.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function open_warming_stripes",
    "component_id": "earth_system_visualization_gui.open_warming_stripes"
  },
  "earth_system_visualization_gui.create_ice_viz": {
    "id": "earth_system_visualization_gui.create_ice_viz",
    "name": "create_ice_viz",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "earth_system_visualization_gui.load_ice_data"
    ],
    "source_code": "def create_ice_viz():\n    \"\"\"Create Arctic sea ice extent visualization - Updated with correct data source\"\"\"\n    data = load_ice_data()\n    if not data:\n        return None\n    \n    records = data['data']\n    metadata = data['metadata']\n    \n    # Filter to September only (annual minimum)\n    sept_records = [r for r in records if r['month'] == 9]\n    \n    # Extract September data\n    years = [r['year'] for r in sept_records]\n    extents = [r['extent_million_km2'] for r in sept_records]\n    \n    # Calculate trend line\n    z = np.polyfit(years, extents, 1)\n    p = np.poly1d(z)\n    trend_line = p(years)\n    \n    # Calculate statistics\n    first_extent = extents[0]\n    latest_extent = extents[-1]\n    min_extent = min(extents)\n    min_year = years[extents.index(min_extent)]\n    decline = first_extent - latest_extent\n    pct_decline = (decline / first_extent) * 100\n    \n    # Create figure\n    fig = go.Figure()\n    \n    # Add actual September data\n    fig.add_trace(go.Scatter(\n        x=years,\n        y=extents,\n        mode='lines+markers',\n        name='September Minimum',\n        line=dict(color='#00B4D8', width=2),\n        marker=dict(size=6, color='#00B4D8'),\n        hovertemplate='<b>%{x}</b><br>Extent: %{y:.2f} million km^2<extra></extra>'\n    ))\n    \n    # Add trend line\n    fig.add_trace(go.Scatter(\n        x=years,\n        y=trend_line,\n        mode='lines',\n        name='Trend',\n        line=dict(color='#03045E', width=2, dash='dash'),\n        hovertemplate='Trend: %{y:.2f} million km^2<extra></extra>'\n    ))\n    \n    # Add 2012 record low annotation\n    fig.add_annotation(\n        x=2012,\n        y=min_extent,\n        text=f\"Record Low: {min_extent:.2f}M km^2<br>September 2012\",\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=2,\n        arrowcolor='#03045E',\n        ax=40,\n        ay=-40,\n        bgcolor='white',\n        bordercolor='#03045E',\n        borderwidth=2,\n        font=dict(size=11, color='#03045E')\n    )\n    \n    # Update layout\n    fig.update_layout(\n        title=dict(\n            text='Arctic Sea Ice Extent - September Minimum<br><sub>Satellite Era (1979-2025) | Full monthly data available, September shown</sub>',\n            font=dict(size=18, color='#03045E', family='Arial')\n        ),\n        xaxis=dict(\n            title='Year',\n            gridcolor='lightgray',\n            showgrid=True\n        ),\n        yaxis=dict(\n            title='Sea Ice Extent (million km^2)',\n            gridcolor='lightgray',\n            showgrid=True\n        ),\n        plot_bgcolor='#E8F4F8',\n        paper_bgcolor='white',\n        hovermode='x unified',\n        showlegend=True,\n        legend=dict(\n            x=0.02,\n            y=0.35,\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='#03045E',\n            borderwidth=1\n        ),\n        width=1200,\n        height=700,\n        margin=dict(r=50, t=100, b=150, l=80)\n    )\n    \n    # Add info box - top right\n    info_text = (\n        f\"<b>September Minimum</b><br>\"\n        f\"(Annual low point)<br><br>\"\n        f\"<b>2025:</b> {latest_extent:.2f} million km^2<br>\"\n        f\"<b>1979:</b> {first_extent:.2f} million km^2<br>\"\n        f\"<b>Decline:</b> -{decline:.2f} million km^2 ({pct_decline:.1f}%)<br>\"\n        f\"<b>Trend:</b> -12.1% per decade<br><br>\"\n        f\"<i>Dataset contains all 12 months<br>\"\n        f\"(561 records total)</i>\"\n    )\n    \n    fig.add_annotation(\n        text=info_text,\n        xref=\"paper\", yref=\"paper\",\n        x=0.98, y=0.98,\n        xanchor='right', yanchor='top',\n        showarrow=False,\n        bgcolor='rgba(255,255,255,0.95)',\n        bordercolor='#00B4D8',\n        borderwidth=2,\n        borderpad=10,\n        font=dict(size=10, color='#03045E')\n    )\n    \n    # Add data source note - top left (UPDATED - crisis resolved!)\n    source_note = (\n        \"<b>[OK] Automated Data Retrieval Working</b><br>\"\n        \"- NSIDC V4.0 Excel format (Oct 2024)<br>\"\n        \"- Migrated from V3 CSV to V4 XLSX<br>\"\n        \"- FTP deprecated HTTPS active<br>\"\n        \"- Full monthly data (1979-2025)\"\n    )\n    \n    fig.add_annotation(\n        text=source_note,\n        xref=\"paper\", yref=\"paper\",\n        x=0.02, y=0.20,\n        xanchor='left', yanchor='top',\n        showarrow=False,\n        bgcolor='rgba(200,255,200,0.95)',\n        bordercolor='#4CAF50',\n        borderwidth=2,\n        borderpad=10,\n        font=dict(size=9, color='#1B5E20')\n    )\n    \n    # Add comprehensive source information at bottom\n    source_url = metadata['source'].get('data_url', metadata['source']['url'])\n    citation = metadata['source'].get('citation', 'NSIDC Sea Ice Index, Version 4')\n    \n    source_text = (\n        f\"<b>Data Source:</b> {metadata['source']['organization']}<br>\"\n        f\"<b>Primary URL:</b> <a href='{metadata['source']['url']}'>{metadata['source']['url']}</a><br>\"\n        f\"<b>Data File:</b> <a href='{source_url}'>Sea_Ice_Index_Monthly_Data_by_Year_G02135_v4.0.xlsx</a><br>\"\n        f\"<b>Citation:</b> {citation}<br>\"\n        f\"<b>Format:</b> Excel (XLSX) parsed with openpyxl | <b>Sheet:</b> NH-Extent | <b>Records:</b> {len(records)} monthly values (1979-2025)<br>\"\n        f\"<b>Note:</b> September minimum represents annual low point. March maximum typically 15-16 million km^2.\"\n    )\n    \n    fig.add_annotation(\n        text=source_text,\n        xref=\"paper\", yref=\"paper\",\n        x=0.5, y=-0.10,\n        xanchor=\"center\", yanchor=\"top\",\n        showarrow=False,\n        align='left',\n        bgcolor='rgba(255,255,255,0.95)',\n        bordercolor='#666',\n        borderwidth=1,\n        borderpad=8,\n        font=dict(size=8, color='#333')\n    )\n    \n    return fig",
    "start_line": 590,
    "end_line": 767,
    "has_docstring": true,
    "docstring": "Create Arctic sea ice extent visualization - Updated with correct data source",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_ice_viz",
    "component_id": "earth_system_visualization_gui.create_ice_viz"
  },
  "earth_system_visualization_gui.load_sea_level_data": {
    "id": "earth_system_visualization_gui.load_sea_level_data",
    "name": "load_sea_level_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [],
    "source_code": "def load_sea_level_data():\n    \"\"\"Load sea level data from cached JSON file\"\"\"\n    try:\n#        with open('sea_level_gmsl_monthly.json', 'r') as f:\n        with open('data/sea_level_gmsl_monthly.json', 'r') as f:    \n            data = json.load(f)\n            return data['data'], data['metadata']\n    except FileNotFoundError:\n        print(\"Sea level data file not found. Run fetch_climate_data.py first.\")\n        return None, None\n    except Exception as e:\n        print(f\"Error loading sea level data: {e}\")\n        return None, None",
    "start_line": 771,
    "end_line": 783,
    "has_docstring": true,
    "docstring": "Load sea level data from cached JSON file",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_sea_level_data",
    "component_id": "earth_system_visualization_gui.load_sea_level_data"
  },
  "earth_system_visualization_gui.create_sea_level_viz": {
    "id": "earth_system_visualization_gui.create_sea_level_viz",
    "name": "create_sea_level_viz",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "earth_system_visualization_gui.load_sea_level_data"
    ],
    "source_code": "def create_sea_level_viz():\n    \"\"\"Create interactive sea level rise visualization\"\"\"\n    records, metadata = load_sea_level_data()\n    \n    if not records:\n        return None\n    \n    # Extract data  \n    dates = [f\"{r['year']}-{r['month']:02d}-01\" for r in records]\n    \n    # Data is already in centimeters\n    sea_level_cm = [r['gmsl_smoothed_cm'] for r in records]\n    \n    # Get latest values\n    latest_date = dates[-1]\n    latest_cm = sea_level_cm[-1]\n    \n    # Calculate statistics\n    # Convert cm to mm (data comes in as gmsl_smoothed_cm)\n    sea_level_mm = [r['gmsl_smoothed_cm'] * 10 for r in records]  # [OK] Convert cm to mm\n    first_mm = sea_level_mm[0]\n    latest_mm = sea_level_mm[-1]\n    first_year = records[0]['year']\n    latest_year = records[-1]['year']\n    years_span = latest_year - first_year\n    total_rise_mm = latest_mm - first_mm\n    total_rise_cm = total_rise_mm / 10\n    rate_mm_per_year = total_rise_mm / years_span\n    \n    # Create figure\n    fig = go.Figure()\n    \n    # Main sea level line\n    fig.add_trace(go.Scatter(\n        x=dates,\n        y=sea_level_cm,\n        mode='lines',\n        name='Global Mean Sea Level',\n        line=dict(color='#006994', width=2),\n        hovertemplate='<b>%{x}</b><br>Sea Level: %{y:.2f} cm<extra></extra>'\n    ))\n    \n    # Add current value marker\n    fig.add_trace(go.Scatter(\n        x=[latest_date],\n        y=[latest_cm],\n        mode='markers',\n        name='Current Level',\n        marker=dict(\n            size=12,\n            color='#E63946',\n            symbol='diamond',\n            line=dict(color='white', width=2)\n        ),\n        hovertemplate=f'<b>Current</b><br>{latest_date}<br>{latest_cm:.2f} cm<extra></extra>'\n    ))\n    \n    # Add baseline (zero line for 1993)\n    fig.add_hline(\n        y=0, \n        line_dash=\"dash\", \n        line_color=\"gray\",\n        annotation_text=\"1993 baseline (zero mean)\",\n        annotation_position=\"bottom right\",\n        annotation=dict(font_size=10, font_color=\"gray\")\n    )\n        \n    # Add trend line\n    try:\n        from scipy import stats\n        import numpy as np\n        \n        # Simple linear regression\n        x_numeric = np.arange(len(sea_level_cm))\n        slope, intercept, r_value, p_value, std_err = stats.linregress(x_numeric, sea_level_cm)\n        trend_line = slope * x_numeric + intercept\n        \n        fig.add_trace(go.Scatter(\n            x=dates,\n            y=trend_line,\n            mode='lines',\n            name='Trend',\n            line=dict(color='rgba(230, 57, 70, 0.5)', width=2, dash='dash'),\n            hoverinfo='skip'\n        ))\n    except ImportError:\n        print(\"scipy not available - trend line skipped\")\n\n    # Layout\n    fig.update_layout(\n        title={\n            'text': 'Global Mean Sea Level Rise<br><sub>NASA-SSH Satellite Altimetry (60-day smoothed)</sub>',\n            'x': 0.5,\n            'xanchor': 'center',\n            'font': {'size': 20, 'color': '#006994', 'family': 'Arial Black'}\n        },\n        xaxis_title='Year',\n        yaxis_title='Sea Level Change (cm)',\n        hovermode='x unified',\n        template='plotly_white',\n        height=700,\n        showlegend=True,\n        legend=dict(\n            yanchor=\"top\",\n            y=0.99,\n            xanchor=\"left\",\n            x=0.30,\n            bgcolor=\"rgba(255, 255, 255, 0.8)\"\n        )\n    )\n    \n    # Add info box\n    info_text = (\n        f\"<b>Current Status ({latest_year})</b><br>\"\n        f\"Sea Level: <b>+{latest_cm:.2f} cm</b> ({latest_mm:.1f} mm)<br>\"\n        f\"<br>\"\n        f\"<b>Since {first_year} ({years_span} years)</b><br>\"\n        f\"Total Rise: <b>+{total_rise_cm:.2f} cm</b> ({total_rise_mm:.1f} mm)<br>\"\n        f\"Rate: <b>{rate_mm_per_year:.2f} mm/year</b><br>\"\n        f\"<br>\"\n        f\"<b>Threat Warning</b><br>\"\n        f\"NASA Earth Science missions<br>\"\n        f\"face budget uncertainty<br>\"\n        f\"<br>\"\n        f\"<b>Impact</b><br>\"\n        f\"- Coastal flooding increasing<br>\"\n        f\"- Storm surge amplification<br>\"\n        f\"- Saltwater intrusion<br>\"\n        f\"- Island nations at risk<br>\"\n        f\"<br>\"\n        f\"<i>Data: NASA Earth Indicators</i><br>\"\n        f\"<i>32-year satellite record</i><br>\"\n        f\"<a href='https://science.nasa.gov/earth/explore/earth-indicators/sea-leve/'>NASA Sea Level Data</a><br>\"\n        f\"(download requires registration)\"\n    )\n\n       \n    fig.add_annotation(\n        text=info_text,\n        xref=\"paper\", yref=\"paper\",\n        x=0.02, y=0.98,\n        xanchor='left', yanchor='top',\n        showarrow=False,\n        font=dict(size=11, color='#333'),\n        align='left',\n        bgcolor='rgba(255, 255, 255, 0.9)',\n        bordercolor='#006994',\n        borderwidth=2,\n        borderpad=10\n    )\n    \n    return fig",
    "start_line": 785,
    "end_line": 936,
    "has_docstring": true,
    "docstring": "Create interactive sea level rise visualization",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sea_level_viz",
    "component_id": "earth_system_visualization_gui.create_sea_level_viz"
  },
  "earth_system_visualization_gui.load_ph_data": {
    "id": "earth_system_visualization_gui.load_ph_data",
    "name": "load_ph_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [],
    "source_code": "def load_ph_data():\n    \"\"\"Load ocean pH data from JSON cache\"\"\"\n    try:\n#        with open('ocean_ph_hot_monthly.json', 'r') as f:\n        with open('data/ocean_ph_hot_monthly.json', 'r') as f:    \n            return json.load(f)\n    except FileNotFoundError:\n        return None\n    except json.JSONDecodeError:\n        print(\"Error: pH data file is corrupted\")\n        return None",
    "start_line": 938,
    "end_line": 948,
    "has_docstring": true,
    "docstring": "Load ocean pH data from JSON cache",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_ph_data",
    "component_id": "earth_system_visualization_gui.load_ph_data"
  },
  "earth_system_visualization_gui.create_ph_viz": {
    "id": "earth_system_visualization_gui.create_ph_viz",
    "name": "create_ph_viz",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "earth_system_visualization_gui.load_ph_data"
    ],
    "source_code": "def create_ph_viz():\n    \"\"\"Create interactive ocean acidification (pH) visualization\"\"\"\n    data = load_ph_data()\n    if not data:\n        return None\n    \n    records = data['records']\n    metadata = data['metadata']\n    \n    if not records:\n        return None\n    \n    # Extract data for plotting\n    dates = [f\"{r['year']}-{r['month']:02d}-01\" for r in records]\n    ph_values = [r['ph_total'] for r in records]\n    years = [r['year'] for r in records]\n    \n    # Create figure\n    fig = go.Figure()\n    \n    # Add pH measurements\n    fig.add_trace(go.Scatter(\n        x=dates,\n        y=ph_values,\n        mode='lines+markers',\n        name='Measured pH',\n        line=dict(color='#0077BE', width=2),\n        marker=dict(size=4, color='#0077BE'),\n        hovertemplate='<b>Date:</b> %{x}<br>' +\n                      '<b>pH:</b> %{y:.4f}<br>' +\n                      '<extra></extra>'\n    ))\n    \n    # Add trend line using scipy\n    if SCIPY_AVAILABLE:\n        x_numeric = list(range(len(ph_values)))\n        slope, intercept, r_value, p_value, std_err = stats.linregress(x_numeric, ph_values)\n        trend_line = [slope * x + intercept for x in x_numeric]\n        \n        fig.add_trace(go.Scatter(\n            x=dates,\n            y=trend_line,\n            mode='lines',\n            name='Trend Line',\n            line=dict(color='#C1121F', width=2, dash='dash'),\n            hovertemplate='<b>Trend</b><br>' +\n                          '<b>pH:</b> %{y:.4f}<br>' +\n                          '<extra></extra>'\n        ))\n    \n    # Add pre-industrial reference line\n    pre_industrial_ph = metadata['context']['pre_industrial_ph']\n    fig.add_hline(\n        y=pre_industrial_ph,\n        line=dict(color='#2E7D32', width=2, dash='dot'),\n        annotation_text=f'Pre-industrial pH (~{pre_industrial_ph})',\n        annotation_position='top left'\n    )\n    \n    # Add baseline reference (first full year)\n    first_ph = records[0]['ph_total']\n    fig.add_hline(\n        y=first_ph,\n        line=dict(color='#2E44B2', width=1, dash='dot'),\n        annotation_text=f'Baseline {records[0][\"year\"]} ({first_ph:.4f})',\n        annotation_position='top left',\n        annotation_font=dict(size=12, color=\"#2E44B2\")\n    )\n    \n    # Layout with REVERSED y-axis (more acidic goes down visually)\n    fig.update_layout(\n        title={\n            'text': f\"Ocean Acidification: Surface pH at {metadata['source']['station']}<br>\" +\n                    \"<sub>Lower pH = More Acidic Ocean | Monthly Measurements 1988-2023</sub>\",\n            'x': 0.5,\n            'xanchor': 'center',\n            'font': {'size': 16, 'color': '#1a1a1a'}\n        },\n        xaxis_title=\"Year\",\n        yaxis_title=\"pH (total scale)\",\n        yaxis=dict(\n            autorange='reversed',  # REVERSED: declining pH goes visually downward\n            tickformat='.3f'\n        ),\n        template=\"plotly_white\",\n        width=1200,\n        height=700,\n        hovermode='x unified',\n        showlegend=True,\n        legend=dict(x=0.02, y=0.98, bgcolor=\"rgba(255,255,255,0.8)\")\n    )\n    \n    # Calculate statistics for info box\n    latest_record = records[-1]\n    first_record = records[0]\n    ph_decline = first_record['ph_total'] - latest_record['ph_total']  # Positive = decline\n    years_span = latest_record['year'] - first_record['year']\n    annual_rate = metadata['statistics']['annual_rate']\n    \n    # Add information box\n    info_text = (\n        f\"<b>Latest Measurement</b><br>\"\n        f\"Date: {latest_record['year']}-{latest_record['month']:02d}<br>\"\n        f\"pH: <b>{latest_record['ph_total']:.4f}</b><br>\"\n        f\"<br>\"\n        f\"<b>Since {first_record['year']} ({years_span} years)</b><br>\"\n        f\"pH Decline: <b>{ph_decline:.4f} units</b><br>\"\n        f\"Rate: <b>{annual_rate:.5f} units/year</b><br>\"\n        f\"<br>\"\n        f\"<b>Context</b><br>\"\n        f\"Pre-industrial pH: ~{pre_industrial_ph}<br>\"\n        f\"Total decline since 1750: ~0.1 units<br>\"\n        f\"<br>\"\n        f\"<b>Impact</b><br>\"\n        f\"- Coral reef stress & bleaching<br>\"\n        f\"- Shellfish mortality (calcification)<br>\"\n        f\"- Food web disruption<br>\"\n        f\"- Ecosystem collapse risk<br>\"\n        f\"<br>\"\n        f\"<b>Understanding pH</b><br>\"\n        f\"<i>pH scale: Lower = More acidic</i><br>\"\n        f\"<i>Logarithmic: 0.1 drop = 30% -> acidity</i><br>\"\n        f\"<i>Fastest change in 300M years</i>\"\n    )\n    \n    fig.add_annotation(\n        text=info_text,\n        xref=\"paper\", yref=\"paper\",\n        x=0.80, y=0.02,\n        xanchor=\"left\", yanchor=\"bottom\",\n        bgcolor=\"rgba(255,255,255,0.9)\",\n        bordercolor=\"#0077BE\",\n        borderwidth=2,\n        borderpad=10,\n        showarrow=False,\n        font=dict(size=10),\n        align='left'\n    )\n    \n    # Add threat warning\n    threat_text = (\n        \"Ocean chemistry changing<br>\"\n        \"faster than any time in<br>\"\n        \"300 million years\"\n    )\n    \n    fig.add_annotation(\n        text=threat_text,\n        xref=\"paper\", yref=\"paper\",\n        x=0.40, y=0.98,\n        xanchor=\"right\", yanchor=\"top\",\n        bgcolor=\"rgba(255,200,200,0.8)\",\n        bordercolor=\"#C1121F\",\n        borderwidth=2,\n        borderpad=8,\n        showarrow=False,\n        font=dict(size=9, color=\"#C1121F\"),\n        align='left'\n    )\n    \n    # Add footer with source\n    fig.add_annotation(\n        text=f\"Data Source: {metadata['source']['organization']} | <a href=\\\"{metadata['source']['url']}\\\">{metadata['source']['url']}</a>\",\n        xref=\"paper\", yref=\"paper\",\n        x=0.5, y=-0.12,\n        xanchor=\"center\", yanchor=\"top\",\n        showarrow=False,\n        font=dict(size=9, color='gray')\n    )\n    \n    return fig",
    "start_line": 950,
    "end_line": 1120,
    "has_docstring": true,
    "docstring": "Create interactive ocean acidification (pH) visualization",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_ph_viz",
    "component_id": "earth_system_visualization_gui.create_ph_viz"
  },
  "earth_system_visualization_gui.create_planetary_boundaries_viz": {
    "id": "earth_system_visualization_gui.create_planetary_boundaries_viz",
    "name": "create_planetary_boundaries_viz",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [],
    "source_code": "def create_planetary_boundaries_viz():\n    \"\"\"\n    Planetary Boundaries - keep Tony's style & notes\n    - Split wedges: Climate (RF/CO2), Biosphere (Functional/Genetic), Biogeochemical (P/N), Freshwater (Green/Blue)\n    - Polar-locked labels so titles align with wedges\n    - Ocean Acidification normalized to 0.10 pH drop\n    - Small wedge gaps; boundary ring at 1.0 and high-risk ring at 1.6\n    \"\"\"\n    if not PLOTLY_AVAILABLE:\n        return None\n\n    # ---------- helpers ----------\n    def _safe_latest(records, key):\n        return records[-1].get(key, None) if records else None\n\n    def _normalize(val, boundary, clip=3.0):\n        if val is None or boundary is None or boundary <= 0:\n            return None\n        return min(val / boundary, clip)\n\n    def _color_for(norm):\n        # same smooth mapping you used: green -> orange -> deep red\n        if norm is None:\n            return \"#E8E8E8\"\n        if norm < 0.75:\n            t = norm / 0.75\n            return f\"rgb({int(60+80*t)},{int(150+40*t)},{int(60-10*t)})\"\n        if norm < 1.0:\n            t = (norm-0.75)/0.25\n            return f\"rgb({int(180+75*t)},{int(130+60*t)},{int(40-10*t)})\"\n        if norm < 1.6:\n            t = (norm-1.0)/0.6\n            return f\"rgb(255,{int(190-120*t)},{int(30-30*t)})\"\n        return \"rgb(220,50,40)\"\n\n    # ---------- live data for temp/pH/CO2 ----------\n    temp_data = load_temperature_data()\n    latest_temp_c = _safe_latest(temp_data['data'], 'anomaly_c') if temp_data and temp_data.get('data') else None\n\n    ph_data = load_ph_data()\n    latest_ph = _safe_latest(ph_data['records'], 'ph_total') if ph_data and ph_data.get('records') else None\n    ph_drop = (8.2319 - latest_ph) if (latest_ph is not None) else None  # live decline vs ~8.2319 Feb 1991\n\n    co2_data = load_co2_data() \n    latest_co2 = None\n    if co2_data and co2_data.get('data'):\n        latest_co2 = co2_data['data'][-1]['co2_ppm']    \n\n    # ---------- SRC 2025 normalized values (boundary=1.0, high-risk~ deg~1.6) ----------\n    SRC = {\n        \"CLIMATE_RF\": 2.56,   # Radiative forcing\n        \"CLIMATE_CO2\": 1.44,  # CO2 concentration\n        \"NOVEL\": 1.80,\n        \"OZONE\": 0.48,\n        \"AEROSOLS\": 0.80,\n        \"OCEAN_ACID\": 1.04,   # newly breached\n        \"FRESH_GREEN\": 0.95,  # soil moisture / ET regimes\n        \"FRESH_BLUE\": 1.16,   # surface/groundwater\n        \"LAND\": 1.46,\n        \"BIO_FUNC\": 2.00,     # functional diversity\n        \"BIO_GEN\": 1.60,      # genetic diversity (~ deg~)\n        \"BIOGEO_P\": 2.14,\n        \"BIOGEO_N\": 2.82\n    }\n\n    # ---------- wedges in SRC clockwise order (top = Climate RF) ----------\n    # IMPORTANT: climate wedges use src_value (value_raw=None) so they differ.\n    boundaries = [\n        dict(name=\"CLIMATE CHANGE\",                     subtext=\"Radiative forcing\",                    key=\"CLIMATE_RF\",   value_raw=None,     boundary=1.0,   src_value=SRC[\"CLIMATE_RF\"],    has_viz=False),\n        dict(name=\"CLIMATE CHANGE\",                     subtext=\"CO2 concentration\",                    key=\"CLIMATE_CO2\",  value_raw=None,     boundary=1.0,   src_value=SRC[\"CLIMATE_CO2\"],   has_viz=False),\n        dict(name=\"NOVEL ENTITIES\",                     subtext=\"\",                                     key=\"NOVEL\",        value_raw=None,     boundary=1.0,   src_value=SRC[\"NOVEL\"],         has_viz=False),\n        dict(name=\"STRATOSPHERIC<br>OZONE DEPLETION\",   subtext=\"\",                                     key=\"OZONE\",        value_raw=None,     boundary=1.0,   src_value=SRC[\"OZONE\"],         has_viz=False),\n        dict(name=\"ATMOSPHERIC AEROSOL<br>LOADING\",     subtext=\"\",                                     key=\"AEROSOLS\",     value_raw=None,     boundary=1.0,   src_value=SRC[\"AEROSOLS\"],      has_viz=False),\n        dict(name=\"OCEAN<br>ACIDIFICATION\",             subtext=\"\",                                     key=\"OCEAN_ACID\",   value_raw=None,     boundary=1.0,   src_value=SRC[\"OCEAN_ACID\"],    has_viz=False),\n        dict(name=\"FRESHWATER<br>CHANGE\",               subtext=\"Green water (soil moisture)\",          key=\"FRESH_GREEN\",  value_raw=None,     boundary=1.0,   src_value=SRC[\"FRESH_GREEN\"],   has_viz=False),\n        dict(name=\"FRESHWATER<br>CHANGE\",               subtext=\"Blue water (liquid)\",                  key=\"FRESH_BLUE\",   value_raw=None,     boundary=1.0,   src_value=SRC[\"FRESH_BLUE\"],    has_viz=False),\n        dict(name=\"LAND-SYSTEM<br>CHANGE\",              subtext=\"\",                                     key=\"LAND\",         value_raw=None,     boundary=1.0,   src_value=SRC[\"LAND\"],          has_viz=False),\n        dict(name=\"BIOSPHERE INTEGRITY\",                subtext=\"Functional\",                           key=\"BIO_FUNC\",     value_raw=None,     boundary=1.0,   src_value=SRC[\"BIO_FUNC\"],      has_viz=False),\n        dict(name=\"BIOSPHERE INTEGRITY\",                subtext=\"Genetic\",                              key=\"BIO_GEN\",      value_raw=None,     boundary=1.0,   src_value=SRC[\"BIO_GEN\"],       has_viz=False),\n        dict(name=\"BIOGEOCHEMICAL<br>FLOWS\",            subtext=\"Phosphorus\",                           key=\"BIOGEO_P\",     value_raw=None,     boundary=1.0,   src_value=SRC[\"BIOGEO_P\"],      has_viz=False),\n        dict(name=\"BIOGEOCHEMICAL<br>FLOWS\",            subtext=\"Nitrogen\",                             key=\"BIOGEO_N\",     value_raw=None,     boundary=1.0,   src_value=SRC[\"BIOGEO_N\"],      has_viz=False),\n    ]\n\n    # ---------- compute normalized radii ----------\n    names, radii, colors, hovertext = [], [], [], []\n    for b in boundaries:\n        names.append(b[\"name\"])\n        if b[\"value_raw\"] is not None:\n            norm = _normalize(b[\"value_raw\"], b[\"boundary\"])\n        else:\n            norm = b[\"src_value\"]\n        radii.append(norm if norm is not None else 0.1)\n        colors.append(_color_for(norm))\n\n        # build hover text (keep your concise tone)\n        zone = (\"Safe operating space\" if norm < 1.0 else\n                \"Increasing risk / zone of uncertainty\" if norm < 1.6 else\n                \"High risk (transgressed)\")\n        live_note = \"\"\n        if b[\"key\"] == \"OCEAN_ACID\":\n            if ph_drop is not None:\n                live_note = f\"<br>Live pH decline from Feb 1991: {ph_drop:.3f} \"\n                \"(norm {min(ph_drop/0.10,3.0):.2f})\"\n            else:\n                live_note = f\"<br>SRC 2025: {SRC['OCEAN_ACID']:.2f}\"\n        elif b[\"key\"] == \"CLIMATE_CO2\":\n            if latest_co2 is not None:\n                live_note = f\"<br>Live CO2: {latest_co2:.1f} ppm (boundary: 350 ppm)\"\n            else:\n                live_note = f\"<br>SRC 2025: {SRC['CLIMATE_CO2']:.2f}\"                \n        hovertext.append(\n            f\"<b>{b['name'].replace('<br>', ' ')}</b><br>{b['subtext']}\"\n            f\"<br>Normalized: {radii[-1]:.2f}<br>Status: {zone}{live_note}\"\n        )\n\n    # ---------- figure ----------\n    fig = go.Figure()\n\n    # green safe-space core + rings (keeps your look)\n    circle_theta = list(range(0, 361, 3))\n    r_boundary = [1.0] * len(circle_theta)\n    r_highrisk = [1.6] * len(circle_theta)\n\n    fig.add_trace(go.Scatterpolar(\n        r=r_boundary, theta=circle_theta, fill='toself',\n        fillcolor='rgba(76,175,80,0.20)', line=dict(color='rgba(0,0,0,0)'),\n        hoverinfo='skip', showlegend=False\n    ))\n    fig.add_trace(go.Scatterpolar(\n        r=r_boundary, theta=circle_theta, mode='lines',\n        line=dict(color='#4CAF50', width=2, dash='dash'),\n        hoverinfo='skip', showlegend=False\n    ))\n    fig.add_trace(go.Scatterpolar(\n        r=r_highrisk, theta=circle_theta, mode='lines',\n        line=dict(color='#E53935', width=1, dash='dot'),\n        hoverinfo='skip', showlegend=False\n    ))\n\n    # polar geometry -> centers + tiny gap so separators read cleanly\n    N = len(boundaries)\n    base_wedge_width = 360.0 / N\n    theta_positions = [i * base_wedge_width for i in range(N)]\n    wedge_widths = [base_wedge_width * 0.96] * N  # small gap, keeps your style\n\n    # main wedge layer (your flat style; keep opacity)\n    fig.add_trace(go.Barpolar(\n        r=radii,\n        theta=theta_positions,\n        width=wedge_widths,\n        marker_color=colors,\n        marker_line_color=colors,\n        marker_line_width=0,\n        hovertext=hovertext,\n        hovertemplate=\"%{hovertext}<extra></extra>\",\n        opacity=0.85,\n        name=\"Planetary Boundaries\"\n    ))\n\n    # layout (keep your orientation & page look)\n    fig.update_layout(\n        title=dict(\n            text=(\"<b>Planetary Boundaries</b><br>\"\n                  \"<sub>Stockholm Resilience Centre framework with live climate data integration</sub>\"),\n            x=0.5, xanchor=\"center\", font=dict(size=20, family=\"Arial\", color=\"#2C3E50\")\n        ),\n        template=\"plotly_white\",\n        polar=dict(\n            angularaxis=dict(\n                showline=False, ticks=\"\", showticklabels=False,\n                direction=\"clockwise\", rotation=90   # top = Climate RF\n            ),\n            radialaxis=dict(range=[0, 3.0], showline=False, ticks=\"\", showticklabels=False, showgrid=False),\n            bgcolor=\"white\"\n        ),\n        showlegend=False,\n        width=1200, height=1100,\n        margin=dict(t=100, b=260, l=140, r=140),\n        paper_bgcolor=\"white\",\n        plot_bgcolor=\"white\"\n    )\n\n    # ---------- POLAR-LOCKED LABELS (align with wedges; keep your text style) ----------\n    label_r = [1.90] * N\n#    label_theta = [th + base_wedge_width/2 for th in theta_positions]\n    label_theta = theta_positions\n    label_texts = []\n    for b in boundaries:\n        main = f\"<b>{b['name']}</b>\"\n        sub = f\"<br><span style='font-size:9px;color:#666'><i>{b['subtext']}</i></span>\" if b['subtext'] else \"\"\n        label_texts.append(main + sub)\n\n    # small leader lines\n    for ang in label_theta:\n        fig.add_trace(go.Scatterpolar(\n            r=[1.62, 1.84], theta=[ang, ang], mode=\"lines\",\n            line=dict(color=\"#999\", width=1), hoverinfo=\"skip\", showlegend=False\n        ))\n\n    fig.add_trace(go.Scatterpolar(\n        r=label_r, theta=label_theta, mode=\"text\",\n        text=label_texts, hoverinfo=\"skip\", showlegend=False,\n        textfont=dict(size=10, color=\"#000\", family=\"Arial\")\n    ))\n\n    # center tag (your wording)\n    fig.add_annotation(\n        text=\"<b>Safe operating space</b>\",\n        xref=\"paper\", yref=\"paper\", x=0.5, y=0.60, showarrow=False,\n        font=dict(size=12, color=\"#4CAF50\"), bgcolor=\"rgba(255,255,255,0)\", borderpad=10\n    )\n\n    # status box (keep your tone; show live temp & pH if present)\n    live_count = sum(1 for b in boundaries if b['value_raw'] is not None)\n    live_text = \"<b>Planetary Health Check 2025</b><br><br>7/9 boundaries transgressed\"\n    if latest_temp_c is not None:\n        live_text += f\"<br>Temp anomaly (live): <b>{latest_temp_c:.3f} degC</b>\"\n    if ph_drop is not None:\n        live_text += f\"<br>Ocean pH decline (live): <b>{ph_drop:.3f}</b>\"\n#        \"</b> (norm {min(ph_drop/0.10,3.0):.2f})\"\n#    live_text += f\"<br><br>Live Data Integration: {live_count}/13\"\n    if latest_co2 is not None:\n        live_text += f\"<br>CO2 concentration (live): <b>{latest_co2:.1f} ppm</b>\"\n\n    fig.add_annotation(\n        text=live_text,\n        xref=\"paper\", yref=\"paper\",\n        x=0.15, y=0.1, xanchor=\"left\", yanchor=\"top\",\n        bgcolor=\"rgba(255,255,255,0.95)\", bordercolor=\"#2196F3\",\n        borderwidth=2, borderpad=12, showarrow=False,\n        font=dict(size=9), align=\"left\"\n    )\n\n    # your legend box (keep style)\n    legend_text = (\n        \"<b>Risk Zones:</b><br>\"\n        \"- Safe operating space (green)<br>\"\n        \"- Increasing risk (orange)<br>\"\n        \"- High risk (red)<br>\"\n        \"- No data (gray)<br>\"\n        \"<br><b>Reference lines:</b><br>\"\n        \"- Planetary Boundary<br>\"\n        \"- High-risk Line\"\n    )\n    fig.add_annotation(\n        text=legend_text,\n        xref=\"paper\", yref=\"paper\",\n        x=0.94, y=1.10, xanchor=\"right\", yanchor=\"top\",\n        bgcolor=\"rgba(255,255,255,0.95)\", bordercolor=\"#999\",\n        borderwidth=1, borderpad=10, showarrow=False,\n        font=dict(size=9), align=\"left\"\n    )\n\n    # attribution / framework note (keep your long footer style)\n    attribution_text = (\n        \"<b>Framework Attribution:</b><br>\"\n        \"The 2025 update to the Planetary boundaries.<br>\"\n        \"Licensed under <a href='https://creativecommons.org/licenses/by-nc-nd/3.0/'>CC BY-NC-ND 3.0</a>.<br>\"\n        \"Credit: Azote for Stockholm Resilience Centre, based on analysis in Sakschewski and Caesar et al. 2025.<br>\"\n        \"<b>Live data:</b> Temperature (NASA GISS), Ocean pH (HOT / BCO-DMO).\"\n    )\n    fig.add_annotation(\n        text=attribution_text,\n        xref=\"paper\", yref=\"paper\",\n        x=0.75, y=0.1, xanchor=\"center\", yanchor=\"top\",\n        bgcolor=\"rgba(250,250,250,0.98)\", bordercolor=\"#999\",\n        borderwidth=1, borderpad=12, showarrow=False,\n        font=dict(size=8, color=\"#555\"), align=\"left\"\n    )\n\n    # educational callout (keep your box tone)\n    fig.add_annotation(\n        text=(\"Understanding Planetary Boundaries</b><br>\"\n              \"Nine Earth-system processes regulate planetary stability. Transgressing<br>\" \n              \"these boundaries increases the risk of abrupt or irreversible<br>\" \n              \"environmental change. This visualization keeps the SRC design<br>\" \n              \"while linking to our live climate data for education and context.\"),\n        xref=\"paper\", yref=\"paper\",\n        x=0.06, y=1.10, xanchor=\"center\", yanchor=\"top\",\n        bgcolor=\"rgba(255,252,240,0.95)\", bordercolor=\"#F39C12\",\n        borderwidth=1, borderpad=10, showarrow=False,\n        font=dict(size=9, color=\"#666\"), align=\"center\"\n    )\n\n    return fig",
    "start_line": 1122,
    "end_line": 1406,
    "has_docstring": true,
    "docstring": "Planetary Boundaries - keep Tony's style & notes\n- Split wedges: Climate (RF/CO2), Biosphere (Functional/Genetic), Biogeochemical (P/N), Freshwater (Green/Blue)\n- Polar-locked labels so titles align with wedges\n- Ocean Acidification normalized to 0.10 pH drop\n- Small wedge gaps; boundary ring at 1.0 and high-risk ring at 1.6",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_planetary_boundaries_viz",
    "component_id": "earth_system_visualization_gui.create_planetary_boundaries_viz"
  },
  "earth_system_visualization_gui._safe_latest": {
    "id": "earth_system_visualization_gui._safe_latest",
    "name": "_safe_latest",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [],
    "source_code": "    def _safe_latest(records, key):\n        return records[-1].get(key, None) if records else None",
    "start_line": 1134,
    "end_line": 1135,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "records",
      "key"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _safe_latest",
    "component_id": "earth_system_visualization_gui._safe_latest"
  },
  "earth_system_visualization_gui._normalize": {
    "id": "earth_system_visualization_gui._normalize",
    "name": "_normalize",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [],
    "source_code": "    def _normalize(val, boundary, clip=3.0):\n        if val is None or boundary is None or boundary <= 0:\n            return None\n        return min(val / boundary, clip)",
    "start_line": 1137,
    "end_line": 1140,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "val",
      "boundary",
      "clip"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _normalize",
    "component_id": "earth_system_visualization_gui._normalize"
  },
  "earth_system_visualization_gui._color_for": {
    "id": "earth_system_visualization_gui._color_for",
    "name": "_color_for",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [],
    "source_code": "    def _color_for(norm):\n        # same smooth mapping you used: green -> orange -> deep red\n        if norm is None:\n            return \"#E8E8E8\"\n        if norm < 0.75:\n            t = norm / 0.75\n            return f\"rgb({int(60+80*t)},{int(150+40*t)},{int(60-10*t)})\"\n        if norm < 1.0:\n            t = (norm-0.75)/0.25\n            return f\"rgb({int(180+75*t)},{int(130+60*t)},{int(40-10*t)})\"\n        if norm < 1.6:\n            t = (norm-1.0)/0.6\n            return f\"rgb(255,{int(190-120*t)},{int(30-30*t)})\"\n        return \"rgb(220,50,40)\"",
    "start_line": 1142,
    "end_line": 1155,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "norm"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _color_for",
    "component_id": "earth_system_visualization_gui._color_for"
  },
  "earth_system_visualization_gui.open_ph_viz": {
    "id": "earth_system_visualization_gui.open_ph_viz",
    "name": "open_ph_viz",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "save_utils.save_plot",
      "earth_system_visualization_gui.create_ph_viz"
    ],
    "source_code": "def open_ph_viz():\n    \"\"\"Open ocean pH visualization in browser\"\"\"\n    try:\n        fig = create_ph_viz()\n        if fig:\n            fig.show()\n            # Save to output directory\n            save_plot(fig, \"ocean_acidification_ph_trend\")\n        else:\n            messagebox.showerror(\n                \"Data Not Available\",\n                \"Ocean pH data not found.\\n\\n\"\n                \"Please download HOT data and run convert_hot_ph_to_json.py first.\"\n            )\n    except Exception as e:\n        messagebox.showerror(\n            \"Visualization Error\",\n            f\"Error creating pH visualization:\\n\\n{str(e)}\"\n        )",
    "start_line": 1410,
    "end_line": 1428,
    "has_docstring": true,
    "docstring": "Open ocean pH visualization in browser",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function open_ph_viz",
    "component_id": "earth_system_visualization_gui.open_ph_viz"
  },
  "earth_system_visualization_gui.open_planetary_boundaries": {
    "id": "earth_system_visualization_gui.open_planetary_boundaries",
    "name": "open_planetary_boundaries",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "earth_system_visualization_gui.create_planetary_boundaries_viz",
      "save_utils.save_plot"
    ],
    "source_code": "def open_planetary_boundaries():\n    \"\"\"Open Planetary Boundaries visualization in browser\"\"\"\n    try:\n        fig = create_planetary_boundaries_viz()\n        if fig:\n            fig.show()\n            save_plot(fig, \"planetary_boundaries\")\n        else:\n            messagebox.showerror(\n                \"Visualization Error\",\n                \"Could not create Planetary Boundaries visualization.\\n\\n\"\n                \"Please ensure Plotly is installed.\"\n            )\n    except Exception as e:\n        messagebox.showerror(\n            \"Visualization Error\",\n            f\"Error creating Planetary Boundaries visualization:\\n\\n{str(e)}\"\n        )        ",
    "start_line": 1430,
    "end_line": 1447,
    "has_docstring": true,
    "docstring": "Open Planetary Boundaries visualization in browser",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function open_planetary_boundaries",
    "component_id": "earth_system_visualization_gui.open_planetary_boundaries"
  },
  "earth_system_visualization_gui.open_paleoclimate_viz": {
    "id": "earth_system_visualization_gui.open_paleoclimate_viz",
    "name": "open_paleoclimate_viz",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "save_utils.save_plot",
      "paleoclimate_wet_bulb_full.create_paleoclimate_visualization"
    ],
    "source_code": "def open_paleoclimate_viz():\n    \"\"\"Open Cenozoic paleoclimate visualization\"\"\"\n    try:\n        fig = create_paleoclimate_visualization()\n        if fig:\n            fig.show()\n            # Offer to save\n            save_plot(fig, \"paleoclimate_cenozoic_66Ma\")\n        else:\n            messagebox.showerror(\n                \"Data Not Available\",\n                \"Paleoclimate data not found. Please run fetch_paleoclimate_data.py first.\"\n            )\n    except Exception as e:\n        messagebox.showerror(\"Visualization Error\", f\"Could not create visualization:\\n{str(e)}\")",
    "start_line": 1450,
    "end_line": 1464,
    "has_docstring": true,
    "docstring": "Open Cenozoic paleoclimate visualization",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function open_paleoclimate_viz",
    "component_id": "earth_system_visualization_gui.open_paleoclimate_viz"
  },
  "earth_system_visualization_gui.open_paleoclimate_dual_scale_viz": {
    "id": "earth_system_visualization_gui.open_paleoclimate_dual_scale_viz",
    "name": "open_paleoclimate_dual_scale_viz",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "paleoclimate_dual_scale.create_paleoclimate_dual_scale_visualization",
      "save_utils.save_plot"
    ],
    "source_code": "def open_paleoclimate_dual_scale_viz():\n    \"\"\"Open dual-scale paleoclimate visualization (modern + deep time)\"\"\"\n    try:\n        fig = create_paleoclimate_dual_scale_visualization()\n        if fig:\n            fig.show()\n            # Offer to save\n            save_plot(fig, \"paleoclimate_dual_scale\")\n        else:\n            messagebox.showerror(\n                \"Data Not Available\",\n                \"Paleoclimate data not found. Please run fetch_paleoclimate_data.py first.\"\n            )\n    except Exception as e:\n        messagebox.showerror(\"Visualization Error\", f\"Could not create visualization:\\n{str(e)}\")        ",
    "start_line": 1467,
    "end_line": 1481,
    "has_docstring": true,
    "docstring": "Open dual-scale paleoclimate visualization (modern + deep time)",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function open_paleoclimate_dual_scale_viz",
    "component_id": "earth_system_visualization_gui.open_paleoclimate_dual_scale_viz"
  },
  "earth_system_visualization_gui.open_phanerozoic_viz": {
    "id": "earth_system_visualization_gui.open_phanerozoic_viz",
    "name": "open_phanerozoic_viz",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "save_utils.save_plot"
    ],
    "source_code": "def open_phanerozoic_viz():\n    \"\"\"Open Phanerozoic (540 Ma) paleoclimate visualization\"\"\"\n    try:\n        fig = create_phanerozoic_viz()\n        if fig:\n            fig.show()\n            # Offer to save\n            save_plot(fig, \"paleoclimate_540Ma_to_present\")\n        else:\n            messagebox.showerror(\n                \"Data Not Available\",\n                \"Phanerozoic temperature data not found.\\n\\n\"\n                \"Required files:\\n\"\n                \"* data/8c__Phanerozoic_Pole_to_Equator_Temperatures.csv\\n\"\n                \"* data/lr04_benthic_stack.json\\n\"\n                \"* data/temp12k_allmethods_percentiles.csv (optional)\\n\"\n                \"* data/temperature_giss_monthly.json (optional)\"\n            )\n    except Exception as e:\n        messagebox.showerror(\"Visualization Error\", f\"Could not create Phanerozoic visualization:\\n{str(e)}\")        ",
    "start_line": 1484,
    "end_line": 1503,
    "has_docstring": true,
    "docstring": "Open Phanerozoic (540 Ma) paleoclimate visualization",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function open_phanerozoic_viz",
    "component_id": "earth_system_visualization_gui.open_phanerozoic_viz"
  },
  "earth_system_visualization_gui.open_human_origins_viz": {
    "id": "earth_system_visualization_gui.open_human_origins_viz",
    "name": "open_human_origins_viz",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "save_utils.save_plot"
    ],
    "source_code": "def open_human_origins_viz():\n    \"\"\"Open Paleoclimate + Human Origins visualization (540 Ma + 25 hominin species)\"\"\"\n    try:\n        fig = create_human_origins_viz()\n        if fig:\n            fig.show()\n            # Save to output directory\n            save_plot(fig, \"paleoclimate_human_origins\")\n        else:\n            messagebox.showerror(\n                \"Data Not Available\",\n                \"Paleoclimate data not found.\\n\\n\"\n                \"Please ensure the following files exist:\\n\"\n                \"* data/8c__Phanerozoic_Pole_to_Equator_Temperatures.csv\\n\"\n                \"* data/lr04_benthic_stack.json\\n\"\n                \"* data/temp12k_allmethods_percentiles.csv (optional)\\n\"\n                \"* data/temperature_giss_monthly.json (optional)\"\n            )\n    except Exception as e:\n        messagebox.showerror(\"Visualization Error\", f\"Could not create Human Origins visualization:\\n{str(e)}\")        ",
    "start_line": 1505,
    "end_line": 1524,
    "has_docstring": true,
    "docstring": "Open Paleoclimate + Human Origins visualization (540 Ma + 25 hominin species)",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function open_human_origins_viz",
    "component_id": "earth_system_visualization_gui.open_human_origins_viz"
  },
  "earth_system_visualization_gui.open_sea_level_viz": {
    "id": "earth_system_visualization_gui.open_sea_level_viz",
    "name": "open_sea_level_viz",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "earth_system_visualization_gui.create_sea_level_viz",
      "save_utils.save_plot"
    ],
    "source_code": "def open_sea_level_viz():\n    \"\"\"Open sea level visualization in browser\"\"\"\n    try:\n        fig = create_sea_level_viz()\n        if fig:\n            fig.show()\n            # Save to output directory\n            save_plot(fig, \"sea_level_rise\")\n        else:\n            messagebox.showerror(\n                \"Data Not Available\",\n                \"Sea level data not found.\\n\\n\"\n                \"Please run fetch_climate_data.py first to download the data.\"\n            )\n    except Exception as e:\n        messagebox.showerror(\n            \"Visualization Error\",\n            f\"Error creating sea level visualization:\\n\\n{str(e)}\"\n        )",
    "start_line": 1526,
    "end_line": 1544,
    "has_docstring": true,
    "docstring": "Open sea level visualization in browser",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function open_sea_level_viz",
    "component_id": "earth_system_visualization_gui.open_sea_level_viz"
  },
  "earth_system_visualization_gui.open_keeling_curve": {
    "id": "earth_system_visualization_gui.open_keeling_curve",
    "name": "open_keeling_curve",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "earth_system_visualization_gui.create_keeling_curve",
      "save_utils.save_plot"
    ],
    "source_code": "def open_keeling_curve():\n    \"\"\"Open Keeling Curve in browser\"\"\"\n    try:\n        fig = create_keeling_curve()\n        if fig:\n            fig.show()\n            # Save to output directory\n            save_plot(fig, \"keeling_curve_co2_concentration\")\n        else:\n            messagebox.showerror(\"Data Not Found\", \n                \"CO2 data file not found. Please run fetch_climate_data.py first.\")\n    except Exception as e:\n        messagebox.showerror(\"Error\", f\"Failed to create visualization:\\n{str(e)}\")",
    "start_line": 1547,
    "end_line": 1559,
    "has_docstring": true,
    "docstring": "Open Keeling Curve in browser",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function open_keeling_curve",
    "component_id": "earth_system_visualization_gui.open_keeling_curve"
  },
  "earth_system_visualization_gui.open_temperature_viz": {
    "id": "earth_system_visualization_gui.open_temperature_viz",
    "name": "open_temperature_viz",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "earth_system_visualization_gui.create_temperature_viz",
      "save_utils.save_plot"
    ],
    "source_code": "def open_temperature_viz():\n    \"\"\"Open temperature visualization in browser\"\"\"\n    try:\n        fig = create_temperature_viz()\n        if fig:\n            fig.show()\n            # Save to output directory\n            save_plot(fig, \"global_temperature_anomalies\")\n        else:\n            messagebox.showerror(\"Data Not Found\",\n                \"Temperature data file not found. Please run fetch_climate_data.py first.\")\n    except Exception as e:\n        messagebox.showerror(\"Error\", f\"Failed to create visualization:\\n{str(e)}\")",
    "start_line": 1561,
    "end_line": 1573,
    "has_docstring": true,
    "docstring": "Open temperature visualization in browser",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function open_temperature_viz",
    "component_id": "earth_system_visualization_gui.open_temperature_viz"
  },
  "earth_system_visualization_gui.open_ice_viz": {
    "id": "earth_system_visualization_gui.open_ice_viz",
    "name": "open_ice_viz",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "save_utils.save_plot",
      "earth_system_visualization_gui.create_ice_viz"
    ],
    "source_code": "def open_ice_viz():\n    \"\"\"Open Arctic ice visualization in browser\"\"\"\n    try:\n        fig = create_ice_viz()\n        if fig:\n            fig.show()\n                # Save to output directory  \n            save_plot(fig, \"arctic_ice_extent\")\n        else:\n            messagebox.showerror(\"Data Not Found\",\n                \"Arctic ice data file not found.\\n\\n\"\n                \"The file data/arctic_ice_extent_monthly.json contains manually preserved data.\\n\"\n                \"Automated fetch failed due to NSIDC infrastructure issues.\")\n    except Exception as e:\n        messagebox.showerror(\"Error\", f\"Failed to create visualization:\\n{str(e)}\")",
    "start_line": 1575,
    "end_line": 1589,
    "has_docstring": true,
    "docstring": "Open Arctic ice visualization in browser",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function open_ice_viz",
    "component_id": "earth_system_visualization_gui.open_ice_viz"
  },
  "earth_system_visualization_gui.open_energy_imbalance": {
    "id": "earth_system_visualization_gui.open_energy_imbalance",
    "name": "open_energy_imbalance",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "energy_imbalance.create_energy_imbalance_visualization",
      "save_utils.save_plot"
    ],
    "source_code": "def open_energy_imbalance():\n    \"\"\"Open energy imbalance visualization in browser\"\"\"\n    try:\n        fig = create_energy_imbalance_visualization()\n        if fig:\n            fig.show()\n            # Save to output directory\n            save_plot(fig, \"energy_imbalance\")\n        else:\n            messagebox.showerror(\"Data Not Found\",\n                \"Required climate data not found. Please run fetch_climate_data.py first.\")\n    except Exception as e:\n        messagebox.showerror(\"Error\", f\"Failed to create visualization:\\n{str(e)}\")",
    "start_line": 1591,
    "end_line": 1603,
    "has_docstring": true,
    "docstring": "Open energy imbalance visualization in browser",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function open_energy_imbalance",
    "component_id": "earth_system_visualization_gui.open_energy_imbalance"
  },
  "earth_system_visualization_gui.run_update_in_thread": {
    "id": "earth_system_visualization_gui.run_update_in_thread",
    "name": "run_update_in_thread",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [],
    "source_code": "def run_update_in_thread(update_button, status_label, window):\n    \"\"\"Run climate data update in background thread\"\"\"\n    try:\n        import climate_cache_manager\n        from tkinter import messagebox\n        \n        # Show initial warning dialog with time estimate\n        response = messagebox.askyesno(\n            \"Update Climate Data\",\n            \"This will download the latest climate data from NASA, NOAA, and NSIDC.\\n\\n\"\n            \" Expected time: ~30 seconds\\n\"\n            \"Datasets: CO2, Temperature, Arctic Ice\\n\\n\"\n            \"Progress will be shown in the console window.\\n\\n\"\n            \"Continue with update?\",\n            icon='question'\n        )\n        \n        if not response:\n            return  # User clicked No\n        \n        # Disable button during update\n        update_button.config(state='disabled', text=' Updating...')\n        status_label.config(text=\"Updating... (check console for progress)\")\n        \n        def update_thread():\n            # FIXED: Unpack all 3 return values\n            success, message, details = climate_cache_manager.update_climate_data()\n            \n            # Re-enable button and show result (using window.after for thread safety)\n            window.after(0, lambda: update_button.config(state='normal', text=' Update Climate Data'))\n            window.after(0, lambda: status_label.config(text=\"\"))\n            \n            if success:\n                # Show detailed success message\n                detail_msg = message\n                if details:\n                    detail_msg += \"\\n\\nDetails:\\n\"\n                    for dataset, info in details.items():\n                        if info.get('success'):\n                            detail_msg += f\"  [OK] {dataset.upper()}: {info['records']} records\\n\"\n                        else:\n                            detail_msg += f\"  [FAIL]' {dataset.upper()}: {info.get('error', 'Failed')}\\n\"\n                \n                window.after(0, lambda: messagebox.showinfo(\"[OK] Update Complete\", detail_msg))\n            else:\n                window.after(0, lambda: messagebox.showerror(\"[FAIL]' Update Failed\", message))\n        \n        # Start thread\n        thread = threading.Thread(target=update_thread, daemon=True)\n        thread.start()\n        \n    except ImportError:\n        messagebox.showwarning(\"Update Unavailable\",\n            \"Climate cache manager not found.\\n\"\n            \"Run fetch_climate_data.py manually to update data.\")\n    except Exception as e:\n        messagebox.showerror(\"Error\", f\"Update failed:\\n{str(e)}\")\n        update_button.config(state='normal', text=' Update Climate Data')\n        status_label.config(text=\"\")",
    "start_line": 1605,
    "end_line": 1663,
    "has_docstring": true,
    "docstring": "Run climate data update in background thread",
    "parameters": [
      "update_button",
      "status_label",
      "window"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function run_update_in_thread",
    "component_id": "earth_system_visualization_gui.run_update_in_thread"
  },
  "earth_system_visualization_gui.update_thread": {
    "id": "earth_system_visualization_gui.update_thread",
    "name": "update_thread",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "climate_cache_manager.update_climate_data"
    ],
    "source_code": "        def update_thread():\n            # FIXED: Unpack all 3 return values\n            success, message, details = climate_cache_manager.update_climate_data()\n            \n            # Re-enable button and show result (using window.after for thread safety)\n            window.after(0, lambda: update_button.config(state='normal', text=' Update Climate Data'))\n            window.after(0, lambda: status_label.config(text=\"\"))\n            \n            if success:\n                # Show detailed success message\n                detail_msg = message\n                if details:\n                    detail_msg += \"\\n\\nDetails:\\n\"\n                    for dataset, info in details.items():\n                        if info.get('success'):\n                            detail_msg += f\"  [OK] {dataset.upper()}: {info['records']} records\\n\"\n                        else:\n                            detail_msg += f\"  [FAIL]' {dataset.upper()}: {info.get('error', 'Failed')}\\n\"\n                \n                window.after(0, lambda: messagebox.showinfo(\"[OK] Update Complete\", detail_msg))\n            else:\n                window.after(0, lambda: messagebox.showerror(\"[FAIL]' Update Failed\", message))",
    "start_line": 1629,
    "end_line": 1650,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function update_thread",
    "component_id": "earth_system_visualization_gui.update_thread"
  },
  "earth_system_visualization_gui.open_wet_bulb_viz": {
    "id": "earth_system_visualization_gui.open_wet_bulb_viz",
    "name": "open_wet_bulb_viz",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "save_utils.save_plot"
    ],
    "source_code": "def open_wet_bulb_viz():\n    \"\"\"Open Wet Bulb Temperature paleoclimate visualization\"\"\"\n    try:\n        fig = create_wet_bulb_viz()\n        if fig:\n            fig.show()\n            save_plot(fig, \"paleoclimate_wet_bulb\")\n        else:\n            messagebox.showerror(\n                \"Data Not Available\",\n                \"Wet bulb temperature data not found.\\n\\n\"\n                \"Required files:\\n\"\n                \"* data/8c__Phanerozoic_Pole_to_Equator_Temperatures.csv\\n\"\n                \"* data/lr04_benthic_stack.json\"\n            )\n    except Exception as e:\n        messagebox.showerror(\"Visualization Error\", f\"Could not create Wet Bulb visualization:\\n{str(e)}\")",
    "start_line": 1665,
    "end_line": 1681,
    "has_docstring": true,
    "docstring": "Open Wet Bulb Temperature paleoclimate visualization",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function open_wet_bulb_viz",
    "component_id": "earth_system_visualization_gui.open_wet_bulb_viz"
  },
  "earth_system_visualization_gui.open_google_earth_controller": {
    "id": "earth_system_visualization_gui.open_google_earth_controller",
    "name": "open_google_earth_controller",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [],
    "source_code": "def open_google_earth_controller():\n    \"\"\"Launch the Google Earth KML layer controller\"\"\"\n    try:\n        # Get the directory where this script is located\n        script_dir = os.path.dirname(os.path.abspath(__file__))\n        controller_path = os.path.join(script_dir, 'earth_system_controller.py')\n        \n        if os.path.exists(controller_path):\n            subprocess.Popen(['python', controller_path], cwd=script_dir)\n        else:\n            messagebox.showerror(\"Not Found\", \n                f\"Could not find earth_system_controller.py\\nExpected at: {controller_path}\")\n    except Exception as e:\n        messagebox.showerror(\"Error\", f\"Failed to launch controller: {e}\")",
    "start_line": 1683,
    "end_line": 1696,
    "has_docstring": true,
    "docstring": "Launch the Google Earth KML layer controller",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function open_google_earth_controller",
    "component_id": "earth_system_visualization_gui.open_google_earth_controller"
  },
  "earth_system_visualization_gui.open_earth_system_gui": {
    "id": "earth_system_visualization_gui.open_earth_system_gui",
    "name": "open_earth_system_gui",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_system_visualization_gui.py",
    "relative_path": "earth_system_visualization_gui.py",
    "depends_on": [
      "earth_system_visualization_gui.run_update_in_thread"
    ],
    "source_code": "def open_earth_system_gui(parent=None):\n    \"\"\"\n    Open Earth System Visualization hub window\n    \"\"\"\n    if not PLOTLY_AVAILABLE:\n        messagebox.showerror(\"Missing Dependency\",\n            \"Plotly is required for visualizations.\\n\"\n            \"Install with: pip install plotly\")\n        return\n    \n    # Create window\n    window = tk.Toplevel(parent) if parent else tk.Tk()\n    window.title(\"[EARTH] Earth System Visualization\")\n\n    window.geometry(\"1200x900+150+0\")  # Wider window for two columns \"WIDTHxHEIGHT+X_POSITION+Y_POSITION\"\n    \n    # Header\n    header_frame = tk.Frame(window, bg='#2E86AB', height=80)\n    header_frame.pack(fill='x')\n    header_frame.pack_propagate(False)\n    \n    title_label = tk.Label(header_frame, \n                          text=\"Earth System Visualization\",\n                          font=('Arial', 18, 'bold'),\n                          bg='#2E86AB',\n                          fg='white')\n    title_label.pack(pady=5)\n    \n    subtitle_label = tk.Label(header_frame,\n                             text=\"Data Preservation is Climate Action\",\n                             font=('Arial', 10, 'italic'),\n                             bg='#2E86AB',\n                             fg='white')\n    subtitle_label.pack()\n    \n    # Main content frame\n    content_frame = tk.Frame(window, padx=20, pady=20)\n    content_frame.pack(fill='both', expand=True)\n    \n    # Description\n    desc_label = tk.Label(content_frame,\n                         text=\"Select a visualization to explore Earth's changing systems.\\n\"\n                         \"Each chart shows critical data about our planet's health.\",\n                         font=('Arial', 10),\n                         justify='left',\n                         wraplength=550)\n    desc_label.pack(anchor='w', pady=(0, 15))\n    \n    # Update Data button (prominent at top)\n    update_frame = tk.Frame(content_frame, relief='solid', borderwidth=1, bg='#E8F5E9')\n    update_frame.pack(fill='x', pady=(0, 10))\n    \n    update_button = tk.Button(update_frame,\n                             text='Update Climate Data',\n                             font=('Arial', 11, 'bold'),\n                             bg='#90EE90',\n                             fg='black',\n                             activebackground='#7BC97B',\n                             cursor='hand2',\n                             padx=20,\n                             pady=10,\n                             command=lambda: run_update_in_thread(update_button, status_label, window))\n    update_button.pack(fill='x', padx=10, pady=10)\n      \n    \n    update_desc = tk.Label(update_frame,\n                        text=\"Click to download latest data from NASA and NOAA (CO2, Temperature, Arctic Ice)\",\n                        font=('Arial', 9),\n                        bg='#E8F5E9',\n                        fg='#555')\n    update_desc.pack(pady=(0, 5))\n\n    # Add sea level note\n    sealevel_note = tk.Label(update_frame,\n                            text=\"Sea Level: Manual update only (see climate_readme.md)\",\n                            font=('Arial', 8, 'italic'),\n                            bg='#E8F5E9',\n                            fg='#666')\n#    sealevel_note.pack(pady=(0, 10))\n    sealevel_note.pack(pady=(0, 5))\n\n    status_label = tk.Label(update_frame,\n                           text=\"\",\n                           font=('Arial', 9),\n                           bg='#E8F5E9',\n                           fg='#666')\n    status_label.pack(pady=(0, 5))\n    \n    # Separator -- removed for cleaner layout\n#    separator = tk.Frame(content_frame, height=2, bg='#ccc')\n#    separator.pack(fill='x', pady=10)\n    \n    # Section label -- removed for cleaner layout\n#    section_label = tk.Label(content_frame,\n#                            text=\"Available Visualizations:\",\n#                            font=('Arial', 11, 'bold'),\n#                            justify='left')\n#    section_label.pack(anchor='w', pady=(5, 10))\n    \n    # Create frame for two-column layout\n    buttons_frame = tk.Frame(content_frame)\n    buttons_frame.pack(fill='both', expand=True)\n    \n    # Left column\n    left_column = tk.Frame(buttons_frame)\n    left_column.pack(side='left', fill='both', expand=True, padx=(0, 5))\n    \n    # Right column\n    right_column = tk.Frame(buttons_frame)\n    right_column.pack(side='left', fill='both', expand=True, padx=(5, 0))\n    \n    # LEFT COLUMN\n    # Climate & Atmosphere section\n    climate_label = tk.Label(left_column,\n                            text=\"Climate & Atmosphere:\",\n                            font=('Arial', 10, 'bold'),\n                            justify='left')\n    climate_label.pack(anchor='w', pady=(5, 5))\n    \n    # Keeling Curve button\n    keeling_button = tk.Button(left_column,\n                              text='The Keeling Curve (Mauna Loa CO2)',\n                              font=('Arial', 10),\n                              bg='#FFB6A3',\n                              fg='black',\n                              activebackground='#E8A090',\n                              cursor='hand2',\n                              padx=15,\n                              pady=8,\n                              command=open_keeling_curve)\n    keeling_button.pack(fill='x', pady=2)\n    \n    # Temperature button\n    temp_button = tk.Button(left_column,\n                           text='Global Temperature Anomalies',\n                           font=('Arial', 10),\n                           bg='#FFB6A3',\n                           fg='black',\n                           activebackground='#E8A090',\n                           cursor='hand2',\n                           padx=15,\n                           pady=8,\n                           command=open_temperature_viz)\n    temp_button.pack(fill='x', pady=(10, 2))\n    \n    # Monthly temperature progression button\n    monthly_btn = tk.Button(left_column,\n                           text='Monthly Temperature: Year-over-Year',\n                           font=('Arial', 10),\n                           bg='#FFB6A3',\n                           fg='black',\n                           activebackground='#E8A090',\n                           cursor='hand2',\n                           padx=15,\n                           pady=8,\n                           command=open_monthly_temp_lines)\n    monthly_btn.pack(fill='x', pady=2)\n    \n    # Warming stripes button\n    stripes_btn = tk.Button(left_column,\n                           text='Warming Stripes (Ed Hawkins Style)',\n                           font=('Arial', 10),\n                           bg='#FFB6A3',\n                           fg='black',\n                           activebackground='#E8A090',\n                           cursor='hand2',\n                           padx=15,\n                           pady=8,\n                           command=open_warming_stripes)\n    stripes_btn.pack(fill='x', pady=2)\n\n    # Energy Imbalance button - the explainer showing mechanism\n    energy_btn = tk.Button(left_column,\n                        text='Energy Imbalance: The Climate Mechanism',\n                        font=('Arial', 10),\n                        bg='#FFB6A3',\n                        fg='black',\n                        activebackground='#E8A090',\n                        cursor='hand2',\n                        padx=15,\n                        pady=8,\n                        command=open_energy_imbalance)\n    energy_btn.pack(fill='x', pady=(10, 2))\n\n    # Climate History and Projections section\n    history_label = tk.Label(left_column,\n                            text=\"Climate History and Projections:\",\n                            font=('Arial', 10, 'bold'),\n                            justify='left')\n    history_label.pack(anchor='w', pady=(10, 5))\n\n    # Paleoclimate button\n    paleo_btn = tk.Button(left_column,\n                         text='Paleoclimate: Cenozoic Climate History',\n                         font=('Arial', 10),\n                         bg='#DEB887',\n                         fg='black',\n                         activebackground='#C9A676',\n                         cursor='hand2',\n                         padx=15,\n                         pady=8,\n                         command=open_paleoclimate_viz)\n    paleo_btn.pack(fill='x', pady=2)\n\n    # Paleoclimate DUAL SCALE button\n    paleo_dual_btn = tk.Button(left_column,\n                         text='Paleoclimate: Dual Scale (Modern + Deep Time)',\n                         font=('Arial', 10),\n                         bg='#DEB887',\n                         fg='black',\n                         activebackground='#C9A676',\n                         cursor='hand2',\n                         padx=15,\n                         pady=8,\n                         command=open_paleoclimate_dual_scale_viz)\n    paleo_dual_btn.pack(fill='x', pady=2)\n\n    # Paleoclimate PHANEROZOIC button\n    paleo_phan_btn = tk.Button(left_column,\n                         text='Paleoclimate: Full History (540 Ma - Present)',\n                         font=('Arial', 10),\n                         bg='#DEB887',\n                         fg='black',\n                         activebackground='#C9A676',\n                         cursor='hand2',\n                         padx=15,\n                         pady=8,\n                         command=open_phanerozoic_viz)\n    paleo_phan_btn.pack(fill='x', pady=2)\n\n    # Paleoclimate HUMAN ORIGINS button\n    human_origins_btn = tk.Button(right_column,\n                         text='[DNA] Human Origins (540 Ma + Evolution)',\n                         font=('Arial', 10),\n                         bg='#DEB887',\n                         fg='black',\n                         activebackground='#C9A676',\n                         cursor='hand2',\n                         padx=15,\n                         pady=8,\n                         command=open_human_origins_viz)\n    human_origins_btn.pack(fill='x', pady=2)\n\n    # RIGHT COLUMN\n    # Cryosphere section\n    cryo_label = tk.Label(right_column,\n                         text=\"Cryosphere:\",\n                         font=('Arial', 10, 'bold'),\n                         justify='left')\n    cryo_label.pack(anchor='w', pady=(5, 5))\n    \n    # Arctic Ice button\n    ice_button = tk.Button(right_column,\n                          text='Arctic Sea Ice Extent (September Minimum)',\n                          font=('Arial', 10),\n                          bg='#87CEEB',\n                          fg='black',\n                          activebackground='#72B8D4',\n                          cursor='hand2',\n                          padx=15,\n                          pady=8,\n                          command=open_ice_viz)\n    ice_button.pack(fill='x', pady=2)\n    \n    # Ocean Systems section\n    ocean_label = tk.Label(right_column,\n                          text=\"Ocean Systems:\",\n                          font=('Arial', 10, 'bold'),\n                          justify='left')\n    ocean_label.pack(anchor='w', pady=(10, 5))\n\n    # Sea Level button\n    sealevel_button = tk.Button(right_column,\n                            text='Global Mean Sea Level Rise',\n                            font=('Arial', 10),\n                            bg='#87CEEB',\n                            fg='black',\n                            activebackground='#72B8D4',\n                            cursor='hand2',\n                            padx=15,\n                            pady=8,\n                            command=open_sea_level_viz)\n    sealevel_button.pack(fill='x', pady=2)\n\n    \n    ph_button = tk.Button(right_column,\n                        text='Ocean Acidification',\n                        font=('Arial', 10),\n                        bg='#87CEEB',\n                        fg='black',\n                        activebackground='#72B8D4',\n                        cursor='hand2',\n                        padx=15,\n                        pady=8,\n                        command=open_ph_viz)\n    ph_button.pack(fill='x', pady=2) \n\n    # Earth System section (NEW!)\n    earth_system_label = tk.Label(right_column,\n                                  text=\"Earth System:\",\n                                  font=('Arial', 10, 'bold'),\n                                  justify='left')\n    earth_system_label.pack(anchor='w', pady=(10, 5))\n    \n    # Planetary Boundaries button (NEW!)\n    pb_button = tk.Button(right_column,\n                         text='Planetary Boundaries (SRC Framework)',\n                         font=('Arial', 10),\n                         bg='#98FB98',\n                         fg='black',\n                         activebackground='#82E082',\n                         cursor='hand2',\n                         padx=15,\n                         pady=8,\n                         command=open_planetary_boundaries)\n    pb_button.pack(fill='x', pady=2)   \n\n    # Google Earth Layers section\n    ge_label = tk.Label(right_column,\n                        text=\"Google Earth Heat Wave Layers (Google Earth Pro preinstalled required):\",\n                        font=('Arial', 10, 'bold'),\n                        justify='left')\n    ge_label.pack(anchor='w', pady=(10, 5))\n    \n    ge_button = tk.Button(right_column,\n                         text='KML Layer Launcher in Google Earth Pro',\n                         font=('Arial', 10),\n                         bg='gray90',\n                         fg='black',\n                         activebackground='#CCCCCC',\n                         cursor='hand2',\n                         padx=15,\n                         pady=8,\n                         command=open_google_earth_controller)\n    ge_button.pack(fill='x', pady=2)\n\n    # Wet Bulb Temperature button\n    wetbulb_button = tk.Button(right_column,\n                         text='Wet Bulb Temperature (Human Survivability)',\n                         font=('Arial', 10),\n                         bg='gray90',\n                         fg='black',\n                         activebackground='#CCCCCC',\n                         cursor='hand2',\n                         padx=15,\n                         pady=8,\n                         command=open_wet_bulb_viz)\n    wetbulb_button.pack(fill='x', pady=2)\n\n    footer_label = tk.Label(content_frame,\n                        text=\"12 of 12 visualizations active\",  \n                        font=('Arial', 9),\n                        fg='#666',\n                        justify='center')   \n    footer_label.pack(side='bottom', pady=10)\n\n    if not parent:\n        window.mainloop()",
    "start_line": 1698,
    "end_line": 2055,
    "has_docstring": true,
    "docstring": "Open Earth System Visualization hub window",
    "parameters": [
      "parent"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function open_earth_system_gui",
    "component_id": "earth_system_visualization_gui.open_earth_system_gui"
  },
  "earth_visualization_shells.create_earth_inner_core_shell": {
    "id": "earth_visualization_shells.create_earth_inner_core_shell",
    "name": "create_earth_inner_core_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_visualization_shells.py",
    "relative_path": "earth_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_earth_inner_core_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Earth's inner core shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.19,  # Inner core: 0-19% of Earth's radius\n        'color': 'rgb(255, 180, 140)',  # Orange-red for hot iron core\n        'opacity': 1.0,\n        'name': 'Inner Core',\n        'description': (\n            \"Earth's inner core is a solid sphere composed primarily of iron and nickel.<br>\"\n            \"Despite incredible pressure, temperatures of 5,400 degC (9,800 degF) keep it nearly<br>\"\n            \"at melting point. It rotates slightly faster than the rest of Earth, creating<br>\"\n            \"complex dynamics in Earth's magnetic field. The inner core is approximately<br>\"\n            \"1,220 km (760 miles) in radius.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * EARTH_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=4.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Earth: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Earth: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 17,
    "end_line": 63,
    "has_docstring": true,
    "docstring": "Creates Earth's inner core shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_earth_inner_core_shell",
    "component_id": "earth_visualization_shells.create_earth_inner_core_shell"
  },
  "earth_visualization_shells.create_earth_outer_core_shell": {
    "id": "earth_visualization_shells.create_earth_outer_core_shell",
    "name": "create_earth_outer_core_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_visualization_shells.py",
    "relative_path": "earth_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_earth_outer_core_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Earth's outer core shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.55,  # Outer core: 19-55% of Earth's radius\n        'color': 'rgb(255, 140, 0)',  # Deeper orange for liquid metal\n        'opacity': 0.8,\n        'name': 'Outer Core',\n        'description': (\n            \"The outer core is a liquid layer of iron, nickel, and lighter elements.<br>\"\n            \"Convection currents in this highly conductive fluid generate Earth's<br>\"\n            \"magnetic field through a process called the geodynamo. It extends from<br>\"\n            \"1,220 to 3,500 km from Earth's center and has temperatures ranging from<br>\"\n            \"4,500 degC (8,100 degF) to 5,400 degC (9,800 degF).\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * EARTH_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.7,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Earth: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Earth: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 73,
    "end_line": 119,
    "has_docstring": true,
    "docstring": "Creates Earth's outer core shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_earth_outer_core_shell",
    "component_id": "earth_visualization_shells.create_earth_outer_core_shell"
  },
  "earth_visualization_shells.create_earth_lower_mantle_shell": {
    "id": "earth_visualization_shells.create_earth_lower_mantle_shell",
    "name": "create_earth_lower_mantle_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_visualization_shells.py",
    "relative_path": "earth_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_earth_lower_mantle_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Earth's lower mantle shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.85,  # Lower mantle: 55-85% of Earth's radius\n        'color': 'rgb(230, 100, 20)',  # Reddish-brown\n        'opacity': 0.7,\n        'name': 'Lower Mantle',\n        'description': (\n            \"The lower mantle is composed of solid silicate rocks rich in iron and magnesium.<br>\"\n            \"Despite being solid, it flows very slowly through convection, driving plate tectonics.<br>\"\n            \"This region extends from 660 to 2,900 km below Earth's surface and experiences<br>\"\n            \"temperatures from 2,200 degC to 4,500 degC (4,000 degF to 8,100 degF) and extreme pressure.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * EARTH_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.4,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Earth: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Earth: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 128,
    "end_line": 173,
    "has_docstring": true,
    "docstring": "Creates Earth's lower mantle shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_earth_lower_mantle_shell",
    "component_id": "earth_visualization_shells.create_earth_lower_mantle_shell"
  },
  "earth_visualization_shells.create_earth_upper_mantle_shell": {
    "id": "earth_visualization_shells.create_earth_upper_mantle_shell",
    "name": "create_earth_upper_mantle_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_visualization_shells.py",
    "relative_path": "earth_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_earth_upper_mantle_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Earth's upper mantle shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.98,  # Upper mantle: 85-98% of Earth's radius\n        'color': 'rgb(205, 85, 85)',  # Lighter reddish-brown\n        'opacity': 0.6,\n        'name': 'Upper Mantle',\n        'description': (\n            \"The upper mantle includes the asthenosphere, a partially molten layer where<br>\"\n            \"most magma originates. This region flows more readily than the lower mantle,<br>\"\n            \"allowing tectonic plates to move. It extends from about 30 to 660 km below<br>\"\n            \"the surface, with temperatures from 500 degC to 2,200 degC (900 degF to 4,000 degF).\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * EARTH_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.1,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Earth: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Earth: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 182,
    "end_line": 227,
    "has_docstring": true,
    "docstring": "Creates Earth's upper mantle shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_earth_upper_mantle_shell",
    "component_id": "earth_visualization_shells.create_earth_upper_mantle_shell"
  },
  "earth_visualization_shells.create_earth_crust_shell": {
    "id": "earth_visualization_shells.create_earth_crust_shell",
    "name": "create_earth_crust_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_visualization_shells.py",
    "relative_path": "earth_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_earth_crust_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Earth's crust shell using Mesh3d for better performance with improved hover.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.0,  # Crust: 100% of Mars's radius\n        'color': 'rgb(70, 120, 160)',  # Bluish for oceans, brown for land\n        'opacity': 1.0,\n        'name': 'Crust',\n        'description': (\n            \"Earth Crust<br>\" \n            \"(Note: toggle off the crust layer in the legend to better see the interior structure.)<br><br>\"\n            \"Earth's crust is the thin, solid outer layer where humans live. It's divided into<br>\"\n            \"oceanic crust (5-10 km thick) made mostly of basalt, and continental crust (30-50 km thick)<br>\"\n            \"made primarily of granite. The crust contains all known life and the accessible portion<br>\"\n            \"of Earth's geological resources. Surface temperatures range from -80 degC to 60 degC (-112 degF to 140 degF).\"\n        )\n    }\n    \n    # Calculate radius in AU\n    radius = layer_info['radius_fraction'] * EARTH_RADIUS_AU\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Create mesh with reasonable resolution for performance\n    resolution = 24  # Reduced from typical 50 for markers\n    \n    # Create a UV sphere\n    phi = np.linspace(0, 2*np.pi, resolution)\n    theta = np.linspace(-np.pi/2, np.pi/2, resolution)\n    phi, theta = np.meshgrid(phi, theta)\n    \n    x = radius * np.cos(theta) * np.cos(phi)\n    y = radius * np.cos(theta) * np.sin(phi)\n    z = radius * np.sin(theta)\n    \n    # Apply center position offset\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    # Create triangulation\n    indices = []\n    for i in range(resolution-1):\n        for j in range(resolution-1):\n            p1 = i * resolution + j\n            p2 = i * resolution + (j + 1)\n            p3 = (i + 1) * resolution + j\n            p4 = (i + 1) * resolution + (j + 1)\n            \n            indices.append([p1, p2, p4])\n            indices.append([p1, p4, p3])\n    \n    # Create main surface\n    surface_trace = go.Mesh3d(\n        x=x.flatten(), \n        y=y.flatten(), \n        z=z.flatten(),\n        i=[idx[0] for idx in indices],\n        j=[idx[1] for idx in indices],\n        k=[idx[2] for idx in indices],\n        color=layer_info['color'],\n        opacity=layer_info['opacity'],\n        name=f\"Earth: {layer_info['name']}\",\n        showlegend=True,\n        hoverinfo='none',  # Disable hover on mesh surface\n        # Add these new parameters to make hover text invisible\n        hovertemplate=' ',  # Empty template instead of None\n        hoverlabel=dict(\n    #        bgcolor='rgba(0,0,0,0)',  # Transparent background\n            font=dict(\n                color='rgba(0,0,0,0)',  # Transparent text\n    #            size=0                  # Zero font size\n            ),\n            bordercolor='rgba(0,0,0,0)'  # Transparent border\n        ), \n        # Add these new parameters to eliminate shading\n        flatshading=True,  # Use flat shading instead of smooth\n        lighting=dict(\n            ambient=1.0,     # Set to maximum (1.0)\n            diffuse=0.0,     # Turn off diffuse lighting\n            specular=0.0,    # Turn off specular highlights\n            roughness=1.0,   # Maximum roughness\n            fresnel=0.0      # Turn off fresnel effect\n        ),\n        lightposition=dict(\n            x=0,  # Centered light\n            y=0,  # Centered light\n            z=10000  # Light from very far above to minimize shadows\n        )       \n    )\n        \n    # Use the Fibonacci sphere algorithm for more even point distribution\n    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points\n    \n    # Generate fibonacci sphere points\n    fib_points = fibonacci_sphere(samples=50)  # Originally, 50 hover points evenly distributed\n    \n    # Scale and offset the points\n    x_hover = [p[0] * radius + center_x for p in fib_points]\n    y_hover = [p[1] * radius + center_y for p in fib_points]\n    z_hover = [p[2] * radius + center_z for p in fib_points]\n        \n    # Create a list of repeated descriptions for each point\n    # This is crucial - we need exactly one text entry per point\n    hover_texts = [layer_info['description']] * len(x_hover)\n\n    # Just the name for \"Object Names Only\" mode\n    layer_name = f\"Earth: {layer_info['name']}\"\n    minimal_hover_texts = [layer_name] * len(x_hover)\n\n    # Create hover trace with direct text assignment\n    hover_trace = go.Scatter3d(\n        x=x_hover, \n        y=y_hover, \n        z=z_hover,\n        mode='markers',\n        marker=dict(\n            size=2,  # originally 5\n            color='rgb(70, 120, 160)',  # Layer color, originally 'white'\n            opacity=1.0,  # originally 0.8\n            line=dict(  # Add a contrasting outline\n                width=1,\n                color='black'\n            )\n        ),\n        name=f\"Earth: {layer_info['name']} (Info)\",\n        text=hover_texts,  # IMPORTANT: Matching length with coordinate arrays\n        customdata=minimal_hover_texts,  # For \"Object Names Only\" mode\n        hovertemplate='%{text}<extra></extra>',  # Use the standard hover template\n        showlegend=False  # Don't show in legend since it's just for hover\n    )\n\n    return [surface_trace, hover_trace]",
    "start_line": 236,
    "end_line": 384,
    "has_docstring": true,
    "docstring": "Creates Earth's crust shell using Mesh3d for better performance with improved hover.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_earth_crust_shell",
    "component_id": "earth_visualization_shells.create_earth_crust_shell"
  },
  "earth_visualization_shells.fibonacci_sphere": {
    "id": "earth_visualization_shells.fibonacci_sphere",
    "name": "fibonacci_sphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_visualization_shells.py",
    "relative_path": "earth_visualization_shells.py",
    "depends_on": [],
    "source_code": "    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points",
    "start_line": 329,
    "end_line": 344,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "samples"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fibonacci_sphere",
    "component_id": "earth_visualization_shells.fibonacci_sphere"
  },
  "earth_visualization_shells.create_earth_atmosphere_shell": {
    "id": "earth_visualization_shells.create_earth_atmosphere_shell",
    "name": "create_earth_atmosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_visualization_shells.py",
    "relative_path": "earth_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_earth_atmosphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Earth's lower atmosphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.05,  # Troposphere and stratosphere\n        'color': 'rgb(150, 200, 255)',  # Light blue for atmosphere\n        'opacity': 0.5,\n        'name': 'Lower Atmosphere',\n        'description': (\n            \"The lower atmosphere includes the troposphere (0-12 km) where weather occurs, and<br>\"\n            \"the stratosphere (12-50 km) which contains the ozone layer. These regions contain<br>\"\n            \"99% of atmospheric mass, primarily nitrogen and oxygen. Temperature varies from<br>\"\n            \"about 15 degC (59 degF) at sea level to -60 degC (-76 degF) at the stratopause.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * EARTH_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.5,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Earth: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Earth: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 393,
    "end_line": 438,
    "has_docstring": true,
    "docstring": "Creates Earth's lower atmosphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_earth_atmosphere_shell",
    "component_id": "earth_visualization_shells.create_earth_atmosphere_shell"
  },
  "earth_visualization_shells.create_earth_upper_atmosphere_shell": {
    "id": "earth_visualization_shells.create_earth_upper_atmosphere_shell",
    "name": "create_earth_upper_atmosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_visualization_shells.py",
    "relative_path": "earth_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_earth_upper_atmosphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Earth's upper atmosphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.25,  # Mesosphere, thermosphere, and exosphere\n        'color': 'rgb(100, 150, 255)',  # Lighter blue\n        'opacity': 0.3,\n        'name': 'Upper Atmosphere',\n        'description': (\n            \"The upper atmosphere extends from 50 km to about 1,000 km altitude. It includes<br>\"\n            \"the mesosphere where meteors burn up, the thermosphere where the aurora occurs and<br>\"\n            \"the International Space Station orbits, and the exosphere which gradually transitions<br>\"\n            \"to space. In the thermosphere, temperatures can reach 2,000 degC (3,600 degF), though the<br>\"\n            \"gas is so thin that it would feel cold to human skin.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * EARTH_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Earth: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Earth: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=layer_radius\n    )\n    for trace in sun_traces:\n        traces.append(trace) \n\n    return traces",
    "start_line": 448,
    "end_line": 501,
    "has_docstring": true,
    "docstring": "Creates Earth's upper atmosphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_earth_upper_atmosphere_shell",
    "component_id": "earth_visualization_shells.create_earth_upper_atmosphere_shell"
  },
  "earth_visualization_shells.create_earth_magnetosphere_shell": {
    "id": "earth_visualization_shells.create_earth_magnetosphere_shell",
    "name": "create_earth_magnetosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_visualization_shells.py",
    "relative_path": "earth_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_magnetosphere_shape",
      "shared_utilities.create_sun_direction_indicator"
    ],
    "source_code": "def create_earth_magnetosphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Earth's magnetosphere.\"\"\"\n    traces = []\n    \n    # Parameters for magnetosphere components (in Earth radii)\n    params = {\n        # Compressed sunward side\n        'sunward_distance': 10,  # Compressed toward the sun\n        \n        # Equatorial extension (wider than polar)\n        'equatorial_radius': 12,\n        'polar_radius': 10,\n        \n        # Magnetotail parameters\n        'tail_length': 100,  # Length of visible magnetotail\n        'tail_base_radius': 15,  # Radius at the base of the tail\n        'tail_end_radius': 25,  # Radius at the end of the tail\n        \n        # Radiation belts\n        'inner_belt_distance': 1.5,  # Distance in Earth radii\n        'outer_belt_distance': 4.5,  # Distance in Earth radii\n        'belt_thickness': 0.5,\n    }\n    \n    # Scale everything by Earth's radius in AU\n    for key in params:\n        params[key] *= EARTH_RADIUS_AU\n    \n    # Create magnetosphere main shape\n    x, y, z = create_magnetosphere_shape(params)\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # 1. Add the main magnetosphere structure\n    x = np.array(x) + center_x\n    y = np.array(y) + center_y\n    z = np.array(z) + center_z\n    \n    magnetosphere_text = [\"Earth's magnetosphere extends about 10 Earth radii on the Sun-facing side<br>\"\n                 \"and stretches into a long magnetotail on the night side. It protects Earth<br>\"\n                 \"from solar radiation and cosmic rays, making complex life possible.\"]\n    \n    magnetosphere_customdata = ['Earth: Magnetosphere']\n\n    traces.append(\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.0,\n                color='rgb(180, 180, 255)', # Light blue for magnetic field\n                opacity=0.2\n            ),\n            name='Earth: Magnetosphere',\n            text=magnetosphere_text * len(x),\n            customdata=magnetosphere_customdata * len(x),      \n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    )\n    \n    # 2. Create and add bow shock\n    bow_shock_x = []\n    bow_shock_y = []\n    bow_shock_z = []\n    \n    n_phi = 30\n    n_theta = 30\n    bow_shock_standoff = 15 * EARTH_RADIUS_AU\n    bow_shock_width = 25 * EARTH_RADIUS_AU\n    \n    # Create a paraboloid for the bow shock\n    for i_phi in range(n_phi):\n        phi = (i_phi / (n_phi-1)) * np.pi  # Only the front half\n        \n        for i_theta in range(n_theta):\n            theta = (i_theta / (n_theta-1)) * 2 * np.pi\n            \n            # Paraboloid shape, flattened in x-direction for bow shock\n            x = -bow_shock_standoff * np.cos(phi)  # Negative for sunward direction\n            rho = bow_shock_width * (1 + np.sin(phi)) / 2  # Wider for larger phi (away from sun)\n            y = rho * np.cos(theta)\n            z = rho * np.sin(theta)\n            \n            bow_shock_x.append(x)\n            bow_shock_y.append(y)\n            bow_shock_z.append(z)\n    \n    # Apply center position offset\n    bow_shock_x = np.array(bow_shock_x) + center_x\n    bow_shock_y = np.array(bow_shock_y) + center_y\n    bow_shock_z = np.array(bow_shock_z) + center_z\n    \n    bow_shock_text = [\"Bow Shock: The boundary where the supersonic solar wind is first slowed<br>\"\n                \"by Earth's magnetic field, typically located about 15 Earth radii upstream<br>\"\n                \"from Earth on the Sun-facing side.<br>\"\n                \"The Bow Shock points towards the Sun along the X-axis. The XY plane is the ecliptic.\"]\n    \n    bow_shock_customdata = ['Earth: Bow Shock']\n\n    traces.append(\n        go.Scatter3d(\n            x=bow_shock_x,\n            y=bow_shock_y,\n            z=bow_shock_z,\n            mode='markers',\n            marker=dict(\n                size=1.5,\n                color='rgb(255, 200, 150)',  # Orange-ish color for bow shock\n                opacity=0.2\n            ),\n            name='Earth: Bow Shock',\n            text=bow_shock_text * len(bow_shock_x),\n            customdata=bow_shock_customdata * len(bow_shock_x),  # This was the line causing the error\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    )\n    \n    # 3. Create and add Van Allen radiation belts\n    belt_colors = ['rgb(255, 100, 100)', 'rgb(100, 200, 255)']\n    belt_names = ['Earth: Inner Radiation Belt', 'Earth: Outer Radiation Belt']\n    belt_texts = [\n        \"Inner Van Allen Belt: Region of trapped charged particles (mainly protons)<br>\"\n        \"extending from about 1,000 km to 6,000 km above Earth's surface.\",\n        \"Outer Van Allen Belt: Region of trapped charged particles (mainly electrons)<br>\"\n        \"extending from about 13,000 km to 60,000 km above Earth's surface.\"\n    ]\n    \n    belt_distances = [\n        params['inner_belt_distance'],\n        params['outer_belt_distance']\n    ]\n    \n    for i, belt_distance in enumerate(belt_distances):\n        belt_x = []\n        belt_y = []\n        belt_z = []\n        \n        n_points = 80\n        n_rings = 5\n        \n        for i_ring in range(n_rings):\n            # Vary the radius slightly to create thickness\n            radius_offset = (i_ring / (n_rings-1) - 0.5) * params['belt_thickness']\n            belt_radius = belt_distance + radius_offset\n            \n            for j in range(n_points):\n                angle = (j / n_points) * 2 * np.pi\n                \n                # Create a belt around Earth's rotational axis\n                x = belt_radius * np.cos(angle)\n                y = belt_radius * np.sin(angle)\n                \n                # Add some z variation based on angle to create the shape of a belt\n                # rather than a perfect torus (thinner near poles)\n                z_scale = 0.2 * belt_radius  # Controls how flat the belts are\n                z = z_scale * np.sin(2 * angle)\n                \n                belt_x.append(x)\n                belt_y.append(y)\n                belt_z.append(z)\n        \n        # Apply center position offset\n        belt_x = np.array(belt_x) + center_x\n        belt_y = np.array(belt_y) + center_y\n        belt_z = np.array(belt_z) + center_z\n        \n        belt_text = [belt_texts[i]]\n        belt_customdata = [belt_names[i]]\n\n        traces.append(\n            go.Scatter3d(\n                x=belt_x,\n                y=belt_y,\n                z=belt_z,\n                mode='markers',\n                marker=dict(\n                    size=1.5,\n                    color=belt_colors[i],\n                    opacity=0.2\n                ),\n                name=belt_names[i],\n                text=belt_text * len(belt_x),\n                customdata=belt_customdata * len(belt_x),  # Fix here as well\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            )\n        )\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=100 * EARTH_RADIUS_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 520,
    "end_line": 718,
    "has_docstring": true,
    "docstring": "Creates Earth's magnetosphere.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_earth_magnetosphere_shell",
    "component_id": "earth_visualization_shells.create_earth_magnetosphere_shell"
  },
  "earth_visualization_shells.create_earth_hill_sphere_shell": {
    "id": "earth_visualization_shells.create_earth_hill_sphere_shell",
    "name": "create_earth_hill_sphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\earth_visualization_shells.py",
    "relative_path": "earth_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_earth_hill_sphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Earth's Hill sphere.\"\"\"\n    # Hill sphere radius in Earth radii\n    radius_fraction = 235  # Earth's Hill sphere is about 235 Earth radii\n    \n    # Calculate radius in AU\n    radius_au = radius_fraction * EARTH_RADIUS_AU\n    \n    # Create sphere points with fewer points for memory efficiency\n    n_points = 30  # Reduced for large spheres\n    x, y, z = create_sphere_points(radius_au, n_points=n_points)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    # Create hover text\n    hover_text = (\"Earth's Hill Sphere (extends to ~235 Earth radii or about 1.5 million km)<br><br>\"\n                \"The Hill sphere is the region around a where its own gravity is the dominant force in attracting satellites. For <br>\" \n                \"a planet orbiting a star, it's the region where the planet's gravity is stronger than the star's tidal forces.<br><br>\" \n                \"The Hill Sphere radius can be described in words as follows: it is equal to the planet's average distance from the <br>\" \n                \"Sun (its orbital semi-major axis) multiplied by the cube root of the ratio between the planet's mass and three times <br>\" \n                \"the Sun's mass. In other words, you take how far the planet orbits out from the Sun, then scale that distance by the <br>\" \n                \"cube root of (planet mass / [3 x solar mass]) to find the boundary within which the planet's gravity dominates over the Sun's.\"                  \n                )\n    \n    # Create the trace\n    traces = [\n        go.Scatter3d(\n            x=x,\n            y=y,\n            z=z,\n            mode='markers',\n            marker=dict(\n                size=1.0,\n                color='rgb(0, 255, 0)',  # Green for Hill sphere\n                opacity=0.25\n            ),\n            name='Earth: Hill Sphere',\n            text=[hover_text] * len(x),\n            customdata=['Earth: Hill Sphere'] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=radius_au\n    )\n    for trace in sun_traces:\n        traces.append(trace) \n\n    return traces",
    "start_line": 725,
    "end_line": 780,
    "has_docstring": true,
    "docstring": "Creates Earth's Hill sphere.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_earth_hill_sphere_shell",
    "component_id": "earth_visualization_shells.create_earth_hill_sphere_shell"
  },
  "energy_imbalance.load_ocean_heat_content": {
    "id": "energy_imbalance.load_ocean_heat_content",
    "name": "load_ocean_heat_content",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\energy_imbalance.py",
    "relative_path": "energy_imbalance.py",
    "depends_on": [],
    "source_code": "def load_ocean_heat_content():\n    \"\"\"\n    Load NOAA ocean heat content data and convert to energy imbalance\n    \n    Returns:\n        tuple: (decimal_years, ohc_anomaly_zj, imbalance_watts_per_m2)\n    \"\"\"\n    try:\n        # Load CSV (no header, format: YYYY-M,value)\n        df = pd.read_csv(OHC_FILE, header=None, names=['date', 'ohc'])\n        \n        # Parse date\n        df['year'] = df['date'].str.split('-').str[0].astype(int)\n        df['month'] = df['date'].str.split('-').str[1].astype(int)\n        df['decimal_year'] = df['year'] + (df['month'] - 1) / 12.0\n        \n        # OHC is in units of 10^22 Joules (Zettajoules)\n        # Calculate rate of change for energy imbalance\n        # Using gradient (centered difference)\n        ohc_rate_zj_per_year = np.gradient(df['ohc'].values, df['decimal_year'].values)\n        \n        # Convert to W/m^2\n        # 1 ZJ = 10^22 J\n        # Earth surface area = 5.1 x 10^14 m^2\n        # 1 year = 365.25 x 24 x 3600 seconds\n        \n        earth_surface_m2 = 5.1e14\n        seconds_per_year = 365.25 * 24 * 3600\n        zj_to_joules = 1e22\n        \n        watts = ohc_rate_zj_per_year * zj_to_joules / seconds_per_year\n        imbalance_w_per_m2 = watts / earth_surface_m2\n        \n        return df['decimal_year'].values, df['ohc'].values, imbalance_w_per_m2\n        \n    except Exception as e:\n        print(f\"Warning: Could not load ocean heat content data: {e}\")\n        return None, None, None",
    "start_line": 35,
    "end_line": 72,
    "has_docstring": true,
    "docstring": "Load NOAA ocean heat content data and convert to energy imbalance\n\nReturns:\n    tuple: (decimal_years, ohc_anomaly_zj, imbalance_watts_per_m2)",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_ocean_heat_content",
    "component_id": "energy_imbalance.load_ocean_heat_content"
  },
  "energy_imbalance.load_modern_temperature_data": {
    "id": "energy_imbalance.load_modern_temperature_data",
    "name": "load_modern_temperature_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\energy_imbalance.py",
    "relative_path": "energy_imbalance.py",
    "depends_on": [],
    "source_code": "def load_modern_temperature_data():\n    \"\"\"Load NASA GISS instrumental temperature data (1880-2025)\"\"\"\n    try:\n        with open(GISS_TEMP_FILE, 'r') as f:\n            data = json.load(f)\n        \n        records = data['data']\n        \n        # Convert to arrays and get annual averages\n        years = []\n        temps = []\n        \n        for record in records:\n            year = record['year']\n            \n            if year not in years:\n                years.append(year)\n                # Get all months for this year that have valid data\n                year_temps = [r['anomaly_c'] for r in records \n                             if r['year'] == year and r['anomaly_c'] is not None]\n                if year_temps:\n                    temps.append(np.mean(year_temps))\n                else:\n                    years.pop()\n        \n        return np.array(years), np.array(temps)\n        \n    except Exception as e:\n        print(f\"Warning: Could not load modern temperature data: {e}\")\n        return None, None",
    "start_line": 74,
    "end_line": 103,
    "has_docstring": true,
    "docstring": "Load NASA GISS instrumental temperature data (1880-2025)",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_modern_temperature_data",
    "component_id": "energy_imbalance.load_modern_temperature_data"
  },
  "energy_imbalance.create_energy_imbalance_visualization": {
    "id": "energy_imbalance.create_energy_imbalance_visualization",
    "name": "create_energy_imbalance_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\energy_imbalance.py",
    "relative_path": "energy_imbalance.py",
    "depends_on": [
      "energy_imbalance.load_modern_temperature_data",
      "energy_imbalance.load_ocean_heat_content"
    ],
    "source_code": "def create_energy_imbalance_visualization():\n    \"\"\"\n    Create energy imbalance visualization (2005-2025)\n    \n    Dual Y-axis plot showing:\n    - Left: Temperature anomaly ( degC)\n    - Right: Energy imbalance (W/m^2)\n    \n    Demonstrates the relationship between energy accumulation (cause)\n    and temperature change (effect), revealing climate system inertia.\n    \"\"\"\n    \n    if not PLOTLY_AVAILABLE:\n        return None\n    \n    # Load data\n    years_temp, temp_anomaly = load_modern_temperature_data()\n    years_ohc, ohc_zj, imbalance_w_m2 = load_ocean_heat_content()\n    \n    if years_ohc is None or years_temp is None:\n        print(\"Could not load required data files\")\n        return None\n    \n    # Filter temperature data to OHC time range (2005-2025)\n    temp_mask = (years_temp >= years_ohc.min()) & (years_temp <= years_ohc.max())\n    years_temp_filtered = years_temp[temp_mask]\n    temp_anomaly_filtered = temp_anomaly[temp_mask]\n    \n    # Create figure with dual y-axes\n    fig = make_subplots(\n        rows=1, cols=1,\n        specs=[[{\"secondary_y\": True}]]\n    )\n    \n    # Add ENSO event bands as background (plotted first so they appear behind data)\n    # Each event includes characteristics explaining what made it unique\n    enso_events = [\n        {\n            'start': 2006.5, 'end': 2007.2, 'type': 'El Nino',  # Back to original coordinates\n            'color': 'rgba(255, 140, 0, 0.15)', 'label': '06/07 EN',\n            'hover': '2006-07 El Nino: Moderate event. Followed 2005-06 La Nina. Brief but contributed to 2006 being 6th warmest year on record.'\n        },\n        {\n            'start': 2007.5, 'end': 2008.2, 'type': 'La Nina', \n            'color': 'rgba(70, 130, 180, 0.15)', 'label': '07/08 LN',\n            'hover': '2007-08 La Nina: Moderate event. Cooled global temperatures but 2008 still among top 10 warmest years - showing baseline warming trend.'\n        },\n        {\n            'start': 2009.5, 'end': 2010.3, 'type': 'El Nino', \n            'color': 'rgba(255, 140, 0, 0.15)', 'label': '09/10 EN',\n            'hover': '2009-10 El Nino: Moderate-Strong event. Made 2010 tied for warmest year on record (with 2005). Ended prolonged neutral/La Nina conditions.'\n        },\n        {\n            'start': 2010.5, 'end': 2012.2, 'type': 'La Nina', \n            'color': 'rgba(70, 130, 180, 0.15)', 'label': '10/12 (L) LN',\n            'hover': '2010-12 La Nina: LONG multi-year event (rare). Strong cooling yet 2010 still warmest on record. Demonstrates how much baseline warming has occurred.'\n        },\n        {\n            'start': 2015.5, 'end': 2016.3, 'type': 'El Nino', \n            'color': 'rgba(255, 140, 0, 0.15)', 'label': '15/16 (S) EN',\n            'hover': '2015-16 El Nino: SUPER event - one of strongest on record (with 1997-98, 1982-83). Made 2016 hottest year ever recorded. Massive global temperature spike.'\n        },\n        {\n            'start': 2016.5, 'end': 2017.2, 'type': 'La Nina', \n            'color': 'rgba(70, 130, 180, 0.15)', 'label': '16/17 LN',\n            'hover': '2016-17 La Nina: Brief weak event following super El Nino. Cooled temperatures but 2017 still 3rd warmest on record (behind 2016, 2015).'\n        },\n        # Skipping 2018/2019 Weak El Nino for clarity/space\n        {\n            'start': 2020.5, 'end': 2023.3, 'type': 'La Nina', \n            'color': 'rgba(70, 130, 180, 0.15)', 'label': '20/23 (3xL) LN',\n            'hover': '2020-23 La Nina: UNPRECEDENTED triple-dip - 3 consecutive years (extremely rare). Despite strong cooling, 2020-2023 all in top 10 warmest years. Shows inexorable warming trend.'\n        },\n        {\n            'start': 2023.5, 'end': 2024.3, 'type': 'El Nino', \n            'color': 'rgba(255, 140, 0, 0.15)', 'label': '23/24 EN',\n            'hover': '2023-24 El Nino: Moderate-Strong event. Made 2023 hottest year on record by large margin, breaking 2016 record. Combined with long-term warming trend.'\n        },\n    ]\n    \n    # Store ENSO shapes to add to layout later (after all traces are added)\n    enso_shapes = []\n    enso_annotations = []\n    \n    # Debug: Print actual data range\n    print(f\"DEBUG: OHC data range: {years_ohc.min():.2f} to {years_ohc.max():.2f}\", flush=True)\n    \n    # Base band filter on the plotted window instead of OHC-only bounds\n    # This ensures all bands within the x-axis range display properly\n    data_start = 2004.0  # Match x-axis range\n    data_end = 2026.0    # Match x-axis range\n    \n    for event in enso_events:\n        # Only add events that overlap with our plot window\n        if event['end'] < data_start or event['start'] > data_end:\n            print(f\"DEBUG: Skipping {event['label']} ({event['start']}-{event['end']}) - outside plot window\", flush=True)\n            continue\n        \n        print(f\"DEBUG: Adding {event['label']} ({event['start']}-{event['end']}) - {event['type']}\", flush=True)\n            \n        # Add ENSO band as a filled scatter trace (bypasses shape rendering bug)\n        fig.add_trace(\n            go.Scatter(\n                x=[event['start'], event['end'], event['end'], event['start'], event['start']],\n                y=[0, 0, 1.5, 1.5, 0],  # Span full temperature range\n                fill='toself',\n                fillcolor=event['color'],\n                line=dict(width=0),\n                mode='none',\n                showlegend=False,  # Don't clutter legend\n                hoverinfo='skip'\n            ),\n            secondary_y=False  # Use primary y-axis (temperature scale)\n        )\n        # Add annotation for label at bottom (simplified) with hover info\n        label_text = 'El Nino' if event['type'] == 'El Nino' else 'La Nina'\n        enso_annotations.append(\n            dict(\n                x=(event['start'] + event['end']) / 2,  # Center of band\n                y=0.02,  # Near bottom\n                yref='paper',\n                text=label_text,\n                showarrow=False,\n                font=dict(size=8, color='gray'),\n                yanchor='bottom',\n                hovertext=event['hover'],\n                hoverlabel=dict(\n                    bgcolor='white',\n                    font_size=11,\n                    font_family='Arial'\n                )\n            )\n        )\n    \n    print(f\"DEBUG: Total shapes created: {len(enso_shapes)}\", flush=True)\n    if len(enso_shapes) > 0:\n        print(f\"DEBUG: First shape: {enso_shapes[0]}\", flush=True)\n        print(f\"DEBUG: Second shape: {enso_shapes[1] if len(enso_shapes) > 1 else 'N/A'}\", flush=True)\n    \n    # CRITICAL DEBUG: Check if shapes are within visible x-range\n    for i, shape in enumerate(enso_shapes):\n        x0, x1 = shape['x0'], shape['x1']\n        print(f\"DEBUG: Shape {i}: x0={x0}, x1={x1}, color={shape['fillcolor']}, layer={shape['layer']}\", flush=True)\n    \n    # Add temperature trace (left y-axis)\n    fig.add_trace(\n        go.Scatter(\n            x=years_temp_filtered,\n            y=temp_anomaly_filtered,\n            mode='lines+markers',\n            name='Air Temperature Anomaly (GMST)',  # Clarified\n            line=dict(color='#DC143C', width=3),  # Crimson\n            marker=dict(size=6, color='#DC143C'),\n            hovertemplate='Year: %{x:.0f}<br>Air Temp: %{y:.2f} degC<extra></extra>',\n            legendgroup='measurements',\n            legendgrouptitle_text='Measurements'\n        ),\n        secondary_y=False\n    )\n    \n    # Add shaded areas for energy imbalance (positive=red, negative=blue)\n    # Properly segment at zero crossings - each continuous segment is separate\n    \n    # Find zero crossings and create segments\n    segments_pos = []  # Positive segments (above zero)\n    segments_neg = []  # Negative segments (below zero)\n    \n    current_segment_x = []\n    current_segment_y = []\n    is_positive = None\n    \n    for i, (x, y) in enumerate(zip(years_ohc, imbalance_w_m2)):\n        current_positive = (y >= 0)\n        \n        # Handle zero crossings\n        if is_positive is not None and current_positive != is_positive:\n            # We crossed zero - interpolate the crossing point\n            if len(current_segment_x) > 0:\n                x_prev, y_prev = current_segment_x[-1], current_segment_y[-1]\n                # Linear interpolation to find x where y=0\n                if y_prev != y:  # Avoid division by zero\n                    x_cross = x_prev + (0 - y_prev) * (x - x_prev) / (y - y_prev)\n                    current_segment_x.append(x_cross)\n                    current_segment_y.append(0)\n                \n                # Save completed segment\n                if is_positive:\n                    segments_pos.append((current_segment_x.copy(), current_segment_y.copy()))\n                else:\n                    segments_neg.append((current_segment_x.copy(), current_segment_y.copy()))\n                \n                # Start new segment at crossing point\n                current_segment_x = [x_cross, x]\n                current_segment_y = [0, y]\n        else:\n            current_segment_x.append(x)\n            current_segment_y.append(y)\n        \n        is_positive = current_positive\n    \n    # Save final segment\n    if len(current_segment_x) > 0:\n        if is_positive:\n            segments_pos.append((current_segment_x, current_segment_y))\n        else:\n            segments_neg.append((current_segment_x, current_segment_y))\n    \n    print(f\"DEBUG: Created {len(segments_pos)} warming segments and {len(segments_neg)} cooling segments\", flush=True)\n    print(f\"DEBUG: Total traces to be added: 5 (1 warming + 1 cooling + temp + imbalance + OHC) - CONSOLIDATED!\", flush=True)\n    \n    # Plot positive segments (red warming) - CONSOLIDATED into single trace\n    # Combine all warming segments into one trace to reduce trace count\n    if segments_pos:\n        all_warming_x = []\n        all_warming_y = []\n        \n        for seg_x, seg_y in segments_pos:\n            # Add the filled polygon for this segment\n            all_warming_x.extend(seg_x)\n            all_warming_x.extend(seg_x[::-1])\n            all_warming_x.append(None)  # None creates a break between segments\n            \n            all_warming_y.extend(seg_y)\n            all_warming_y.extend([0] * len(seg_y))\n            all_warming_y.append(None)\n        \n        fig.add_trace(\n            go.Scatter(\n                x=all_warming_x,\n                y=all_warming_y,\n                fill='toself',\n                fillcolor='rgba(255, 99, 71, 0.3)',  # Tomato red\n                line=dict(width=0),\n                mode='none',\n                name='Ocean Warming',\n                showlegend=True,\n                hoverinfo='skip',\n                legendgroup='ocean_heat',\n                legendgrouptitle_text='Ocean Heat (0-2000m)'\n            ),\n            secondary_y=True\n        )\n    \n    # Plot negative segments (blue cooling) - CONSOLIDATED into single trace\n    # Combine all cooling segments into one trace to reduce trace count\n    if segments_neg:\n        all_cooling_x = []\n        all_cooling_y = []\n        \n        for seg_x, seg_y in segments_neg:\n            # Add the filled polygon for this segment\n            all_cooling_x.extend(seg_x)\n            all_cooling_x.extend(seg_x[::-1])\n            all_cooling_x.append(None)  # None creates a break between segments\n            \n            all_cooling_y.extend([0] * len(seg_y))\n            all_cooling_y.extend(seg_y[::-1])\n            all_cooling_y.append(None)\n        \n        fig.add_trace(\n            go.Scatter(\n                x=all_cooling_x,\n                y=all_cooling_y,\n                fill='toself',\n                fillcolor='rgba(70, 130, 180, 0.3)',  # Steel blue\n                line=dict(width=0),\n                mode='none',\n                name='Ocean Cooling',\n                showlegend=True,\n                hoverinfo='skip',\n                legendgroup='ocean_heat'\n            ),\n            secondary_y=True\n        )\n    \n    # Add energy imbalance trace (right y-axis) - plot AFTER shading so line is on top\n    fig.add_trace(\n        go.Scatter(\n            x=years_ohc,\n            y=imbalance_w_m2,\n            mode='lines+markers',\n            name='Energy Imbalance (from ocean heat uptake)',\n            line=dict(color='#FF8C00', width=3),  # Dark orange\n            marker=dict(size=5, color='#FF8C00'),\n            hovertemplate='Year: %{x:.1f}<br>Imbalance: %{y:.2f} W/m^2<extra></extra>',\n            legendgroup='measurements'\n        ),\n        secondary_y=True\n    )\n    \n    # Add cumulative integral (Ocean Heat Content) using secondary_y for reliability\n    # This shows the running sum: integral of imbalance over time\n    # CRITICAL: Shows ongoing energy accumulation driving temperature rise\n    # Uses 2000m ocean data (centennial-millennial timescale buffer)\n    fig.add_trace(\n        go.Scatter(\n            x=years_ohc,\n            y=ohc_zj,\n            mode='lines',\n            name='Ocean Heat Content (OHC) (0-2000m)',\n            line=dict(color='#4169E1', width=2.5, dash='dot'),  # Royal blue, dotted, thicker\n            hovertemplate='Year: %{x:.1f}<br>Ocean Heat Content: %{y:.1f} ZJ<extra></extra>',\n            yaxis='y2',  # Use secondary y-axis\n            legendgroup='ocean_heat'\n        ),\n        secondary_y=True  # Plot on right axis with energy imbalance\n    )\n    \n    # Add polynomial trend line to show acceleration\n    # 2nd order polynomial shows the curvature (acceleration) in ocean heat accumulation\n    coefs = np.polyfit(years_ohc, ohc_zj, 2)\n    ohc_trend = np.polyval(coefs, years_ohc)\n    \n    fig.add_trace(\n        go.Scatter(\n            x=years_ohc,\n            y=ohc_trend,\n            mode='lines',\n            name='OHC Trend (Quadratic Fit)',\n            line=dict(color='#4169E1', width=1, dash='dash'),  # Light touch\n            opacity=0.6,\n            hovertemplate='Year: %{x:.1f}<br>Trend: %{y:.1f} ZJ<extra></extra>',\n            yaxis='y2',\n            legendgroup='ocean_heat',\n            showlegend=True\n        ),\n        secondary_y=True\n    )\n    \n    # Add zero reference line for energy imbalance\n    fig.add_hline(\n        y=0, \n        line_dash=\"dash\", \n        line_color=\"gray\", \n        line_width=1,\n        secondary_y=True,\n        annotation_text=\"Zero imbalance (equilibrium)\",\n        annotation_position=\"top left\"\n    )\n    \n    # Add zero line at bottom of temperature axis for visual grounding\n    fig.add_hline(\n        y=0,\n        line_dash=\"solid\",\n        line_color=\"lightgray\",\n        line_width=1,\n        secondary_y=False\n    )\n    \n    # Update axes\n    fig.update_xaxes(\n    #    title_text=\"Year\",\n        gridcolor='lightgray',\n        showgrid=True,\n        autorange=True  # Let Plotly auto-calculate range with proper margins\n    )\n    \n    fig.update_yaxes(\n        title_text=\"<b>Global Mean Surface Temperature Anomaly ( degC)</b><br><i>GMST (NASA GISS)</i>\",\n        secondary_y=False,\n        gridcolor='lightgray',\n        showgrid=True,\n        title_font=dict(color='#DC143C', size=14),\n        tickfont=dict(color='#DC143C'),\n        range=[0, 1.5]  # Proper temperature range\n    )\n    \n    fig.update_yaxes(\n        title_text=\"<b>Energy Imbalance (W/m^2)</b><br>\"\n                \"<b>Ocean Heat Content (ZJ)</b><br>\",\n        #           \"<i>Ocean Heat Uptake/Release (0-2000m)</i>\",\n        secondary_y=True,\n        title_font=dict(color='#0A0A09', size=13),\n        tickfont=dict(color=\"#0A0A09\"),\n        range=[-8, 36]  # Fixed range: covers energy imbalance (-5 to +7) and Ocean Heat Content (10 to 33)\n    )\n    \n    # Update layout\n    fig.update_layout(\n        title={\n            'text': \"<b>Earth's Energy Imbalance & Temperature (2005-2025)</b><br>\"\n            #       \"<i>Cause and Effect: Energy drives temperature change</i><br>\"\n                   \"<i>Energy drives temperature change -- <b>every tenth matters!</b></i><br>\"                   \n                   \"<span style='font-size:11px; color:#666;'>Data: NASA GISS (temperature) | NOAA NCEI (Ocean Heat Content 0-2000m)</span>\",\n            'x': 0.5,\n            'xanchor': 'center',\n            'font': {'size': 18}\n        },\n        hovermode='x unified',\n        plot_bgcolor='white',\n        paper_bgcolor='white',\n        showlegend=True,\n        legend=dict(\n            x=0.035,\n            y=1.15,\n            xanchor='left',\n            yanchor='top',\n            bgcolor='rgba(255,255,255,0.9)',  # More opaque for better readability\n            bordercolor='gray',\n            borderwidth=1\n        ),\n        height=600,\n        margin=dict(l=80, r=80, t=100, b=100),  # Restored original margins\n        # Shapes removed - using traces instead to avoid rendering bug\n    )\n    \n    # Add ENSO annotations\n    for annotation in enso_annotations:\n        fig.add_annotation(**annotation)\n    \n    # Add key annotations\n    \n    # Calculate year_2025 first (needed for multiple annotations)\n    idx_2025 = -1  # Last data point\n    temp_2025 = temp_anomaly_filtered[idx_2025]\n    imbalance_2025 = imbalance_w_m2[idx_2025]\n    year_2025 = years_ohc[idx_2025]  # Actual decimal year of last point\n    \n    # 0. Add vertical line at end of data for reference\n    fig.add_vline(\n        x=year_2025,\n        line_dash=\"dot\",\n        line_color=\"gray\",\n        line_width=1,\n        secondary_y=False\n    )\n    \n    \"\"\"\n    # 0b. Calculate average annual Ocean Heat Content accumulation for comparison\n    # Ocean Heat Content went from ~10 ZJ (2005) to ~33 ZJ (2025) = 23 ZJ over 20 years\n    ohc_start = ohc_zj[0]\n    ohc_end = ohc_zj[-1]\n    years_span = years_ohc[-1] - years_ohc[0]\n    avg_annual_ohc = (ohc_end - ohc_start) / years_span\n    \n    # Add humanity energy comparison annotation\n    # Calculate committed \"pipeline\" warming from stored Ocean Heat Content\n    # Rough estimate: Ocean Heat Content capacity ~4000 J/(kg*K), mass ~1.4e21 kg for 0-2000m\n    # Stored excess heat ~23 ZJ, implies ~0.4 degC committed warming in pipeline\n    pipeline_warming = 0.4  # Conservative estimate\n    \n    fig.add_annotation(\n        x=year_2025,\n        y=32.7,  # Position near top of Ocean Heat Content scale\n        text=f'<b>Scale Comparison:</b><br>'\n             f'Humanity\\'s annual energy use: ~0.6 ZJ/yr<br>'\n             f'Ocean Heat Content accumulation: ~{avg_annual_ohc:.1f} ZJ/yr<br>'\n             f'<i>Ocean absorbs ~{avg_annual_ohc/0.6:.0f}x human energy use!</i><br><br>'\n             f'<b>Pipeline Warming:</b><br>'\n             f'Stored heat: {ohc_end - ohc_start:.1f} ZJ since 2005<br>'\n             f'<i>~{pipeline_warming:.1f} degC committed warming<br>still unrealized in atmosphere</i>',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='#4169E1',  # Royal blue to match Ocean Heat Content line\n        ax=-140,\n        ay=-50,\n        font=dict(size=9, color='#4169E1'),\n        bgcolor='rgba(255,255,255,0.95)',\n        bordercolor='#4169E1',\n        borderwidth=1.5,\n        align='left',\n        xref='x',\n        yref='y2'  # Use secondary y-axis (Ocean Heat Content scale)\n    )\n    \n    # 0c. Baseline annotation at 2005 - explain integration starting point\n    ohc_baseline = ohc_zj[0]\n    ohc_end = ohc_zj[-1]\n    total_accumulation = ohc_end - ohc_baseline\n    \n    # Simple two-line approach: fit linear trend to each decade\n    # First decade: 2005-2015\n    mask_first = (years_ohc >= 2005) & (years_ohc < 2015)\n    if np.sum(mask_first) > 1:\n        coef_first = np.polyfit(years_ohc[mask_first], ohc_zj[mask_first], 1)\n        slope_first = coef_first[0]  # ZJ per year\n    else:\n        slope_first = 1.0\n    \n    # Second decade: 2015-2025\n    mask_second = (years_ohc >= 2015) & (years_ohc <= 2025)\n    if np.sum(mask_second) > 1:\n        coef_second = np.polyfit(years_ohc[mask_second], ohc_zj[mask_second], 1)\n        slope_second = coef_second[0]  # ZJ per year\n    else:\n        slope_second = 1.2\n    \n    fig.add_annotation(\n        x=2005.2,\n        y=ohc_baseline,\n        text=f'<b>Integration Baseline</b><br>'\n             f'Starting: {ohc_baseline:.1f} ZJ (2005)<br>'\n             f'Accumulated: {total_accumulation:.1f} ZJ (20 yrs)<br>'\n             f'<i>Trend: {slope_first:.2f}[OK]{slope_second:.2f} ZJ/yr<br>(increasing rate)</i>',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='#4169E1',  # Royal blue to match Ocean Heat Content line\n        ax=60,\n        ay=-75,\n        font=dict(size=9, color='#4169E1'),\n        bgcolor='rgba(255,255,255,0.9)',\n        bordercolor='#4169E1',\n        borderwidth=1.5,\n        align='left',\n        xref='x',\n        yref='y2'  # Use secondary y-axis (Ocean Heat Content scale)\n    )\n    \"\"\"\n    \n    # CORRECTED ANNOTATION SECTION FOR energy_imbalance.py\n    # Replace lines 530-613 with this code\n\n    # Calculate key values from actual data\n    ohc_start = ohc_zj[0]\n    ohc_end = ohc_zj[-1]\n    years_span = years_ohc[-1] - years_ohc[0]\n    total_accumulation = ohc_end - ohc_start\n    avg_annual_ohc = total_accumulation / years_span\n\n    # Get the quadratic fit coefficients (already calculated in line 415)\n    # coefs = np.polyfit(years_ohc, ohc_zj, 2)\n    # ohc_trend = np.polyval(coefs, years_ohc)\n\n    # Calculate instantaneous slopes of the quadratic at 5-year intervals\n    # For quadratic y = a*x^2 + b*x + c, the derivative (slope) is: dy/dx = 2*a*x + b\n    def quadratic_slope(x, coefs):\n        \"\"\"Calculate instantaneous slope of quadratic at point x\"\"\"\n        return 2 * coefs[0] * x + coefs[1]\n\n    # Tony's empirically-determined values from sampling the trend line\n    # These represent the instantaneous slope of the quadratic at each point\n    slope_2010 = 1.00  # ZJ/yr\n    slope_2015 = 1.06  # ZJ/yr\n    slope_2020 = 1.10  # ZJ/yr\n    slope_2025 = 1.14  # ZJ/yr\n\n    # Find OHC values at 5-year intervals (from trend line or data)\n    # We'll use the actual data points closest to these years\n    def get_closest_value(year_target):\n        \"\"\"Get OHC value at year closest to target\"\"\"\n        idx = np.argmin(np.abs(years_ohc - year_target))\n        return ohc_zj[idx]\n\n    ohc_2005 = ohc_start  # 9.0 ZJ\n    ohc_2010 = get_closest_value(2010.2)  # ~14.9 ZJ\n    ohc_2015 = get_closest_value(2015.2)  # ~20.2 ZJ (from trend, or ~23.4 actual)\n    ohc_2020 = get_closest_value(2020.2)  # ~25.7 ZJ\n    ohc_2025 = ohc_end  # 31.9 ZJ\n\n    # ANNOTATION 1: Five-year progression markers along OHC line\n    # These show the relentless accumulation and increasing rate\n\n    # 2005.2 - Starting point (boundary condition)\n    fig.add_annotation(\n        x=2005.2,\n        y=ohc_2005,\n        text=f'March 2005: {ohc_2005:.1f} ZJ<br><i>Start</i>',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=0.8,\n        arrowwidth=1,\n        arrowcolor='#4169E1',\n        ax=0,\n        ay=-60,\n        font=dict(size=7, color='#4169E1'),\n        bgcolor='rgba(255,255,255,0.85)',\n        bordercolor='#4169E1',\n        borderwidth=1,\n        align='center',\n        xref='x',\n        yref='y2'\n    )\n\n    # 2010.2 - First interval\n    fig.add_annotation(\n        x=2010.2,\n        y=ohc_2010,\n        text=f'March 2010: {ohc_2010:.1f} ZJ<br><i>Rate: {slope_2010:.2f} ZJ/yr</i>',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=0.8,\n        arrowwidth=1,\n        arrowcolor='#4169E1',\n        ax=-50,\n        ay=-40,\n        font=dict(size=7, color='#4169E1'),\n        bgcolor='rgba(255,255,255,0.85)',\n        bordercolor='#4169E1',\n        borderwidth=1,\n        align='left',\n        xref='x',\n        yref='y2'\n    )\n\n    # 2015.2 - Midpoint\n    fig.add_annotation(\n        x=2015.2,\n        y=ohc_2015,\n        text=f'March 2015: {ohc_2015:.1f} ZJ<br><i>Rate: {slope_2015:.2f} ZJ/yr</i>',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=0.8,\n        arrowwidth=1,\n        arrowcolor='#4169E1',\n        ax=50,\n        ay=-40,\n        font=dict(size=7, color='#4169E1'),\n        bgcolor='rgba(255,255,255,0.85)',\n        bordercolor='#4169E1',\n        borderwidth=1,\n        align='right',\n        xref='x',\n        yref='y2'\n    )\n\n    # 2020.2 - Recent interval\n    fig.add_annotation(\n        x=2020.2,\n        y=ohc_2020,\n        text=f'March 2020: {ohc_2020:.1f} ZJ<br><i>Rate: {slope_2020:.2f} ZJ/yr</i>',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=0.8,\n        arrowwidth=1,\n        arrowcolor='#4169E1',\n        ax=-50,\n        ay=-40,\n        font=dict(size=7, color='#4169E1'),\n        bgcolor='rgba(255,255,255,0.85)',\n        bordercolor='#4169E1',\n        borderwidth=1,\n        align='left',\n        xref='x',\n        yref='y2'\n    )\n\n    # 2025.2 - Current endpoint (boundary condition)\n    fig.add_annotation(\n        x=2025.2,\n    #    y=ohc_2025,\n        y=31.9,\n    #    text=f'March 2025: {ohc_2025:.1f} ZJ<br><i>Rate: {slope_2025:.2f} ZJ/yr</i>',\n        text=f'March 2025: {31.9:.1f} ZJ<br><i>Rate: {slope_2025:.2f} ZJ/yr</i>',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=0.8,\n        arrowwidth=1,\n        arrowcolor='#4169E1',\n        ax=0,\n        ay=80,\n        font=dict(size=7, color='#4169E1'),\n        bgcolor='rgba(255,255,255,0.85)',\n        bordercolor='#4169E1',\n        borderwidth=1,\n        align='center',\n        xref='x',\n        yref='y2'\n    )\n\n    # ANNOTATION 2: Trend line explanation (small note near the trend line)\n#    fig.add_annotation(\n#        x=2012.0,\n#        y=16.0,\n#        text='<i>Dashed line: Quadratic fit<br>(shows acceleration)</i>',\n#        showarrow=False,\n#        font=dict(size=7, color='#4169E1'),\n#        bgcolor='rgba(255,255,255,0.7)',\n#        bordercolor='#4169E1',\n#        borderwidth=0.5,\n#        align='center',\n#        xref='x',\n#        yref='y2'\n#    )\n\n    # ANNOTATION 3: Scale Comparison (updated with corrected values)\n#    pipeline_warming = 0.4  # Conservative estimate\n    pipeline_warming = 0.6  # Hansen et al. (2005) - Earth's Energy Imbalance\n\n    fig.add_annotation(\n    #    x=year_2025,\n        x=2025.2,\n    #    y=32.7,  # Position near top of Ocean Heat Content scale\n        y=31.9,\n        text=f'<b>Scale Comparison:</b><br>'\n            f'Humanity\\'s annual energy use: ~0.6 ZJ/yr<br>'\n            f'Ocean heat accumulation<br>'\n    #        f'(March 2005 - March 2025): ~{avg_annual_ohc:.2f} ZJ/yr<br>'\n            f'(March 2005 - March 2025): ~ 1.08 ZJ/yr<br>'\n    #        f'<i>Ocean absorbs ~{avg_annual_ohc/0.6:.0f}x human energy use!</i><br><br>'\n            f'<i>Ocean absorbs ~{1.075/0.6:.0f}x human energy use!</i><br>'\n            f'<b>Total Accumulation (2005-2025):</b><br>'\n    #        f'Final: {ohc_2025:.1f} ZJ (2025)<br>'\n    #        f'March 2025: {31.9:.1f} ZJ<br>'            \n    #        f'Accumulated: {total_accumulation:.1f} ZJ<br>'\n            f'Accumulated since March 2005: {22.9:.1f} ZJ<br>'            \n            f'Acceleration: {slope_2010:.2f} [OK] {slope_2025:.2f} ZJ/yr (+{100*(slope_2025-slope_2010)/slope_2010:.0f}%)<br>',\n    #        f'<b>Pipeline Warming:</b><br>'        # this comment needs more developement\n    #        f'<i>~{pipeline_warming:.1f} degC committed warming (2005)<br>still unrealized in atmosphere</i>',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='#4169E1',\n        ax=-145,\n        ay=-60,\n        font=dict(size=8, color='#4169E1'),\n        bgcolor='rgba(255,255,255,0.95)',\n        bordercolor='#4169E1',\n        borderwidth=1.5,\n        align='left',\n        xref='x',\n        yref='y2'  # Use secondary y-axis (Ocean Heat Content scale)\n    )\n\n    # Note: The old \"Integration Baseline\" annotation has been replaced by the\n    # five-year progression markers above, which show the accumulation more clearly.\n    # The \"Scale Comparison\" now includes the final value, total accumulation,\n    # and acceleration information.\n\n    # 1. Paris Agreement (2015)\n    fig.add_annotation(\n        x=2015,\n        y=1.2,\n        text='Paris Agreement',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='#2E8B57',  # Sea green\n        ax=0,\n        ay=-40,\n        font=dict(size=10, color='#2E8B57'),\n        bgcolor='rgba(255,255,255,0.95)',\n        bordercolor='#2E8B57',\n        borderwidth=1\n    )\n    \n    # 1b. Key Climate Events\n    \"\"\"\n    # 2023 Record Heat\n    fig.add_annotation(\n        x=2023.2,\n        y=1.32,\n        text='2023 Record',\n        showarrow=False,\n        arrowhead=2,\n        arrowsize=0.8,\n        arrowwidth=1,\n        arrowcolor='#8B0000',  # Dark red\n        ax=1,\n        ay=1,\n        font=dict(size=8, color='#8B0000'),\n        bgcolor='rgba(255,255,255,0.9)',\n        bordercolor='#8B0000',\n        borderwidth=0.5\n    )\n    \"\"\"\n    \n    # 2. Present (2025) - use actual data values\n    fig.add_annotation(\n        x=year_2025,  # Use actual decimal year position\n        y=0.6,\n        text=f'April 2025<br>Imbalance: {imbalance_2025:.2f} W/m^2<br>Temp: +{temp_2025:.2f} degC',\n        showarrow=False,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=2,\n        arrowcolor='red',\n        ax=-60,\n        ay=80,\n        font=dict(size=10, color='red'),\n        bgcolor='rgba(255,255,255,0.9)',\n        bordercolor='red',\n        borderwidth=1\n    )\n    \n    # 3. The ocean buffer and visual integration explanation\n    fig.add_annotation(\n        x=0,\n        y=-0.23,\n        xref='paper',\n        yref='paper',\n        text=\n    #    '<b>The Causal Chain:</b> Greenhouse gases (CO2, CH4) trap outgoing radiation [OK] Earth\\'s energy imbalance (more in than out) [OK] '\n    #         '~90% of excess energy absorbed by oceans (0-2000m layer acts as heat reservoir) [OK] atmospheric temperature rises with lag.<br>'\n    #         '<b>Visual Guide:</b> Red shading = ocean warming periods (absorbing energy). Blue = cooling periods (releasing energy). '\n    #         'Net red dominance [OK] blue dotted line rises (cumulative heat storage grows) [OK] continued atmospheric warming as stored heat eventually releases.<br>'\n\n            '<b>The Causal Chain:</b> The accumulation of greenhouse gases (CO2, CH4) creates a sustained <b>Planetary Energy Imbalance (EEI)</b> (Orange line). Over 90% of this excess energy is absorbed by the' \n            'deep ocean, driving the rise of the <b>Ocean Heat Content (OHC)</b>.<br>' \n\n    #        '<b>ENSO & The Trade-off:</b> The El Nino-La Nina oscillation modulates this energy flow:<br>' \n            ' *<b>La Nina (Blue Bands):</b> The ocean absorbs more solar energy, temporarily <b>increasing the EEI</b> (Orange line peaks) while **cooling the atmosphere** (GMST dips).<br>' \n            ' *<b>El Nino (Orange Bands):</b> The ocean releases stored heat into the atmosphere, causing atmospheric temperature to <b>peak</b> (GMST peaks) while the planet temporarily reflects more sunlight, **decreasing the EEI** (Orange line dips).<br>'            \n            '<b>Key Insight:</b> The atmospheric temperature (GMST) swings are merely a *redistribution* of heat. The net positive accumulation shown by the rising **OHC** demonstrates the growing total committed warming stored in the climate system.<br>' \n\n    #         '<b>Data Sources:</b> '\n    #         'Temperature: <a href=\"https://data.giss.nasa.gov/gistemp/\">NASA GISS Surface Temperature Analysis (GISTEMP v4)</a> | '\n    #         'Ocean Heat Content: <a href=\"https://www.ncei.noaa.gov/access/global-ocean-heat-content/\">NOAA NCEI Ocean Heat Content (0-2000m, Levitus et al.)</a>',\n\n            '<b>Data Sources:</b> '\n            'Temperature: <a href=\"https://data.giss.nasa.gov/gistemp/\">NASA GISS Surface Temperature Analysis (GISTEMP v4)</a> | '\n            'Ocean Heat Content: <a href=\"https://www.ncei.noaa.gov/access/global-ocean-heat-content/\">NOAA NCEI Ocean Heat Content (0-2000m, Levitus et al.)</a> | '\n            'Pipeline Warming: <a href=\"https://doi.org/10.1126/science.1110252\">Hansen et al. (2005), Science</a>',\n\n\n        showarrow=False,\n        font=dict(size=9, color='#333'),\n        align='left',\n        bgcolor='rgba(255,250,205,0.9)',  # Light yellow\n        bordercolor='#FF8C00',\n        borderwidth=1,\n        borderpad=8\n    )\n    \n    return fig",
    "start_line": 105,
    "end_line": 924,
    "has_docstring": true,
    "docstring": "Create energy imbalance visualization (2005-2025)\n\nDual Y-axis plot showing:\n- Left: Temperature anomaly ( degC)\n- Right: Energy imbalance (W/m^2)\n\nDemonstrates the relationship between energy accumulation (cause)\nand temperature change (effect), revealing climate system inertia.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_energy_imbalance_visualization",
    "component_id": "energy_imbalance.create_energy_imbalance_visualization"
  },
  "energy_imbalance.quadratic_slope": {
    "id": "energy_imbalance.quadratic_slope",
    "name": "quadratic_slope",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\energy_imbalance.py",
    "relative_path": "energy_imbalance.py",
    "depends_on": [],
    "source_code": "    def quadratic_slope(x, coefs):\n        \"\"\"Calculate instantaneous slope of quadratic at point x\"\"\"\n        return 2 * coefs[0] * x + coefs[1]",
    "start_line": 634,
    "end_line": 636,
    "has_docstring": true,
    "docstring": "Calculate instantaneous slope of quadratic at point x",
    "parameters": [
      "x",
      "coefs"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function quadratic_slope",
    "component_id": "energy_imbalance.quadratic_slope"
  },
  "energy_imbalance.get_closest_value": {
    "id": "energy_imbalance.get_closest_value",
    "name": "get_closest_value",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\energy_imbalance.py",
    "relative_path": "energy_imbalance.py",
    "depends_on": [],
    "source_code": "    def get_closest_value(year_target):\n        \"\"\"Get OHC value at year closest to target\"\"\"\n        idx = np.argmin(np.abs(years_ohc - year_target))\n        return ohc_zj[idx]",
    "start_line": 647,
    "end_line": 650,
    "has_docstring": true,
    "docstring": "Get OHC value at year closest to target",
    "parameters": [
      "year_target"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_closest_value",
    "component_id": "energy_imbalance.get_closest_value"
  },
  "energy_imbalance.main": {
    "id": "energy_imbalance.main",
    "name": "main",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\energy_imbalance.py",
    "relative_path": "energy_imbalance.py",
    "depends_on": [
      "energy_imbalance.create_energy_imbalance_visualization",
      "save_utils.save_plot"
    ],
    "source_code": "def main():\n    \"\"\"Create and save the visualization\"\"\"\n    fig = create_energy_imbalance_visualization()\n    \n    if fig is not None:\n        # Show the visualization in browser (like other visualizations)\n        fig.show()\n        \n        # Then offer to save using save_utils if available\n        if SAVE_UTILS_AVAILABLE:\n            # save_plot signature: save_plot(fig, default_name)\n            save_plot(fig, 'energy_imbalance_2005_2025')\n        else:\n            # Fallback: save as HTML without dialog\n            output_file = 'energy_imbalance_2005_2025.html'\n            fig.write_html(output_file)\n            print(f\"[OK] Saved to: {output_file}\")\n        \n        print(\"[OK] Energy imbalance visualization created successfully\")\n        return True\n    else:\n        print(\"[FAIL] Could not create visualization\")\n        return False",
    "start_line": 926,
    "end_line": 948,
    "has_docstring": true,
    "docstring": "Create and save the visualization",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "energy_imbalance.main"
  },
  "eris_visualization_shells.create_eris_core_shell": {
    "id": "eris_visualization_shells.create_eris_core_shell",
    "name": "create_eris_core_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\eris_visualization_shells.py",
    "relative_path": "eris_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_eris_core_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Eris's core shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.60,  # range is .5 to .65\n        'color': 'rgb(187, 63, 63)',  # dull red at 875 K\n        'opacity': 1.0,\n        'name': 'Core',\n        'description': (\n            \"Eris, a dwarf planet in the Kuiper Belt, has a structure that scientists have been piecing together through observations <br>\" \n            \"and theoretical modeling. Here's what we currently understand:<br>\" \n            \"Core: Eris is believed to have a rocky core. Its high bulk density (around 2.5 g/cm^3) suggests that it is composed <br>\" \n            \"primarily of rock, making up a significant portion of its mass (possibly over 85%). This core likely contains radioactive <br>\" \n            \"elements, which produce internal heat.<br>\" \n            \"* Determining the precise radius fraction of Eris's core is challenging because we don't have direct observations of its <br>\" \n            \"  internal structure. However, we can make estimations based on its known properties:<br>\" \n            \"  * Total Radius: Eris has a radius of approximately 1163 +/- 6 kilometers.<br>\" \n            \"  * Density: Its density is estimated to be around 2.52 +/- 0.07 g/cm^3. This high density suggests a significant rocky component.<br>\" \n            \"  * Compositional Models: Based on its density, scientists believe Eris is composed largely of rock (possibly over 85% of its <br>\" \n            \"    mass) with the remainder being primarily water ice. The ice forms the mantle surrounding the rocky core.<br>\" \n            \"* Considering these factors, and drawing comparisons to other icy bodies with rocky cores like Europa or Ganymede in the outer <br>\" \n            \"  solar system, a reasonable estimate for the radius fraction of Eris's core would likely be around 50-65% of its total radius. <br>\" \n            \"  To achieve Eris's high bulk density with a significant ice mantle, the denser rocky core must occupy a substantial portion of <br>\" \n            \"  its volume. If the core were much smaller (a smaller radius fraction), the overall density would likely be lower, given the <br>\" \n            \"  lower density of water ice. Conversely, if the core occupied a much larger fraction, there would be less room for the <br>\" \n            \"  substantial ice mantle that is believed to exist. Therefore, while we don't have a definitive number, the rocky core of Eris <br>\" \n            \"  likely makes up roughly half to two-thirds of its total radius.<br>\" \n            \"* Temperature:<br>\" \n            \"  * Radiogenic Heating: The rocky core of Eris likely contains radioactive isotopes (such as uranium, thorium, and <br>\" \n            \"    potassium) that decay over time, releasing heat.<br>\" \n            \"  * Recent research based on data from the James Webb Space Telescope provides indirect evidence for a warm, potentially <br>\" \n            \"    even hot, rocky core in Eris. The detection of a moderate deuterium-to-hydrogen (D/H) ratio in methane ice on its surface <br>\" \n            \"    suggests that the methane was likely produced through geochemical processes in the interior, requiring elevated <br>\" \n            \"    temperatures (possibly above 150 degC or 300 degF) within the rocky core. Theoretical modeling of Eris's interior, considering <br>\" \n            \"    radiogenic heating and thermal conductivity, suggests that the central temperature could have been as high as 875 K.<br>\" \n            \"  * This warmth might even be sufficient to support a subsurface ocean at the core-mantle boundary.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * ERIS_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=4.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Eris: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Eris: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 18,
    "end_line": 86,
    "has_docstring": true,
    "docstring": "Creates Eris's core shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_eris_core_shell",
    "component_id": "eris_visualization_shells.create_eris_core_shell"
  },
  "eris_visualization_shells.create_eris_mantle_shell": {
    "id": "eris_visualization_shells.create_eris_mantle_shell",
    "name": "create_eris_mantle_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\eris_visualization_shells.py",
    "relative_path": "eris_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_eris_mantle_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Eris's mantle shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.66,  \n        'color': 'rgb(150, 0, 0)',  # These still represent red but with a lower intensity,  \n        'opacity': 0.9,\n        'name': 'Mantle',\n        'description': (\n            \"Mantle: Surrounding the rocky core is a substantial mantle made of water ice. Unlike Pluto's ice shell, Eris's ice <br>\" \n            \"mantle is thought to be convecting. This means that the warmer ice closer to the core rises, while the colder ice near <br>\" \n            \"the surface sinks, a process that helps dissipate the internal heat generated by the core. The thickness of this ice <br>\" \n            \"shell is estimated to be around 100 kilometers. There is currently no evidence to suggest the presence of a subsurface <br>\" \n            \"ocean within Eris.<br>\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * ERIS_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.5,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Eris: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Eris: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 97,
    "end_line": 143,
    "has_docstring": true,
    "docstring": "Creates Eris's mantle shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_eris_mantle_shell",
    "component_id": "eris_visualization_shells.create_eris_mantle_shell"
  },
  "eris_visualization_shells.create_eris_crust_shell": {
    "id": "eris_visualization_shells.create_eris_crust_shell",
    "name": "create_eris_crust_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\eris_visualization_shells.py",
    "relative_path": "eris_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_eris_crust_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates eris's cloud layer shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.0,  # the top of the troposphere is actually 1.002\n        'color': 'rgb(240, 240, 240)',  # optical, a color that is very close to white but with a slight hint of gray\n        'opacity': 1.0,\n        'name': 'Crust',\n        'description': (\n            \"Eris Crust<br>\" \n            \"(Note: toggle off the cloud layer in the legend to better see the interior structure.)<br><br>\"\n            \"Crust: The outermost layer is a crust of frozen gases, primarily nitrogen and methane ice. Eris has a very high albedo <br>\" \n            \"(reflectivity), reflecting about 96% of the sunlight that hits it. This bright surface is likely due to a frost layer <br>\" \n            \"formed from the condensation of its atmosphere when it is far from the Sun.<br>\" \n            \"* The optical color of Eris is primarily characterized by its very high albedo, meaning it reflects a large percentage <br>\" \n            \"  of the sunlight that hits it (around 96%). This high reflectivity is due to a relatively fresh layer of frozen nitrogen <br>\" \n            \"  and methane on its surface. The color is largely that of the illuminating source (the Sun). <br>\" \n            \"* Atmospheric effects (if any): Although its atmosphere is currently thought to be very thin or mostly frozen, any past or <br>\" \n            \"  transient atmosphere could have slightly altered the light scattering and thus the observed color.\"\n            )\n    }\n    \n    # Calculate radius in AU\n    radius = layer_info['radius_fraction'] * ERIS_RADIUS_AU\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Create mesh with reasonable resolution for performance\n    resolution = 24  # Reduced from typical 50 for markers\n    \n    # Create a UV sphere\n    phi = np.linspace(0, 2*np.pi, resolution)\n    theta = np.linspace(-np.pi/2, np.pi/2, resolution)\n    phi, theta = np.meshgrid(phi, theta)\n    \n    x = radius * np.cos(theta) * np.cos(phi)\n    y = radius * np.cos(theta) * np.sin(phi)\n    z = radius * np.sin(theta)\n    \n    # Apply center position offset\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    # Create triangulation\n    indices = []\n    for i in range(resolution-1):\n        for j in range(resolution-1):\n            p1 = i * resolution + j\n            p2 = i * resolution + (j + 1)\n            p3 = (i + 1) * resolution + j\n            p4 = (i + 1) * resolution + (j + 1)\n            \n            indices.append([p1, p2, p4])\n            indices.append([p1, p4, p3])\n    \n    # Create main surface\n    surface_trace = go.Mesh3d(\n        x=x.flatten(), \n        y=y.flatten(), \n        z=z.flatten(),\n        i=[idx[0] for idx in indices],\n        j=[idx[1] for idx in indices],\n        k=[idx[2] for idx in indices],\n        color=layer_info['color'],\n        opacity=layer_info['opacity'],\n        name=f\"Eris: {layer_info['name']}\",\n        showlegend=True,\n        hoverinfo='none',  # Disable hover on mesh surface\n        # Add these new parameters to make hover text invisible\n        hovertemplate=' ',  # Empty template instead of None\n        hoverlabel=dict(\n    #        bgcolor='rgba(0,0,0,0)',  # Transparent background\n            font=dict(\n                color='rgba(0,0,0,0)',  # Transparent text\n    #            size=0                  # Zero font size\n            ),\n            bordercolor='rgba(0,0,0,0)'  # Transparent border\n        ), \n        # Add these new parameters to eliminate shading\n        flatshading=True,  # Use flat shading instead of smooth\n        lighting=dict(\n            ambient=1.0,     # Set to maximum (1.0)\n            diffuse=0.0,     # Turn off diffuse lighting\n            specular=0.0,    # Turn off specular highlights\n            roughness=1.0,   # Maximum roughness\n            fresnel=0.0      # Turn off fresnel effect\n        ),\n        lightposition=dict(\n            x=0,  # Centered light\n            y=0,  # Centered light\n            z=10000  # Light from very far above to minimize shadows\n        )       \n    )\n        \n    # Use the Fibonacci sphere algorithm for more even point distribution\n    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points\n    \n    # Generate fibonacci sphere points\n    fib_points = fibonacci_sphere(samples=50)  # Originally, 50 hover points evenly distributed\n    \n    # Scale and offset the points\n    x_hover = [p[0] * radius + center_x for p in fib_points]\n    y_hover = [p[1] * radius + center_y for p in fib_points]\n    z_hover = [p[2] * radius + center_z for p in fib_points]\n        \n    # Create a list of repeated descriptions for each point\n    # This is crucial - we need exactly one text entry per point\n    hover_texts = [layer_info['description']] * len(x_hover)\n\n    # Just the name for \"Object Names Only\" mode\n    layer_name = f\"Eris: {layer_info['name']}\"\n    minimal_hover_texts = [layer_name] * len(x_hover)\n\n    # Create hover trace with direct text assignment\n    hover_trace = go.Scatter3d(\n        x=x_hover, \n        y=y_hover, \n        z=z_hover,\n        mode='markers',\n        marker=dict(\n            size=2,  # originally 5\n            color='rgb(240, 240, 240)',  \n            opacity=1.0,  # originally 0.8\n            line=dict(  # Add a contrasting outline\n                width=1,\n                color='black'\n            )\n        ),\n        name=f\"Eris: {layer_info['name']} (Info)\",\n        text=hover_texts,  # IMPORTANT: Matching length with coordinate arrays\n        customdata=minimal_hover_texts,  # For \"Object Names Only\" mode\n        hovertemplate='%{text}<extra></extra>',  # Use the standard hover template\n        showlegend=False  # Don't show in legend since it's just for hover\n    )\n\n    return [surface_trace, hover_trace]",
    "start_line": 153,
    "end_line": 305,
    "has_docstring": true,
    "docstring": "Creates eris's cloud layer shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_eris_crust_shell",
    "component_id": "eris_visualization_shells.create_eris_crust_shell"
  },
  "eris_visualization_shells.fibonacci_sphere": {
    "id": "eris_visualization_shells.fibonacci_sphere",
    "name": "fibonacci_sphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\eris_visualization_shells.py",
    "relative_path": "eris_visualization_shells.py",
    "depends_on": [],
    "source_code": "    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points",
    "start_line": 250,
    "end_line": 265,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "samples"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fibonacci_sphere",
    "component_id": "eris_visualization_shells.fibonacci_sphere"
  },
  "eris_visualization_shells.create_eris_atmosphere_shell": {
    "id": "eris_visualization_shells.create_eris_atmosphere_shell",
    "name": "create_eris_atmosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\eris_visualization_shells.py",
    "relative_path": "eris_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_eris_atmosphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates eris's atmosphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.005,  # almost none and intermittent\n        'color': 'rgb(240, 245, 250)',  # optical pale blue\n        'opacity': 0.1,\n        'name': 'Atmosphere',\n        'description': (\n            \"Atmosphere: Eris has a very tenuous atmosphere that is dynamic. When Eris is at its farthest point from the Sun <br>\" \n            \"(aphelion), the extremely cold temperatures cause its atmosphere, likely composed of nitrogen and methane, to freeze <br>\" \n            \"and fall as snow onto the surface. As Eris moves closer to the Sun in its highly elliptical orbit (perihelion), the <br>\" \n            \"surface warms up, and these ices sublimate, potentially creating a temporary atmosphere similar to Pluto's. However, <br>\" \n            \"observations have placed a very low upper limit on the current atmospheric pressure, suggesting it is currently very <br>\" \n            \"thin or mostly frozen.<br>\" \n            \"* The current understanding of Eris's atmosphere is that it is extremely tenuous, with an upper limit on surface <br>\" \n            \"  pressure of about 1 nanobar. This is about 10,000 times thinner than Pluto's current atmosphere. Given such a low <br>\" \n            \"  pressure, the extent of the atmosphere in terms of Eris's radii would be very small and likely not easily definable <br>\" \n            \"  in a significant way.<br>\" \n            \"* Near-Surface Existence: At such low pressures, the \\\"atmosphere\\\" is likely confined to a very thin layer near the <br>\" \n            \"  surface. The density of gas molecules would drop off extremely rapidly with altitude.<br>\" \n            \"* Collapse at Aphelion: Eris is currently near its aphelion (farthest point from the Sun). At these extremely cold <br>\" \n            \"  temperatures (around -240 degC), the primary atmospheric constituents, nitrogen and methane, would freeze and deposit <br>\" \n            \"  as frost on the surface. Any atmosphere present would be minimal.<br>\" \n            \"* Potential Sublimation at Perihelion: As Eris gets closer to the Sun (perihelion), the surface temperature will increase <br>\" \n            \"  slightly, potentially causing some of these ices to sublimate and form a transient, thin atmosphere. However, even in <br>\" \n            \"  this case, the extent is not expected to be a significant fraction of Eris's radius. In practical terms, the extent of <br>\" \n            \"  Eris's atmosphere in radii is considered negligible for most structural considerations. Scientists often discuss the <br>\" \n            \"  surface composition and potential for a thin, dynamic atmosphere rather than a significant, extended gaseous envelope. <br>\" \n            \"* To put it in perspective: if Eris had an atmosphere that extended even a few kilometers, that would be a tiny fraction <br>\" \n            \"  (less than 0.01) of its total radius. The current observational limits suggest it's likely much less than that for a <br>\" \n            \"  sustained atmosphere at its current distance from the Sun.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * ERIS_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Eris: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Eris: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=layer_radius\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 317,
    "end_line": 388,
    "has_docstring": true,
    "docstring": "Creates eris's atmosphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_eris_atmosphere_shell",
    "component_id": "eris_visualization_shells.create_eris_atmosphere_shell"
  },
  "eris_visualization_shells.create_eris_hill_sphere_shell": {
    "id": "eris_visualization_shells.create_eris_hill_sphere_shell",
    "name": "create_eris_hill_sphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\eris_visualization_shells.py",
    "relative_path": "eris_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_eris_hill_sphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Eris's Hill sphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 6965, \n        'color': 'rgb(0, 255, 0)',  # Green for Hill sphere\n        'opacity': 0.25,\n        'name': 'Hill Sphere',\n        'description': (\n            \"SET MANUAL SCALE OF AT LEAST 0.05 AU TO VISUALIZE.<br><br>\"\n            \"Hill Sphere: The Hill sphere, or Roche sphere, of Eris is the region around it where its own gravity is the dominant <br>\" \n            \"force attracting satellites. For Eris, the radius of its Hill sphere is estimated to be about 8.1 million kilometers <br>\" \n            \"(0.054 astronomical units). This is the region where its moon, Dysnomia, orbits. Any object within this sphere is more <br>\" \n            \"likely to be gravitationally bound to Eris.<br>\" \n            \"* The region where Eris's gravity is the dominant force attracting satellites extends to a distance of roughly 6965 <br>\" \n            \"  Eris radii from its center.\"          \n            )\n    }\n        \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * ERIS_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Eris: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Eris: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=layer_radius\n    )\n    for trace in sun_traces:\n        traces.append(trace) \n\n    return traces",
    "start_line": 400,
    "end_line": 455,
    "has_docstring": true,
    "docstring": "Creates Eris's Hill sphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_eris_hill_sphere_shell",
    "component_id": "eris_visualization_shells.create_eris_hill_sphere_shell"
  },
  "examine_hot_csv.examine_csv": {
    "id": "examine_hot_csv.examine_csv",
    "name": "examine_csv",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\examine_hot_csv.py",
    "relative_path": "examine_hot_csv.py",
    "depends_on": [],
    "source_code": "def examine_csv():\n    filename = '3773_v3_niskin_hot001_yr01_to_hot348_yr35.csv'\n    \n    print(\"=\" * 80)\n    print(f\"Examining: {filename}\")\n    print(\"=\" * 80)\n    \n    with open(filename, 'r', encoding='utf-8') as f:\n        reader = csv.reader(f)\n        \n        # Get header\n        header = next(reader)\n        \n        print(f\"\\nTotal columns: {len(header)}\")\n        print(\"\\n\" + \"=\" * 80)\n        print(\"ALL COLUMN NAMES:\")\n        print(\"=\" * 80)\n        for i, col in enumerate(header):\n            print(f\"{i:3d}: {col}\")\n        \n        # Look for date and pH columns\n        print(\"\\n\" + \"=\" * 80)\n        print(\"COLUMNS CONTAINING 'date', 'year', 'month', or 'ph':\")\n        print(\"=\" * 80)\n        for i, col in enumerate(header):\n            col_lower = col.lower()\n            if any(keyword in col_lower for keyword in ['date', 'year', 'month', 'ph']):\n                print(f\"{i:3d}: {col}\")\n        \n        # Show first 5 data rows\n        print(\"\\n\" + \"=\" * 80)\n        print(\"FIRST 5 DATA ROWS:\")\n        print(\"=\" * 80)\n        for row_num, row in enumerate(reader):\n            if row_num >= 5:\n                break\n            print(f\"\\nRow {row_num + 1}:\")\n            # Show date column (index 4)\n            if len(row) > 4:\n                print(f\"  Date (col 4): {row[4]}\")\n            # Show pH column (index 22)\n            if len(row) > 22:\n                print(f\"  pH (col 22): {row[22]}\")\n            # Show first 10 columns\n            print(f\"  First 10 cols: {row[:10]}\")",
    "start_line": 6,
    "end_line": 50,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function examine_csv",
    "component_id": "examine_hot_csv.examine_csv"
  },
  "exoplanet_coordinates.apply_proper_motion": {
    "id": "exoplanet_coordinates.apply_proper_motion",
    "name": "apply_proper_motion",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_coordinates.py",
    "relative_path": "exoplanet_coordinates.py",
    "depends_on": [],
    "source_code": "def apply_proper_motion(ra_deg, dec_deg, pmra_mas_yr, pmdec_mas_yr,\n                       epoch, target_date, distance_pc=None):\n    \"\"\"\n    Apply proper motion to stellar position\n    \n    Critical for nearby stars like Proxima Centauri which have\n    significant proper motion (>3 arcsec/year).\n    \n    Parameters:\n        ra_deg: float - Right ascension at epoch (degrees)\n        dec_deg: float - Declination at epoch (degrees)\n        pmra_mas_yr: float - Proper motion in RA (mas/year, includes cos(dec))\n        pmdec_mas_yr: float - Proper motion in Dec (mas/year)\n        epoch: datetime - Reference epoch for coordinates\n        target_date: datetime - Date to calculate position for\n        distance_pc: float - Distance in parsecs (optional, for 3D motion)\n        \n    Returns:\n        ra_new, dec_new: floats - Corrected position (degrees)\n        \n    Note:\n        pmra is typically already multiplied by cos(dec) in catalogs.\n        If not, multiply pmra by cos(dec_deg) before calling.\n    \"\"\"\n    # Ensure dates are UTC-aware\n    if epoch.tzinfo is None:\n        epoch = epoch.replace(tzinfo=timezone.utc)\n    if target_date.tzinfo is None:\n        target_date = target_date.replace(tzinfo=timezone.utc)\n    \n    # Calculate elapsed time in years\n    dt_seconds = (target_date - epoch).total_seconds()\n    years_elapsed = dt_seconds / (365.25 * 86400)\n    \n    # Convert proper motion from mas/year to degrees\n    # 1 mas = 1/3,600,000 degrees\n    pmra_deg_yr = pmra_mas_yr / 3600000.0\n    pmdec_deg_yr = pmdec_mas_yr / 3600000.0\n    \n    # Apply corrections\n    delta_ra = pmra_deg_yr * years_elapsed\n    delta_dec = pmdec_deg_yr * years_elapsed\n    \n    ra_new = ra_deg + delta_ra\n    dec_new = dec_deg + delta_dec\n    \n    # Wrap RA to [0, 360)\n    ra_new = ra_new % 360.0\n    \n    # Clamp Dec to [-90, 90]\n    dec_new = np.clip(dec_new, -90.0, 90.0)\n    \n    return ra_new, dec_new",
    "start_line": 31,
    "end_line": 83,
    "has_docstring": true,
    "docstring": "Apply proper motion to stellar position\n\nCritical for nearby stars like Proxima Centauri which have\nsignificant proper motion (>3 arcsec/year).\n\nParameters:\n    ra_deg: float - Right ascension at epoch (degrees)\n    dec_deg: float - Declination at epoch (degrees)\n    pmra_mas_yr: float - Proper motion in RA (mas/year, includes cos(dec))\n    pmdec_mas_yr: float - Proper motion in Dec (mas/year)\n    epoch: datetime - Reference epoch for coordinates\n    target_date: datetime - Date to calculate position for\n    distance_pc: float - Distance in parsecs (optional, for 3D motion)\n    \nReturns:\n    ra_new, dec_new: floats - Corrected position (degrees)\n    \nNote:\n    pmra is typically already multiplied by cos(dec) in catalogs.\n    If not, multiply pmra by cos(dec_deg) before calling.",
    "parameters": [
      "ra_deg",
      "dec_deg",
      "pmra_mas_yr",
      "pmdec_mas_yr",
      "epoch",
      "target_date",
      "distance_pc"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function apply_proper_motion",
    "component_id": "exoplanet_coordinates.apply_proper_motion"
  },
  "exoplanet_coordinates.get_star_position_at_date": {
    "id": "exoplanet_coordinates.get_star_position_at_date",
    "name": "get_star_position_at_date",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_coordinates.py",
    "relative_path": "exoplanet_coordinates.py",
    "depends_on": [
      "exoplanet_coordinates.apply_proper_motion"
    ],
    "source_code": "def get_star_position_at_date(host_star_data, target_date):\n    \"\"\"\n    Get corrected stellar position at specific date\n    \n    Applies proper motion if significant. For distant stars (>100 pc)\n    with small proper motion, this correction is minimal.\n    \n    Parameters:\n        host_star_data: dict - Host star data from exoplanet_systems.py\n        target_date: datetime - Date for position\n        \n    Returns:\n        ra, dec: floats - Corrected position (degrees)\n    \"\"\"\n    ra = host_star_data['ra']\n    dec = host_star_data['dec']\n    pmra = host_star_data.get('pmra', 0.0)\n    pmdec = host_star_data.get('pmdec', 0.0)\n    epoch = host_star_data.get('epoch')\n    \n    if epoch is None:\n        # No epoch specified, return original position\n        return ra, dec\n    \n    # Apply proper motion\n    ra_corrected, dec_corrected = apply_proper_motion(\n        ra, dec, pmra, pmdec, epoch, target_date\n    )\n    \n    return ra_corrected, dec_corrected",
    "start_line": 85,
    "end_line": 114,
    "has_docstring": true,
    "docstring": "Get corrected stellar position at specific date\n\nApplies proper motion if significant. For distant stars (>100 pc)\nwith small proper motion, this correction is minimal.\n\nParameters:\n    host_star_data: dict - Host star data from exoplanet_systems.py\n    target_date: datetime - Date for position\n    \nReturns:\n    ra, dec: floats - Corrected position (degrees)",
    "parameters": [
      "host_star_data",
      "target_date"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_star_position_at_date",
    "component_id": "exoplanet_coordinates.get_star_position_at_date"
  },
  "exoplanet_coordinates.radec_to_cartesian": {
    "id": "exoplanet_coordinates.radec_to_cartesian",
    "name": "radec_to_cartesian",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_coordinates.py",
    "relative_path": "exoplanet_coordinates.py",
    "depends_on": [],
    "source_code": "def radec_to_cartesian(ra_deg, dec_deg, distance_au):\n    \"\"\"\n    Convert equatorial coordinates to 3D Cartesian\n    \n    This transformation is ONLY for placing host stars in the\n    galactic/stellar neighborhood context (Phase 4). It is NOT\n    used for exoplanet orbit visualization.\n    \n    Coordinate system (J2000 equatorial):\n    - Origin: Solar System barycenter\n    - X-axis: Points to vernal equinox (RA=0 deg, Dec=0 deg)\n    - Y-axis: Points to RA=90 deg, Dec=0 deg\n    - Z-axis: Points to north celestial pole (Dec=+90 deg)\n    \n    Parameters:\n        ra_deg: float - Right ascension (degrees)\n        dec_deg: float - Declination (degrees)\n        distance_au: float - Distance (AU or parsecs, units preserved)\n        \n    Returns:\n        x, y, z: floats - Cartesian coordinates (same units as distance)\n    \"\"\"\n    # Convert to radians\n    ra_rad = np.radians(ra_deg)\n    dec_rad = np.radians(dec_deg)\n    \n    # Spherical to Cartesian conversion\n    x = distance_au * np.cos(dec_rad) * np.cos(ra_rad)\n    y = distance_au * np.cos(dec_rad) * np.sin(ra_rad)\n    z = distance_au * np.sin(dec_rad)\n    \n    return x, y, z",
    "start_line": 124,
    "end_line": 155,
    "has_docstring": true,
    "docstring": "Convert equatorial coordinates to 3D Cartesian\n\nThis transformation is ONLY for placing host stars in the\ngalactic/stellar neighborhood context (Phase 4). It is NOT\nused for exoplanet orbit visualization.\n\nCoordinate system (J2000 equatorial):\n- Origin: Solar System barycenter\n- X-axis: Points to vernal equinox (RA=0 deg, Dec=0 deg)\n- Y-axis: Points to RA=90 deg, Dec=0 deg\n- Z-axis: Points to north celestial pole (Dec=+90 deg)\n\nParameters:\n    ra_deg: float - Right ascension (degrees)\n    dec_deg: float - Declination (degrees)\n    distance_au: float - Distance (AU or parsecs, units preserved)\n    \nReturns:\n    x, y, z: floats - Cartesian coordinates (same units as distance)",
    "parameters": [
      "ra_deg",
      "dec_deg",
      "distance_au"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function radec_to_cartesian",
    "component_id": "exoplanet_coordinates.radec_to_cartesian"
  },
  "exoplanet_coordinates.cartesian_to_radec": {
    "id": "exoplanet_coordinates.cartesian_to_radec",
    "name": "cartesian_to_radec",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_coordinates.py",
    "relative_path": "exoplanet_coordinates.py",
    "depends_on": [],
    "source_code": "def cartesian_to_radec(x, y, z):\n    \"\"\"\n    Convert 3D Cartesian to equatorial coordinates\n    \n    Inverse of radec_to_cartesian. Used for verification/testing.\n    \n    Parameters:\n        x, y, z: floats - Cartesian coordinates\n        \n    Returns:\n        ra_deg, dec_deg, distance: floats - Spherical coordinates\n    \"\"\"\n    distance = np.sqrt(x**2 + y**2 + z**2)\n    \n    # Avoid division by zero\n    if distance < 1e-10:\n        return 0.0, 0.0, 0.0\n    \n    # Calculate declination\n    dec_rad = np.arcsin(z / distance)\n    dec_deg = np.degrees(dec_rad)\n    \n    # Calculate right ascension\n    ra_rad = np.arctan2(y, x)\n    ra_deg = np.degrees(ra_rad)\n    \n    # Wrap RA to [0, 360)\n    ra_deg = ra_deg % 360.0\n    \n    return ra_deg, dec_deg, distance",
    "start_line": 157,
    "end_line": 186,
    "has_docstring": true,
    "docstring": "Convert 3D Cartesian to equatorial coordinates\n\nInverse of radec_to_cartesian. Used for verification/testing.\n\nParameters:\n    x, y, z: floats - Cartesian coordinates\n    \nReturns:\n    ra_deg, dec_deg, distance: floats - Spherical coordinates",
    "parameters": [
      "x",
      "y",
      "z"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function cartesian_to_radec",
    "component_id": "exoplanet_coordinates.cartesian_to_radec"
  },
  "exoplanet_coordinates.get_star_3d_position": {
    "id": "exoplanet_coordinates.get_star_3d_position",
    "name": "get_star_3d_position",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_coordinates.py",
    "relative_path": "exoplanet_coordinates.py",
    "depends_on": [
      "exoplanet_coordinates.get_star_position_at_date",
      "exoplanet_coordinates.radec_to_cartesian"
    ],
    "source_code": "def get_star_3d_position(host_star_data, target_date=None):\n    \"\"\"\n    Get 3D position of host star in galactic context\n    \n    Used ONLY for Phase 4 integration with stellar visualization.\n    NOT used for exoplanet orbit plotting (which uses local frame).\n    \n    Parameters:\n        host_star_data: dict - Host star data\n        target_date: datetime - Date for proper motion correction (optional)\n        \n    Returns:\n        x, y, z: floats - Position in J2000 equatorial frame (parsecs)\n    \"\"\"\n    # Get corrected position\n    if target_date is not None:\n        ra, dec = get_star_position_at_date(host_star_data, target_date)\n    else:\n        ra = host_star_data['ra']\n        dec = host_star_data['dec']\n    \n    distance_pc = host_star_data['distance_pc']\n    \n    # Convert to Cartesian\n    x, y, z = radec_to_cartesian(ra, dec, distance_pc)\n    \n    return x, y, z",
    "start_line": 188,
    "end_line": 214,
    "has_docstring": true,
    "docstring": "Get 3D position of host star in galactic context\n\nUsed ONLY for Phase 4 integration with stellar visualization.\nNOT used for exoplanet orbit plotting (which uses local frame).\n\nParameters:\n    host_star_data: dict - Host star data\n    target_date: datetime - Date for proper motion correction (optional)\n    \nReturns:\n    x, y, z: floats - Position in J2000 equatorial frame (parsecs)",
    "parameters": [
      "host_star_data",
      "target_date"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_star_3d_position",
    "component_id": "exoplanet_coordinates.get_star_3d_position"
  },
  "exoplanet_coordinates.calculate_binary_barycenter": {
    "id": "exoplanet_coordinates.calculate_binary_barycenter",
    "name": "calculate_binary_barycenter",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_coordinates.py",
    "relative_path": "exoplanet_coordinates.py",
    "depends_on": [],
    "source_code": "def calculate_binary_barycenter(star_A_mass, star_B_mass, \n                                star_A_position, star_B_position):\n    \"\"\"\n    Calculate center of mass for binary star system\n    \n    For visualization purposes, we typically place the barycenter\n    at the origin (0, 0, 0) and calculate stellar positions relative\n    to it. This function is provided for completeness but may not\n    be needed in practice.\n    \n    Parameters:\n        star_A_mass: float - Primary star mass (solar masses)\n        star_B_mass: float - Secondary star mass (solar masses)\n        star_A_position: tuple - (x, y, z) of star A\n        star_B_position: tuple - (x, y, z) of star B\n        \n    Returns:\n        x, y, z: floats - Barycenter position\n    \"\"\"\n    total_mass = star_A_mass + star_B_mass\n    \n    x_A, y_A, z_A = star_A_position\n    x_B, y_B, z_B = star_B_position\n    \n    x_bary = (star_A_mass * x_A + star_B_mass * x_B) / total_mass\n    y_bary = (star_A_mass * y_A + star_B_mass * y_B) / total_mass\n    z_bary = (star_A_mass * z_A + star_B_mass * z_B) / total_mass\n    \n    return x_bary, y_bary, z_bary",
    "start_line": 220,
    "end_line": 248,
    "has_docstring": true,
    "docstring": "Calculate center of mass for binary star system\n\nFor visualization purposes, we typically place the barycenter\nat the origin (0, 0, 0) and calculate stellar positions relative\nto it. This function is provided for completeness but may not\nbe needed in practice.\n\nParameters:\n    star_A_mass: float - Primary star mass (solar masses)\n    star_B_mass: float - Secondary star mass (solar masses)\n    star_A_position: tuple - (x, y, z) of star A\n    star_B_position: tuple - (x, y, z) of star B\n    \nReturns:\n    x, y, z: floats - Barycenter position",
    "parameters": [
      "star_A_mass",
      "star_B_mass",
      "star_A_position",
      "star_B_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_binary_barycenter",
    "component_id": "exoplanet_coordinates.calculate_binary_barycenter"
  },
  "exoplanet_coordinates.create_local_frame_description": {
    "id": "exoplanet_coordinates.create_local_frame_description",
    "name": "create_local_frame_description",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_coordinates.py",
    "relative_path": "exoplanet_coordinates.py",
    "depends_on": [],
    "source_code": "def create_local_frame_description(host_star_data):\n    \"\"\"\n    Generate description of local coordinate frame for exoplanet system\n    \n    This is informational only - helps document what coordinate system\n    we're using for each exoplanet system visualization.\n    \n    Parameters:\n        host_star_data: dict - Host star data\n        \n    Returns:\n        dict: Frame description\n    \"\"\"\n    ra = host_star_data['ra']\n    dec = host_star_data['dec']\n    \n    # Format RA as hours:minutes:seconds\n    ra_hours = ra / 15.0\n    ra_h = int(ra_hours)\n    ra_m = int((ra_hours - ra_h) * 60)\n    ra_s = ((ra_hours - ra_h) * 60 - ra_m) * 60\n    \n    # Format Dec as degrees:arcminutes:arcseconds\n    dec_sign = '+' if dec >= 0 else '-'\n    dec_abs = abs(dec)\n    dec_d = int(dec_abs)\n    dec_m = int((dec_abs - dec_d) * 60)\n    dec_s = ((dec_abs - dec_d) * 60 - dec_m) * 60\n    \n    description = {\n        'origin': 'Host star barycenter at (0, 0, 0)',\n        'xy_plane': 'Sky plane (perpendicular to Earth line of sight)',\n        'z_axis': 'Toward Earth (positive = toward observer)',\n        'line_of_sight_ra': f\"{ra_h:02d}h {ra_m:02d}m {ra_s:04.1f}s\",\n        'line_of_sight_dec': f\"{dec_sign}{dec_d:02d} deg {dec_m:02d}' {dec_s:04.1f}\\\"\",\n        'note': 'Independent frame - NOT aligned with Solar System ecliptic'\n    }\n    \n    return description",
    "start_line": 254,
    "end_line": 292,
    "has_docstring": true,
    "docstring": "Generate description of local coordinate frame for exoplanet system\n\nThis is informational only - helps document what coordinate system\nwe're using for each exoplanet system visualization.\n\nParameters:\n    host_star_data: dict - Host star data\n    \nReturns:\n    dict: Frame description",
    "parameters": [
      "host_star_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_local_frame_description",
    "component_id": "exoplanet_coordinates.create_local_frame_description"
  },
  "exoplanet_coordinates.parsecs_to_lightyears": {
    "id": "exoplanet_coordinates.parsecs_to_lightyears",
    "name": "parsecs_to_lightyears",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_coordinates.py",
    "relative_path": "exoplanet_coordinates.py",
    "depends_on": [],
    "source_code": "def parsecs_to_lightyears(distance_pc):\n    \"\"\"Convert parsecs to light-years (1 pc = 3.26156 ly)\"\"\"\n    return distance_pc * 3.26156",
    "start_line": 298,
    "end_line": 300,
    "has_docstring": true,
    "docstring": "Convert parsecs to light-years (1 pc = 3.26156 ly)",
    "parameters": [
      "distance_pc"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parsecs_to_lightyears",
    "component_id": "exoplanet_coordinates.parsecs_to_lightyears"
  },
  "exoplanet_coordinates.lightyears_to_parsecs": {
    "id": "exoplanet_coordinates.lightyears_to_parsecs",
    "name": "lightyears_to_parsecs",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_coordinates.py",
    "relative_path": "exoplanet_coordinates.py",
    "depends_on": [],
    "source_code": "def lightyears_to_parsecs(distance_ly):\n    \"\"\"Convert light-years to parsecs\"\"\"\n    return distance_ly / 3.26156",
    "start_line": 302,
    "end_line": 304,
    "has_docstring": true,
    "docstring": "Convert light-years to parsecs",
    "parameters": [
      "distance_ly"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function lightyears_to_parsecs",
    "component_id": "exoplanet_coordinates.lightyears_to_parsecs"
  },
  "exoplanet_coordinates.parsecs_to_au": {
    "id": "exoplanet_coordinates.parsecs_to_au",
    "name": "parsecs_to_au",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_coordinates.py",
    "relative_path": "exoplanet_coordinates.py",
    "depends_on": [],
    "source_code": "def parsecs_to_au(distance_pc):\n    \"\"\"Convert parsecs to AU (1 pc = 206265 AU)\"\"\"\n    return distance_pc * 206265",
    "start_line": 306,
    "end_line": 308,
    "has_docstring": true,
    "docstring": "Convert parsecs to AU (1 pc = 206265 AU)",
    "parameters": [
      "distance_pc"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parsecs_to_au",
    "component_id": "exoplanet_coordinates.parsecs_to_au"
  },
  "exoplanet_coordinates.au_to_parsecs": {
    "id": "exoplanet_coordinates.au_to_parsecs",
    "name": "au_to_parsecs",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_coordinates.py",
    "relative_path": "exoplanet_coordinates.py",
    "depends_on": [],
    "source_code": "def au_to_parsecs(distance_au):\n    \"\"\"Convert AU to parsecs\"\"\"\n    return distance_au / 206265",
    "start_line": 310,
    "end_line": 312,
    "has_docstring": true,
    "docstring": "Convert AU to parsecs",
    "parameters": [
      "distance_au"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function au_to_parsecs",
    "component_id": "exoplanet_coordinates.au_to_parsecs"
  },
  "exoplanet_coordinates.stellar_parallax_to_distance": {
    "id": "exoplanet_coordinates.stellar_parallax_to_distance",
    "name": "stellar_parallax_to_distance",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_coordinates.py",
    "relative_path": "exoplanet_coordinates.py",
    "depends_on": [],
    "source_code": "def stellar_parallax_to_distance(parallax_mas):\n    \"\"\"\n    Convert parallax to distance\n    \n    Parameters:\n        parallax_mas: float - Parallax (milliarcseconds)\n        \n    Returns:\n        distance_pc: float - Distance (parsecs)\n    \"\"\"\n    if parallax_mas <= 0:\n        return float('inf')\n    return 1000.0 / parallax_mas",
    "start_line": 314,
    "end_line": 326,
    "has_docstring": true,
    "docstring": "Convert parallax to distance\n\nParameters:\n    parallax_mas: float - Parallax (milliarcseconds)\n    \nReturns:\n    distance_pc: float - Distance (parsecs)",
    "parameters": [
      "parallax_mas"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function stellar_parallax_to_distance",
    "component_id": "exoplanet_coordinates.stellar_parallax_to_distance"
  },
  "exoplanet_coordinates.distance_to_stellar_parallax": {
    "id": "exoplanet_coordinates.distance_to_stellar_parallax",
    "name": "distance_to_stellar_parallax",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_coordinates.py",
    "relative_path": "exoplanet_coordinates.py",
    "depends_on": [],
    "source_code": "def distance_to_stellar_parallax(distance_pc):\n    \"\"\"\n    Convert distance to parallax\n    \n    Parameters:\n        distance_pc: float - Distance (parsecs)\n        \n    Returns:\n        parallax_mas: float - Parallax (milliarcseconds)\n    \"\"\"\n    if distance_pc <= 0:\n        return 0.0\n    return 1000.0 / distance_pc",
    "start_line": 328,
    "end_line": 340,
    "has_docstring": true,
    "docstring": "Convert distance to parallax\n\nParameters:\n    distance_pc: float - Distance (parsecs)\n    \nReturns:\n    parallax_mas: float - Parallax (milliarcseconds)",
    "parameters": [
      "distance_pc"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function distance_to_stellar_parallax",
    "component_id": "exoplanet_coordinates.distance_to_stellar_parallax"
  },
  "exoplanet_coordinates.calculate_tangential_velocity": {
    "id": "exoplanet_coordinates.calculate_tangential_velocity",
    "name": "calculate_tangential_velocity",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_coordinates.py",
    "relative_path": "exoplanet_coordinates.py",
    "depends_on": [],
    "source_code": "def calculate_tangential_velocity(pmra_mas_yr, pmdec_mas_yr, distance_pc):\n    \"\"\"\n    Calculate tangential velocity from proper motion\n    \n    Parameters:\n        pmra_mas_yr: float - Proper motion in RA (mas/year)\n        pmdec_mas_yr: float - Proper motion in Dec (mas/year)\n        distance_pc: float - Distance (parsecs)\n        \n    Returns:\n        velocity_km_s: float - Tangential velocity (km/s)\n    \"\"\"\n    # Total proper motion (mas/year)\n    pm_total = np.sqrt(pmra_mas_yr**2 + pmdec_mas_yr**2)\n    \n    # Convert to arcsec/year\n    pm_arcsec_yr = pm_total / 1000.0\n    \n    # Convert to radians/year\n    pm_rad_yr = pm_arcsec_yr * (np.pi / 648000.0)\n    \n    # Tangential velocity = distance x angular velocity\n    # 1 AU/year = 4.74 km/s\n    velocity_au_yr = distance_pc * 206265 * pm_rad_yr\n    velocity_km_s = velocity_au_yr * 4.74\n    \n    return velocity_km_s",
    "start_line": 346,
    "end_line": 372,
    "has_docstring": true,
    "docstring": "Calculate tangential velocity from proper motion\n\nParameters:\n    pmra_mas_yr: float - Proper motion in RA (mas/year)\n    pmdec_mas_yr: float - Proper motion in Dec (mas/year)\n    distance_pc: float - Distance (parsecs)\n    \nReturns:\n    velocity_km_s: float - Tangential velocity (km/s)",
    "parameters": [
      "pmra_mas_yr",
      "pmdec_mas_yr",
      "distance_pc"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_tangential_velocity",
    "component_id": "exoplanet_coordinates.calculate_tangential_velocity"
  },
  "exoplanet_coordinates.get_proper_motion_summary": {
    "id": "exoplanet_coordinates.get_proper_motion_summary",
    "name": "get_proper_motion_summary",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_coordinates.py",
    "relative_path": "exoplanet_coordinates.py",
    "depends_on": [
      "exoplanet_coordinates.calculate_tangential_velocity"
    ],
    "source_code": "def get_proper_motion_summary(host_star_data):\n    \"\"\"\n    Generate human-readable summary of proper motion\n    \n    Parameters:\n        host_star_data: dict - Host star data\n        \n    Returns:\n        str: Summary text\n    \"\"\"\n    pmra = host_star_data.get('pmra', 0.0)\n    pmdec = host_star_data.get('pmdec', 0.0)\n    distance_pc = host_star_data['distance_pc']\n    \n    # Total proper motion\n    pm_total = np.sqrt(pmra**2 + pmdec**2)\n    pm_arcsec_yr = pm_total / 1000.0\n    \n    # Tangential velocity\n    v_tan = calculate_tangential_velocity(pmra, pmdec, distance_pc)\n    \n    summary = f\"Proper motion: {pm_arcsec_yr:.3f} arcsec/year\\n\"\n    summary += f\"  RA component: {pmra:.2f} mas/yr\\n\"\n    summary += f\"  Dec component: {pmdec:.2f} mas/yr\\n\"\n    summary += f\"Tangential velocity: {v_tan:.1f} km/s\"\n    \n    return summary",
    "start_line": 374,
    "end_line": 400,
    "has_docstring": true,
    "docstring": "Generate human-readable summary of proper motion\n\nParameters:\n    host_star_data: dict - Host star data\n    \nReturns:\n    str: Summary text",
    "parameters": [
      "host_star_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_proper_motion_summary",
    "component_id": "exoplanet_coordinates.get_proper_motion_summary"
  },
  "exoplanet_orbits.solve_kepler_equation": {
    "id": "exoplanet_orbits.solve_kepler_equation",
    "name": "solve_kepler_equation",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_orbits.py",
    "relative_path": "exoplanet_orbits.py",
    "depends_on": [],
    "source_code": "def solve_kepler_equation(M, e, tolerance=1e-8, max_iterations=30):\n    \"\"\"\n    Solve Kepler's equation: M = E - e*sin(E) for eccentric anomaly E\n    \n    Uses Newton-Raphson iteration for numerical solution\n    \n    Parameters:\n        M: float or array - Mean anomaly (radians)\n        e: float - Eccentricity\n        tolerance: float - Convergence tolerance\n        max_iterations: int - Maximum iterations\n        \n    Returns:\n        E: float or array - Eccentric anomaly (radians)\n    \"\"\"\n    # Initial guess\n    E = M if e < 0.8 else np.pi\n    \n    # Handle array inputs\n    is_array = isinstance(M, np.ndarray)\n    if not is_array:\n        M = np.array([M])\n        E = np.array([E])\n    \n    # Newton-Raphson iteration\n    for _ in range(max_iterations):\n        f = E - e * np.sin(E) - M\n        f_prime = 1 - e * np.cos(E)\n        E_new = E - f / f_prime\n        \n        if np.all(np.abs(E_new - E) < tolerance):\n            break\n        E = E_new\n    \n    return E[0] if not is_array else E",
    "start_line": 50,
    "end_line": 84,
    "has_docstring": true,
    "docstring": "Solve Kepler's equation: M = E - e*sin(E) for eccentric anomaly E\n\nUses Newton-Raphson iteration for numerical solution\n\nParameters:\n    M: float or array - Mean anomaly (radians)\n    e: float - Eccentricity\n    tolerance: float - Convergence tolerance\n    max_iterations: int - Maximum iterations\n    \nReturns:\n    E: float or array - Eccentric anomaly (radians)",
    "parameters": [
      "M",
      "e",
      "tolerance",
      "max_iterations"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function solve_kepler_equation",
    "component_id": "exoplanet_orbits.solve_kepler_equation"
  },
  "exoplanet_orbits.calculate_true_anomaly": {
    "id": "exoplanet_orbits.calculate_true_anomaly",
    "name": "calculate_true_anomaly",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_orbits.py",
    "relative_path": "exoplanet_orbits.py",
    "depends_on": [],
    "source_code": "def calculate_true_anomaly(E, e):\n    \"\"\"\n    Calculate true anomaly from eccentric anomaly\n    \n    Parameters:\n        E: float or array - Eccentric anomaly (radians)\n        e: float - Eccentricity\n        \n    Returns:\n        nu: float or array - True anomaly (radians)\n    \"\"\"\n    nu = 2 * np.arctan2(\n        np.sqrt(1 + e) * np.sin(E / 2),\n        np.sqrt(1 - e) * np.cos(E / 2)\n    )\n    return nu",
    "start_line": 86,
    "end_line": 101,
    "has_docstring": true,
    "docstring": "Calculate true anomaly from eccentric anomaly\n\nParameters:\n    E: float or array - Eccentric anomaly (radians)\n    e: float - Eccentricity\n    \nReturns:\n    nu: float or array - True anomaly (radians)",
    "parameters": [
      "E",
      "e"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_true_anomaly",
    "component_id": "exoplanet_orbits.calculate_true_anomaly"
  },
  "exoplanet_orbits.calculate_keplerian_orbit": {
    "id": "exoplanet_orbits.calculate_keplerian_orbit",
    "name": "calculate_keplerian_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_orbits.py",
    "relative_path": "exoplanet_orbits.py",
    "depends_on": [],
    "source_code": "def calculate_keplerian_orbit(a, e, i_deg, omega_deg, Omega_deg, \n                              period_days, epoch, date=None, \n                              num_points=360):\n    \"\"\"\n    Calculate complete orbital path in 3D space\n    \n    This function generates the orbital ellipse and rotates it to the\n    correct orientation in 3D space using standard Keplerian rotations.\n    \n    Coordinate system:\n    - Origin at central body (host star or barycenter)\n    - XY plane: Sky plane (perpendicular to Earth line of sight)\n    - Z axis: Toward Earth (line of sight direction)\n    \n    Parameters:\n        a: float - Semi-major axis (AU)\n        e: float - Eccentricity\n        i_deg: float - Inclination (degrees) - angle between orbit and sky plane\n        omega_deg: float - Argument of periastron (degrees)\n        Omega_deg: float - Longitude of ascending node (degrees)\n        period_days: float - Orbital period (days)\n        epoch: datetime - Reference epoch for orbital phase\n        date: datetime - Current date for phase calculation (if None, uses epoch)\n        num_points: int - Number of points along orbit\n        \n    Returns:\n        x, y, z: arrays - 3D coordinates of orbital path (AU)\n    \"\"\"\n    # Convert to radians\n    i_rad = np.radians(i_deg)\n    omega_rad = np.radians(omega_deg)\n    Omega_rad = np.radians(Omega_deg)\n    \n    # Generate true anomaly array (full orbit)\n    nu = np.linspace(0, 2 * np.pi, num_points)\n    \n    # Calculate radius at each point (distance from focus)\n    r = a * (1 - e**2) / (1 + e * np.cos(nu))\n    \n    # Position in orbital plane (perifocal frame)\n    # X-axis points to periastron, Y-axis in direction of motion\n    x_orb = r * np.cos(nu)\n    y_orb = r * np.sin(nu)\n    z_orb = np.zeros_like(x_orb)\n    \n    # Apply standard rotation sequence to transform to 3D frame\n    # 1. Rotate by argument of periastron (omega) about Z-axis\n    # 2. Rotate by inclination (i) about X-axis  \n    # 3. Rotate by longitude of ascending node (Omega) about Z-axis\n    \n    # Rotation 1: omega about Z-axis\n    x1 = x_orb * np.cos(omega_rad) - y_orb * np.sin(omega_rad)\n    y1 = x_orb * np.sin(omega_rad) + y_orb * np.cos(omega_rad)\n    z1 = z_orb\n    \n    # Rotation 2: i about X-axis\n    x2 = x1\n    y2 = y1 * np.cos(i_rad) - z1 * np.sin(i_rad)\n    z2 = y1 * np.sin(i_rad) + z1 * np.cos(i_rad)\n    \n    # Rotation 3: Omega about Z-axis\n    x = x2 * np.cos(Omega_rad) - y2 * np.sin(Omega_rad)\n    y = x2 * np.sin(Omega_rad) + y2 * np.cos(Omega_rad)\n    z = z2\n    \n    return x, y, z",
    "start_line": 103,
    "end_line": 168,
    "has_docstring": true,
    "docstring": "Calculate complete orbital path in 3D space\n\nThis function generates the orbital ellipse and rotates it to the\ncorrect orientation in 3D space using standard Keplerian rotations.\n\nCoordinate system:\n- Origin at central body (host star or barycenter)\n- XY plane: Sky plane (perpendicular to Earth line of sight)\n- Z axis: Toward Earth (line of sight direction)\n\nParameters:\n    a: float - Semi-major axis (AU)\n    e: float - Eccentricity\n    i_deg: float - Inclination (degrees) - angle between orbit and sky plane\n    omega_deg: float - Argument of periastron (degrees)\n    Omega_deg: float - Longitude of ascending node (degrees)\n    period_days: float - Orbital period (days)\n    epoch: datetime - Reference epoch for orbital phase\n    date: datetime - Current date for phase calculation (if None, uses epoch)\n    num_points: int - Number of points along orbit\n    \nReturns:\n    x, y, z: arrays - 3D coordinates of orbital path (AU)",
    "parameters": [
      "a",
      "e",
      "i_deg",
      "omega_deg",
      "Omega_deg",
      "period_days",
      "epoch",
      "date",
      "num_points"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_keplerian_orbit",
    "component_id": "exoplanet_orbits.calculate_keplerian_orbit"
  },
  "exoplanet_orbits.calculate_planet_position": {
    "id": "exoplanet_orbits.calculate_planet_position",
    "name": "calculate_planet_position",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_orbits.py",
    "relative_path": "exoplanet_orbits.py",
    "depends_on": [
      "exoplanet_orbits.calculate_true_anomaly",
      "exoplanet_orbits.solve_kepler_equation"
    ],
    "source_code": "def calculate_planet_position(a, e, i_deg, omega_deg, Omega_deg,\n                             period_days, epoch, date):\n    \"\"\"\n    Calculate planet's current position at specific date\n    \n    Parameters:\n        (same as calculate_keplerian_orbit)\n        date: datetime - Date for position calculation\n        \n    Returns:\n        x, y, z: floats - 3D position at specified date (AU)\n    \"\"\"\n    # Convert dates to UTC if needed\n    if epoch.tzinfo is None:\n        epoch = epoch.replace(tzinfo=timezone.utc)\n    if date.tzinfo is None:\n        date = date.replace(tzinfo=timezone.utc)\n    \n    # Calculate time since epoch\n    dt_seconds = (date - epoch).total_seconds()\n    dt_days = dt_seconds / 86400.0\n    \n    # Mean motion (radians per day)\n    n = 2 * np.pi / period_days\n    \n    # Mean anomaly\n    M = n * dt_days\n    M = M % (2 * np.pi)  # Wrap to [0, 2pi]\n    \n    # Solve for eccentric anomaly\n    E = solve_kepler_equation(M, e)\n    \n    # True anomaly\n    nu = calculate_true_anomaly(E, e)\n    \n    # Distance from focus\n    r = a * (1 - e**2) / (1 + e * np.cos(nu))\n    \n    # Position in orbital plane\n    x_orb = r * np.cos(nu)\n    y_orb = r * np.sin(nu)\n    z_orb = 0.0\n    \n    # Apply rotations (same as calculate_keplerian_orbit but for single point)\n    i_rad = np.radians(i_deg)\n    omega_rad = np.radians(omega_deg)\n    Omega_rad = np.radians(Omega_deg)\n    \n    # Rotation by omega\n    x1 = x_orb * np.cos(omega_rad) - y_orb * np.sin(omega_rad)\n    y1 = x_orb * np.sin(omega_rad) + y_orb * np.cos(omega_rad)\n    z1 = z_orb\n    \n    # Rotation by i\n    x2 = x1\n    y2 = y1 * np.cos(i_rad) - z1 * np.sin(i_rad)\n    z2 = y1 * np.sin(i_rad) + z1 * np.cos(i_rad)\n    \n    # Rotation by Omega\n    x = x2 * np.cos(Omega_rad) - y2 * np.sin(Omega_rad)\n    y = x2 * np.sin(Omega_rad) + y2 * np.cos(Omega_rad)\n    z = z2\n    \n    return x, y, z",
    "start_line": 170,
    "end_line": 233,
    "has_docstring": true,
    "docstring": "Calculate planet's current position at specific date\n\nParameters:\n    (same as calculate_keplerian_orbit)\n    date: datetime - Date for position calculation\n    \nReturns:\n    x, y, z: floats - 3D position at specified date (AU)",
    "parameters": [
      "a",
      "e",
      "i_deg",
      "omega_deg",
      "Omega_deg",
      "period_days",
      "epoch",
      "date"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_planet_position",
    "component_id": "exoplanet_orbits.calculate_planet_position"
  },
  "exoplanet_orbits.calculate_binary_star_orbits": {
    "id": "exoplanet_orbits.calculate_binary_star_orbits",
    "name": "calculate_binary_star_orbits",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_orbits.py",
    "relative_path": "exoplanet_orbits.py",
    "depends_on": [],
    "source_code": "def calculate_binary_star_orbits(star_A_mass, star_B_mass, \n                                 binary_separation, binary_period,\n                                 binary_eccentricity=0.0):\n    \"\"\"\n    Calculate orbital parameters for both stars in binary system\n    \n    Both stars orbit their common center of mass (barycenter).\n    For visualization, barycenter is at origin (0, 0, 0).\n    \n    Parameters:\n        star_A_mass: float - Primary star mass (solar masses)\n        star_B_mass: float - Secondary star mass (solar masses)\n        binary_separation: float - Semi-major axis of binary orbit (AU)\n        binary_period: float - Binary orbital period (days)\n        binary_eccentricity: float - Binary orbit eccentricity (default 0)\n        \n    Returns:\n        dict: Orbital parameters for both stars\n            {\n                'star_A': {'a': ..., 'e': ..., 'period': ..., 'phase': ...},\n                'star_B': {'a': ..., 'e': ..., 'period': ..., 'phase': ...}\n            }\n    \"\"\"\n    total_mass = star_A_mass + star_B_mass\n    \n    # Semi-major axes from barycenter (using center of mass formula)\n    # Star A (more massive, closer to barycenter)\n    a_A = binary_separation * (star_B_mass / total_mass)\n    \n    # Star B (less massive, farther from barycenter)\n    a_B = binary_separation * (star_A_mass / total_mass)\n    \n    return {\n        'star_A': {\n            'a': a_A,\n            'e': binary_eccentricity,\n            'period': binary_period,\n            'phase': 0.0  # Arbitrary starting phase\n        },\n        'star_B': {\n            'a': a_B,\n            'e': binary_eccentricity,\n            'period': binary_period,\n            'phase': 180.0  # Opposite side of orbit\n        }\n    }",
    "start_line": 239,
    "end_line": 284,
    "has_docstring": true,
    "docstring": "Calculate orbital parameters for both stars in binary system\n\nBoth stars orbit their common center of mass (barycenter).\nFor visualization, barycenter is at origin (0, 0, 0).\n\nParameters:\n    star_A_mass: float - Primary star mass (solar masses)\n    star_B_mass: float - Secondary star mass (solar masses)\n    binary_separation: float - Semi-major axis of binary orbit (AU)\n    binary_period: float - Binary orbital period (days)\n    binary_eccentricity: float - Binary orbit eccentricity (default 0)\n    \nReturns:\n    dict: Orbital parameters for both stars\n        {\n            'star_A': {'a': ..., 'e': ..., 'period': ..., 'phase': ...},\n            'star_B': {'a': ..., 'e': ..., 'period': ..., 'phase': ...}\n        }",
    "parameters": [
      "star_A_mass",
      "star_B_mass",
      "binary_separation",
      "binary_period",
      "binary_eccentricity"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_binary_star_orbits",
    "component_id": "exoplanet_orbits.calculate_binary_star_orbits"
  },
  "exoplanet_orbits.calculate_binary_star_position": {
    "id": "exoplanet_orbits.calculate_binary_star_position",
    "name": "calculate_binary_star_position",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_orbits.py",
    "relative_path": "exoplanet_orbits.py",
    "depends_on": [
      "exoplanet_orbits.calculate_true_anomaly",
      "exoplanet_orbits.solve_kepler_equation"
    ],
    "source_code": "def calculate_binary_star_position(star_params, date, epoch, \n                                  i_deg=0.0, Omega_deg=0.0):\n    \"\"\"\n    Calculate position of one star in binary system at given date\n    \n    For binary stars, both stars must have the same true anomaly at any instant\n    (they orbit together), but they're on opposite sides of the barycenter.\n    We achieve this by calculating the orbit normally, then applying a 180 deg\n    rotation if this is the secondary star.\n    \n    Parameters:\n        star_params: dict - From calculate_binary_star_orbits()\n        date: datetime - Date for calculation\n        epoch: datetime - Reference epoch\n        i_deg: float - Inclination of binary orbit (degrees)\n        Omega_deg: float - Orientation of binary orbit (degrees)\n        \n    Returns:\n        x, y, z: floats - Star position (AU)\n    \"\"\"\n    a = star_params['a']\n    e = star_params['e']\n    period = star_params['period']\n    phase_offset_deg = star_params['phase']  # [OK] Keep in degrees: 0 deg for A, 180 deg for B\n    \n    # For simplicity, assume omega = 0 for binary orbit\n    omega_deg = 0.0\n    \n    # Convert dates to UTC if needed\n    if epoch.tzinfo is None:\n        epoch = epoch.replace(tzinfo=timezone.utc)\n    if date.tzinfo is None:\n        date = date.replace(tzinfo=timezone.utc)\n    \n    # Calculate time since epoch\n    dt_seconds = (date - epoch).total_seconds()\n    dt_days = dt_seconds / 86400.0\n    \n    # Mean motion (radians per day)\n    n = 2 * np.pi / period\n    \n    # [OK] KEY FIX: Mean anomaly is SAME for both stars\n    M = n * dt_days\n    M = M % (2 * np.pi)  # Wrap to [0, 2pi]\n    \n    # Solve for eccentric anomaly\n    E = solve_kepler_equation(M, e)\n    \n    # [OK] KEY FIX: True anomaly is SAME for both stars (they orbit together)\n    nu = calculate_true_anomaly(E, e)\n    \n    # Distance from focus (barycenter)\n    r = a * (1 - e**2) / (1 + e * np.cos(nu))\n    \n    # [OK] KEY FIX: Apply phase offset to TRUE ANOMALY in orbital plane\n    # This puts Star B 180 deg ahead of Star A in their shared orbit\n    nu_with_offset = nu + np.radians(phase_offset_deg)\n    x_orb = r * np.cos(nu_with_offset)\n    y_orb = r * np.sin(nu_with_offset)\n    z_orb = 0.0\n    \n    # Apply rotations (standard Keplerian rotation sequence)\n    i_rad = np.radians(i_deg)\n    omega_rad = np.radians(omega_deg)\n    Omega_rad = np.radians(Omega_deg)\n    \n    # Rotation by omega (argument of periapsis)\n    x1 = x_orb * np.cos(omega_rad) - y_orb * np.sin(omega_rad)\n    y1 = x_orb * np.sin(omega_rad) + y_orb * np.cos(omega_rad)\n    z1 = z_orb\n    \n    # Rotation by i (inclination)\n    x2 = x1\n    y2 = y1 * np.cos(i_rad) - z1 * np.sin(i_rad)\n    z2 = y1 * np.sin(i_rad) + z1 * np.cos(i_rad)\n    \n    # Rotation by Omega (longitude of ascending node)\n    x = x2 * np.cos(Omega_rad) - y2 * np.sin(Omega_rad)\n    y = x2 * np.sin(Omega_rad) + y2 * np.cos(Omega_rad)\n    z = z2\n    \n    return x, y, z",
    "start_line": 286,
    "end_line": 367,
    "has_docstring": true,
    "docstring": "Calculate position of one star in binary system at given date\n\nFor binary stars, both stars must have the same true anomaly at any instant\n(they orbit together), but they're on opposite sides of the barycenter.\nWe achieve this by calculating the orbit normally, then applying a 180 deg\nrotation if this is the secondary star.\n\nParameters:\n    star_params: dict - From calculate_binary_star_orbits()\n    date: datetime - Date for calculation\n    epoch: datetime - Reference epoch\n    i_deg: float - Inclination of binary orbit (degrees)\n    Omega_deg: float - Orientation of binary orbit (degrees)\n    \nReturns:\n    x, y, z: floats - Star position (AU)",
    "parameters": [
      "star_params",
      "date",
      "epoch",
      "i_deg",
      "Omega_deg"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_binary_star_position",
    "component_id": "exoplanet_orbits.calculate_binary_star_position"
  },
  "exoplanet_orbits.plot_exoplanet_orbits": {
    "id": "exoplanet_orbits.plot_exoplanet_orbits",
    "name": "plot_exoplanet_orbits",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_orbits.py",
    "relative_path": "exoplanet_orbits.py",
    "depends_on": [
      "exoplanet_orbits.calculate_keplerian_orbit",
      "exoplanet_orbits.calculate_planet_position",
      "formatting_utils.format_maybe_float"
    ],
    "source_code": "def plot_exoplanet_orbits(fig, exoplanet_objects, host_star_system, date,\n                         show_orbits=True, show_markers=True):\n    \"\"\"\n    Plot exoplanet orbits in Plotly figure\n    \n    Main integration point with Paloma's Orrery visualization pipeline.\n    Called from plot_objects() when exoplanet objects are selected.\n    \n    Parameters:\n        fig: plotly.graph_objs.Figure - Existing figure to add traces to\n        exoplanet_objects: list - Planet data dictionaries from exoplanet_systems.py\n        host_star_system: dict - Host star system data\n        date: datetime - Current date for planet positions\n        show_orbits: bool - Show orbital paths\n        show_markers: bool - Show planet position markers\n        \n    Returns:\n        fig: Updated Plotly figure\n    \"\"\"\n    from formatting_utils import format_maybe_float\n    \n    # Plot each planet\n    for planet in exoplanet_objects:\n        # Extract orbital parameters\n        a = planet['semi_major_axis_au']\n        e = planet.get('eccentricity', 0.0)\n        i = planet.get('inclination_deg', 90.0)\n        omega = planet.get('omega_deg', 0.0)\n        Omega = planet.get('Omega_deg', 0.0)\n        period = planet['period_days']\n        epoch = planet['epoch']\n        \n        # Calculate orbit path\n        if show_orbits:\n            x_orbit, y_orbit, z_orbit = calculate_keplerian_orbit(\n                a, e, i, omega, Omega, period, epoch, date\n            )\n            \n            # Add orbit trace\n            fig.add_trace(go.Scatter3d(\n                x=x_orbit,\n                y=y_orbit,\n                z=z_orbit,\n                mode='lines',\n                name=f\"{planet['name']} orbit\",\n                line=dict(\n                    color=planet.get('color', 'lightblue'),\n                    width=2\n                ),\n                showlegend=True,\n                hoverinfo='skip'\n            ))\n        \n        # Calculate current position\n        if show_markers:\n            x_pos, y_pos, z_pos = calculate_planet_position(\n                a, e, i, omega, Omega, period, epoch, date\n            )\n            \n            # Create hover text\n            hover_text = f\"<b>{planet['name']}</b><br>\"\n            hover_text += f\"Period: {planet['period_days']:.2f} days<br>\"\n            hover_text += f\"Semi-major axis: {a:.4f} AU<br>\"\n            \n            # Annotate assumed values\n            e_note = \" (assumed circular)\" if planet.get('e_assumed') else \"\"\n            hover_text += f\"Eccentricity: {e:.4f}{e_note}<br>\"\n            \n            i_note = \" (assumed edge-on)\" if planet.get('i_assumed') else \"\"\n            hover_text += f\"Inclination: {i:.1f} deg deg{i_note}<br>\"\n            \n            hover_text += f\"<br>Mass: {format_maybe_float(planet.get('mass_earth'))} [EARTH]<br>\"\n            hover_text += f\"Radius: {format_maybe_float(planet.get('radius_earth'))} [EARTH]<br>\"\n            hover_text += f\"Temp: {planet.get('equilibrium_temp_k')} K<br>\"\n            \n            if planet.get('in_habitable_zone'):\n                hover_text += \"<br><b>[STAR] IN HABITABLE ZONE [STAR]</b><br>\"\n            \n            hover_text += f\"<br>Discovery: {planet['discovery_method']} ({planet['discovery_year']})\"\n            \n            if planet.get('discoverer'):\n                hover_text += f\"<br>By: {planet['discoverer']}\"\n            \n            # Add position marker\n            fig.add_trace(go.Scatter3d(\n                x=[x_pos],\n                y=[y_pos],\n                z=[z_pos],\n                mode='markers',\n                name=planet['name'],\n                marker=dict(\n                    size=8 if planet.get('in_habitable_zone') else 6,\n                    color='green' if planet.get('in_habitable_zone') else planet.get('color', 'lightblue'),\n                    symbol='circle'\n                ),\n                text=[hover_text],\n                hoverinfo='text',\n                showlegend=True\n            ))\n    \n    return fig",
    "start_line": 373,
    "end_line": 473,
    "has_docstring": true,
    "docstring": "Plot exoplanet orbits in Plotly figure\n\nMain integration point with Paloma's Orrery visualization pipeline.\nCalled from plot_objects() when exoplanet objects are selected.\n\nParameters:\n    fig: plotly.graph_objs.Figure - Existing figure to add traces to\n    exoplanet_objects: list - Planet data dictionaries from exoplanet_systems.py\n    host_star_system: dict - Host star system data\n    date: datetime - Current date for planet positions\n    show_orbits: bool - Show orbital paths\n    show_markers: bool - Show planet position markers\n    \nReturns:\n    fig: Updated Plotly figure",
    "parameters": [
      "fig",
      "exoplanet_objects",
      "host_star_system",
      "date",
      "show_orbits",
      "show_markers"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_exoplanet_orbits",
    "component_id": "exoplanet_orbits.plot_exoplanet_orbits"
  },
  "exoplanet_orbits.plot_binary_host_stars": {
    "id": "exoplanet_orbits.plot_binary_host_stars",
    "name": "plot_binary_host_stars",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_orbits.py",
    "relative_path": "exoplanet_orbits.py",
    "depends_on": [
      "exoplanet_stellar_properties.create_exoplanet_host_star_hover_text",
      "exoplanet_stellar_properties.calculate_host_star_properties",
      "exoplanet_stellar_properties.calculate_binary_star_properties",
      "exoplanet_orbits.calculate_keplerian_orbit",
      "exoplanet_orbits.calculate_binary_star_position",
      "visualization_3d.calculate_marker_size",
      "exoplanet_orbits.calculate_binary_star_orbits",
      "exoplanet_stellar_properties.create_binary_star_hover_text"
    ],
    "source_code": "def plot_binary_host_stars(fig, host_star_system, date, show_orbits=True, show_markers=True, system_data=None):\n    \"\"\"\n    Plot binary star system (both stars orbiting barycenter)\n    \n    Uses rich hover text and temperature-based colors from exoplanet_stellar_properties.\n    \n    Parameters:\n        fig: plotly.graph_objs.Figure\n        host_star_system: dict - Host star data from exoplanet_systems.py\n        date: datetime - Current date\n        show_orbits: bool - Show stellar orbital paths\n        show_markers: bool - Show star position markers\n        system_data: dict - Parent system data (for context in hover text)\n        \n    Returns:\n        fig: Updated figure\n    \"\"\"\n\n    if not host_star_system.get('is_binary'):\n        # Single star - just plot at origin\n        \n        # Check if this star was already plotted (avoid duplicates)\n    #    star_name = host_star_system['name']\n    #    if any(trace.name == star_name for trace in fig.data):\n    #        print(f\"[DEBUG] Star {star_name} already plotted, skipping duplicate\")\n    #        return fig\n\n        # Calculate stellar properties for rich hover text and colors\n        if STELLAR_PROPERTIES_AVAILABLE:\n            enhanced_props = calculate_host_star_properties(host_star_system)\n            star_color = enhanced_props['color']\n            marker_size = calculate_marker_size(enhanced_props.get('luminosity', 0.001), base_size=10)\n            hover_text = create_exoplanet_host_star_hover_text(\n                host_star_system, \n                system_data if system_data else {},\n                enhanced_props\n            )\n        else:\n            # Fallback to basic hover text\n            star_color = 'yellow'\n            marker_size = 10\n            hover_text = (f\"<b>{host_star_system['name']}</b><br>\"\n                         f\"Spectral type: {host_star_system['spectral_type']}<br>\"\n                         f\"Mass: {host_star_system['mass_solar']:.2f} M[SUN]\")\n        \n        fig.add_trace(go.Scatter3d(\n            x=[0], y=[0], z=[0],\n            mode='markers',\n            name=host_star_system['name'],\n            marker=dict(size=marker_size, color=star_color, symbol='circle'),\n            text=[hover_text],\n            hoverinfo='text'\n        ))\n        return fig\n    \n    \n    # Binary system - calculate stellar orbits\n    star_A = host_star_system['star_A']\n    star_B = host_star_system['star_B']\n    \n    binary_params = calculate_binary_star_orbits(\n        star_A['mass_solar'],\n        star_B['mass_solar'],\n        host_star_system['binary_separation_au'],\n        host_star_system['binary_period_days'],\n        host_star_system.get('binary_eccentricity', 0.0)\n    )\n    \n    epoch = host_star_system['epoch']\n\n    # Get binary orbital orientation (should match planet orbital plane for circumbinary systems)\n    binary_i = host_star_system.get('binary_inclination_deg', 0.0)\n    binary_Omega = host_star_system.get('binary_Omega_deg', 0.0)\n    binary_omega = 0.0  # Argument of periastron for binary orbit    \n    \n    # Calculate Star A properties first (needed for orbit color)\n    if STELLAR_PROPERTIES_AVAILABLE:\n        props_A, _ = calculate_binary_star_properties(star_A, star_B)\n        color_A = props_A['color']\n        size_A = calculate_marker_size(props_A.get('luminosity', 0.01), base_size=10)\n        hover_A = create_binary_star_hover_text(\n            star_A, \"Primary\", system_data if system_data else {}, props_A\n        )\n    else:\n        color_A = 'yellow'\n        size_A = 10\n        hover_A = (f\"<b>{star_A['name']}</b><br>\"\n                  f\"Type: {star_A['spectral_type']}<br>\"\n                  f\"Mass: {star_A['mass_solar']:.2f} M[SUN]\")\n    \n    # Plot Star A orbit (using calculated color)\n    if show_orbits:\n        x_A, y_A, z_A = calculate_keplerian_orbit(\n            binary_params['star_A']['a'],\n            binary_params['star_A']['e'],\n        #    0.0, 0.0, 0.0,  # Assume coplanar with planets for now\n            binary_i, binary_omega, binary_Omega,  # Use system binary orientation\n            binary_params['star_A']['period'],\n            epoch, date\n        )\n        fig.add_trace(go.Scatter3d(\n            x=x_A, y=y_A, z=z_A,\n            mode='lines',\n            name=f\"{star_A['name']} orbit\",\n            line=dict(color=color_A, width=1, dash='dot'),\n            showlegend=True,\n            hoverinfo='skip'\n        ))\n    \n    # Star A position\n    x_A_pos, y_A_pos, z_A_pos = calculate_binary_star_position(\n#        binary_params['star_A'], date, epoch\n        binary_params['star_A'], date, epoch, binary_i, binary_Omega\n    )\n    \n    if show_markers:\n        fig.add_trace(go.Scatter3d(\n            x=[x_A_pos], y=[y_A_pos], z=[z_A_pos],\n            mode='markers',\n            name=star_A['name'],\n            marker=dict(size=size_A, color=color_A, symbol='circle'),\n            text=[hover_A],\n            hoverinfo='text'\n        ))\n    \n    # Calculate Star B properties first (needed for orbit color)\n    if STELLAR_PROPERTIES_AVAILABLE:\n        _, props_B = calculate_binary_star_properties(star_A, star_B)\n        color_B = props_B['color']\n        size_B = calculate_marker_size(props_B.get('luminosity', 0.01), base_size=8)\n        hover_B = create_binary_star_hover_text(\n            star_B, \"Secondary\", system_data if system_data else {}, props_B\n        )\n    else:\n        color_B = 'orange'\n        size_B = 7\n        hover_B = (f\"<b>{star_B['name']}</b><br>\"\n                  f\"Type: {star_B['spectral_type']}<br>\"\n                  f\"Mass: {star_B['mass_solar']:.2f} M[SUN]\")\n\n    # Plot Star B orbit (using calculated color)\n    if show_orbits:\n        x_B, y_B, z_B = calculate_keplerian_orbit(\n            binary_params['star_B']['a'],\n            binary_params['star_B']['e'],\n        #    0.0, 0.0, 0.0,\n            binary_i, binary_omega, binary_Omega,  # Use system binary orientation\n            binary_params['star_B']['period'],\n            epoch, date\n        )\n        # Apply 180 deg phase shift\n        x_B, y_B = -x_B, -y_B\n        \n        fig.add_trace(go.Scatter3d(\n            x=x_B, y=y_B, z=z_B,\n            mode='lines',\n            name=f\"{star_B['name']} orbit\",\n            line=dict(color=color_B, width=1, dash='dot'),\n            showlegend=True,\n            hoverinfo='skip'\n        ))\n    \n    # Star B position\n    x_B_pos, y_B_pos, z_B_pos = calculate_binary_star_position(\n#        binary_params['star_B'], date, epoch\n        binary_params['star_B'], date, epoch, binary_i, binary_Omega\n    )\n        \n    if show_markers:\n        fig.add_trace(go.Scatter3d(\n            x=[x_B_pos], y=[y_B_pos], z=[z_B_pos],\n            mode='markers',\n            name=star_B['name'],\n            marker=dict(size=size_B, color=color_B, symbol='circle'),\n            text=[hover_B],\n            hoverinfo='text'\n        ))\n\n    # Add barycenter marker (optional, for reference)\n    \n    if show_markers:\n        fig.add_trace(go.Scatter3d(\n            x=[0], y=[0], z=[0],\n            mode='markers',\n            name='Barycenter',\n            marker=dict(size=12, color='white', symbol='square-open'),\n            text=['<b>Barycenter</b><br>Center of mass'],\n            hoverinfo='text',\n            showlegend=False\n        ))\n\n    return fig",
    "start_line": 476,
    "end_line": 667,
    "has_docstring": true,
    "docstring": "Plot binary star system (both stars orbiting barycenter)\n\nUses rich hover text and temperature-based colors from exoplanet_stellar_properties.\n\nParameters:\n    fig: plotly.graph_objs.Figure\n    host_star_system: dict - Host star data from exoplanet_systems.py\n    date: datetime - Current date\n    show_orbits: bool - Show stellar orbital paths\n    show_markers: bool - Show star position markers\n    system_data: dict - Parent system data (for context in hover text)\n    \nReturns:\n    fig: Updated figure",
    "parameters": [
      "fig",
      "host_star_system",
      "date",
      "show_orbits",
      "show_markers",
      "system_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_binary_host_stars",
    "component_id": "exoplanet_orbits.plot_binary_host_stars"
  },
  "exoplanet_orbits.calculate_exoplanet_axis_range": {
    "id": "exoplanet_orbits.calculate_exoplanet_axis_range",
    "name": "calculate_exoplanet_axis_range",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_orbits.py",
    "relative_path": "exoplanet_orbits.py",
    "depends_on": [],
    "source_code": "def calculate_exoplanet_axis_range(exoplanet_objects):\n    \"\"\"\n    Calculate appropriate axis range for exoplanet system\n    \n    Uses same logic as calculate_axis_range() in palomas_orrery_helpers.py\n    \n    Parameters:\n        exoplanet_objects: list - Planet data dictionaries\n        \n    Returns:\n        float: Axis range ( deg+/-value in AU)\n    \"\"\"\n    if not exoplanet_objects:\n        return 1.0  # Default 1 AU\n    \n    # Find maximum apastron distance\n    max_distance = 0\n    for planet in exoplanet_objects:\n        a = planet['semi_major_axis_au']\n        e = planet.get('eccentricity', 0.0)\n        apastron = a * (1 + e)\n        max_distance = max(max_distance, apastron)\n    \n    # Add 20% buffer\n    axis_range = max_distance * 1.2\n    \n    # Minimum range for visibility\n    axis_range = max(axis_range, 0.01)\n    \n    return axis_range",
    "start_line": 670,
    "end_line": 699,
    "has_docstring": true,
    "docstring": "Calculate appropriate axis range for exoplanet system\n\nUses same logic as calculate_axis_range() in palomas_orrery_helpers.py\n\nParameters:\n    exoplanet_objects: list - Planet data dictionaries\n    \nReturns:\n    float: Axis range ( deg+/-value in AU)",
    "parameters": [
      "exoplanet_objects"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_exoplanet_axis_range",
    "component_id": "exoplanet_orbits.calculate_exoplanet_axis_range"
  },
  "exoplanet_stellar_properties.get_temperature_color": {
    "id": "exoplanet_stellar_properties.get_temperature_color",
    "name": "get_temperature_color",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_stellar_properties.py",
    "relative_path": "exoplanet_stellar_properties.py",
    "depends_on": [],
    "source_code": "def get_temperature_color(temperature_k):\n    \"\"\"\n    Get RGB color for a given temperature using continuous interpolation.\n    \n    Uses the same color scale as the stellar neighborhood visualizations\n    for consistency across all of Paloma's Orrery.\n    \n    Parameters:\n        temperature_k (float): Effective temperature in Kelvin\n        \n    Returns:\n        str: RGB color string in format 'rgb(r, g, b)'\n    \"\"\"\n    if temperature_k is None or np.isnan(temperature_k):\n        return 'rgb(128, 128, 128)'  # Gray for unknown temperature\n    \n    # Temperature color scale (matching stellar visualizations)\n    temp_colors = {\n        1300: (255, 0, 0),        # Red for L-type\n        2400: (255, 0, 0),        # Red for M-type\n        3700: (255, 165, 0),      # Orange for K-type\n        5200: (255, 255, 0),      # Yellow for G-type (like our Sun)\n        6000: (255, 255, 255),    # White for F-type\n        7500: (173, 216, 230),    # Light Blue for A-type\n        10000: (0, 0, 255),       # Blue for B-type\n        30000: (0, 0, 139),       # Dark Blue for O-type\n        50000: (75, 0, 130),      # Indigo for upper O limit\n    }\n    \n    # Get sorted temperature breakpoints\n    temp_points = sorted(temp_colors.keys())\n    \n    # Handle boundary cases\n    if temperature_k <= temp_points[0]:\n        r, g, b = temp_colors[temp_points[0]]\n        return f'rgb({r}, {g}, {b})'\n    if temperature_k >= temp_points[-1]:\n        r, g, b = temp_colors[temp_points[-1]]\n        return f'rgb({r}, {g}, {b})'\n    \n    # Find bracketing temperatures\n    for i in range(len(temp_points) - 1):\n        if temp_points[i] <= temperature_k <= temp_points[i + 1]:\n            t_low = temp_points[i]\n            t_high = temp_points[i + 1]\n            color_low = temp_colors[t_low]\n            color_high = temp_colors[t_high]\n            \n            # Linear interpolation\n            fraction = (temperature_k - t_low) / (t_high - t_low)\n            r = int(color_low[0] + fraction * (color_high[0] - color_low[0]))\n            g = int(color_low[1] + fraction * (color_high[1] - color_low[1]))\n            b = int(color_low[2] + fraction * (color_high[2] - color_low[2]))\n            \n            return f'rgb({r}, {g}, {b})'\n    \n    # Fallback (shouldn't reach here)\n    return 'rgb(255, 255, 255)'  # White",
    "start_line": 49,
    "end_line": 106,
    "has_docstring": true,
    "docstring": "Get RGB color for a given temperature using continuous interpolation.\n\nUses the same color scale as the stellar neighborhood visualizations\nfor consistency across all of Paloma's Orrery.\n\nParameters:\n    temperature_k (float): Effective temperature in Kelvin\n    \nReturns:\n    str: RGB color string in format 'rgb(r, g, b)'",
    "parameters": [
      "temperature_k"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_temperature_color",
    "component_id": "exoplanet_stellar_properties.get_temperature_color"
  },
  "exoplanet_stellar_properties.get_temperature_colors_dict": {
    "id": "exoplanet_stellar_properties.get_temperature_colors_dict",
    "name": "get_temperature_colors_dict",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_stellar_properties.py",
    "relative_path": "exoplanet_stellar_properties.py",
    "depends_on": [],
    "source_code": "def get_temperature_colors_dict():\n    \"\"\"\n    Get the complete temperature-to-color mapping dictionary.\n    \n    Returns:\n        dict: Mapping of temperatures to RGB color strings\n    \"\"\"\n    return {\n        1300: 'rgb(255, 0, 0)',        # Red for L\n        2400: 'rgb(255, 0, 0)',        # Red for M\n        3700: 'rgb(255, 165, 0)',      # Orange for K\n        5200: 'rgb(255, 255, 0)',      # Yellow for G\n        6000: 'rgb(255, 255, 255)',    # White for F\n        7500: 'rgb(173, 216, 230)',    # Light Blue for A\n        10000: 'rgb(0, 0, 255)',       # Blue for B\n        30000: 'rgb(0, 0, 139)',       # Dark Blue for O\n        50000: 'rgb(75, 0, 130)',      # Indigo for upper O limit\n    }",
    "start_line": 109,
    "end_line": 126,
    "has_docstring": true,
    "docstring": "Get the complete temperature-to-color mapping dictionary.\n\nReturns:\n    dict: Mapping of temperatures to RGB color strings",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_temperature_colors_dict",
    "component_id": "exoplanet_stellar_properties.get_temperature_colors_dict"
  },
  "exoplanet_stellar_properties.parse_stellar_class": {
    "id": "exoplanet_stellar_properties.parse_stellar_class",
    "name": "parse_stellar_class",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_stellar_properties.py",
    "relative_path": "exoplanet_stellar_properties.py",
    "depends_on": [],
    "source_code": "def parse_stellar_class(spectral_type):\n    \"\"\"\n    Parse stellar luminosity class from spectral type string.\n    \n    Extracts Roman numerals (I-V) and returns human-readable description.\n    \n    Parameters:\n        spectral_type (str): Spectral type string (e.g., 'M8V', 'K0III')\n        \n    Returns:\n        str: Human-readable stellar class (e.g., 'Main-sequence')\n    \"\"\"\n    if spectral_type is None or not isinstance(spectral_type, str):\n        return \"Unknown\"\n    \n    # Look for Roman numerals\n    match = re.search(r'([IV]+)', str(spectral_type))\n    if match:\n        luminosity_class = match.group(1)\n        return class_mapping.get(luminosity_class, luminosity_class)\n    \n    return \"Unknown\"",
    "start_line": 133,
    "end_line": 154,
    "has_docstring": true,
    "docstring": "Parse stellar luminosity class from spectral type string.\n\nExtracts Roman numerals (I-V) and returns human-readable description.\n\nParameters:\n    spectral_type (str): Spectral type string (e.g., 'M8V', 'K0III')\n    \nReturns:\n    str: Human-readable stellar class (e.g., 'Main-sequence')",
    "parameters": [
      "spectral_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parse_stellar_class",
    "component_id": "exoplanet_stellar_properties.parse_stellar_class"
  },
  "exoplanet_stellar_properties.get_stellar_class_description": {
    "id": "exoplanet_stellar_properties.get_stellar_class_description",
    "name": "get_stellar_class_description",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_stellar_properties.py",
    "relative_path": "exoplanet_stellar_properties.py",
    "depends_on": [
      "exoplanet_stellar_properties.parse_stellar_class"
    ],
    "source_code": "def get_stellar_class_description(spectral_type):\n    \"\"\"\n    Get detailed description of stellar class.\n    \n    Parameters:\n        spectral_type (str): Spectral type string\n        \n    Returns:\n        str: Full description with parenthetical explanation\n    \"\"\"\n    stellar_class = parse_stellar_class(spectral_type)\n    \n    if stellar_class == \"Main-sequence\":\n        return \"Main-sequence (Stars in the prime of their lives, fusing hydrogen into helium in their cores)\"\n    elif stellar_class == \"Bright Giant\":\n        return \"Bright Giant (Evolved star that has exhausted core hydrogen and expanded)\"\n    elif stellar_class == \"Subgiant\":\n        return \"Subgiant (Star transitioning from main sequence to giant phase)\"\n    elif stellar_class == \"Giant\":\n        return \"Giant (Evolved star with expanded outer layers)\"\n    elif stellar_class == \"Supergiant\":\n        return \"Supergiant (Extremely luminous evolved massive star)\"\n    else:\n        return stellar_class",
    "start_line": 157,
    "end_line": 180,
    "has_docstring": true,
    "docstring": "Get detailed description of stellar class.\n\nParameters:\n    spectral_type (str): Spectral type string\n    \nReturns:\n    str: Full description with parenthetical explanation",
    "parameters": [
      "spectral_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_stellar_class_description",
    "component_id": "exoplanet_stellar_properties.get_stellar_class_description"
  },
  "exoplanet_stellar_properties.calculate_host_star_properties": {
    "id": "exoplanet_stellar_properties.calculate_host_star_properties",
    "name": "calculate_host_star_properties",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_stellar_properties.py",
    "relative_path": "exoplanet_stellar_properties.py",
    "depends_on": [
      "exoplanet_stellar_properties.get_stellar_class_description",
      "exoplanet_stellar_properties.get_temperature_color",
      "exoplanet_stellar_properties.parse_stellar_class",
      "stellar_parameters.estimate_temperature_from_spectral_type"
    ],
    "source_code": "def calculate_host_star_properties(host_star_data):\n    \"\"\"\n    Calculate comprehensive stellar properties for an exoplanet host star.\n    \n    Takes the host_star dictionary from exoplanet_systems.py and enriches it\n    with calculated properties for visualization.\n    \n    Parameters:\n        host_star_data (dict): Host star data from exoplanet_systems.py\n                               Must contain: spectral_type, teff_k, mass_solar, radius_solar\n                               \n    Returns:\n        dict: Enriched properties including:\n              - temperature (K)\n              - temperature_source (str)\n              - color (RGB string)\n              - stellar_class (str)\n              - stellar_class_desc (str)\n              - luminosity (Lsun)\n              - abs_magnitude (float)\n    \"\"\"\n    properties = {}\n    \n    # Temperature (prefer provided teff_k, fall back to spectral type estimation)\n    spectral_type = host_star_data.get('spectral_type', '')\n    provided_temp = host_star_data.get('teff_k')\n    \n    if provided_temp and not np.isnan(provided_temp):\n        properties['temperature'] = provided_temp\n        properties['temperature_source'] = 'literature'\n    else:\n        # Estimate from spectral type\n        estimated_temp = estimate_temperature_from_spectral_type(spectral_type)\n        properties['temperature'] = estimated_temp\n        properties['temperature_source'] = 'estimated from spectral type'\n    \n    # Color mapping\n    properties['color'] = get_temperature_color(properties['temperature'])\n    \n    # Stellar classification\n    properties['stellar_class'] = parse_stellar_class(spectral_type)\n    properties['stellar_class_desc'] = get_stellar_class_description(spectral_type)\n    \n    # Luminosity calculation (if radius and temperature available)\n    radius_solar = host_star_data.get('radius_solar')\n    temp = properties['temperature']\n    \n    if radius_solar and temp and not np.isnan(radius_solar) and not np.isnan(temp):\n        # Stefan-Boltzmann law: L = 4pi R^2 sigma T^4\n        # In solar units: L/L[SUN] = (R/R[SUN])^2 x (T/T[SUN])^4\n        T_sun = 5772  # K\n        properties['luminosity'] = (radius_solar ** 2) * ((temp / T_sun) ** 4)\n    elif 'luminosity_solar' in host_star_data:\n        # Use provided luminosity\n        properties['luminosity'] = host_star_data['luminosity_solar']\n    else:\n        properties['luminosity'] = np.nan\n    \n    # Absolute magnitude (from luminosity)\n    if properties['luminosity'] and not np.isnan(properties['luminosity']):\n        M_sun = 4.83  # Absolute magnitude of the Sun\n        properties['abs_magnitude'] = M_sun - 2.5 * np.log10(properties['luminosity'])\n    else:\n        properties['abs_magnitude'] = np.nan\n    \n    # Apparent magnitude (from absolute magnitude and distance)\n    if 'distance_pc' in host_star_data and not np.isnan(properties.get('abs_magnitude', np.nan)):\n        distance_pc = host_star_data['distance_pc']\n        properties['apparent_magnitude'] = properties['abs_magnitude'] + 5 * np.log10(distance_pc / 10)\n    else:\n        properties['apparent_magnitude'] = np.nan\n    \n    return properties",
    "start_line": 187,
    "end_line": 259,
    "has_docstring": true,
    "docstring": "Calculate comprehensive stellar properties for an exoplanet host star.\n\nTakes the host_star dictionary from exoplanet_systems.py and enriches it\nwith calculated properties for visualization.\n\nParameters:\n    host_star_data (dict): Host star data from exoplanet_systems.py\n                           Must contain: spectral_type, teff_k, mass_solar, radius_solar\n                           \nReturns:\n    dict: Enriched properties including:\n          - temperature (K)\n          - temperature_source (str)\n          - color (RGB string)\n          - stellar_class (str)\n          - stellar_class_desc (str)\n          - luminosity (Lsun)\n          - abs_magnitude (float)",
    "parameters": [
      "host_star_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_host_star_properties",
    "component_id": "exoplanet_stellar_properties.calculate_host_star_properties"
  },
  "exoplanet_stellar_properties.calculate_binary_star_properties": {
    "id": "exoplanet_stellar_properties.calculate_binary_star_properties",
    "name": "calculate_binary_star_properties",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_stellar_properties.py",
    "relative_path": "exoplanet_stellar_properties.py",
    "depends_on": [
      "exoplanet_stellar_properties.calculate_host_star_properties"
    ],
    "source_code": "def calculate_binary_star_properties(star_A_data, star_B_data):\n    \"\"\"\n    Calculate properties for both stars in a binary system.\n    \n    Parameters:\n        star_A_data (dict): Primary star data\n        star_B_data (dict): Secondary star data\n        \n    Returns:\n        tuple: (star_A_properties, star_B_properties)\n    \"\"\"\n    props_A = calculate_host_star_properties(star_A_data)\n    props_B = calculate_host_star_properties(star_B_data)\n    \n    return props_A, props_B",
    "start_line": 262,
    "end_line": 276,
    "has_docstring": true,
    "docstring": "Calculate properties for both stars in a binary system.\n\nParameters:\n    star_A_data (dict): Primary star data\n    star_B_data (dict): Secondary star data\n    \nReturns:\n    tuple: (star_A_properties, star_B_properties)",
    "parameters": [
      "star_A_data",
      "star_B_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_binary_star_properties",
    "component_id": "exoplanet_stellar_properties.calculate_binary_star_properties"
  },
  "exoplanet_stellar_properties.create_exoplanet_host_star_hover_text": {
    "id": "exoplanet_stellar_properties.create_exoplanet_host_star_hover_text",
    "name": "create_exoplanet_host_star_hover_text",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_stellar_properties.py",
    "relative_path": "exoplanet_stellar_properties.py",
    "depends_on": [
      "exoplanet_stellar_properties.calculate_host_star_properties",
      "visualization_core.format_value"
    ],
    "source_code": "def create_exoplanet_host_star_hover_text(host_star_data, system_data, enhanced_properties=None):\n    \"\"\"\n    Create rich hover text for exoplanet host stars.\n    \n    Matches the quality and style of hover text in stellar neighborhood visualizations.\n    \n    Parameters:\n        host_star_data (dict): Host star data from exoplanet_systems.py\n        system_data (dict): Parent system data (for context like distance, notable features)\n        enhanced_properties (dict, optional): Pre-calculated properties from calculate_host_star_properties()\n        \n    Returns:\n        str: HTML-formatted hover text\n    \"\"\"\n    # Calculate properties if not provided\n    if enhanced_properties is None:\n        enhanced_properties = calculate_host_star_properties(host_star_data)\n    \n    # Start with star name\n    star_name = host_star_data.get('name', 'Unknown Star')\n    hover_text = f'<b>{star_name}</b><br><br>'\n    \n    # Distance\n    distance_pc = system_data.get('distance_pc', host_star_data.get('distance_pc'))\n    distance_ly = system_data.get('distance_ly', host_star_data.get('distance_ly'))\n    if distance_pc:\n        hover_text += f'Distance: {format_value(distance_pc, \".2f\")} pc '\n        hover_text += f'({format_value(distance_ly, \".1f\")} ly)<br>'\n    \n    # Temperature\n    temp = enhanced_properties.get('temperature')\n    temp_source = enhanced_properties.get('temperature_source')\n    if temp and not np.isnan(temp):\n        hover_text += f'Temperature: {format_value(temp, \".0f\")} K'\n        if temp_source != 'literature':\n            hover_text += f' ({temp_source})'\n        hover_text += '<br>'\n    \n    # Luminosity\n    lum = enhanced_properties.get('luminosity')\n    if lum and not np.isnan(lum):\n        hover_text += f'Luminosity: {format_value(lum, \".6f\")} L[SUN]<br>'\n    \n    # Magnitudes\n    abs_mag = enhanced_properties.get('abs_magnitude')\n    app_mag = enhanced_properties.get('apparent_magnitude')\n    if abs_mag and not np.isnan(abs_mag):\n        hover_text += f'Absolute Magnitude: {format_value(abs_mag, \".2f\")}<br>'\n    if app_mag and not np.isnan(app_mag):\n        hover_text += f'Apparent Magnitude: {format_value(app_mag, \".2f\")}<br>'\n    \n    # Spectral Type\n    spectral_type = host_star_data.get('spectral_type', 'Unknown')\n    hover_text += f'Spectral Type: {spectral_type}'\n    if 'P' in str(spectral_type).upper():\n        hover_text += ' (Peculiar)'\n    hover_text += '<br>'\n    \n    # Stellar Class\n    stellar_class = enhanced_properties.get('stellar_class', 'Unknown')\n    hover_text += f'Stellar Class: {stellar_class}'\n    if stellar_class in class_mapping.values():\n        # Already in human-readable form\n        pass\n    hover_text += '<br>'\n    \n    # Mass and Radius (physical properties)\n    mass = host_star_data.get('mass_solar')\n    if mass:\n        hover_text += f'Mass: {format_value(mass, \".3f\")} M[SUN]<br>'\n    \n    radius = host_star_data.get('radius_solar')\n    if radius:\n        hover_text += f'Radius: {format_value(radius, \".3f\")} R[SUN]<br>'\n    \n    # Age (if available)\n    age = host_star_data.get('age_gyr')\n    if age:\n        hover_text += f'Age: {format_value(age, \".1f\")} Gyr<br>'\n    \n    # Object Type Description\n    if spectral_type.startswith('M8'):\n        hover_text += 'Object Type: Ultra-cool red dwarf<br>'\n    elif spectral_type.startswith('M'):\n        hover_text += 'Object Type: Red dwarf<br>'\n    elif spectral_type.startswith('K'):\n        hover_text += 'Object Type: Orange dwarf<br>'\n    elif spectral_type.startswith('G'):\n        hover_text += 'Object Type: Yellow dwarf (Sun-like)<br>'\n    elif spectral_type.startswith('F'):\n        hover_text += 'Object Type: White main-sequence star<br>'\n    \n    # Notable features from system\n    notable_features = system_data.get('notable_features', [])\n    if notable_features:\n        hover_text += '<br>Note:<br>'\n        for feature in notable_features:\n            hover_text += f'* {feature}<br>'\n    \n    # Mission info (if available)\n    mission_info = host_star_data.get('mission_info')\n    if mission_info:\n        hover_text += f'<br>{mission_info}'\n    \n    return hover_text",
    "start_line": 283,
    "end_line": 387,
    "has_docstring": true,
    "docstring": "Create rich hover text for exoplanet host stars.\n\nMatches the quality and style of hover text in stellar neighborhood visualizations.\n\nParameters:\n    host_star_data (dict): Host star data from exoplanet_systems.py\n    system_data (dict): Parent system data (for context like distance, notable features)\n    enhanced_properties (dict, optional): Pre-calculated properties from calculate_host_star_properties()\n    \nReturns:\n    str: HTML-formatted hover text",
    "parameters": [
      "host_star_data",
      "system_data",
      "enhanced_properties"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_exoplanet_host_star_hover_text",
    "component_id": "exoplanet_stellar_properties.create_exoplanet_host_star_hover_text"
  },
  "exoplanet_stellar_properties.create_binary_star_hover_text": {
    "id": "exoplanet_stellar_properties.create_binary_star_hover_text",
    "name": "create_binary_star_hover_text",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_stellar_properties.py",
    "relative_path": "exoplanet_stellar_properties.py",
    "depends_on": [
      "exoplanet_stellar_properties.calculate_host_star_properties",
      "visualization_core.format_value"
    ],
    "source_code": "def create_binary_star_hover_text(star_data, star_label, system_data, enhanced_properties=None):\n    \"\"\"\n    Create hover text for individual stars in a binary system.\n    \n    Parameters:\n        star_data (dict): Individual star data (star_A or star_B)\n        star_label (str): Label like \"Primary\" or \"Secondary\" or just the star name\n        system_data (dict): Parent system data\n        enhanced_properties (dict, optional): Pre-calculated properties\n        \n    Returns:\n        str: HTML-formatted hover text\n    \"\"\"\n    if enhanced_properties is None:\n        enhanced_properties = calculate_host_star_properties(star_data)\n    \n    star_name = star_data.get('name', star_label)\n    hover_text = f'<b>{star_name}</b><br>'\n    hover_text += f'<i>{star_label}</i><br><br>'\n    \n    # Temperature\n    temp = enhanced_properties.get('temperature')\n    if temp and not np.isnan(temp):\n        hover_text += f'Temperature: {format_value(temp, \".0f\")} K<br>'\n    \n    # Spectral Type\n    spectral_type = star_data.get('spectral_type', 'Unknown')\n    hover_text += f'Spectral Type: {spectral_type}<br>'\n    \n    # Stellar Class\n    stellar_class = enhanced_properties.get('stellar_class', 'Unknown')\n    hover_text += f'Stellar Class: {stellar_class}<br>'\n    \n    # Mass\n    mass = star_data.get('mass_solar')\n    if mass:\n        hover_text += f'Mass: {format_value(mass, \".3f\")} M[SUN]<br>'\n    \n    # Radius\n    radius = star_data.get('radius_solar')\n    if radius:\n        hover_text += f'Radius: {format_value(radius, \".3f\")} R[SUN]<br>'\n    \n    # Luminosity\n    lum = enhanced_properties.get('luminosity')\n    if lum and not np.isnan(lum):\n        hover_text += f'Luminosity: {format_value(lum, \".6f\")} L[SUN]<br>'\n    \n    # System context\n    hover_text += f'<br>System: {system_data.get(\"system_name\", \"Unknown\")}<br>'\n    hover_text += f'Distance: {format_value(system_data.get(\"distance_ly\"), \".1f\")} ly'\n    \n    return hover_text",
    "start_line": 390,
    "end_line": 442,
    "has_docstring": true,
    "docstring": "Create hover text for individual stars in a binary system.\n\nParameters:\n    star_data (dict): Individual star data (star_A or star_B)\n    star_label (str): Label like \"Primary\" or \"Secondary\" or just the star name\n    system_data (dict): Parent system data\n    enhanced_properties (dict, optional): Pre-calculated properties\n    \nReturns:\n    str: HTML-formatted hover text",
    "parameters": [
      "star_data",
      "star_label",
      "system_data",
      "enhanced_properties"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_binary_star_hover_text",
    "component_id": "exoplanet_stellar_properties.create_binary_star_hover_text"
  },
  "exoplanet_stellar_properties.calculate_marker_size": {
    "id": "exoplanet_stellar_properties.calculate_marker_size",
    "name": "calculate_marker_size",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_stellar_properties.py",
    "relative_path": "exoplanet_stellar_properties.py",
    "depends_on": [],
    "source_code": "def calculate_marker_size(luminosity, base_size=8, scale_factor=2):\n    \"\"\"\n    Calculate marker size based on stellar luminosity.\n    \n    Uses logarithmic scaling to show luminosity differences visually while\n    keeping sizes reasonable.\n    \n    Parameters:\n        luminosity (float): Stellar luminosity in solar units\n        base_size (float): Minimum marker size\n        scale_factor (float): Scaling factor for size differences\n        \n    Returns:\n        float: Marker size in pixels\n    \"\"\"\n    if luminosity is None or np.isnan(luminosity) or luminosity <= 0:\n        return base_size\n    \n    # Logarithmic scaling\n    size = base_size + scale_factor * np.log10(luminosity + 1)\n    \n    # Clamp to reasonable range\n    return max(base_size, min(size, 20))",
    "start_line": 449,
    "end_line": 471,
    "has_docstring": true,
    "docstring": "Calculate marker size based on stellar luminosity.\n\nUses logarithmic scaling to show luminosity differences visually while\nkeeping sizes reasonable.\n\nParameters:\n    luminosity (float): Stellar luminosity in solar units\n    base_size (float): Minimum marker size\n    scale_factor (float): Scaling factor for size differences\n    \nReturns:\n    float: Marker size in pixels",
    "parameters": [
      "luminosity",
      "base_size",
      "scale_factor"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_marker_size",
    "component_id": "exoplanet_stellar_properties.calculate_marker_size"
  },
  "exoplanet_stellar_properties.enrich_exoplanet_system": {
    "id": "exoplanet_stellar_properties.enrich_exoplanet_system",
    "name": "enrich_exoplanet_system",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_stellar_properties.py",
    "relative_path": "exoplanet_stellar_properties.py",
    "depends_on": [
      "exoplanet_stellar_properties.calculate_host_star_properties",
      "exoplanet_stellar_properties.calculate_binary_star_properties"
    ],
    "source_code": "def enrich_exoplanet_system(system_dict):\n    \"\"\"\n    Enrich an exoplanet system dictionary with calculated stellar properties.\n    \n    Takes a system from exoplanet_systems.py and adds enhanced_properties\n    to host_star (and star_A/star_B for binary systems).\n    \n    Parameters:\n        system_dict (dict): System dictionary from EXOPLANET_CATALOG\n        \n    Returns:\n        dict: Same dictionary with added 'enhanced_properties' keys\n    \"\"\"\n    host_star = system_dict['host_star']\n    \n    if host_star.get('is_binary'):\n        # Binary system - calculate for both stars\n        props_A, props_B = calculate_binary_star_properties(\n            host_star['star_A'],\n            host_star['star_B']\n        )\n        host_star['star_A']['enhanced_properties'] = props_A\n        host_star['star_B']['enhanced_properties'] = props_B\n    else:\n        # Single star system\n        props = calculate_host_star_properties(host_star)\n        host_star['enhanced_properties'] = props\n    \n    return system_dict",
    "start_line": 478,
    "end_line": 506,
    "has_docstring": true,
    "docstring": "Enrich an exoplanet system dictionary with calculated stellar properties.\n\nTakes a system from exoplanet_systems.py and adds enhanced_properties\nto host_star (and star_A/star_B for binary systems).\n\nParameters:\n    system_dict (dict): System dictionary from EXOPLANET_CATALOG\n    \nReturns:\n    dict: Same dictionary with added 'enhanced_properties' keys",
    "parameters": [
      "system_dict"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function enrich_exoplanet_system",
    "component_id": "exoplanet_stellar_properties.enrich_exoplanet_system"
  },
  "exoplanet_stellar_properties.get_exoplanet_object_type_description": {
    "id": "exoplanet_stellar_properties.get_exoplanet_object_type_description",
    "name": "get_exoplanet_object_type_description",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_stellar_properties.py",
    "relative_path": "exoplanet_stellar_properties.py",
    "depends_on": [],
    "source_code": "def get_exoplanet_object_type_description(spectral_type):\n    \"\"\"\n    Get a brief object type description for exoplanet host stars.\n    \n    Parameters:\n        spectral_type (str): Spectral type string\n        \n    Returns:\n        str: Brief description\n    \"\"\"\n    if not spectral_type:\n        return \"Unknown\"\n    \n    sp = spectral_type.upper()\n    \n    if sp.startswith('M8') or sp.startswith('M9'):\n        return \"Ultra-cool red dwarf\"\n    elif sp.startswith('M'):\n        return \"Red dwarf\"\n    elif sp.startswith('K'):\n        return \"Orange dwarf\"\n    elif sp.startswith('G'):\n        return \"Yellow dwarf (Sun-like)\"\n    elif sp.startswith('F'):\n        return \"White main-sequence star\"\n    elif sp.startswith('A'):\n        return \"Blue-white main-sequence star\"\n    elif sp.startswith('B'):\n        return \"Hot blue star\"\n    elif sp.startswith('O'):\n        return \"Very hot blue supergiant\"\n    else:\n        return \"Star\"",
    "start_line": 509,
    "end_line": 541,
    "has_docstring": true,
    "docstring": "Get a brief object type description for exoplanet host stars.\n\nParameters:\n    spectral_type (str): Spectral type string\n    \nReturns:\n    str: Brief description",
    "parameters": [
      "spectral_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_exoplanet_object_type_description",
    "component_id": "exoplanet_stellar_properties.get_exoplanet_object_type_description"
  },
  "exoplanet_systems.get_system": {
    "id": "exoplanet_systems.get_system",
    "name": "get_system",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_systems.py",
    "relative_path": "exoplanet_systems.py",
    "depends_on": [],
    "source_code": "def get_system(system_id):\n    \"\"\"\n    Get exoplanet system by ID\n    \n    Parameters:\n        system_id: str - System identifier ('trappist1', 'toi1338', 'proxima')\n        \n    Returns:\n        dict: System data or None if not found\n    \"\"\"\n    return EXOPLANET_CATALOG.get(system_id)",
    "start_line": 619,
    "end_line": 629,
    "has_docstring": true,
    "docstring": "Get exoplanet system by ID\n\nParameters:\n    system_id: str - System identifier ('trappist1', 'toi1338', 'proxima')\n    \nReturns:\n    dict: System data or None if not found",
    "parameters": [
      "system_id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_system",
    "component_id": "exoplanet_systems.get_system"
  },
  "exoplanet_systems.get_all_systems": {
    "id": "exoplanet_systems.get_all_systems",
    "name": "get_all_systems",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_systems.py",
    "relative_path": "exoplanet_systems.py",
    "depends_on": [],
    "source_code": "def get_all_systems():\n    \"\"\"Get list of all available system IDs\"\"\"\n    return list(EXOPLANET_CATALOG.keys())",
    "start_line": 631,
    "end_line": 633,
    "has_docstring": true,
    "docstring": "Get list of all available system IDs",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_all_systems",
    "component_id": "exoplanet_systems.get_all_systems"
  },
  "exoplanet_systems.get_system_summary": {
    "id": "exoplanet_systems.get_system_summary",
    "name": "get_system_summary",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_systems.py",
    "relative_path": "exoplanet_systems.py",
    "depends_on": [
      "exoplanet_systems.get_system"
    ],
    "source_code": "def get_system_summary(system_id):\n    \"\"\"\n    Get quick summary of system for GUI display\n    \n    Returns:\n        str: Human-readable summary\n    \"\"\"\n    system = get_system(system_id)\n    if not system:\n        return \"System not found\"\n    \n    n_planets = len(system['planets'])\n    distance = system['distance_ly']\n    \n    summary = f\"{system['system_name']}: {n_planets} planet\"\n    if n_planets != 1:\n        summary += \"s\"\n    summary += f\" at {distance:.1f} light-years\"\n    \n    if system['host_star'].get('is_binary'):\n        summary += \" (binary star)\"\n    \n    return summary",
    "start_line": 635,
    "end_line": 657,
    "has_docstring": true,
    "docstring": "Get quick summary of system for GUI display\n\nReturns:\n    str: Human-readable summary",
    "parameters": [
      "system_id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_system_summary",
    "component_id": "exoplanet_systems.get_system_summary"
  },
  "exoplanet_systems.get_planets_in_hz": {
    "id": "exoplanet_systems.get_planets_in_hz",
    "name": "get_planets_in_hz",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\exoplanet_systems.py",
    "relative_path": "exoplanet_systems.py",
    "depends_on": [
      "exoplanet_systems.get_system"
    ],
    "source_code": "def get_planets_in_hz(system_id):\n    \"\"\"\n    Get list of planets in habitable zone\n    \n    Returns:\n        list: Planet names in HZ\n    \"\"\"\n    system = get_system(system_id)\n    if not system:\n        return []\n    \n    return [p['name'] for p in system['planets'] if p.get('in_habitable_zone', False)]",
    "start_line": 659,
    "end_line": 670,
    "has_docstring": true,
    "docstring": "Get list of planets in habitable zone\n\nReturns:\n    list: Planet names in HZ",
    "parameters": [
      "system_id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_planets_in_hz",
    "component_id": "exoplanet_systems.get_planets_in_hz"
  },
  "fetch_climate_data.fetch_ocean_ph_bcodmo": {
    "id": "fetch_climate_data.fetch_ocean_ph_bcodmo",
    "name": "fetch_ocean_ph_bcodmo",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_climate_data.py",
    "relative_path": "fetch_climate_data.py",
    "depends_on": [
      "fetch_climate_data.parse_carbonate_data"
    ],
    "source_code": "def fetch_ocean_ph_bcodmo():\n    \"\"\"\n    Fetch ocean pH data from BCO-DMO HOT dataset\n    BCO-DMO provides structured access to HOT carbonate chemistry\n    \"\"\"\n    print(\"Attempting to fetch pH data from BCO-DMO...\")\n    \n    # BCO-DMO dataset 3773 - HOT core data\n    # Try their data download API\n    api_url = \"https://www.bco-dmo.org/dataset/3773.csv\"\n    \n    try:\n        response = requests.get(api_url, timeout=30)\n        response.raise_for_status()\n        print(\"[OK] BCO-DMO download successful\")\n        \n        lines = response.text.split('\\n')\n        return parse_carbonate_data(lines, source='BCO-DMO')\n        \n    except requests.exceptions.RequestException as e:\n        print(f\"[FAIL] BCO-DMO fetch failed: {e}\")\n        return None",
    "start_line": 43,
    "end_line": 64,
    "has_docstring": true,
    "docstring": "Fetch ocean pH data from BCO-DMO HOT dataset\nBCO-DMO provides structured access to HOT carbonate chemistry",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_ocean_ph_bcodmo",
    "component_id": "fetch_climate_data.fetch_ocean_ph_bcodmo"
  },
  "fetch_climate_data.fetch_ocean_ph_hot_direct": {
    "id": "fetch_climate_data.fetch_ocean_ph_hot_direct",
    "name": "fetch_ocean_ph_hot_direct",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_climate_data.py",
    "relative_path": "fetch_climate_data.py",
    "depends_on": [
      "fetch_climate_data.parse_carbonate_data"
    ],
    "source_code": "def fetch_ocean_ph_hot_direct():\n    \"\"\"\n    Try to fetch pH data directly from HOT program\n    \"\"\"\n    print(\"Attempting to fetch pH data from HOT direct...\")\n    \n    for url in HOT_DIRECT_DATA_URLS:\n        try:\n            response = requests.get(url, timeout=30)\n            response.raise_for_status()\n            \n            # Check if this looks like data (not HTML)\n            if 'text/plain' in response.headers.get('Content-Type', '') or \\\n               not response.text.strip().startswith('<'):\n                print(f\"[OK] HOT direct download successful from {url}\")\n                lines = response.text.split('\\n')\n                return parse_carbonate_data(lines, source='HOT')\n                \n        except Exception as e:\n            continue\n    \n    print(\"[FAIL] No direct HOT URL worked\")\n    return None",
    "start_line": 66,
    "end_line": 88,
    "has_docstring": true,
    "docstring": "Try to fetch pH data directly from HOT program",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_ocean_ph_hot_direct",
    "component_id": "fetch_climate_data.fetch_ocean_ph_hot_direct"
  },
  "fetch_climate_data.parse_carbonate_data": {
    "id": "fetch_climate_data.parse_carbonate_data",
    "name": "parse_carbonate_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_climate_data.py",
    "relative_path": "fetch_climate_data.py",
    "depends_on": [],
    "source_code": "def parse_carbonate_data(lines, source='Unknown'):\n    \"\"\"\n    Parse carbonate chemistry data (flexible parser)\n    Works with BCO-DMO, HOT, or similar formats\n    \"\"\"\n    records = []\n    header_found = False\n    col_map = {}\n    \n    for i, line in enumerate(lines):\n        line = line.strip()\n        \n        if not line or line.startswith('!'):\n            continue\n        \n        # Find header\n        line_lower = line.lower()\n        if not header_found and ('ph' in line_lower or 'year' in line_lower):\n            # Parse header\n            headers = line.replace('#', '').replace('\\t', ' ').split()\n            headers = [h.strip() for h in headers if h.strip()]\n            \n            # Map columns\n            for idx, h in enumerate(headers):\n                h_lower = h.lower()\n                if 'year' in h_lower or 'yr' in h_lower:\n                    col_map['year'] = idx\n                elif 'month' in h_lower or 'mon' in h_lower:\n                    col_map['month'] = idx\n                elif 'ph' in h_lower:\n                    # Prefer pH_total or pH_t\n                    if 'total' in h_lower or h_lower == 'ph_t':\n                        col_map['ph_total'] = idx\n                    elif 'ph' not in col_map:  # Use first pH column found\n                        col_map['ph'] = idx\n            \n            header_found = True\n            print(f\"[OK] Identified columns: {col_map}\")\n            continue\n        \n        if not header_found or line.startswith('#'):\n            continue\n        \n        # Parse data\n        try:\n            parts = line.replace('\\t', ' ').split()\n            parts = [p.strip() for p in parts if p.strip()]\n            \n            if len(parts) < 3:\n                continue\n            \n            # Extract values\n            year = None\n            month = None\n            ph_value = None\n            \n            # Get year, month, pH using column map\n            if 'year' in col_map and col_map['year'] < len(parts):\n                year = int(float(parts[col_map['year']]))\n            \n            if 'month' in col_map and col_map['month'] < len(parts):\n                month = int(float(parts[col_map['month']]))\n            \n            # Get pH from mapped column\n            ph_col = col_map.get('ph_total') or col_map.get('ph')\n            if ph_col is not None and ph_col < len(parts):\n                ph_value = float(parts[ph_col])\n            \n            # Validate\n            if year and month and ph_value:\n                if 1900 <= year <= 2100 and 1 <= month <= 12 and 7.0 < ph_value < 9.0:\n                    key = (year, month)\n                    # For now, just store first measurement per month\n                    # Could enhance to average multiple measurements\n                    record = {\n                        'year': year,\n                        'month': month,\n                        'date': f\"{year}-{month:02d}\",\n                        'ph_total': round(ph_value, 4),\n                        'source': source\n                    }\n                    records.append(record)\n        \n        except (ValueError, IndexError):\n            continue\n    \n    # Remove duplicates, keep first per month\n    seen = set()\n    unique_records = []\n    for r in sorted(records, key=lambda x: (x['year'], x['month'])):\n        key = (r['year'], r['month'])\n        if key not in seen:\n            unique_records.append(r)\n            seen.add(key)\n    \n    print(f\"[OK] Parsed {len(unique_records)} unique monthly records\")\n    return unique_records",
    "start_line": 90,
    "end_line": 186,
    "has_docstring": true,
    "docstring": "Parse carbonate chemistry data (flexible parser)\nWorks with BCO-DMO, HOT, or similar formats",
    "parameters": [
      "lines",
      "source"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parse_carbonate_data",
    "component_id": "fetch_climate_data.parse_carbonate_data"
  },
  "fetch_climate_data.create_ph_metadata": {
    "id": "fetch_climate_data.create_ph_metadata",
    "name": "create_ph_metadata",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_climate_data.py",
    "relative_path": "fetch_climate_data.py",
    "depends_on": [],
    "source_code": "def create_ph_metadata(records):\n    \"\"\"Create metadata for ocean pH dataset\"\"\"\n    if not records:\n        return {}\n    \n    first = records[0]\n    latest = records[-1]\n    ph_change = latest['ph_total'] - first['ph_total']\n    years_span = latest['year'] - first['year']\n    \n    return {\n        'dataset_name': 'ocean_ph_hot_monthly',\n        'description': 'Ocean surface pH measurements from Hawaii Ocean Time-series',\n        'source': {\n            'organization': 'University of Hawaii - HOT Program',\n            'station': 'Station ALOHA (22 deg45\\'N, 158 degW)',\n            'url': 'https://hahana.soest.hawaii.edu/hot/',\n            'data_providers': [\n                'BCO-DMO: https://www.bco-dmo.org/dataset/3773',\n                'Scripps CO2: https://scrippsco2.ucsd.edu/data/seawater_carbon/',\n                'HOT Program: https://hahana.soest.hawaii.edu/hot/'\n            ],\n            'citation': 'Hawaii Ocean Time-series (HOT), University of Hawaii'\n        },\n        'parameters': {\n            'measurement': 'pH (total scale)',\n            'location': 'Surface ocean (~5m depth)',\n            'frequency': 'Monthly sampling',\n            'method': 'Spectrophotometric or potentiometric'\n        },\n        'time_range': {\n            'start': first['date'],\n            'end': latest['date'],\n            'record_count': len(records)\n        },\n        'statistics': {\n            'first_ph': first['ph_total'],\n            'latest_ph': latest['ph_total'],\n            'ph_change': round(ph_change, 4),\n            'years_span': years_span,\n            'annual_rate': round(ph_change / years_span, 6) if years_span > 0 else 0\n        },\n        'context': {\n            'pre_industrial_ph': 8.2,\n            'current_decline': 0.1,\n            'threat': 'Ocean acidification threatens marine ecosystems',\n            'impact': 'pH is logarithmic: 0.1 unit drop = 30% increase in acidity',\n            'rate': 'Faster than any time in 300 million years'\n        },\n        'last_updated': datetime.now().isoformat(),\n        'cache_file': PH_OUTPUT_FILE\n    }",
    "start_line": 188,
    "end_line": 239,
    "has_docstring": true,
    "docstring": "Create metadata for ocean pH dataset",
    "parameters": [
      "records"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_ph_metadata",
    "component_id": "fetch_climate_data.create_ph_metadata"
  },
  "fetch_climate_data.fetch_ocean_ph": {
    "id": "fetch_climate_data.fetch_ocean_ph",
    "name": "fetch_ocean_ph",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_climate_data.py",
    "relative_path": "fetch_climate_data.py",
    "depends_on": [
      "fetch_climate_data.fetch_ocean_ph_bcodmo",
      "fetch_climate_data.fetch_ocean_ph_hot_direct"
    ],
    "source_code": "def fetch_ocean_ph():\n    \"\"\"\n    Main function to fetch ocean pH data\n    Tries multiple sources in order of reliability\n    \"\"\"\n    print(\"Fetching ocean pH data...\")\n    \n    # Try BCO-DMO first (most reliable for automation)\n    records = fetch_ocean_ph_bcodmo()\n    \n    # If that fails, try direct HOT sources\n    if not records:\n        records = fetch_ocean_ph_hot_direct()\n    \n    # If still no data, provide manual instructions\n    if not records:\n        print()\n        print(\"[FAIL] Automated fetch failed\")\n        print()\n        print(\"MANUAL DOWNLOAD OPTION:\")\n        print(\"1. Visit: https://www.bco-dmo.org/dataset/3773\")\n        print(\"2. Click 'Get Data' [OK] Download CSV\")\n        print(\"3. Save as 'hot_carbonate_data.txt'\")\n        print(\"4. Run: python convert_hot_ph_to_json.py\")\n        print()\n        return []\n    \n    return records",
    "start_line": 241,
    "end_line": 268,
    "has_docstring": true,
    "docstring": "Main function to fetch ocean pH data\nTries multiple sources in order of reliability",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_ocean_ph",
    "component_id": "fetch_climate_data.fetch_ocean_ph"
  },
  "fetch_climate_data.fetch_nasa_sea_level": {
    "id": "fetch_climate_data.fetch_nasa_sea_level",
    "name": "fetch_nasa_sea_level",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_climate_data.py",
    "relative_path": "fetch_climate_data.py",
    "depends_on": [],
    "source_code": "def fetch_nasa_sea_level():\n    \"\"\"\n    Fetch NASA sea level data from science.nasa.gov indicator page\n    Note: Currently requires manual download from the Earth Indicators page\n    Returns list of records with date and sea level\n    \"\"\"\n    print(\"Fetching NASA sea level data...\")\n    \n    # Check if user has downloaded the file\n    local_file = \"nasa_earthdata_sea_level_data.txt\"\n    \n    if os.path.exists(local_file):\n        print(f\"[OK] Found local file: {local_file}\")\n        try:\n            with open(local_file, 'r') as f:\n                lines = f.readlines()\n        except Exception as e:\n            print(f\"[FAIL] Error reading local file: {e}\")\n            return []\n    else:\n        print(f\"[FAIL] File not found: {local_file}\")\n        print(f\"  Please download from: https://science.nasa.gov/earth/explore/earth-indicators/sea-level/\")\n        print(f\"  Save as: {local_file}\")\n        return []\n    \n    print(f\"[OK] Read {len(lines)} lines\")\n    \n    records = []\n    \n    # Parse NASA format\n    # Header lines start with HDR\n    # Data format: year+fraction  GMSL(cm)  GMSL_60day_smoothed(cm)\n    # Example: 1993.0109589    -0.230726    -0.445896\n    \n    for line in lines:\n        line = line.strip()\n        \n        # Skip empty lines and header lines\n        if not line or line.startswith('HDR'):\n            continue\n        \n        try:\n            parts = line.split()\n            \n            if len(parts) >= 3:\n                # First column is decimal year\n                year_fraction = float(parts[0])\n                year = int(year_fraction)\n                month = int(round((year_fraction - year) * 12)) + 1\n                if month > 12:\n                    month = 12\n                if month < 1:\n                    month = 1\n                \n                # Second column: GMSL in centimeters\n                gmsl_cm = float(parts[1])\n                \n                # Third column: 60-day smoothed GMSL in cm\n                gmsl_smoothed_cm = float(parts[2])\n                \n                records.append({\n                    'year': year,\n                    'month': month,\n                    'year_fraction': round(year_fraction, 7),\n                    'gmsl_cm': round(gmsl_cm, 3),\n                    'gmsl_smoothed_cm': round(gmsl_smoothed_cm, 3)\n                })\n        \n        except (ValueError, IndexError):\n            continue  # Skip malformed lines\n    \n    print(f\"[OK] Parsed {len(records)} records\")\n    return records",
    "start_line": 270,
    "end_line": 342,
    "has_docstring": true,
    "docstring": "Fetch NASA sea level data from science.nasa.gov indicator page\nNote: Currently requires manual download from the Earth Indicators page\nReturns list of records with date and sea level",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_nasa_sea_level",
    "component_id": "fetch_climate_data.fetch_nasa_sea_level"
  },
  "fetch_climate_data.status_print": {
    "id": "fetch_climate_data.status_print",
    "name": "status_print",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_climate_data.py",
    "relative_path": "fetch_climate_data.py",
    "depends_on": [],
    "source_code": "def status_print(msg):\n    \"\"\"Print status message with indentation\"\"\"\n    print(f\"  {msg}\")",
    "start_line": 344,
    "end_line": 346,
    "has_docstring": true,
    "docstring": "Print status message with indentation",
    "parameters": [
      "msg"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function status_print",
    "component_id": "fetch_climate_data.status_print"
  },
  "fetch_climate_data.fetch_mauna_loa_co2": {
    "id": "fetch_climate_data.fetch_mauna_loa_co2",
    "name": "fetch_mauna_loa_co2",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_climate_data.py",
    "relative_path": "fetch_climate_data.py",
    "depends_on": [],
    "source_code": "def fetch_mauna_loa_co2(status_callback=None):     \n    \"\"\"\n    Fetch Mauna Loa CO2 monthly data\n    Returns list of records with year, month, and CO2 concentration\n    \n    IMPORTANT: Field names must match existing cache file:\n    - co2_ppm (not 'average')\n    - co2_deseasonalized (not 'interpolated' or 'trend')\n    - days, std_dev, uncertainty (always included, even if missing data = -1, -9.99, -0.99)\n    \"\"\"\n    def status(msg):\n        if status_callback:\n            status_callback(msg)\n        status_print(msg)\n    \n    status(\"Fetching Mauna Loa CO2 monthly data...\")\n    \n    try:\n        response = requests.get(MAUNA_LOA_URL, timeout=30)\n        response.raise_for_status()\n        \n        lines = response.text.strip().split('\\n')\n        print(f\"[OK] Download successful ({len(lines)} lines)\")\n        \n        records = []\n        \n        for line in lines:\n            line = line.strip()\n            if not line or line.startswith('#'):\n                continue\n                \n            parts = line.split()\n            if len(parts) >= 5:\n                try:\n                    year = int(parts[0])\n                    month = int(parts[1])\n                    decimal_date = float(parts[2])\n                    average = float(parts[3])\n                    deseasonalized = float(parts[4])\n                    \n                    # Skip rows where CO2 is marked as missing (-99.99)\n                    if average < 0:\n                        continue\n                    \n                    # Always include all fields (matching cached format)\n                    # Use placeholder values if data is missing, just like NOAA does\n                    record = {\n                        'year': year,\n                        'month': month,\n                        'decimal_date': round(decimal_date, 4),\n                        'co2_ppm': round(average, 2),  # <- Field name MUST be 'co2_ppm'\n                        'co2_deseasonalized': round(deseasonalized, 2),  # <- Field name MUST be 'co2_deseasonalized'\n                        # Always include these fields (even if missing = -1, -9.99, -0.99)\n                        'days': int(parts[5]) if len(parts) >= 6 else -1,\n                        'std_dev': round(float(parts[6]), 2) if len(parts) >= 7 else -9.99,\n                        'uncertainty': round(float(parts[7]), 2) if len(parts) >= 8 else -0.99\n                    }\n                    \n                    records.append(record)\n                    \n                except (ValueError, IndexError):\n                    continue\n        \n        print(f\"[OK] Parsed {len(records)} records\")\n        return records\n        \n    except requests.exceptions.RequestException as e:\n        print(f\"[FAIL] Error fetching CO2 data: {e}\")\n        return []",
    "start_line": 349,
    "end_line": 417,
    "has_docstring": true,
    "docstring": "Fetch Mauna Loa CO2 monthly data\nReturns list of records with year, month, and CO2 concentration\n\nIMPORTANT: Field names must match existing cache file:\n- co2_ppm (not 'average')\n- co2_deseasonalized (not 'interpolated' or 'trend')\n- days, std_dev, uncertainty (always included, even if missing data = -1, -9.99, -0.99)",
    "parameters": [
      "status_callback"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_mauna_loa_co2",
    "component_id": "fetch_climate_data.fetch_mauna_loa_co2"
  },
  "fetch_climate_data.status": {
    "id": "fetch_climate_data.status",
    "name": "status",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_climate_data.py",
    "relative_path": "fetch_climate_data.py",
    "depends_on": [
      "fetch_climate_data.status_print"
    ],
    "source_code": "    def status(msg):\n        if status_callback:\n            status_callback(msg)\n        status_print(msg)",
    "start_line": 424,
    "end_line": 427,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "msg"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function status",
    "component_id": "fetch_climate_data.status"
  },
  "fetch_climate_data.fetch_nasa_giss_temperature": {
    "id": "fetch_climate_data.fetch_nasa_giss_temperature",
    "name": "fetch_nasa_giss_temperature",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_climate_data.py",
    "relative_path": "fetch_climate_data.py",
    "depends_on": [],
    "source_code": "def fetch_nasa_giss_temperature(status_callback=None):\n    \"\"\"\n    Fetch NASA GISS global temperature data\n    Returns: (records, metadata) tuple or (None, None) on error\n    \"\"\"\n    def status(msg):\n        if status_callback:\n            status_callback(msg)\n        status_print(msg)\n    \n    status(\"Downloading NASA GISS temperature data...\")\n    \n    try:\n        # NASA requires a User-Agent header now\n        headers = {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n        }\n        req = urllib.request.Request(NASA_GISS_URL, headers=headers)\n        \n        with urllib.request.urlopen(req, timeout=30) as response:\n            data = response.read().decode('utf-8')\n        \n        status(\"[OK] Download complete\")\n        status(\"Parsing temperature data...\")\n        \n        # Rest of the function stays the same...\n        records = []\n        lines = data.split('\\n')\n        \n        for line in lines:\n            line = line.strip()\n            if not line:\n                continue\n            \n            try:\n                parts = line.split()\n                if len(parts) >= 13 and parts[0].isdigit():\n                    year = int(parts[0])\n                    \n                    for month_idx in range(12):\n                        temp_str = parts[month_idx + 1]\n                        if temp_str != '***':\n                            anomaly = float(temp_str) / 100.0\n                            \n                            records.append({\n                                'year': year,\n                                'month': month_idx + 1,\n                                'anomaly_c': anomaly\n                            })\n            except (ValueError, IndexError):\n                continue\n        \n        status(f\"[OK] Parsed {len(records)} temperature records\")\n        \n        metadata = create_temperature_metadata(records)\n        return records, metadata\n        \n    except Exception as e:\n        status(f\"[FAIL] Failed to fetch temperature data: {e}\")\n        return None, None",
    "start_line": 419,
    "end_line": 478,
    "has_docstring": true,
    "docstring": "Fetch NASA GISS global temperature data\nReturns: (records, metadata) tuple or (None, None) on error",
    "parameters": [
      "status_callback"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_nasa_giss_temperature",
    "component_id": "fetch_climate_data.fetch_nasa_giss_temperature"
  },
  "fetch_climate_data.fetch_arctic_ice": {
    "id": "fetch_climate_data.fetch_arctic_ice",
    "name": "fetch_arctic_ice",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_climate_data.py",
    "relative_path": "fetch_climate_data.py",
    "depends_on": [],
    "source_code": "def fetch_arctic_ice():\n    \"\"\"\n    Fetch NSIDC Arctic sea ice extent data (V4 Excel format)\n    Returns list of records with year, month, and ice extent\n    \"\"\"\n    print(\"Fetching NSIDC Arctic sea ice extent data (V4)...\")\n    \n    try:\n        # Check if openpyxl is available\n        try:\n            import openpyxl\n        except ImportError:\n            print(\"[FAIL] openpyxl not found. Install with: pip install openpyxl\")\n            return []\n        \n        # Download Excel file\n        response = requests.get(NSIDC_V4_URL, timeout=60)\n        response.raise_for_status()\n        print(f\"[OK] Download successful ({len(response.content)} bytes)\")\n        \n        # Save to temporary file\n        temp_file = \"temp_ice_data.xlsx\"\n        with open(temp_file, 'wb') as f:\n            f.write(response.content)\n        \n        # Load workbook\n        workbook = openpyxl.load_workbook(temp_file, data_only=True)\n        \n        # Use NH-Extent sheet (Northern Hemisphere extent)\n        if 'NH-Extent' not in workbook.sheetnames:\n            print(f\"[FAIL] 'NH-Extent' sheet not found. Available sheets: {workbook.sheetnames}\")\n            os.remove(temp_file)\n            return []\n        \n        sheet = workbook['NH-Extent']\n        print(\"[OK] Parsing monthly data from 'NH-Extent' sheet...\")\n        \n        records = []\n        \n        # Skip header rows (first 2 rows are headers)\n        for row_num, row in enumerate(sheet.iter_rows(min_row=3, values_only=True), start=3):\n            if not row or not row[0]:  # Skip empty rows\n                continue\n            \n            try:\n                year = int(row[0])  # First column is year\n                \n                # Columns 1-12 are monthly extent values (million km^2)\n                months = [\n                    ('January', 1), ('February', 2), ('March', 3), ('April', 4),\n                    ('May', 5), ('June', 6), ('July', 7), ('August', 8),\n                    ('September', 9), ('October', 10), ('November', 11), ('December', 12)\n                ]\n                \n                for i, (month_name, month_num) in enumerate(months, start=1):\n                    if i < len(row) and row[i] is not None:\n                        try:\n                            extent = float(row[i])\n                            \n                            records.append({\n                                'year': year,\n                                'month': month_num,\n                                'month_name': month_name,\n                                'extent_million_km2': round(extent, 2)\n                            })\n                        except (ValueError, TypeError):\n                            continue\n                            \n            except (ValueError, IndexError, TypeError):\n                continue\n        \n        # Clean up temp file\n        os.remove(temp_file)\n        \n        print(f\"[OK] Parsed {len(records)} records (all 12 months)\")\n        return records\n        \n    except requests.exceptions.RequestException as e:\n        print(f\"[FAIL] Error fetching Arctic ice data: {e}\")\n        return []\n    except Exception as e:\n        print(f\"[FAIL] Error parsing Excel file: {e}\")\n        if os.path.exists(\"temp_ice_data.xlsx\"):\n            os.remove(\"temp_ice_data.xlsx\")\n        return []",
    "start_line": 480,
    "end_line": 564,
    "has_docstring": true,
    "docstring": "Fetch NSIDC Arctic sea ice extent data (V4 Excel format)\nReturns list of records with year, month, and ice extent",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_arctic_ice",
    "component_id": "fetch_climate_data.fetch_arctic_ice"
  },
  "fetch_climate_data.create_co2_metadata": {
    "id": "fetch_climate_data.create_co2_metadata",
    "name": "create_co2_metadata",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_climate_data.py",
    "relative_path": "fetch_climate_data.py",
    "depends_on": [],
    "source_code": "def create_co2_metadata(records):\n    \"\"\"Create metadata for CO2 dataset\"\"\"\n    return {\n        'dataset_name': 'mauna_loa_co2_monthly',\n        'description': 'Monthly atmospheric CO2 concentrations from Mauna Loa Observatory, Hawaii',\n        'source': {\n            'organization': 'NOAA Global Monitoring Laboratory',\n            'url': 'https://gml.noaa.gov/ccgg/trends/',\n            'data_url': MAUNA_LOA_URL,\n            'citation': 'Keeling, C.D., S.C. Piper, R.B. Bacastow, et al. Atmospheric CO2 concentrations from Mauna Loa Observatory. NOAA Global Monitoring Laboratory.'\n        },\n        'cached_date': datetime.now().isoformat(),\n        'record_count': len(records),\n        'temporal_range': {\n            'start': f\"{records[0]['year']}-{records[0]['month']:02d}\",\n            'end': f\"{records[-1]['year']}-{records[-1]['month']:02d}\"\n        },\n        'units': 'ppm (parts per million)',\n        'measurement_method': 'Non-dispersive infrared spectroscopy',\n        'baseline': 'Direct atmospheric measurement',\n        'license': 'Public domain - U.S. Government data',\n        'threat_status': 'Mauna Loa Observatory threatened with closure (August 2025 lease expiration)',\n        'preservation_priority': 'CRITICAL - 67-year continuous record at risk'\n    }",
    "start_line": 566,
    "end_line": 589,
    "has_docstring": true,
    "docstring": "Create metadata for CO2 dataset",
    "parameters": [
      "records"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_co2_metadata",
    "component_id": "fetch_climate_data.create_co2_metadata"
  },
  "fetch_climate_data.create_temperature_metadata": {
    "id": "fetch_climate_data.create_temperature_metadata",
    "name": "create_temperature_metadata",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_climate_data.py",
    "relative_path": "fetch_climate_data.py",
    "depends_on": [],
    "source_code": "def create_temperature_metadata(records):\n    \"\"\"Create metadata for temperature dataset\"\"\"\n    return {\n        'dataset_name': 'nasa_giss_temperature_anomaly',\n        'description': 'Global mean surface temperature anomalies (GISTEMP v4)',\n        'source': {\n            'organization': 'NASA Goddard Institute for Space Studies (GISS)',\n            'url': 'https://data.giss.nasa.gov/gistemp/',\n            'citation': 'GISTEMP Team, 2024: GISS Surface Temperature Analysis (GISTEMP), version 4. NASA Goddard Institute for Space Studies.'\n        },\n        'cached_date': datetime.now().isoformat(),\n        'record_count': len(records),\n        'temporal_range': {\n            'start': f\"{records[0]['year']}-{records[0]['month']:02d}\",\n            'end': f\"{records[-1]['year']}-{records[-1]['month']:02d}\"\n        },\n        'units': 'degrees Celsius ( degC)',\n        'measurement_method': 'Combined land-surface air and sea-surface water temperature anomalies',\n        'baseline': '1951-1980 average (0 degC reference)',\n        'baseline_note': 'Pre-industrial baseline (~1850-1900) is approximately -0.3 degC relative to this baseline',\n        'license': 'Public domain - U.S. Government data',\n        'threat_status': 'NASA Earth Science faces 52% budget cuts; GISS institutional future uncertain (August 2025)',\n        'preservation_priority': 'CRITICAL - 145-year record, James Hansen legacy dataset'\n    }",
    "start_line": 591,
    "end_line": 614,
    "has_docstring": true,
    "docstring": "Create metadata for temperature dataset",
    "parameters": [
      "records"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_temperature_metadata",
    "component_id": "fetch_climate_data.create_temperature_metadata"
  },
  "fetch_climate_data.create_ice_metadata": {
    "id": "fetch_climate_data.create_ice_metadata",
    "name": "create_ice_metadata",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_climate_data.py",
    "relative_path": "fetch_climate_data.py",
    "depends_on": [],
    "source_code": "def create_ice_metadata(records):\n    \"\"\"Create metadata for Arctic sea ice dataset\"\"\"\n    return {\n        'dataset_name': 'arctic_sea_ice_extent',\n        'description': 'Arctic sea ice extent from satellite observations (monthly data)',\n        'source': {\n            'organization': 'National Snow and Ice Data Center (NSIDC)',\n            'url': 'https://nsidc.org/data/seaice_index/',\n            'data_url': NSIDC_V4_URL,\n            'citation': 'Fetterer, F., K. Knowles, W. N. Meier, M. Savoie, A. K. Windnagel, and T. Stafford. 2025. Sea Ice Index, Version 4. Boulder, Colorado USA. NSIDC: National Snow and Ice Data Center. doi:10.7265/a98x-0f50'\n        },\n        'cached_date': datetime.now().isoformat(),\n        'record_count': len(records),\n        'temporal_range': {\n            'start': f\"{records[0]['year']}-{records[0]['month']:02d}\",\n            'end': f\"{records[-1]['year']}-{records[-1]['month']:02d}\"\n        },\n        'units': 'million km^2',\n        'measurement_method': 'Satellite passive microwave observations (SMMR, SSM/I, SSMIS)',\n        'baseline': 'Sea ice extent from 1979-present',\n        'version': 'V4.0',\n        'format': 'Excel (XLSX) parsed to JSON',\n        'migration_note': 'NSIDC migrated from V3 (CSV/FTP) to V4 (Excel/HTTPS) in December 2023',\n        'license': 'Public domain - U.S. Government data',\n        'threat_status': 'Dataset downgraded to \"Basic\" service level; NSIDC facing funding constraints (2025)',\n        'preservation_priority': 'CRITICAL - 47-year continuous satellite record, shows dramatic climate change'\n    }",
    "start_line": 616,
    "end_line": 642,
    "has_docstring": true,
    "docstring": "Create metadata for Arctic sea ice dataset",
    "parameters": [
      "records"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_ice_metadata",
    "component_id": "fetch_climate_data.create_ice_metadata"
  },
  "fetch_climate_data.create_sea_level_metadata": {
    "id": "fetch_climate_data.create_sea_level_metadata",
    "name": "create_sea_level_metadata",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_climate_data.py",
    "relative_path": "fetch_climate_data.py",
    "depends_on": [],
    "source_code": "def create_sea_level_metadata(records):\n    \"\"\"Create metadata for sea level dataset\"\"\"\n    return {\n        'dataset_name': 'nasa_ssh_gmsl_indicator',\n        'description': 'Global Mean Sea Level from NASA-SSH Simple Gridded Sea Surface Height',\n        'source': {\n            'organization': 'NASA Earth Indicators / PO.DAAC',\n            'url': 'https://science.nasa.gov/earth/explore/earth-indicators/sea-level/',\n            'data_url': 'https://science.nasa.gov/earth/explore/earth-indicators/sea-level/',\n            'citation': 'NASA-SSH. 2025. Global Mean Sea Level from Simple Gridded Sea Surface Height from Standardized Reference Missions Only Version 1. PO.DAAC, CA, USA. Dataset accessed [YYYY-MM-DD] at https://doi.org/10.5067/NSIND-GMSV1.'\n        },\n        'cached_date': datetime.now().isoformat(),\n        'record_count': len(records),\n        'temporal_range': {\n            'start': f\"{records[0]['year']}-{records[0]['month']:02d}\",\n            'end': f\"{records[-1]['year']}-{records[-1]['month']:02d}\"\n        },\n        'units': 'centimeters (cm)',\n        'measurement_method': 'Satellite radar altimetry (TOPEX/Poseidon, Jason series, Sentinel-6)',\n        'baseline': 'Zero mean over calendar year 1993',\n        'baseline_note': 'Values shifted to have zero mean over 1993. NOT adjusted for Glacial Isostatic Adjustment (GIA).',\n        'processing': '60-day smoothing available; 10-day observation windows with 7-day intervals',\n        'license': 'Public domain - U.S. Government data',\n        'threat_status': 'NASA Earth Science missions face budget uncertainty (2025)',\n        'preservation_priority': 'CRITICAL - 32-year continuous satellite record showing accelerating rise',\n        'note': 'Data manually downloaded from NASA Earth Indicators page'\n    }",
    "start_line": 644,
    "end_line": 670,
    "has_docstring": true,
    "docstring": "Create metadata for sea level dataset",
    "parameters": [
      "records"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sea_level_metadata",
    "component_id": "fetch_climate_data.create_sea_level_metadata"
  },
  "fetch_climate_data.save_cache": {
    "id": "fetch_climate_data.save_cache",
    "name": "save_cache",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_climate_data.py",
    "relative_path": "fetch_climate_data.py",
    "depends_on": [
      "climate_cache_manager.metadata_func"
    ],
    "source_code": "def save_cache(output_file, records, metadata_func):\n    \"\"\"\n    Safely save data to JSON cache with comprehensive fail-safe protection\n    Follows same pattern as orbit_data_manager.py\n    \"\"\"\n    \n    if not records:\n        print(f\"[FAIL] No records to save for {output_file}\")\n        return False\n    \n    # Create metadata\n    metadata = metadata_func(records)\n    \n    # Create full data structure\n    data = {\n        'metadata': metadata,\n        'data': records\n    }\n    \n    # ===== FAIL-SAFE PROTECTION =====\n    \n    # 1. Check if existing file exists and validate\n    backup_file = f\"{output_file}.backup\"\n    emergency_file = f\"{output_file}.emergency_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n    \n    existing_size = 0\n    existing_count = 0\n    has_existing = os.path.exists(output_file)\n    \n    if has_existing:\n        try:\n            existing_size = os.path.getsize(output_file)\n            with open(output_file, 'r') as f:\n                existing_data = json.load(f)\n                existing_count = len(existing_data.get('data', []))\n        except:\n            existing_size = 0\n            existing_count = 0\n    \n    # 2. Write to temporary file first\n    temp_file = f\"{output_file}.tmp\"\n    \n    try:\n        with open(temp_file, 'w') as f:\n            json.dump(data, f, indent=2)\n        \n        # 3. Validate new file\n        new_size = os.path.getsize(temp_file)\n        new_count = len(records)\n        \n        # 4. Safety checks\n        dangerous_save = False\n        warning_messages = []\n        \n        if has_existing and new_size > 0:\n            # Check for significant shrinkage (>10%)\n            size_ratio = new_size / existing_size if existing_size > 0 else 1\n            if size_ratio < 0.9:\n                dangerous_save = True\n                warning_messages.append(\n                    f\"File size shrinkage detected: {existing_size} -> {new_size} bytes ({size_ratio*100:.1f}%)\"\n                )\n            \n            # Check for record loss (>5 records)\n            count_diff = existing_count - new_count\n            if count_diff > 5:\n                dangerous_save = True\n                warning_messages.append(\n                    f\"Record count decreased: {existing_count} -> {new_count} (lost {count_diff} records)\"\n                )\n        \n        # 5. Handle dangerous saves\n        if dangerous_save:\n            print(f\"\\n[WARN]  SAVE BLOCKED for {output_file}\")\n            for msg in warning_messages:\n                print(f\"   {msg}\")\n            \n            # Create emergency backup of existing file\n            if has_existing:\n                shutil.copy2(output_file, emergency_file)\n                print(f\"   Emergency backup created: {emergency_file}\")\n            \n            # Remove temp file\n            os.remove(temp_file)\n            print(f\"   Keeping existing file unchanged\")\n            return False\n        \n        # 6. Create backup of existing file\n        if has_existing:\n            shutil.copy2(output_file, backup_file)\n        \n        # 7. Move temp file to final location (atomic operation)\n        shutil.move(temp_file, output_file)\n        \n        print(f\"[OK] Saved successfully\")\n        print(f\"  File size: {new_size / 1024:.1f} KB\")\n        print(f\"  Records: {new_count}\")\n        \n        return True\n        \n    except Exception as e:\n        print(f\"[FAIL] Error saving {output_file}: {e}\")\n        \n        # Clean up temp file\n        if os.path.exists(temp_file):\n            os.remove(temp_file)\n        \n        # Restore from backup if save failed\n        if has_existing and os.path.exists(backup_file):\n            shutil.copy2(backup_file, output_file)\n            print(f\"  Restored from backup\")\n        \n        return False",
    "start_line": 672,
    "end_line": 784,
    "has_docstring": true,
    "docstring": "Safely save data to JSON cache with comprehensive fail-safe protection\nFollows same pattern as orbit_data_manager.py",
    "parameters": [
      "output_file",
      "records",
      "metadata_func"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function save_cache",
    "component_id": "fetch_climate_data.save_cache"
  },
  "fetch_climate_data.main": {
    "id": "fetch_climate_data.main",
    "name": "main",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_climate_data.py",
    "relative_path": "fetch_climate_data.py",
    "depends_on": [
      "fetch_climate_data.fetch_ocean_ph",
      "fetch_climate_data.fetch_arctic_ice",
      "fetch_climate_data.fetch_nasa_sea_level",
      "fetch_climate_data.fetch_mauna_loa_co2",
      "fetch_climate_data.save_cache",
      "fetch_climate_data.fetch_nasa_giss_temperature"
    ],
    "source_code": "def main():\n    \"\"\"Main function to fetch all climate data\"\"\"\n    \n    print(\"=\" * 60)\n    print(\"  Climate Data Fetcher - Paloma's Orrery\")\n    print(\"  Data Preservation is Climate Action\")\n    print(\"=\" * 60)\n    print()\n    \n    results = []\n    \n    # 1. Fetch CO2 data\n    print(\"1. Fetching Mauna Loa CO2 monthly data...\")\n    co2_records = fetch_mauna_loa_co2()\n    \n    if co2_records:\n        success = save_cache(CO2_OUTPUT_FILE, co2_records, create_co2_metadata)\n        results.append((\"CO2\", len(co2_records), success))\n        \n        if success and co2_records:\n            latest = co2_records[-1]\n            first = co2_records[0]\n    #        increase = latest['trend'] - first['trend']\n            increase = latest['co2_ppm'] - first['co2_ppm']\n            years = latest['year'] - first['year']\n            \n    #        print(f\"\\nLatest CO2 measurement: {latest['trend']} ppm\")\n            print(f\"Latest CO2 measurement: {latest['co2_ppm']:.2f} ppm\")\n            print(f\"{years}-year increase: +{increase:.2f} ppm\\n\")\n    else:\n        results.append((\"CO2\", 0, False))\n    \n    # 2. Fetch temperature data\n    print(\"2. Fetching NASA GISS temperature data...\")\n#    temp_records = fetch_nasa_giss_temperature()\n    temp_records, temp_metadata = fetch_nasa_giss_temperature()\n    \n    if temp_records:\n        success = save_cache(TEMP_OUTPUT_FILE, temp_records, create_temperature_metadata)\n        results.append((\"Temperature\", len(temp_records), success))\n        \n        if success and temp_records:\n            latest = temp_records[-1]\n            first = temp_records[0]\n    #        warming = latest['anomaly_celsius'] - first['anomaly_celsius']\n            warming = latest['anomaly_c'] - first['anomaly_c']\n            years = latest['year'] - first['year']\n            \n    #        print(f\"\\nLatest temperature anomaly: +{latest['anomaly_celsius']} degC\")\n            print(f\"Latest temperature anomaly: +{latest['anomaly_c']:.2f} degC\")\n            print(f\"{years}-year warming: +{warming:.2f} degC\\n\")\n    else:\n        results.append((\"Temperature\", 0, False))\n    \n    # 3. Fetch Arctic ice data\n    print(\"3. Fetching NSIDC Arctic sea ice extent data...\")\n    ice_records = fetch_arctic_ice()\n    \n    if ice_records:\n        success = save_cache(ICE_OUTPUT_FILE, ice_records, create_ice_metadata)\n        results.append((\"Arctic Ice\", len(ice_records), success))\n        \n        if success and ice_records:\n            # Find September records (minimum extent)\n            sept_records = [r for r in ice_records if r['month'] == 9]\n            if sept_records:\n                latest = sept_records[-1]\n                first = sept_records[0]\n                change = latest['extent_million_km2'] - first['extent_million_km2']\n                years = latest['year'] - first['year']\n                \n                print(f\"\\nLatest September ice extent: {latest['extent_million_km2']} million km^2\")\n                print(f\"{years}-year change: {change:.2f} million km^2 ({change/first['extent_million_km2']*100:.1f}%)\\n\")\n    else:\n        results.append((\"Arctic Ice\", 0, False))\n    \n    # 4. Fetch sea level data\n    print(\"4. Fetching NOAA STAR global mean sea level data...\")\n#    sea_level_records = fetch_noaa_sea_level()\n    sea_level_records = fetch_nasa_sea_level()\n    \n    if sea_level_records:\n        success = save_cache(SEA_LEVEL_OUTPUT_FILE, sea_level_records, create_sea_level_metadata)\n        results.append((\"Sea Level\", len(sea_level_records), success))\n        \n        if success and sea_level_records:\n            latest = sea_level_records[-1]\n            first = sea_level_records[0]\n    #        rise_mm = latest['gmsl_mm'] - first['gmsl_mm']\n            rise_mm = (latest['gmsl_cm'] - first['gmsl_cm']) * 10  # Convert cm to mm\n            years = latest['year'] - first['year']\n            \n            # Convert to cm for readability\n            rise_cm = rise_mm / 10\n            \n    #        print(f\"\\nLatest sea level: {latest['gmsl_mm']:.1f} mm from baseline\")\n            print(f\"\\nLatest sea level: {latest['gmsl_cm']:.2f} cm from baseline\")\n            print(f\"{years}-year rise: +{rise_cm:.1f} cm (+{rise_mm:.1f} mm)\\n\")\n    else:\n        results.append((\"Sea Level\", 0, False))\n    \n    # 5. Fetch ocean pH data\n    print(\"5. Fetching ocean pH data...\")\n    ph_records = fetch_ocean_ph()\n    \n    if ph_records:\n        success = save_cache(PH_OUTPUT_FILE, ph_records, create_ph_metadata)\n        results.append((\"Ocean pH\", len(ph_records), success))\n        \n        if success and ph_records:\n            latest = ph_records[-1]\n            first = ph_records[0]\n            ph_change = latest['ph_total'] - first['ph_total']\n            years = latest['year'] - first['year']\n            \n            print(f\"\\nLatest ocean pH: {latest['ph_total']:.4f}\")\n            print(f\"{years}-year change: {ph_change:+.4f} pH units\\n\")\n    else:\n        results.append((\"Ocean pH\", 0, False))\n        print(\"Note: Ocean pH requires manual download\")\n\n    # Summary\n    print(\"=\" * 60)\n    print(\"  SUMMARY\")\n    print(\"=\" * 60)\n    \n    for dataset, count, success in results:\n        status = \"[OK]\" if success else \"[FAIL]\"\n        print(f\"{status} {dataset}: {count} records\")\n    \n    print()\n    print(\"Data preservation complete!\")\n    print(\"=\" * 60)",
    "start_line": 786,
    "end_line": 918,
    "has_docstring": true,
    "docstring": "Main function to fetch all climate data",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "fetch_climate_data.main"
  },
  "fetch_paleoclimate_data.ensure_data_dir": {
    "id": "fetch_paleoclimate_data.ensure_data_dir",
    "name": "ensure_data_dir",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_paleoclimate_data.py",
    "relative_path": "fetch_paleoclimate_data.py",
    "depends_on": [],
    "source_code": "def ensure_data_dir():\n    \"\"\"Create data directory if it doesn't exist\"\"\"\n    if not os.path.exists(PALEO_DATA_DIR):\n        os.makedirs(PALEO_DATA_DIR)",
    "start_line": 31,
    "end_line": 34,
    "has_docstring": true,
    "docstring": "Create data directory if it doesn't exist",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function ensure_data_dir",
    "component_id": "fetch_paleoclimate_data.ensure_data_dir"
  },
  "fetch_paleoclimate_data.fetch_lr04_data": {
    "id": "fetch_paleoclimate_data.fetch_lr04_data",
    "name": "fetch_lr04_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_paleoclimate_data.py",
    "relative_path": "fetch_paleoclimate_data.py",
    "depends_on": [],
    "source_code": "def fetch_lr04_data():\n    \"\"\"\n    Fetch LR04 benthic stack data (5.3 Ma - present)\n    Benthic delta18O is proxy for ice volume and deep ocean temperature\n    \"\"\"\n    print(\"\\n\" + \"=\"*70)\n    print(\"FETCHING LR04 BENTHIC STACK\")\n    print(\"=\"*70)\n    \n    try:\n        response = requests.get(LR04_URL, timeout=30)\n        response.raise_for_status()\n        \n        # Parse the tab-delimited data\n        lines = response.text.split('\\n')\n        data_started = False\n        records = []\n        \n        for line in lines:\n            if line.startswith('age_calkaBP'):\n                data_started = True\n                continue\n            \n            if data_started and line.strip():\n                parts = line.strip().split('\\t')\n                if len(parts) >= 3:\n                    try:\n                        age_ka = float(parts[0])\n                        d18o = float(parts[1])\n                        error = float(parts[2])\n                        records.append({\n                            'age_ka_bp': age_ka,\n                            'd18o_permil': d18o,\n                            'd18o_error': error\n                        })\n                    except ValueError:\n                        continue\n        \n        # Create cached data structure\n        cache_data = {\n            'metadata': {\n                'source': 'Lisiecki & Raymo (2005)',\n                'doi': '10.1029/2004PA001071',\n                'citation': 'Lisiecki, L.E. and M.E. Raymo. 2005. A Pliocene-Pleistocene stack of 57 globally distributed benthic D18O records. Paleoceanography, 20, PA1003.',\n                'data_url': LR04_URL,\n                'description': 'LR04 benthic delta18O stack - proxy for ice volume and deep ocean temperature',\n                'time_range': '5.3 Ma to present',\n                'downloaded': datetime.now().isoformat(),\n                'record_count': len(records)\n            },\n            'data': records\n        }\n        \n        # Save to cache\n        with open(LR04_CACHE, 'w') as f:\n            json.dump(cache_data, f, indent=2)\n        \n        print(f\"[OK] Downloaded {len(records):,} records\")\n        print(f\"[OK] Time range: {records[0]['age_ka_bp']:.1f} ka BP to {records[-1]['age_ka_bp']:.1f} ka BP\")\n        print(f\"[OK] Cached to: {LR04_CACHE}\")\n        \n        return True\n        \n    except Exception as e:\n        print(f\"[FAIL] Error fetching LR04 data: {e}\")\n        return False",
    "start_line": 36,
    "end_line": 101,
    "has_docstring": true,
    "docstring": "Fetch LR04 benthic stack data (5.3 Ma - present)\nBenthic delta18O is proxy for ice volume and deep ocean temperature",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_lr04_data",
    "component_id": "fetch_paleoclimate_data.fetch_lr04_data"
  },
  "fetch_paleoclimate_data.fetch_epica_co2_data": {
    "id": "fetch_paleoclimate_data.fetch_epica_co2_data",
    "name": "fetch_epica_co2_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_paleoclimate_data.py",
    "relative_path": "fetch_paleoclimate_data.py",
    "depends_on": [],
    "source_code": "def fetch_epica_co2_data():\n    \"\"\"\n    Fetch EPICA Dome C CO2 data (800 ka - present)\n    \"\"\"\n    print(\"\\n\" + \"=\"*70)\n    print(\"FETCHING EPICA DOME C CO2 DATA\")\n    print(\"=\"*70)\n    \n    try:\n        response = requests.get(EPICA_CO2_URL, timeout=30)\n        response.raise_for_status()\n        \n        # Parse the data\n        lines = response.text.split('\\n')\n        data_started = False\n        records = []\n        \n        for line in lines:\n            # Skip comments\n            if line.startswith('#'):\n                continue\n            \n            # Look for data header\n            if 'Age' in line or 'age' in line:\n                data_started = True\n                continue\n            \n            if data_started and line.strip():\n                parts = line.strip().split()\n                if len(parts) >= 2:\n                    try:\n                        # Format varies, but typically: age_yr_BP  CO2_ppmv\n                        age_yr = float(parts[0])\n                        co2_ppm = float(parts[1])\n                        records.append({\n                            'age_yr_bp': age_yr,\n                            'co2_ppm': co2_ppm\n                        })\n                    except ValueError:\n                        continue\n        \n        if records:\n            cache_data = {\n                'metadata': {\n                    'source': 'Luthi et al. (2008)',\n                    'doi': '10.1038/nature06949',\n                    'citation': 'Luthi, D., et al. 2008. High-resolution carbon dioxide concentration record 650,000-800,000 years before present. Nature, Vol. 453, pp. 379-382.',\n                    'data_url': EPICA_CO2_URL,\n                    'description': 'EPICA Dome C ice core 800,000-year CO2 record',\n                    'time_range': '800 ka to present',\n                    'downloaded': datetime.now().isoformat(),\n                    'record_count': len(records)\n                },\n                'data': records\n            }\n            \n            with open(EPICA_CO2_CACHE, 'w') as f:\n                json.dump(cache_data, f, indent=2)\n            \n            print(f\"[OK] Downloaded {len(records):,} records\")\n            print(f\"[OK] Cached to: {EPICA_CO2_CACHE}\")\n            return True\n        else:\n            print(\"[FAIL] No data records found\")\n            return False\n            \n    except Exception as e:\n        print(f\"[FAIL] Error fetching EPICA CO2 data: {e}\")\n        print(\"  Note: URL may need adjustment or data may require manual download\")\n        return False",
    "start_line": 103,
    "end_line": 172,
    "has_docstring": true,
    "docstring": "Fetch EPICA Dome C CO2 data (800 ka - present)",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_epica_co2_data",
    "component_id": "fetch_paleoclimate_data.fetch_epica_co2_data"
  },
  "fetch_paleoclimate_data.main": {
    "id": "fetch_paleoclimate_data.main",
    "name": "main",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\fetch_paleoclimate_data.py",
    "relative_path": "fetch_paleoclimate_data.py",
    "depends_on": [
      "fetch_paleoclimate_data.fetch_epica_co2_data",
      "fetch_paleoclimate_data.ensure_data_dir",
      "fetch_paleoclimate_data.fetch_lr04_data"
    ],
    "source_code": "def main():\n    \"\"\"Fetch all paleoclimate datasets\"\"\"\n    ensure_data_dir()\n    \n    print(\"\\n\" + \"=\"*70)\n    print(\"PALEOCLIMATE DATA FETCHER\")\n    print(\"For Paloma's Orrery - Data Preservation is Climate Action\")\n    print(\"=\"*70)\n    \n    results = {\n        'LR04 Stack': fetch_lr04_data(),\n        'EPICA CO2': fetch_epica_co2_data()\n    }\n    \n    print(\"\\n\" + \"=\"*70)\n    print(\"SUMMARY\")\n    print(\"=\"*70)\n    for name, success in results.items():\n        status = \"[OK] SUCCESS\" if success else \"[FAIL] FAILED\"\n        print(f\"{name}: {status}\")\n    \n    print(\"\\nNext steps:\")\n    print(\"1. Check cached files in:\", PALEO_DATA_DIR)\n    print(\"2. Manual data may be needed for deep Cenozoic (66 Ma)\")\n    print(\"3. Temperature proxies may need conversion from delta18O\")",
    "start_line": 174,
    "end_line": 198,
    "has_docstring": true,
    "docstring": "Fetch all paleoclimate datasets",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "fetch_paleoclimate_data.main"
  },
  "formatting_utils.format_maybe_float": {
    "id": "formatting_utils.format_maybe_float",
    "name": "format_maybe_float",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\formatting_utils.py",
    "relative_path": "formatting_utils.py",
    "depends_on": [],
    "source_code": "def format_maybe_float(value):\n    \"\"\"\n    If 'value' is a numeric type (int or float), return it formatted\n    with 10 decimal places. Otherwise, return 'N/A'.\n    \"\"\"\n    if isinstance(value, (int, float)):\n        return f\"{value:.10f}\"\n    return \"N/A\"",
    "start_line": 3,
    "end_line": 10,
    "has_docstring": true,
    "docstring": "If 'value' is a numeric type (int or float), return it formatted\nwith 10 decimal places. Otherwise, return 'N/A'.",
    "parameters": [
      "value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function format_maybe_float",
    "component_id": "formatting_utils.format_maybe_float"
  },
  "formatting_utils.format_km_float": {
    "id": "formatting_utils.format_km_float",
    "name": "format_km_float",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\formatting_utils.py",
    "relative_path": "formatting_utils.py",
    "depends_on": [],
    "source_code": "def format_km_float(value):\n    \"\"\"\n    Format kilometer values in scientific notation with 2 decimal places.\n    \"\"\"\n    if isinstance(value, (int, float)):\n        return f\"{value:.10e}\"  # using .10e for scientific notation instead of .10f\n    return \"N/A\"",
    "start_line": 12,
    "end_line": 18,
    "has_docstring": true,
    "docstring": "Format kilometer values in scientific notation with 2 decimal places.",
    "parameters": [
      "value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function format_km_float",
    "component_id": "formatting_utils.format_km_float"
  },
  "hr_diagram_apparent_magnitude.ensure_cache_system_ready": {
    "id": "hr_diagram_apparent_magnitude.ensure_cache_system_ready",
    "name": "ensure_cache_system_ready",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\hr_diagram_apparent_magnitude.py",
    "relative_path": "hr_diagram_apparent_magnitude.py",
    "depends_on": [
      "simbad_manager.SimbadConfig",
      "simbad_manager.SimbadQueryManager",
      "star_properties.load_existing_properties"
    ],
    "source_code": "def ensure_cache_system_ready():\n    \"\"\"\n    Minimal cache system initialization using existing modules.\n    Ensures PKL files exist and checks cache health.\n    \"\"\"\n    import os\n    import pickle\n    \n    # Create empty PKL files if they don't exist\n    pkl_files = [\n        'star_data/star_properties_distance.pkl',\n        'star_data/star_properties_magnitude.pkl'        \n    ]\n    \n    for pkl_file in pkl_files:\n#        if not os.path.exists(pkl_file):\n#            print(f\"Creating missing cache: {pkl_file}\")\n#            with open(pkl_file, 'wb') as f:\n#                pickle.dump({}, f)\n        \n        if not os.path.exists(pkl_file):\n            print(f\"\\n[WARN]  WARNING: Cache file not found: {pkl_file}\")\n            print(f\"   This will create an EMPTY cache file.\")\n            print(f\"   If you have existing cache data, this may indicate a path problem.\")\n            response = input(f\"   Create empty cache at this location? (y/n): \")\n            if response.lower() == 'y':\n                print(f\"   Creating empty cache: {pkl_file}\")\n                with open(pkl_file, 'wb') as f:\n                    pickle.dump({}, f)\n            else:\n                print(f\"   Skipping cache creation. Please check your file paths.\")\n                print(f\"   Expected location: {pkl_file}\")\n        elif os.path.getsize(pkl_file) < 1000:  # Less than 1KB = suspicious\n                print(f\"\\n[WARN]  WARNING: Cache file is suspiciously small: {pkl_file}\")\n                print(f\"   Current size: {os.path.getsize(pkl_file)} bytes\")\n                print(f\"   Expected: ~3MB (distance) or ~32MB (magnitude)\")\n                print(f\"   This may indicate corruption or path misconfiguration.\")\n                response = input(f\"   Continue anyway? (y/n): \")\n                if response.lower() != 'y':\n                    print(f\"   Aborting. Please check your cache files.\")\n                    sys.exit(1) \n\n    # Quick status check using existing module\n    try:\n        from simbad_manager import SimbadQueryManager, SimbadConfig\n        config = SimbadConfig()\n        manager = SimbadQueryManager(config)\n        \n        # Check if magnitude PKL has any data\n        props = manager.load_existing_properties('star_data/star_properties_magnitude.pkl')\n        if len(props) == 0:\n            print(\"\\nWarning: star_properties_magnitude.pkl is empty\")\n            print(\"  Stars will appear gray until properties are fetched from SIMBAD\")\n            print(\"  Properties will be fetched automatically as you use the program\")\n        else:\n            print(f\"\\n[OK] Loaded {len(props)} cached star properties\")\n    except Exception as e:\n        # Silent fail is OK here - don't clutter output\n        pass",
    "start_line": 52,
    "end_line": 110,
    "has_docstring": true,
    "docstring": "Minimal cache system initialization using existing modules.\nEnsures PKL files exist and checks cache health.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function ensure_cache_system_ready",
    "component_id": "hr_diagram_apparent_magnitude.ensure_cache_system_ready"
  },
  "hr_diagram_apparent_magnitude.process_stars": {
    "id": "hr_diagram_apparent_magnitude.process_stars",
    "name": "process_stars",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\hr_diagram_apparent_magnitude.py",
    "relative_path": "hr_diagram_apparent_magnitude.py",
    "depends_on": [
      "star_properties.generate_unique_ids",
      "star_properties.assign_properties_to_data",
      "stellar_parameters.calculate_stellar_parameters",
      "star_properties.query_simbad_for_star_properties",
      "star_properties.load_existing_properties",
      "data_processing.select_stars_by_magnitude",
      "data_processing.calculate_cartesian_coordinates"
    ],
    "source_code": "def process_stars(hip_data, gaia_data, mag_limit):\n    \"\"\"\n    Complete star processing pipeline for magnitude-based visualization.\n    Handles selection, coordinates, properties, and parameters.\n    \n    Returns:\n        combined_data: The processed star data\n        counts: Dictionary of star counts\n        unique_ids: List of unique star identifiers\n        existing_properties: Dictionary of existing star properties\n        missing_ids: List of IDs that were missing (for PKL update check)\n    \"\"\"\n    \n    # Step 1: Select and combine stars from both catalogs\n    from data_processing import select_stars_by_magnitude\n    combined_data, counts = select_stars_by_magnitude(hip_data, gaia_data, mag_limit)\n    \n    if combined_data is None:\n        return None, {}, [], {}, []\n    \n# After calling select_stars_by_magnitude (or process_stars)\n    print(f\"\\nDEBUG after select_stars_by_magnitude:\")\n    print(f\"  Combined data: {len(combined_data)} stars\")\n\n    # Step 2: Calculate 3D cartesian coordinates\n    from data_processing import calculate_cartesian_coordinates\n    combined_data = calculate_cartesian_coordinates(combined_data)\n    \n    # Step 3: Load and query star properties from SIMBAD\n    from star_properties import (\n        load_existing_properties, \n        generate_unique_ids, \n        query_simbad_for_star_properties,\n        assign_properties_to_data\n    )\n    \n    properties_file = 'star_data/star_properties_magnitude.pkl'\n    existing_properties = load_existing_properties(properties_file)\n    unique_ids = generate_unique_ids(combined_data)\n    \n    # Find which stars need SIMBAD queries\n    missing_ids = [uid for uid in unique_ids if uid not in existing_properties]\n    \n    if missing_ids:\n        print(f\"Querying SIMBAD for {len(missing_ids)} stars...\")\n        existing_properties = query_simbad_for_star_properties(\n            missing_ids, existing_properties, properties_file\n        )\n    else:\n        print(\"All star properties are already cached.\")\n    \n    # Assign properties to the combined data\n    combined_data = assign_properties_to_data(combined_data, existing_properties, unique_ids)\n    \n    # Step 4: Calculate stellar parameters (temperature, luminosity)\n    from stellar_parameters import calculate_stellar_parameters\n    combined_data, source_counts, estimation_results = calculate_stellar_parameters(combined_data)\n    \n    # Step 5: Update counts with all the statistics\n    counts['source_counts'] = source_counts\n    counts['estimation_results'] = estimation_results\n    \n    # Calculate plottable count (stars with both temperature and luminosity)\n    if 'Temperature' in combined_data.colnames and 'Luminosity' in combined_data.colnames:\n        import numpy as np\n        plottable_mask = (\n            (~np.isnan(combined_data['Temperature'])) &\n            (~np.isnan(combined_data['Luminosity']))\n        )\n        counts['plottable_count'] = int(np.sum(plottable_mask))\n    else:\n        print(\"Warning: 'Temperature' or 'Luminosity' column not found in combined_data.\")\n        counts['plottable_count'] = 0\n    \n    counts['missing_temp_only'] = estimation_results.get('final_missing_temp', 0)\n    counts['missing_lum_only'] = estimation_results.get('final_missing_lum', 0)\n    \n    # Return all needed variables for PKL update check\n    return combined_data, counts, unique_ids, existing_properties, missing_ids",
    "start_line": 113,
    "end_line": 191,
    "has_docstring": true,
    "docstring": "Complete star processing pipeline for magnitude-based visualization.\nHandles selection, coordinates, properties, and parameters.\n\nReturns:\n    combined_data: The processed star data\n    counts: Dictionary of star counts\n    unique_ids: List of unique star identifiers\n    existing_properties: Dictionary of existing star properties\n    missing_ids: List of IDs that were missing (for PKL update check)",
    "parameters": [
      "hip_data",
      "gaia_data",
      "mag_limit"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function process_stars",
    "component_id": "hr_diagram_apparent_magnitude.process_stars"
  },
  "hr_diagram_apparent_magnitude.main": {
    "id": "hr_diagram_apparent_magnitude.main",
    "name": "main",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\hr_diagram_apparent_magnitude.py",
    "relative_path": "hr_diagram_apparent_magnitude.py",
    "depends_on": [
      "data_acquisition_distance.initialize_vizier",
      "hr_diagram_apparent_magnitude.process_stars",
      "visualization_2d.create_hr_diagram",
      "hr_diagram_apparent_magnitude.ensure_cache_system_ready",
      "visualization_2d.prepare_2d_data",
      "incremental_cache_manager.smart_load_or_fetch_hipparcos",
      "visualization_core.analyze_magnitude_distribution",
      "data_processing.align_coordinate_systems",
      "visualization_core.analyze_and_report_stars",
      "stellar_data_patches.apply_temperature_patches",
      "incremental_cache_manager.IncrementalCacheManager",
      "report_manager.ReportManager",
      "incremental_cache_manager.smart_load_or_fetch_gaia",
      "object_type_analyzer.ObjectTypeAnalyzer",
      "simbad_manager.SimbadQueryManager",
      "data_processing.calculate_distances"
    ],
    "source_code": "def main():\n# CALL THE CACHE INITIALIZATION HERE - FIRST THING IN main()\n    ensure_cache_system_ready()\n\n    # Parse command-line arguments\n    if len(sys.argv) > 1:\n        try:\n            mag_limit = float(sys.argv[1])\n            if mag_limit < -1.44 or mag_limit > 9:\n                print(\"Please enter a magnitude between -1.44 and 9.\")\n                print(\"Note: Sirius at magnitude -1.44 is the brightest star.\")\n                return\n        except ValueError:\n            print(\"Invalid input for magnitude limit. Using default value of 4.\")\n            mag_limit = 4\n#    else:\n#        mag_limit = 4  # Default value\n    else:\n        return      # prevents running this module without gui input\n\n    print(f\"Filtering stars with apparent magnitude <= {mag_limit}.\")\n    start_time = time.time()\n\n    try:\n        # Step 1: Data Acquisition\n        print(\"Starting data acquisition...\")\n        v = initialize_vizier()\n        hip_data_file = 'hipparcos_data_magnitude.vot'\n        gaia_data_file = 'gaia_data_magnitude.vot'\n\n#        hip_data_file = 'star_data/hipparcos_data_magnitude.vot'\n#        gaia_data_file = 'star_data/gaia_data_magnitude.vot'\n\n        hip_data = smart_load_or_fetch_hipparcos(v, hip_data_file,\n                                                mode='magnitude',\n                                                limit_value=mag_limit)\n        gaia_data = smart_load_or_fetch_gaia(v, gaia_data_file,\n                                            mode='magnitude',\n                                            limit_value=mag_limit)\n\n        if hip_data is None and gaia_data is None:\n            print(\"Error: Could not load or fetch data from either catalog.\")\n            return\n\n        print(f\"Data acquisition completed in {time.time() - start_time:.2f} seconds.\")\n        \n        from incremental_cache_manager import IncrementalCacheManager\n        cache_mgr = IncrementalCacheManager()\n\n        hip_status, hip_meta = cache_mgr.check_cache_validity(hip_data_file, 'magnitude', mag_limit)\n        gaia_status, gaia_meta = cache_mgr.check_cache_validity(gaia_data_file, 'magnitude', mag_limit)\n\n        print(\"\\n\" + \"=\"*60)\n        print(\"CACHE STATUS REPORT\")\n        print(\"=\"*60)\n        print(f\"Hipparcos: {hip_status}\")\n        if hip_meta:\n            print(f\"  Cached: {hip_meta.entry_count} stars up to magnitude {hip_meta.limit_value}\")\n        print(f\"Gaia: {gaia_status}\")\n        if gaia_meta:\n            print(f\"  Cached: {gaia_meta.entry_count} stars up to magnitude {gaia_meta.limit_value}\")\n\n        if hip_status == 'expand' or gaia_status == 'expand':\n            print(\"\\n[OK] INCREMENTAL FETCH PERFORMED\")\n        elif hip_status == 'subset' or gaia_status == 'subset':\n            print(\"\\n[OK] FILTERED EXISTING CACHE (no fetch needed)\")\n        else:\n            print(\"\\n[OK] EXACT CACHE HIT - using existing data\")\n        print(\"=\"*60 + \"\\n\")\n\n# Debug: Check what smart_load_or_fetch returned\n        import numpy as np\n        \n        if hip_data is not None:\n            print(f\"\\nDEBUG after smart_load_or_fetch:\")\n            print(f\"  Hipparcos: {len(hip_data)} stars returned\")\n            if 'Vmag' in hip_data.colnames:\n                vmags = hip_data['Vmag']\n                print(f\"    Vmag range: {np.min(vmags):.2f} to {np.max(vmags):.2f}\")\n                print(f\"    Stars <= {mag_limit}: {np.sum(vmags <= mag_limit)}\")\n        \n        if gaia_data is not None:\n    #        print(f\"  Gaia: {len(gaia_data)} stars returned\")\n    #        if 'Gmag' in gaia_data.colnames:\n    #            gmags = gaia_data['Gmag']\n    #            print(f\"    Gmag range: {np.min(gmags):.2f} to {np.max(gmags):.2f}\")\n    #            print(f\"    Stars <= {mag_limit}: {np.sum(gmags <= mag_limit)}\")\n\n            # Debug output for Gaia\n            print(f\"  Gaia: {len(gaia_data)} stars returned\")\n            if len(gaia_data) > 0:\n                gmags = gaia_data['Gmag'].filled(np.nan)\n                gmags = gmags[~np.isnan(gmags)]  # Remove NaN values\n                if len(gmags) > 0:\n                    print(f\"    Gmag range: {np.min(gmags):.2f} to {np.max(gmags):.2f}\")\n                    print(f\"    Stars <= {mag_limit}: {len(gaia_data)}\")\n                else:\n                    print(f\"    All Gmag values are NaN\")\n            else:\n                print(f\"    No stars found in magnitude range\")                \n\n        # Step 2: Data Processing\n        print(\"Starting data processing...\")\n        process_start = time.time()\n\n        # Calculate distances and align coordinates\n        hip_data = calculate_distances(hip_data) if hip_data is not None else None\n        gaia_data = calculate_distances(gaia_data) if gaia_data is not None else None\n\n        if hip_data is not None:\n            hip_data = align_coordinate_systems(hip_data)\n        \n\n\n        \"\"\"\n        # Select stars and combine data\n        combined_data, counts = select_stars_by_magnitude(hip_data, gaia_data, mag_limit)\n        if combined_data is None:\n            print(\"No valid stars found to process. Exiting.\")\n            return\n            \n        combined_data = calculate_cartesian_coordinates(combined_data)\n        print(f\"Data processing completed in {time.time() - process_start:.2f} seconds.\")\n\n        # Step 3: Star Properties\n        print(\"Retrieving star properties...\")\n        properties_start = time.time()\n        \n        properties_file = 'star_data/star_properties_magnitude.pkl'\n        existing_properties = load_existing_properties(properties_file)\n        unique_ids = generate_unique_ids(combined_data)\n        \n        missing_ids = [uid for uid in unique_ids if uid not in existing_properties]\n        if missing_ids:\n            existing_properties = query_simbad_for_star_properties(\n                missing_ids, existing_properties, properties_file\n            )\n        else:\n            print(\"All star properties are already cached.\")\n        \n        combined_data = assign_properties_to_data(combined_data, existing_properties, unique_ids)\n        print(f\"Property retrieval completed in {time.time() - properties_start:.2f} seconds.\")\n\n        # Step 4: Calculate Stellar Parameters\n        print(\"Calculating stellar parameters...\")\n        params_start = time.time()\n        \n#        combined_data, source_counts = calculate_stellar_parameters(combined_data)\n        combined_data, source_counts, estimation_results = calculate_stellar_parameters(combined_data)\n        print(f\"Parameter calculations completed in {time.time() - params_start:.2f} seconds.\")\n        \"\"\"\n\n# Process all star data using consolidated function\n        combined_data, counts, unique_ids, existing_properties, missing_ids = process_stars(\n            hip_data, gaia_data, mag_limit\n        )\n        \n        if combined_data is None:\n            print(\"No valid stars found to process. Exiting.\")\n            return\n        \n        # Extract the nested values from counts for use later in the code\n        source_counts = counts.get('source_counts', {})\n        estimation_results = counts.get('estimation_results', {})\n        \n        print(f\"Data processing completed in {time.time() - process_start:.2f} seconds.\")\n\n        # Step 5: Analysis and Visualization\n        print(\"Starting analysis and visualization...\")\n        viz_start = time.time()\n\n        # Convert to pandas DataFrame for visualization\n        combined_df = combined_data.to_pandas()\n\n        # Apply temperature patches for known problematic stars\n        from stellar_data_patches import apply_temperature_patches\n        combined_df = apply_temperature_patches(combined_df)\n\n# Expand object types BEFORE generating report\n    #    print(\"Expanding object type descriptions...\")\n    #    if 'Object_Type' in combined_df.columns:\n    #        combined_df['Object_Type_Desc'] = combined_df['Object_Type'].apply(expand_object_type)\n    #        print(f\"Expanded object types for {combined_df['Object_Type_Desc'].notna().sum()} stars\")\n    #    else:\n    #        print(\"Warning: Object_Type column not found in combined_df\")\n    #        print(f\"Available columns: {combined_df.columns.tolist()}\")\n\n        # Expand object types BEFORE generating report\n        print(\"Expanding object type descriptions...\")\n        from object_type_analyzer import expand_object_type  # Import here, right before use\n        if 'Object_Type' in combined_df.columns:\n            combined_df['Object_Type_Desc'] = combined_df['Object_Type'].apply(expand_object_type)\n            print(f\"Expanded object types for {combined_df['Object_Type_Desc'].notna().sum()} stars\")\n        else:\n            print(\"Warning: Object_Type column not found in combined_df\")\n            print(f\"Available columns: {combined_df.columns.tolist()}\")           \n\n# Define properties file for PKL update\n        properties_file = 'star_data/star_properties_magnitude.pkl'\n        \n        # Only update PKL if we actually added new stars to the dataset\n        if len(missing_ids) > 0:  # Now using missing_ids from process_stars\n            config = SimbadConfig.load_from_file()\n            manager = SimbadQueryManager(config)\n            updated_properties = manager.update_calculated_properties(combined_df, properties_file)\n            print(f\"Updated PKL with calculated properties for {len(missing_ids)} new stars\")\n        else:\n            print(\"No new stars added - PKL file unchanged\")\n\n        if len(combined_df) == 0:\n            print(\"No stars available for visualization after processing.\")\n            return\n\n        # Analyze magnitude distribution\n        analyze_magnitude_distribution(combined_df, mag_limit)\n        \n        # Run comprehensive analysis\n        analysis_results = analyze_and_report_stars(\n            combined_df,\n            mode='magnitude',\n            max_value=mag_limit\n        )\n        \n        # Store the mode in the DataFrame attributes\n        combined_df.attrs['mode'] = 'magnitude'\n\n        # Flatten the analysis for visualization\n        flattened_analysis = {\n            'total_stars': analysis_results['data_quality']['total_stars'],\n            'plottable_hip': analysis_results['plottable']['hipparcos'],\n            'plottable_gaia': analysis_results['plottable']['gaia'],\n            'missing_temp': analysis_results['data_quality']['total_stars'] - analysis_results['data_quality']['valid_temp'],\n            'missing_lum': analysis_results['data_quality']['total_stars'] - analysis_results['data_quality']['valid_lum'],\n            'temp_le_zero': 0\n        }\n        combined_df.attrs['analysis'] = flattened_analysis\n\n        # Generate comprehensive report using ObjectTypeAnalyzer\n        print(\"Generating comprehensive report...\")\n        analyzer = ObjectTypeAnalyzer()\n        report_data = analyzer.generate_complete_report(\n            combined_df,\n            mode='magnitude',\n            limit_value=mag_limit\n        )\n        print(f\"Report generated with {len(report_data['sections'])} sections\")\n\n        # Save the scientific report\n        report_mgr = ReportManager()\n        report_mgr.save_report(report_data, archive=True)\n\n        # Prepare data for visualization\n    #    prepared_df = prepare_2d_data(combined_data)\n        prepared_df = prepare_2d_data(combined_df)\n        if prepared_df is None or len(prepared_df) == 0:\n            print(\"No plottable stars found after data preparation.\")\n            return\n\n        # Calculate final counts for visualization\n        total_stars = len(combined_df)\n        plottable_mask = (~combined_df['Temperature'].isna()) & (~combined_df['Luminosity'].isna())\n        plottable_count = plottable_mask.sum()\n        missing_temp_only = combined_df['Temperature'].isna().sum()\n        missing_lum_only = combined_df['Luminosity'].isna().sum()\n\n        final_counts = {\n            'hip_bright_count': len(combined_df[\n                (combined_df['Source_Catalog'] == 'Hipparcos') &\n                (combined_df['Apparent_Magnitude'] <= 1.73)\n            ]),\n            'hip_mid_count': len(combined_df[\n                (combined_df['Source_Catalog'] == 'Hipparcos') &\n                (combined_df['Apparent_Magnitude'] > 1.73) &\n                (combined_df['Apparent_Magnitude'] <= 4.0)\n            ]),\n            'gaia_mid_count': len(combined_df[\n                (combined_df['Source_Catalog'] == 'Gaia') &\n                (combined_df['Apparent_Magnitude'] > 1.73) &\n                (combined_df['Apparent_Magnitude'] <= 4.0)\n            ]),\n            'gaia_faint_count': len(combined_df[\n                (combined_df['Source_Catalog'] == 'Gaia') &\n                (combined_df['Apparent_Magnitude'] > 4.0) &\n                (combined_df['Apparent_Magnitude'] <= mag_limit)\n            ]),\n            'total_stars': len(combined_df),\n            'plottable_count': plottable_count,\n        #    'missing_temp': estimation_results['final_missing_temp'],\n        #    'missing_lum': estimation_results['final_missing_lum'],\n            'missing_temp_only': missing_temp_only,\n            'missing_lum_only': missing_lum_only,\n            'estimation_results': estimation_results,\n            'source_counts': source_counts\n        }\n\n        # Create visualization\n        create_hr_diagram(\n            combined_df=prepared_df,\n            counts_dict=final_counts,\n            mag_limit=mag_limit\n        )\n\n        # Save plot data for GUI\n        PlotDataExchange.save_plot_data(\n            combined_df=combined_df,  # Use full combined_df, not prepared_df\n            counts_dict=final_counts,\n            processing_times={'total': time.time() - start_time},\n            mode='magnitude',\n            limit_value=mag_limit\n        )\n\n        print(f\"Visualization completed in {time.time() - viz_start:.2f} seconds.\")\n\n    except Exception as e:\n        print(f\"Error during execution: {e}\")\n        import traceback\n        traceback.print_exc()\n        return\n\n    print(f\"Total execution time: {time.time() - start_time:.2f} seconds.\")",
    "start_line": 194,
    "end_line": 513,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "hr_diagram_apparent_magnitude.main"
  },
  "hr_diagram_distance.ensure_cache_system_ready": {
    "id": "hr_diagram_distance.ensure_cache_system_ready",
    "name": "ensure_cache_system_ready",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\hr_diagram_distance.py",
    "relative_path": "hr_diagram_distance.py",
    "depends_on": [
      "simbad_manager.SimbadConfig",
      "simbad_manager.SimbadQueryManager",
      "star_properties.load_existing_properties"
    ],
    "source_code": "def ensure_cache_system_ready():\n    \"\"\"\n    Minimal cache system initialization using existing modules.\n    Ensures PKL files exist and checks cache health.\n    \"\"\"\n    import os\n    import pickle\n    \n    # Create empty PKL files if they don't exist\n    \n    pkl_files = [\n        'star_data/star_properties_distance.pkl',\n        'star_data/star_properties_magnitude.pkl'\n    ] \n   \n    for pkl_file in pkl_files:\n#        if not os.path.exists(pkl_file):\n#            print(f\"Creating missing cache: {pkl_file}\")\n#            with open(pkl_file, 'wb') as f:\n#                pickle.dump({}, f)\n        \n        if not os.path.exists(pkl_file):\n            print(f\"\\n[WARN]  WARNING: Cache file not found: {pkl_file}\")\n            print(f\"   This will create an EMPTY cache file.\")\n            print(f\"   If you have existing cache data, this may indicate a path problem.\")\n            response = input(f\"   Create empty cache at this location? (y/n): \")\n            if response.lower() == 'y':\n                print(f\"   Creating empty cache: {pkl_file}\")\n                with open(pkl_file, 'wb') as f:\n                    pickle.dump({}, f)\n            else:\n                print(f\"   Skipping cache creation. Please check your file paths.\")\n                print(f\"   Expected location: {pkl_file}\")\n        elif os.path.getsize(pkl_file) < 1000:  # Less than 1KB = suspicious\n                print(f\"\\n[WARN]  WARNING: Cache file is suspiciously small: {pkl_file}\")\n                print(f\"   Current size: {os.path.getsize(pkl_file)} bytes\")\n                print(f\"   Expected: ~3MB (distance) or ~32MB (magnitude)\")\n                print(f\"   This may indicate corruption or path misconfiguration.\")\n                response = input(f\"   Continue anyway? (y/n): \")\n                if response.lower() != 'y':\n                    print(f\"   Aborting. Please check your cache files.\")\n                    sys.exit(1)        \n\n    # Quick status check using existing module\n    try:\n        from simbad_manager import SimbadQueryManager, SimbadConfig\n        config = SimbadConfig()\n        manager = SimbadQueryManager(config)\n        \n        # Check if distance PKL has any data\n        props = manager.load_existing_properties('star_data/star_properties_distance.pkl')\n        if len(props) == 0:\n            print(\"\\nWarning: star_properties_distance.pkl is empty\")\n            print(\"  Stars will appear gray until properties are fetched from SIMBAD\")\n            print(\"  Properties will be fetched automatically as you use the program\")\n        else:\n            print(f\"\\n[OK] Loaded {len(props)} cached star properties\")\n    except Exception as e:\n        # Silent fail is OK here - don't clutter output\n        pass",
    "start_line": 55,
    "end_line": 114,
    "has_docstring": true,
    "docstring": "Minimal cache system initialization using existing modules.\nEnsures PKL files exist and checks cache health.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function ensure_cache_system_ready",
    "component_id": "hr_diagram_distance.ensure_cache_system_ready"
  },
  "hr_diagram_distance.process_stars": {
    "id": "hr_diagram_distance.process_stars",
    "name": "process_stars",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\hr_diagram_distance.py",
    "relative_path": "hr_diagram_distance.py",
    "depends_on": [
      "star_properties.generate_unique_ids",
      "catalog_selection.select_stars",
      "star_properties.assign_properties_to_data",
      "stellar_parameters.calculate_stellar_parameters",
      "star_properties.query_simbad_for_star_properties",
      "star_properties.load_existing_properties",
      "data_processing.calculate_cartesian_coordinates"
    ],
    "source_code": "def process_stars(hip_data, gaia_data, max_light_years):\n    \"\"\"\n    Complete star processing pipeline for distance-based visualization.\n    Handles selection, coordinates, properties, and parameters.\n    \n    Returns:\n        combined_data: The processed star data\n        counts: Dictionary of star counts\n        unique_ids: List of unique star identifiers\n        existing_properties: Dictionary of existing star properties\n        missing_ids: List of IDs that were missing (for PKL update check)\n    \"\"\"\n    \n    # Step 1: Select and combine stars from both catalogs\n    from catalog_selection import select_stars\n    combined_data, counts = select_stars(\n        hip_data, \n        gaia_data, \n        mode='distance', \n        limit_value=max_light_years\n    )\n    \n    if combined_data is None:\n        return None, {}, [], {}, []\n    \n    # Step 2: Calculate 3D cartesian coordinates\n    from data_processing import calculate_cartesian_coordinates\n    combined_data = calculate_cartesian_coordinates(combined_data)\n    \n    # Step 3: Load and query star properties from SIMBAD\n    from star_properties import (\n        load_existing_properties, \n        generate_unique_ids, \n        query_simbad_for_star_properties,\n        assign_properties_to_data\n    )\n    \n    properties_file = 'star_data/star_properties_distance.pkl'\n    existing_properties = load_existing_properties(properties_file)\n    unique_ids = generate_unique_ids(combined_data)\n    \n    # Find which stars need SIMBAD queries\n    missing_ids = [uid for uid in unique_ids if uid not in existing_properties]\n    \n    if missing_ids:\n        print(f\"Querying SIMBAD for {len(missing_ids)} stars...\")\n        existing_properties = query_simbad_for_star_properties(\n            missing_ids, existing_properties, properties_file\n        )\n    \n    # Assign properties to the combined data\n    combined_data = assign_properties_to_data(combined_data, existing_properties, unique_ids)\n    \n    # Step 4: Calculate stellar parameters (temperature, luminosity)\n    from stellar_parameters import calculate_stellar_parameters\n    combined_data, source_counts, estimation_results = calculate_stellar_parameters(combined_data)\n    \n    # Step 5: Update counts with all the statistics\n    counts['source_counts'] = source_counts\n    counts['estimation_results'] = estimation_results\n    \n    # Calculate plottable count (stars with both temperature and luminosity)\n    if 'Temperature' in combined_data.colnames and 'Luminosity' in combined_data.colnames:\n        import numpy as np\n        plottable_mask = (\n            (~np.isnan(combined_data['Temperature'])) &\n            (~np.isnan(combined_data['Luminosity']))\n        )\n        counts['plottable_count'] = int(np.sum(plottable_mask))\n    else:\n        print(\"Warning: 'Temperature' or 'Luminosity' column not found in combined_data.\")\n        counts['plottable_count'] = 0\n    \n    counts['missing_temp_only'] = estimation_results.get('final_missing_temp', 0)\n    counts['missing_lum_only'] = estimation_results.get('final_missing_lum', 0)\n    \n    # Return all needed variables for PKL update check\n    return combined_data, counts, unique_ids, existing_properties, missing_ids",
    "start_line": 117,
    "end_line": 194,
    "has_docstring": true,
    "docstring": "Complete star processing pipeline for distance-based visualization.\nHandles selection, coordinates, properties, and parameters.\n\nReturns:\n    combined_data: The processed star data\n    counts: Dictionary of star counts\n    unique_ids: List of unique star identifiers\n    existing_properties: Dictionary of existing star properties\n    missing_ids: List of IDs that were missing (for PKL update check)",
    "parameters": [
      "hip_data",
      "gaia_data",
      "max_light_years"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function process_stars",
    "component_id": "hr_diagram_distance.process_stars"
  },
  "hr_diagram_distance.main": {
    "id": "hr_diagram_distance.main",
    "name": "main",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\hr_diagram_distance.py",
    "relative_path": "hr_diagram_distance.py",
    "depends_on": [
      "data_acquisition_distance.initialize_vizier",
      "visualization_2d.create_hr_diagram",
      "data_processing.calculate_distances",
      "simbad_manager.SimbadQueryManager",
      "visualization_2d.prepare_2d_data",
      "hr_diagram_distance.ensure_cache_system_ready",
      "incremental_cache_manager.smart_load_or_fetch_hipparcos",
      "incremental_cache_manager.smart_load_or_fetch_gaia",
      "data_processing.align_coordinate_systems",
      "data_processing.estimate_vmag_from_gaia",
      "stellar_data_patches.apply_temperature_patches",
      "incremental_cache_manager.IncrementalCacheManager",
      "report_manager.ReportManager",
      "visualization_core.analyze_magnitude_distribution",
      "visualization_core.analyze_and_report_stars",
      "object_type_analyzer.ObjectTypeAnalyzer",
      "data_acquisition_distance.calculate_parallax_limit",
      "hr_diagram_distance.process_stars"
    ],
    "source_code": "def main():\n\n# CALL THE CACHE INITIALIZATION HERE - FIRST THING IN main()\n    ensure_cache_system_ready()\n\n    # Parse command-line arguments for max light-years\n    if len(sys.argv) > 1:\n        try:\n            max_light_years = float(sys.argv[1])\n            if max_light_years <= 0:\n                print(\"Please enter a positive number of light-years.\")\n                print(\"Note: Current maximum reliable distance is 100.1 light-years.\")\n                return\n        except ValueError:\n            print(\"Invalid input for light-years limit. Using default value of 100.1.\")\n            max_light_years = 100.1\n#    else:\n#        max_light_years = 100.1  # Default value\n    else:\n        print(\"Error: Distance parameter required\")\n        return        \n\n    print(f\"Filtering stars within {max_light_years} light-years.\")\n    start_time = time.time()\n\n    try:\n        # Step 1: Data Acquisition\n        print(\"Starting data acquisition...\")\n        v = initialize_vizier()\n        min_parallax_mas = calculate_parallax_limit(max_light_years)\n        \n        # Define data files\n        hip_data_file = 'hipparcos_data_distance.vot'\n        gaia_data_file = 'gaia_data_distance.vot'\n        \n#        hip_data_file = 'star_data/hipparcos_data_distance.vot'\n#        gaia_data_file = 'star_data/gaia_data_distance.vot'\n\n        # Load or fetch data with parallax constraint\n        parallax_constraint = f\">={min_parallax_mas}\"\n\n        hip_data = smart_load_or_fetch_hipparcos(v, hip_data_file,\n                                                mode='distance',\n                                                limit_value=max_light_years,\n                                                parallax_constraint=f\">={min_parallax_mas}\")\n        gaia_data = smart_load_or_fetch_gaia(v, gaia_data_file,\n                                            mode='distance', \n                                            limit_value=max_light_years,\n                                            parallax_constraint=f\">={min_parallax_mas}\")\n\n        if hip_data is None and gaia_data is None:\n            print(\"Error: Could not load or fetch data from either catalog.\")\n            return\n\n        print(f\"Data acquisition completed in {time.time() - start_time:.2f} seconds.\")\n\n        # Cache status reporting (ADD THIS ENTIRE BLOCK)\n        from incremental_cache_manager import IncrementalCacheManager\n        cache_mgr = IncrementalCacheManager()\n\n        hip_status, hip_meta = cache_mgr.check_cache_validity(hip_data_file, 'distance', max_light_years)\n        gaia_status, gaia_meta = cache_mgr.check_cache_validity(gaia_data_file, 'distance', max_light_years)\n\n        print(\"\\n\" + \"=\"*60)\n        print(\"CACHE STATUS REPORT\")\n        print(\"=\"*60)\n        print(f\"Hipparcos: {hip_status}\")\n        if hip_meta:\n            print(f\"  Cached: {hip_meta.entry_count} stars up to {hip_meta.limit_value} ly\")\n            print(f\"  Cache date: {hip_meta.query_date}\")\n        print(f\"Gaia: {gaia_status}\")\n        if gaia_meta:\n            print(f\"  Cached: {gaia_meta.entry_count} stars up to {gaia_meta.limit_value} ly\")\n            print(f\"  Cache date: {gaia_meta.query_date}\")\n\n        if hip_status == 'expand' or gaia_status == 'expand':\n            print(\"\\n[OK] INCREMENTAL FETCH PERFORMED\")\n        elif hip_status == 'subset' or gaia_status == 'subset':\n            print(\"\\n[OK] FILTERED EXISTING CACHE (no fetch needed)\")\n        else:\n            print(\"\\n[OK] EXACT CACHE HIT - using existing data\")\n        print(\"=\"*60 + \"\\n\")        \n        \n        # Step 2: Data Processing\n        process_start = time.time()\n        hip_data = calculate_distances(hip_data) if hip_data is not None else None\n        gaia_data = calculate_distances(gaia_data) if gaia_data is not None else None\n\n        if hip_data is not None:\n            hip_data = align_coordinate_systems(hip_data)\n        \n        if gaia_data is not None:\n            gaia_data['Estimated_Vmag'] = estimate_vmag_from_gaia(gaia_data)\n\n        \"\"\"\n        # Select stars and combine data\n        combined_data, counts = select_stars(hip_data, gaia_data, mode='distance', limit_value=max_light_years)\n        if combined_data is None:\n            print(\"No valid stars found to process. Exiting.\")\n            return\n            \n        combined_data = calculate_cartesian_coordinates(combined_data)\n        print(f\"Data processing completed in {time.time() - process_start:.2f} seconds.\")\n\n        # Step 3: Star Properties\n        print(\"Retrieving star properties...\")\n        properties_start = time.time()\n        \n        properties_file = 'star_data/star_properties_distance.pkl'\n        existing_properties = load_existing_properties(properties_file)\n        unique_ids = generate_unique_ids(combined_data)\n        \n        missing_ids = [uid for uid in unique_ids if uid not in existing_properties]\n        if missing_ids:\n            existing_properties = query_simbad_for_star_properties(\n                missing_ids, existing_properties, properties_file\n            )\n        \n        combined_data = assign_properties_to_data(combined_data, existing_properties, unique_ids)\n        print(f\"Property retrieval completed in {time.time() - properties_start:.2f} seconds.\")\n\n        # Step 4: Calculate Stellar Parameters\n        print(\"Calculating stellar parameters...\")\n        params_start = time.time()\n        \n        combined_data, source_counts, estimation_results = calculate_stellar_parameters(combined_data)\n        print(f\"Parameter calculations completed in {time.time() - params_start:.2f} seconds.\")\n        \"\"\"\n\n        # Process all star data using consolidated function\n        combined_data, counts, unique_ids, existing_properties, missing_ids = process_stars(\n            hip_data, gaia_data, max_light_years\n        )\n        \n        if combined_data is None:\n            print(\"No valid stars found to process. Exiting.\")\n            return\n            \n        # Extract the nested values from counts for use later in the code\n        source_counts = counts.get('source_counts', {})\n        estimation_results = counts.get('estimation_results', {})\n\n        print(f\"Data processing completed in {time.time() - process_start:.2f} seconds.\")\n\n        # Step 5: Analysis and Visualization\n        print(\"Starting analysis and visualization...\")\n        viz_start = time.time()\n\n        # Convert to pandas DataFrame for visualization\n        combined_df = combined_data.to_pandas()\n\n        # Apply temperature patches for known problematic stars\n        from stellar_data_patches import apply_temperature_patches\n        combined_df = apply_temperature_patches(combined_df)\n\n        # ADD THIS SECTION - Expand object types BEFORE generating report\n        print(\"Expanding object type descriptions...\")\n        from object_type_analyzer import expand_object_type\n        if 'Object_Type' in combined_df.columns:\n            combined_df['Object_Type_Desc'] = combined_df['Object_Type'].apply(expand_object_type)\n            print(f\"Expanded object types for {combined_df['Object_Type_Desc'].notna().sum()} stars\")\n        else:\n            print(\"Warning: Object_Type column not found in combined_df\")\n            print(f\"Available columns: {combined_df.columns.tolist()}\")\n\n        print(f\"DEBUG: Columns in combined_df: {combined_df.columns.tolist()}\")\n\n        # Generate comprehensive report using ObjectTypeAnalyzer\n        print(\"Generating comprehensive report...\")\n        analyzer = ObjectTypeAnalyzer()\n\n        # Prepare counts_dict from the existing counts\n        counts_dict = {\n            'Hipparcos_bright': counts.get('hip_bright_count', 0),\n            'Hipparcos_mid': counts.get('hip_mid_count', 0),\n            'Gaia_mid': counts.get('gaia_mid_count', 0),\n            'Gaia_faint': counts.get('gaia_faint_count', 0),\n            'total': counts.get('total_stars', len(combined_df))\n        }\n\n        # Generate the complete report\n        report_data = analyzer.generate_complete_report(\n            combined_df=combined_df,\n            counts_dict=counts_dict,\n            processing_times={'total': time.time() - start_time},\n            mode='distance',\n            limit_value=max_light_years\n        )\n\n        print(f\"Report generated with {len(report_data['sections'])} sections\")\n\n        # Save the scientific report\n        report_mgr = ReportManager()\n        report_mgr.save_report(report_data, archive=True)\n\n        # After applying the patch\n        mizar = combined_df[combined_df['HIP'] == 65378]\n        if len(mizar) > 0:\n            print(f\"\\nMizar data after patch:\")\n            print(f\"Temperature: {mizar['Temperature'].iloc[0]}\")\n            print(f\"Luminosity: {mizar['Luminosity'].iloc[0]}\")\n            print(f\"Is Luminosity NaN? {pd.isna(mizar['Luminosity'].iloc[0])}\")\n            print(f\"Abs_Mag: {mizar['Abs_Mag'].iloc[0]}\")\n\n        # Define properties file for PKL update\n        properties_file = 'star_data/star_properties_distance.pkl'      \n\n        # Only update PKL if we actually added new stars to the dataset\n#        if len([uid for uid in unique_ids if uid not in existing_properties]) > 0:\n        if len(missing_ids) > 0:  # Now using missing_ids from process_stars    \n            config = SimbadConfig.load_from_file()\n            manager = SimbadQueryManager(config)\n            updated_properties = manager.update_calculated_properties(combined_df, properties_file)\n\n            print(f\"Updated PKL with calculated properties for {len(missing_ids)} new stars\")\n        else:\n            print(\"No new stars added - PKL file unchanged\")\n\n        if len(combined_df) == 0:\n            print(\"No stars available for visualization after processing.\")\n            return\n        \n        # Analyze magnitude distribution\n        analyze_magnitude_distribution(combined_df, mag_limit=None)\n        \n        # Run comprehensive analysis\n        analysis_results = analyze_and_report_stars(\n            combined_df,\n            mode='distance',\n            max_value=max_light_years\n        )\n        \n        # Store the mode in the DataFrame attributes\n        combined_df.attrs['mode'] = 'distance'\n\n        # Flatten the analysis for visualization (ADD THIS ENTIRE BLOCK)\n        flattened_analysis = {\n            'total_stars': analysis_results['data_quality']['total_stars'],\n            'plottable_hip': analysis_results['plottable']['hipparcos'],\n            'plottable_gaia': analysis_results['plottable']['gaia'],\n            'missing_temp': analysis_results['data_quality']['total_stars'] - analysis_results['data_quality']['valid_temp'],\n            'missing_lum': analysis_results['data_quality']['total_stars'] - analysis_results['data_quality']['valid_lum'],\n            'temp_le_zero': 0\n        }\n        combined_df.attrs['analysis'] = flattened_analysis\n\n        # Prepare data for visualization\n    #    prepared_df = prepare_2d_data(combined_data)\n        prepared_df = prepare_2d_data(combined_df)\n        if prepared_df is None or len(prepared_df) == 0:\n            print(\"No plottable stars found after data preparation.\")\n            return\n\n        # In main() before final_counts:\n        plottable_mask = (\n            (~combined_df['Temperature'].isna()) & \n            (~combined_df['Luminosity'].isna()) &\n            (\n                ((combined_df['Source_Catalog'] == 'Hipparcos') & \n                (combined_df['Apparent_Magnitude'] <= 4.0)) |\n                ((combined_df['Source_Catalog'] == 'Gaia') & \n                (combined_df['Apparent_Magnitude'] > 4.0))\n            )\n        )\n        plottable_count = plottable_mask.sum()\n\n        # Calculate final counts for visualization\n        final_counts = {\n            'hip_bright_count': counts.get('hip_bright_count', 0),\n            'hip_mid_count': counts.get('hip_mid_count', 0),\n            'gaia_mid_count': counts.get('gaia_mid_count', 0),\n            'gaia_faint_count': counts.get('gaia_faint_count', 0),\n            'total_stars': counts.get('total_stars', len(combined_df)),\n            'plottable_count': plottable_count,\n            'missing_temp_only': estimation_results.get('final_missing_temp', 0),\n            'missing_lum_only': estimation_results.get('final_missing_lum', 0),\n            'estimation_results': estimation_results,\n            'source_counts': source_counts\n        }\n\n        # Right before creating the plot\n        print(f\"\\nTotal stars in dataframe: {len(combined_df)}\")\n        print(f\"Stars with both T and L: {len(combined_df[(combined_df['Temperature'] > 0) & (combined_df['Luminosity'] > 0)])}\")\n\n        # Check if Mizar made it to plotting\n        mizar_in_plot = combined_df[combined_df['HIP'] == 65378]\n        if len(mizar_in_plot) > 0:\n            print(f\"Mizar in final plot data: YES\")\n            print(f\"  Will plot at: T={mizar_in_plot['Temperature'].iloc[0]}, L={mizar_in_plot['Luminosity'].iloc[0]}\")\n        else:\n            print(f\"Mizar in final plot data: NO - FILTERED OUT!\")\n\n        # Create visualization\n        create_hr_diagram(\n            combined_df=prepared_df,\n            counts_dict=final_counts,\n            max_light_years=max_light_years\n        )\n\n        # Save plot data for GUI\n        PlotDataExchange.save_plot_data(\n            combined_df=combined_df,  # Use full combined_df, not prepared_df\n            counts_dict=final_counts,\n            processing_times={'total': time.time() - start_time},\n            mode='distance',\n            limit_value=max_light_years\n        )\n        print(\"Plot data saved to last_plot_data.json\")\n\n        # Save plot data with complete report for GUI\n    #    exchange_data = {\n    #        'plot_stats': {\n    #            'mode': 'distance' if 'distance' in sys.argv[0] else 'magnitude',\n    #            'limit_value': max_light_years if 'distance' in sys.argv[0] else max_light_years,\n    #            'total_stars': len(combined_df),\n    #            'temp_valid': (~combined_df['Temperature'].isna()).sum(),\n    #            'temp_missing': combined_df['Temperature'].isna().sum(),\n    #            'lum_valid': (~combined_df['Luminosity'].isna()).sum(),\n    #            'lum_missing': combined_df['Luminosity'].isna().sum(),\n    #            'catalog_counts': counts_dict,\n    #            'magnitude_stats': {\n    #                'min': float(combined_df['Apparent_Magnitude'].min()),\n    #                'max': float(combined_df['Apparent_Magnitude'].max()),\n    #                'mean': float(combined_df['Apparent_Magnitude'].mean())\n    #            } if 'Apparent_Magnitude' in combined_df.columns else None,\n    #            'processing_times': {'total': time.time() - start_time},\n    #            'timestamp': datetime.now().isoformat()\n    #        },\n    #        'report_data': report_data  # Complete report from analyzer\n    #    }\n\n    #    PlotDataExchange.save_plot_data(exchange_data)\n    #    print(\"Plot data saved with complete report\")        \n\n        print(f\"Visualization completed in {time.time() - viz_start:.2f} seconds.\")\n\n    except Exception as e:\n        print(f\"Error during execution: {e}\")\n        import traceback\n        traceback.print_exc()\n        return\n\n    print(f\"Total execution time: {time.time() - start_time:.2f} seconds.\")",
    "start_line": 197,
    "end_line": 539,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "hr_diagram_distance.main"
  },
  "idealized_orbits.get_planet_perturbation_note": {
    "id": "idealized_orbits.get_planet_perturbation_note",
    "name": "get_planet_perturbation_note",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [],
    "source_code": "def get_planet_perturbation_note(obj_name, orbit_source=\"Keplerian\"):\n    \"\"\"\n    Get appropriate perturbation note for planet's Keplerian orbit hover text.\n    \n    Parameters:\n        obj_name (str): Name of the planet/object\n        orbit_source (str): Either \"Keplerian\" or \"osculating\"\n    \n    Returns:\n        str: HTML-formatted perturbation note\n    \"\"\"\n    if orbit_source == \"osculating\":\n        # For osculating orbits - generic perturbation note\n        return (\n            \"<br><br><i>Osculating orbit 'kisses' actual position at epoch,<br>\"\n            \"then diverges as perturbations accumulate from:<br>\"\n            \"* Gravitational tugs from other planets<br>\"\n            \"* Solar oblateness (equatorial bulge effect)<br>\"\n            \"<br>It fits only the present position, not past or future positions.</i>\"\n        )\n    \n    # For Keplerian orbits - planet-specific perturbations\n    perturbation_notes = {\n        'Mercury': (\n            \"<br><br><i>Keplerian orbit uses averaged orbital elements.<br>\"\n            \"Major perturbations from:<br>\"\n            \"* Venus and Jupiter gravitational tugs<br>\"\n            \"* Relativistic precession (+43 arcsec/century)<br>\"\n            \"  - Einstein's General Relativity effect<br>\"\n            \"* High eccentricity amplifies perturbations</i>\"\n        ),\n        'Venus': (\n            \"<br><br><i>Keplerian orbit uses averaged orbital elements.<br>\"\n            \"Major perturbations from:<br>\"\n            \"* Earth and Jupiter gravitational tugs<br>\"\n            \"* Nearly circular orbit (e ~ 0.007)<br>\"\n            \"* Most stable inner planet orbit</i>\"\n        ),\n        'Earth': (\n            \"<br><br><i>Keplerian orbit uses averaged orbital elements.<br>\"\n            \"Major perturbations from:<br>\"\n            \"* Moon's gravitational influence<br>\"\n            \"* Jupiter and Venus gravitational tugs<br>\"\n            \"* Axial precession (25,772 year cycle)</i>\"\n        ),\n        'Mars': (\n            \"<br><br><i>Keplerian orbit uses averaged orbital elements.<br>\"\n            \"Major perturbations from:<br>\"\n            \"* Jupiter gravitational tugs (largest)<br>\"\n            \"* Earth and Venus effects<br>\"\n            \"* Eccentricity varies 0.000-0.140 over ~2 Myr</i>\"\n        ),\n        'Jupiter': (\n            \"<br><br><i>Keplerian orbit uses averaged orbital elements.<br>\"\n            \"Major perturbations from:<br>\"\n            \"* Saturn gravitational interaction<br>\"\n            \"* Great Inequality (900-year cycle)<br>\"\n            \"* Dominates inner solar system dynamics</i>\"\n        ),\n        'Saturn': (\n            \"<br><br><i>Keplerian orbit uses averaged orbital elements.<br>\"\n            \"Major perturbations from:<br>\"\n            \"* Jupiter gravitational interaction<br>\"\n            \"* Great Inequality (900-year cycle)<br>\"\n            \"* 5:2 resonance with Jupiter</i>\"\n        ),\n        'Uranus': (\n            \"<br><br><i>Keplerian orbit uses averaged orbital elements.<br>\"\n            \"Major perturbations from:<br>\"\n            \"* Jupiter and Saturn gravitational tugs<br>\"\n            \"* Neptune interaction<br>\"\n            \"* Extreme axial tilt (98 deg)</i>\"\n        ),\n        'Neptune': (\n            \"<br><br><i>Keplerian orbit uses averaged orbital elements.<br>\"\n            \"Major perturbations from:<br>\"\n            \"* Jupiter and Saturn gravitational tugs<br>\"\n            \"* Uranus interaction<br>\"\n            \"* 3:2 resonance captures Pluto</i>\"\n        ),\n        'Pluto': (\n            \"<br><br><i>Keplerian orbit uses averaged orbital elements.<br>\"\n            \"Major perturbations from:<br>\"\n            \"* Neptune 3:2 mean motion resonance<br>\"\n            \"* High eccentricity (e ~ 0.25)<br>\"\n            \"* High inclination (i ~ 17 deg)</i>\"\n        ),\n    }\n    \n    # Default for other objects (asteroids, comets, etc.)\n    default_note = (\n        \"<br><br><i>Keplerian orbit uses averaged orbital elements.<br>\"\n        \"Subject to gravitational perturbations from planets.</i>\"\n    )\n    \n    return perturbation_notes.get(obj_name, default_note)",
    "start_line": 82,
    "end_line": 177,
    "has_docstring": true,
    "docstring": "Get appropriate perturbation note for planet's Keplerian orbit hover text.\n\nParameters:\n    obj_name (str): Name of the planet/object\n    orbit_source (str): Either \"Keplerian\" or \"osculating\"\n\nReturns:\n    str: HTML-formatted perturbation note",
    "parameters": [
      "obj_name",
      "orbit_source"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_planet_perturbation_note",
    "component_id": "idealized_orbits.get_planet_perturbation_note"
  },
  "idealized_orbits.calculate_mars_satellite_elements": {
    "id": "idealized_orbits.calculate_mars_satellite_elements",
    "name": "calculate_mars_satellite_elements",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [],
    "source_code": "def calculate_mars_satellite_elements(date, satellite_name):\n    \"\"\"\n    Calculate time-varying orbital elements for Mars satellites\n    Similar to your Moon implementation but with Mars-specific perturbations\n    \"\"\"\n    # Calculate days since revision date of ephemeris for Phobos and Deimos\n    base_epoch = datetime(2025, 6, 2, 0, 0, 0)\n\n    # Calculate days since the base epoch (NOT J2000!)\n    d = (date - base_epoch).days\n    \n    # Base elements\n    if satellite_name == 'Phobos':\n        a_base = 0.000062682  # AU\n        e_base = 0.0151\n        i_base = 1.082\n        omega_base = 216.3\n        Omega_base = 169.2\n        \n        # Mars equatorial bulge-induced precession rates (much faster than Moon)\n        omega_rate = 27.0 / 365.25  # degrees/day (apsidal precession)\n        Omega_rate = -158.0 / 365.25  # degrees/day (node regression)\n        \n        # Tidal acceleration (Phobos spiraling inward)\n        # Semi-major axis decreases by ~1.8 cm/year\n        a_secular = -1.8e-5 / 149597870.7 / 365.25 * d  # AU change\n        \n    elif satellite_name == 'Deimos':\n        a_base = 0.0001568\n        e_base = 0.00033\n        i_base = 1.791\n        omega_base = 0.0\n        Omega_base = 54.4\n        \n        # Slower precession rates for more distant Deimos\n        omega_rate = 0.84 / 365.25  # degrees/day\n        Omega_rate = -7.6 / 365.25  # degrees/day\n        \n        # Minimal tidal effects\n        a_secular = 0\n    \n    # Apply secular changes\n    omega = (omega_base + omega_rate * d) % 360.0\n    Omega = (Omega_base + Omega_rate * d) % 360.0\n    a = a_base + a_secular\n    \n    # Could add periodic perturbations like you do for Moon\n    # Solar perturbations, Mars librations, etc.\n    \n    return {\n        'a': a,\n        'e': e_base,  # Could add eccentricity variations\n        'i': i_base,  # Could add inclination oscillations\n        'omega': omega,\n        'Omega': Omega\n    }",
    "start_line": 180,
    "end_line": 235,
    "has_docstring": true,
    "docstring": "Calculate time-varying orbital elements for Mars satellites\nSimilar to your Moon implementation but with Mars-specific perturbations",
    "parameters": [
      "date",
      "satellite_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_mars_satellite_elements",
    "component_id": "idealized_orbits.calculate_mars_satellite_elements"
  },
  "idealized_orbits.calculate_jupiter_satellite_elements": {
    "id": "idealized_orbits.calculate_jupiter_satellite_elements",
    "name": "calculate_jupiter_satellite_elements",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [],
    "source_code": "def calculate_jupiter_satellite_elements(date, satellite_name):\n    \"\"\"\n    Calculate time-varying orbital elements for Jupiter satellites.\n    \n    Base elements are in Jupiter equatorial frame.\n    Follows same pattern as Mars satellites.\n    \n    Parameters:\n        date: datetime object for calculation epoch\n        satellite_name: Name of Jupiter moon\n        \n    Returns:\n        dict: Orbital elements with time-varying Omega and omega\n    \"\"\"\n    from datetime import datetime\n    \n    base_epoch = datetime(2025, 11, 22, 0, 0, 0)\n    d = (date - base_epoch).days\n    \n    # Base elements in Jupiter equatorial frame\n    if satellite_name == 'Io':\n        a_base, e_base, i_base = 0.002819, 0.0041, 0.05\n        omega_base, Omega_base = 49.1, 0.0\n    elif satellite_name == 'Europa':\n        a_base, e_base, i_base = 0.004486, 0.0094, 0.47\n        omega_base, Omega_base = 85.2, 0.0\n    elif satellite_name == 'Ganymede':\n        a_base, e_base, i_base = 0.007155, 0.0013, 0.18\n        omega_base, Omega_base = 192.4, 0.0\n    elif satellite_name == 'Callisto':\n        a_base, e_base, i_base = 0.012585, 0.0074, 0.19\n        omega_base, Omega_base = 52.6, 0.0\n    elif satellite_name == 'Metis':\n        a_base, e_base, i_base = 0.000856, 0.0002, 0.06\n        omega_base, Omega_base = 0.0, 0.0\n    elif satellite_name == 'Adrastea':\n        a_base, e_base, i_base = 0.000864, 0.0015, 0.03\n        omega_base, Omega_base = 0.0, 0.0\n    elif satellite_name == 'Amalthea':\n        a_base, e_base, i_base = 0.001217, 0.0032, 0.37\n        omega_base, Omega_base = 0.0, 0.0\n    elif satellite_name == 'Thebe':\n        a_base, e_base, i_base = 0.001486, 0.0175, 1.08\n        omega_base, Omega_base = 0.0, 0.0\n    else:\n        print(f\"Warning: No base elements defined for {satellite_name}\", flush=True)\n        return None\n    \n    # Precession rates (placeholders - can be refined later)\n    omega_rate = 0.0 / 365.25\n    Omega_rate = 0.0 / 365.25\n    \n    omega = (omega_base + omega_rate * d) % 360.0\n    Omega = (Omega_base + Omega_rate * d) % 360.0\n    \n    return {'a': a_base, 'e': e_base, 'i': i_base, 'omega': omega, 'Omega': Omega}",
    "start_line": 238,
    "end_line": 293,
    "has_docstring": true,
    "docstring": "Calculate time-varying orbital elements for Jupiter satellites.\n\nBase elements are in Jupiter equatorial frame.\nFollows same pattern as Mars satellites.\n\nParameters:\n    date: datetime object for calculation epoch\n    satellite_name: Name of Jupiter moon\n    \nReturns:\n    dict: Orbital elements with time-varying Omega and omega",
    "parameters": [
      "date",
      "satellite_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_jupiter_satellite_elements",
    "component_id": "idealized_orbits.calculate_jupiter_satellite_elements"
  },
  "idealized_orbits.calculate_saturn_satellite_elements": {
    "id": "idealized_orbits.calculate_saturn_satellite_elements",
    "name": "calculate_saturn_satellite_elements",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [],
    "source_code": "def calculate_saturn_satellite_elements(date, satellite_name):\n    \"\"\"\n    Calculate time-varying orbital elements for Saturn satellites.\n    \n    Base elements are in Saturn equatorial frame.\n    Follows same pattern as Jupiter satellites.\n    \"\"\"\n    from datetime import datetime\n    \n    base_epoch = datetime(2025, 11, 23, 0, 0, 0)\n    d = (date - base_epoch).days\n    \n    # Base elements from orbital_elements.py (JPL Horizons derived)\n    if satellite_name == 'Mimas':\n        a_base, e_base, i_base = 0.001242, 0.0196, 1.572\n        omega_base, Omega_base = 160.4, 66.2\n    elif satellite_name == 'Enceladus':\n        a_base, e_base, i_base = 0.001587, 0.0047, 0.009\n        omega_base, Omega_base = 119.5, 0.0\n    elif satellite_name == 'Tethys':\n        a_base, e_base, i_base = 0.001970, 0.001, 1.091\n        omega_base, Omega_base = 335.3, 273.0\n    elif satellite_name == 'Dione':\n        a_base, e_base, i_base = 0.002525, 0.0022, 0.0\n        omega_base, Omega_base = 116.0, 0.0\n    elif satellite_name == 'Rhea':\n        a_base, e_base, i_base = 0.003524, 0.0010, 0.333\n        omega_base, Omega_base = 44.3, 133.7\n    elif satellite_name == 'Titan':\n        a_base, e_base, i_base = 0.008168, 0.0288, 0.306\n        omega_base, Omega_base = 78.3, 78.6\n    elif satellite_name == 'Hyperion':\n        a_base, e_base, i_base = 0.010033, 0.0232, 0.615\n        omega_base, Omega_base = 214.0, 87.1\n    elif satellite_name == 'Iapetus':\n        a_base, e_base, i_base = 0.02380, 0.0283, 7.489\n        omega_base, Omega_base = 254.5, 86.5\n    else:\n        print(f\"Warning: No base elements defined for {satellite_name}\", flush=True)\n        return None\n    \n    omega_rate = 0.0 / 365.25\n    Omega_rate = 0.0 / 365.25\n    \n    omega = (omega_base + omega_rate * d) % 360.0\n    Omega = (Omega_base + Omega_rate * d) % 360.0\n    \n    return {'a': a_base, 'e': e_base, 'i': i_base, 'omega': omega, 'Omega': Omega}",
    "start_line": 295,
    "end_line": 342,
    "has_docstring": true,
    "docstring": "Calculate time-varying orbital elements for Saturn satellites.\n\nBase elements are in Saturn equatorial frame.\nFollows same pattern as Jupiter satellites.",
    "parameters": [
      "date",
      "satellite_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_saturn_satellite_elements",
    "component_id": "idealized_orbits.calculate_saturn_satellite_elements"
  },
  "idealized_orbits.test_mars_rotations": {
    "id": "idealized_orbits.test_mars_rotations",
    "name": "test_mars_rotations",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "planet_visualization_utilities.rotate_points"
    ],
    "source_code": "def test_mars_rotations(satellite_name, planetary_params, color, fig=None):     # test function only\n    \"\"\"Test multiple rotation combinations to find the best alignment\"\"\"\n    if fig is None:\n        fig = go.Figure()\n    \n    try:\n        # Get orbital parameters\n        if satellite_name not in planetary_params:\n            print(f\"Error: No orbital parameters found for {satellite_name}\", flush=True)\n            return fig\n            \n        orbital_params = planetary_params[satellite_name]\n        \n        # Extract orbital elements\n        a = orbital_params.get('a', 0)\n        e = orbital_params.get('e', 0)\n        i = orbital_params.get('i', 0)\n        omega = orbital_params.get('omega', 0)\n        Omega = orbital_params.get('Omega', 0)\n        \n        # Generate ellipse in orbital plane\n        theta = np.linspace(0, 2*np.pi, 360)\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        \n        x_orbit = r * np.cos(theta)\n        y_orbit = r * np.sin(theta)\n        z_orbit = np.zeros_like(theta)\n\n        # Convert angles to radians\n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n\n        # Test several different rotation combinations\n        rotations = [\n            {\"name\": \"Basic\", \"z1\": Omega_rad, \"x\": i_rad, \"z2\": omega_rad, \"extra\": None},\n            {\"name\": \"Mars Tilt +\", \"z1\": Omega_rad, \"x\": i_rad, \"z2\": omega_rad, \n             \"extra\": {\"axis\": 'x', \"angle\": np.radians(25.19)}},\n            {\"name\": \"Mars Tilt -\", \"z1\": Omega_rad, \"x\": i_rad, \"z2\": omega_rad, \n             \"extra\": {\"axis\": 'x', \"angle\": np.radians(-25.19)}},\n            {\"name\": \"Mars Y\", \"z1\": Omega_rad, \"x\": i_rad, \"z2\": omega_rad, \n             \"extra\": {\"axis\": 'y', \"angle\": np.radians(35.4)}},\n            {\"name\": \"Mars Z\", \"z1\": Omega_rad, \"x\": i_rad, \"z2\": omega_rad, \n             \"extra\": {\"axis\": 'z', \"angle\": np.radians(49.58)}},\n            {\"name\": \"Y+Z\", \"z1\": Omega_rad, \"x\": i_rad, \"z2\": omega_rad, \n             \"extra\": [{\"axis\": 'y', \"angle\": np.radians(35.4)}, \n                     {\"axis\": 'z', \"angle\": np.radians(49.58)}]},\n            {\"name\": \"Z+X\", \"z1\": Omega_rad, \"x\": i_rad, \"z2\": omega_rad, \n             \"extra\": [{\"axis\": 'z', \"angle\": np.radians(49.58)}, \n                     {\"axis\": 'x', \"angle\": np.radians(25.19)}]},\n        ]\n        \n        # Define line styles for each rotation\n        styles = [\"solid\", \"dash\", \"dot\", \"dashdot\", \"longdash\", \"longdashdot\", \"longdashdotdot\"]\n        \n        # Apply each rotation combination\n        for idx, rot in enumerate(rotations):\n            # Apply standard orbital element rotations\n            x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, rot[\"z1\"], 'z')\n            x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, rot[\"x\"], 'x')\n            x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, rot[\"z2\"], 'z')\n            \n            # Apply extra rotations if specified\n            if rot[\"extra\"]:\n                if isinstance(rot[\"extra\"], list):\n                    # Apply multiple extra rotations\n                    for extra_rot in rot[\"extra\"]:\n                        x_temp, y_temp, z_temp = rotate_points(\n                            x_temp, y_temp, z_temp, \n                            extra_rot[\"angle\"], extra_rot[\"axis\"]\n                        )\n                else:\n                    # Apply single extra rotation\n                    x_temp, y_temp, z_temp = rotate_points(\n                        x_temp, y_temp, z_temp, \n                        rot[\"extra\"][\"angle\"], rot[\"extra\"][\"axis\"]\n                    )\n            \n            # Add trace to figure\n            line_style = styles[idx % len(styles)]\n            \n            fig.add_trace(\n                go.Scatter3d(\n                    x=x_temp,\n                    y=y_temp,\n                    z=z_temp,\n                    mode='lines',\n                    line=dict(dash=line_style, width=1, color=color),\n                    name=f\"{satellite_name} {rot['name']}\",\n                    text=[f\"{satellite_name} {rot['name']} Rotation\"] * len(x_temp),\n                    customdata=[f\"{satellite_name} {rot['name']} Rotation\"] * len(x_temp),\n                    hovertemplate='%{text}<extra></extra>',\n                    showlegend=True\n                )\n            )\n        \n        return fig\n    \n    except Exception as e:\n        print(f\"Error testing Mars rotations for {satellite_name}: {e}\", flush=True)\n        return fig",
    "start_line": 345,
    "end_line": 445,
    "has_docstring": true,
    "docstring": "Test multiple rotation combinations to find the best alignment",
    "parameters": [
      "satellite_name",
      "planetary_params",
      "color",
      "fig"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function test_mars_rotations",
    "component_id": "idealized_orbits.test_mars_rotations"
  },
  "idealized_orbits.test_uranus_equatorial_transformations": {
    "id": "idealized_orbits.test_uranus_equatorial_transformations",
    "name": "test_uranus_equatorial_transformations",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "planet_visualization_utilities.rotate_points"
    ],
    "source_code": "def test_uranus_equatorial_transformations(satellite_name, planetary_params, color, fig=None):\n    \"\"\"Test transformations assuming orbital elements are in Uranus's equatorial plane\"\"\"\n    if fig is None:\n        fig = go.Figure()\n    \n    try:\n        # Get orbital parameters\n        if satellite_name not in planetary_params:\n            print(f\"Error: No orbital parameters found for {satellite_name}\", flush=True)\n            return fig\n            \n        orbital_params = planetary_params[satellite_name]\n        \n        # Extract orbital elements\n        a = orbital_params.get('a', 0)\n        e = orbital_params.get('e', 0)\n        i = orbital_params.get('i', 0)\n        omega = orbital_params.get('omega', 0)\n        Omega = orbital_params.get('Omega', 0)\n        \n        # Generate ellipse in orbital plane\n        theta = np.linspace(0, 2*np.pi, 360)\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        \n        x_orbit = r * np.cos(theta)\n        y_orbit = r * np.sin(theta)\n        z_orbit = np.zeros_like(theta)\n\n        # Convert angles to radians\n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n        \n        # Standard orbital element rotation sequence - this gives us the orbit in Uranus's equatorial plane\n        x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, Omega_rad, 'z')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, omega_rad, 'z')\n        \n        # Now transform from Uranus's equatorial frame to ecliptic frame\n        # Get Uranus's pole orientation\n        uranus_pole = planet_poles['Uranus']\n        ra_pole = np.radians(uranus_pole['ra'])\n        dec_pole = np.radians(uranus_pole['dec'])\n        \n        # Calculate pole vector\n        sin_dec = np.sin(dec_pole)\n        cos_dec = np.cos(dec_pole)\n        sin_ra = np.sin(ra_pole)\n        cos_ra = np.cos(ra_pole)\n        \n        # Pole vector\n        x_pole = cos_dec * cos_ra\n        y_pole = cos_dec * sin_ra\n        z_pole = sin_dec\n        \n        # Normalize the pole vector\n        pole_norm = np.sqrt(x_pole**2 + y_pole**2 + z_pole**2)\n        x_pole /= pole_norm\n        y_pole /= pole_norm\n        z_pole /= pole_norm\n        \n        print(f\"Uranus pole vector: [{x_pole:.4f}, {y_pole:.4f}, {z_pole:.4f}]\", flush=True)\n        \n        # Transform from equatorial to ecliptic\n        # Step 1: First rotation to get the pole's projection onto the XY plane aligned with the X-axis\n        phi = np.arctan2(y_pole, x_pole)\n        x_rot1, y_rot1, z_rot1 = rotate_points(x_temp, y_temp, z_temp, -phi, 'z')  # Note the negative sign\n        \n        # Step 2: Second rotation to align the pole with the Z-axis\n        theta = np.arccos(z_pole)\n        x_rot2, y_rot2, z_rot2 = rotate_points(x_rot1, y_rot1, z_rot1, -theta, 'y')  # Note the negative sign\n        \n        # Step 3: Third rotation to fix the orientation\n        x_final, y_final, z_final = rotate_points(x_rot2, y_rot2, z_rot2, phi, 'z')\n        \n        # Add trace to figure\n        fig.add_trace(\n            go.Scatter3d(\n                x=x_final,\n                y=y_final,\n                z=z_final,\n                mode='lines',\n                line=dict(dash='solid', width=2, color=color),\n                name=f\"{satellite_name} Equatorial Transform\",\n                text=[f\"{satellite_name} Equatorial Transform\"] * len(x_final),\n                customdata=[f\"{satellite_name} Equatorial Transform\"] * len(x_final),\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            )\n        )\n        \n        return fig\n        \n    except Exception as e:\n        print(f\"Error in test_uranus_equatorial_transformations: {e}\", flush=True)\n        traceback.print_exc()\n        return fig",
    "start_line": 447,
    "end_line": 543,
    "has_docstring": true,
    "docstring": "Test transformations assuming orbital elements are in Uranus's equatorial plane",
    "parameters": [
      "satellite_name",
      "planetary_params",
      "color",
      "fig"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function test_uranus_equatorial_transformations",
    "component_id": "idealized_orbits.test_uranus_equatorial_transformations"
  },
  "idealized_orbits.test_uranus_rotation_combinations": {
    "id": "idealized_orbits.test_uranus_rotation_combinations",
    "name": "test_uranus_rotation_combinations",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "planet_visualization_utilities.rotate_points"
    ],
    "source_code": "def test_uranus_rotation_combinations(satellite_name, planetary_params, color, fig=None):\n    \"\"\"Test multiple rotation combinations for Uranus satellites systematically\"\"\"\n    if fig is None:\n        fig = go.Figure()\n    \n    try:\n        # Get orbital parameters\n        if satellite_name not in planetary_params:\n            print(f\"Error: No orbital parameters found for {satellite_name}\", flush=True)\n            return fig\n            \n        orbital_params = planetary_params[satellite_name]\n        \n        # Extract orbital elements\n        a = orbital_params.get('a', 0)\n        e = orbital_params.get('e', 0)\n        i = orbital_params.get('i', 0)\n        omega = orbital_params.get('omega', 0)\n        Omega = orbital_params.get('Omega', 0)\n        \n        # Generate ellipse in orbital plane\n        theta = np.linspace(0, 2*np.pi, 360)\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        \n        x_orbit = r * np.cos(theta)\n        y_orbit = r * np.sin(theta)\n        z_orbit = np.zeros_like(theta)\n\n        # Convert angles to radians\n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n        \n        # Standard orbital element rotation sequence\n        x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, Omega_rad, 'z')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, omega_rad, 'z')\n        \n        # Styles for different combinations\n        styles = [\"solid\", \"dash\", \"dot\", \"dashdot\", \"longdash\", \"longdashdot\"]\n        \n        # Uranus's axial tilt value\n        tilt = planet_tilts['Uranus']  # 97.77 degrees\n        tilt_rad = np.radians(tilt)\n        neg_tilt_rad = np.radians(-tilt)\n        \n        # Test combinations\n        combinations = [\n            {\"name\": \"X+\", \"axis\": 'x', \"angle\": tilt_rad},\n            {\"name\": \"X-\", \"axis\": 'x', \"angle\": neg_tilt_rad},\n            {\"name\": \"Y+\", \"axis\": 'y', \"angle\": tilt_rad},\n            {\"name\": \"Y-\", \"axis\": 'y', \"angle\": neg_tilt_rad},\n            {\"name\": \"Z+\", \"axis\": 'z', \"angle\": tilt_rad},\n            {\"name\": \"Z-\", \"axis\": 'z', \"angle\": neg_tilt_rad},\n            # Try some composite rotations\n            {\"name\": \"X+Y+\", \"rotations\": [\n                {\"axis\": 'x', \"angle\": tilt_rad},\n                {\"axis\": 'y', \"angle\": tilt_rad}\n            ]},\n            {\"name\": \"X+Z+\", \"rotations\": [\n                {\"axis\": 'x', \"angle\": tilt_rad},\n                {\"axis\": 'z', \"angle\": tilt_rad}\n            ]},\n            {\"name\": \"90X\", \"axis\": 'x', \"angle\": np.radians(90)},\n            {\"name\": \"90Y\", \"axis\": 'y', \"angle\": np.radians(90)}\n        ]\n        \n        # Plot each combination\n        for idx, combo in enumerate(combinations):\n            x_rotated, y_rotated, z_rotated = x_temp.copy(), y_temp.copy(), z_temp.copy()\n            \n            if \"rotations\" in combo:\n                # Apply multiple rotations in sequence\n                for rot in combo[\"rotations\"]:\n                    x_rotated, y_rotated, z_rotated = rotate_points(\n                        x_rotated, y_rotated, z_rotated, \n                        rot[\"angle\"], rot[\"axis\"]\n                    )\n            else:\n                # Apply single rotation\n                x_rotated, y_rotated, z_rotated = rotate_points(\n                    x_rotated, y_rotated, z_rotated, \n                    combo[\"angle\"], combo[\"axis\"]\n                )\n            \n            # Add trace to figure\n            style = styles[idx % len(styles)]\n            \n            fig.add_trace(\n                go.Scatter3d(\n                    x=x_rotated,\n                    y=y_rotated,\n                    z=z_rotated,\n                    mode='lines',\n                    line=dict(dash=style, width=1, color=color),\n                    name=f\"{satellite_name} {combo['name']}\",\n                    text=[f\"{satellite_name} {combo['name']}\"] * len(x_rotated),\n                    customdata=[f\"{satellite_name} {combo['name']}\"] * len(x_rotated),\n                    hovertemplate='%{text}<extra></extra>',\n                    showlegend=True\n                )\n            )\n        \n        return fig\n        \n    except Exception as e:\n        print(f\"Error in test_uranus_rotation_combinations: {e}\", flush=True)\n        traceback.print_exc()\n        return fig",
    "start_line": 545,
    "end_line": 653,
    "has_docstring": true,
    "docstring": "Test multiple rotation combinations for Uranus satellites systematically",
    "parameters": [
      "satellite_name",
      "planetary_params",
      "color",
      "fig"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function test_uranus_rotation_combinations",
    "component_id": "idealized_orbits.test_uranus_rotation_combinations"
  },
  "idealized_orbits.debug_planet_transformation": {
    "id": "idealized_orbits.debug_planet_transformation",
    "name": "debug_planet_transformation",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [],
    "source_code": "def debug_planet_transformation(planet_name):\n    \"\"\"Print detailed information about the transformation for a specific planet\"\"\"\n    print(f\"\\n==== DEBUG: {planet_name} Transformation ====\", flush=True)\n    \n    # Get the planet's axial tilt\n    tilt = planet_tilts.get(planet_name, 0)\n    print(f\"Axial tilt: {tilt} degrees\", flush=True)\n    \n    # Simple tilt matrix\n    tilt_rad = np.radians(tilt)\n    simple_matrix = np.array([\n        [1, 0, 0],\n        [0, np.cos(tilt_rad), -np.sin(tilt_rad)],\n        [0, np.sin(tilt_rad), np.cos(tilt_rad)]\n    ])\n    print(\"\\nSimple tilt matrix:\", flush=True)\n    print(simple_matrix, flush=True)\n    \n    # If we have pole data, calculate the complex matrix\n    if planet_name in planet_poles:\n        pole = planet_poles[planet_name]\n        ra_pole = np.radians(pole['ra'])\n        dec_pole = np.radians(pole['dec'])\n        \n        print(f\"\\nPole direction: RA = {pole['ra']} deg, Dec = {pole['dec']} deg\", flush=True)\n        \n        # Calculate pole vector\n        sin_dec = np.sin(dec_pole)\n        cos_dec = np.cos(dec_pole)\n        sin_ra = np.sin(ra_pole)\n        cos_ra = np.cos(ra_pole)\n        \n        x_pole = cos_dec * cos_ra\n        y_pole = cos_dec * sin_ra\n        z_pole = sin_dec\n        \n        print(f\"Pole vector: [{x_pole:.4f}, {y_pole:.4f}, {z_pole:.4f}]\", flush=True)\n        \n        # Calculate node vector\n        node_denom = np.sqrt(x_pole**2 + y_pole**2)\n        if node_denom > 0:\n            x_node = -y_pole / node_denom\n            y_node = x_pole / node_denom\n            z_node = 0\n            \n            print(f\"Node vector: [{x_node:.4f}, {y_node:.4f}, {z_node:.4f}]\", flush=True)\n            \n            # Create basis vectors\n            z_basis = np.array([x_pole, y_pole, z_pole])\n            x_basis = np.array([x_node, y_node, z_node])\n            y_basis = np.cross(z_basis, x_basis)\n            \n            print(f\"X basis: [{x_basis[0]:.4f}, {x_basis[1]:.4f}, {x_basis[2]:.4f}]\", flush=True)\n            print(f\"Y basis: [{y_basis[0]:.4f}, {y_basis[1]:.4f}, {y_basis[2]:.4f}]\", flush=True)\n            print(f\"Z basis: [{z_basis[0]:.4f}, {z_basis[1]:.4f}, {z_basis[2]:.4f}]\", flush=True)\n            \n            # Construct transformation matrix\n            complex_matrix = np.vstack((x_basis, y_basis, z_basis)).T\n            print(\"\\nComplex transformation matrix:\", flush=True)\n            print(complex_matrix, flush=True)\n            \n            # Calculate the angle between simple and complex transformations\n            # by comparing the transformed z-axis\n            z_axis = np.array([0, 0, 1])\n            simple_z = np.dot(simple_matrix, z_axis)\n            complex_z = np.dot(complex_matrix, z_axis)\n            \n            dot_product = np.dot(simple_z, complex_z)\n            angle = np.arccos(min(1, max(-1, dot_product))) * 180 / np.pi\n            \n            print(f\"\\nAngle between simple and complex transformations: {angle:.2f} deg\", flush=True)\n        else:\n            print(\"Cannot calculate node vector (pole is directly aligned with Z-axis)\", flush=True)",
    "start_line": 655,
    "end_line": 727,
    "has_docstring": true,
    "docstring": "Print detailed information about the transformation for a specific planet",
    "parameters": [
      "planet_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function debug_planet_transformation",
    "component_id": "idealized_orbits.debug_planet_transformation"
  },
  "idealized_orbits.debug_mars_moons": {
    "id": "idealized_orbits.debug_mars_moons",
    "name": "debug_mars_moons",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "idealized_orbits.debug_planet_transformation"
    ],
    "source_code": "def debug_mars_moons(satellites_data, parent_planets):          # test function only\n    \"\"\"Special debug function for Mars and its moons\"\"\"\n    print(\"\\n==== MARS SYSTEM DEBUG ====\", flush=True)\n    \n    # Print Mars' axial tilt and pole direction\n    debug_planet_transformation('Mars')\n    \n    # Print orbital elements for Mars' moons\n    mars_moons = parent_planets.get('Mars', [])\n    for moon in mars_moons:\n        if moon in satellites_data:\n            params = satellites_data[moon]\n            print(f\"\\n{moon} orbital elements:\", flush=True)\n            for key, value in params.items():\n                print(f\"  {key}: {value}\")\n    \n    # Test if the moons' inclinations are relative to:\n    # 1. Mars' equator\n    # 2. Mars' orbital plane\n    # 3. The ecliptic\n    print(\"\\nInclination references analysis:\", flush=True)\n    \n    # Mars' axial tilt to the ecliptic\n    mars_tilt = np.radians(planet_tilts['Mars'])\n    \n    for moon in mars_moons:\n        if moon in satellites_data:\n            params = satellites_data[moon]\n            i = params.get('i', 0)\n            i_rad = np.radians(i)\n            \n            # If inclination is relative to Mars' equator,\n            # then the true inclination to the ecliptic would be:\n            i_to_ecliptic = np.arccos(np.cos(i_rad) * np.cos(mars_tilt) - \n                                       np.sin(i_rad) * np.sin(mars_tilt)) * 180/np.pi\n            \n            # If inclination is relative to the ecliptic,\n            # then the true inclination to Mars' equator would be:\n            i_to_equator = np.arccos(np.cos(i_rad) * np.cos(mars_tilt) + \n                                      np.sin(i_rad) * np.sin(mars_tilt)) * 180/np.pi\n            \n            print(f\"\\n{moon}:\", flush=True)\n            print(f\"  Stated inclination: {i} deg\", flush=True)\n            print(f\"  If relative to Mars' equator, inclination to ecliptic would be ~{i_to_ecliptic:.2f} deg\", flush=True)\n            print(f\"  If relative to ecliptic, inclination to Mars' equator would be ~{i_to_equator:.2f} deg\", flush=True)",
    "start_line": 729,
    "end_line": 773,
    "has_docstring": true,
    "docstring": "Special debug function for Mars and its moons",
    "parameters": [
      "satellites_data",
      "parent_planets"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function debug_mars_moons",
    "component_id": "idealized_orbits.debug_mars_moons"
  },
  "idealized_orbits.compare_transformation_methods": {
    "id": "idealized_orbits.compare_transformation_methods",
    "name": "compare_transformation_methods",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "idealized_orbits.plot_satellite_orbit",
      "constants_new.color_map"
    ],
    "source_code": "def compare_transformation_methods(fig, satellites_data, parent_planets):       # test function only\n    \"\"\"Plot orbits with different transformation methods for comparison\"\"\"\n    \n    # Plot Mars moons with all transformation methods\n    for moon in parent_planets.get('Mars', []):\n        if moon in satellites_data:\n            for method in [\"none\", \"simple\", \"complex\"]:\n                plot_satellite_orbit(\n                    moon, \n                    satellites_data[moon],\n                    'Mars',\n                    color_map('Mars'),  # Call the function with planet name\n                    fig,\n                    debug=True,\n                    transform_method=method\n                )\n    \n    # Plot Jupiter moons with all transformation methods\n    for moon in ['Io', 'Europa', 'Ganymede', 'Callisto']:  # Just the main moons\n        if moon in satellites_data:\n            for method in [\"none\", \"simple\", \"complex\"]:\n                plot_satellite_orbit(\n                    moon, \n                    satellites_data[moon],\n                    'Jupiter',\n                    color_map('Jupiter'),  # Changed brackets [] to parentheses ()\n                    fig,\n                    debug=True,\n                    transform_method=method\n                )\n    \n    return fig",
    "start_line": 775,
    "end_line": 806,
    "has_docstring": true,
    "docstring": "Plot orbits with different transformation methods for comparison",
    "parameters": [
      "fig",
      "satellites_data",
      "parent_planets"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function compare_transformation_methods",
    "component_id": "idealized_orbits.compare_transformation_methods"
  },
  "idealized_orbits.test_mars_negative_tilt": {
    "id": "idealized_orbits.test_mars_negative_tilt",
    "name": "test_mars_negative_tilt",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "planet_visualization_utilities.rotate_points"
    ],
    "source_code": "def test_mars_negative_tilt(fig, satellites_data):          # test function only\n    \"\"\"Test hypothesis that Mars needs a negative tilt application\"\"\"\n    \n    # Mars moons\n    for moon in ['Phobos', 'Deimos']:\n        if moon in satellites_data:\n            # Extract orbital elements\n            params = satellites_data[moon]\n            a = params.get('a', 0)\n            e = params.get('e', 0)\n            i = params.get('i', 0)\n            omega = params.get('omega', 0)\n            Omega = params.get('Omega', 0)\n            \n            # Standard orbital transformation\n            theta = np.linspace(0, 2*np.pi, 360)\n            r = a * (1 - e**2) / (1 + e * np.cos(theta))\n            \n            x_orbit = r * np.cos(theta)\n            y_orbit = r * np.sin(theta)\n            z_orbit = np.zeros_like(theta)\n            \n            i_rad = np.radians(i)\n            omega_rad = np.radians(omega)\n            Omega_rad = np.radians(Omega)\n            \n            # Standard rotation sequence\n            x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, Omega_rad, 'z')\n            x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n            x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, omega_rad, 'z')\n            \n            # Try NEGATIVE tilt for Mars\n            tilt_rad = np.radians(-planet_tilts['Mars'])\n            x_final, y_final, z_final = rotate_points(x_temp, y_temp, z_temp, tilt_rad, 'x')\n            \n            # Add to figure\n            fig.add_trace(\n                go.Scatter3d(\n                    x=x_final,\n                    y=y_final,\n                    z=z_final,\n                    mode='lines',\n                    line=dict(dash='solid', width=2, color='purple'),\n                    name=f\"{moon} (Negative Tilt Test)\",\n                    text=[f\"{moon} with negative tilt test\"] * len(x_final),\n                    hovertemplate='%{text}<extra></extra>',\n                    showlegend=True\n                )\n            )\n    \n    return fig",
    "start_line": 808,
    "end_line": 858,
    "has_docstring": true,
    "docstring": "Test hypothesis that Mars needs a negative tilt application",
    "parameters": [
      "fig",
      "satellites_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function test_mars_negative_tilt",
    "component_id": "idealized_orbits.test_mars_negative_tilt"
  },
  "idealized_orbits.debug_satellite_systems": {
    "id": "idealized_orbits.debug_satellite_systems",
    "name": "debug_satellite_systems",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "idealized_orbits.debug_planet_transformation",
      "idealized_orbits.compare_transformation_methods",
      "idealized_orbits.test_mars_negative_tilt",
      "idealized_orbits.debug_mars_moons"
    ],
    "source_code": "def debug_satellite_systems():\n    fig = go.Figure()\n    \n    # Print transformation matrices\n    debug_planet_transformation('Mars')\n    debug_planet_transformation('Jupiter')\n    \n    # Special debug for Mars\n    debug_mars_moons(planetary_params, parent_planets)\n    \n    # Compare transformation methods\n    fig = compare_transformation_methods(fig, planetary_params, parent_planets)\n    \n    # Test negative tilt for Mars\n    fig = test_mars_negative_tilt(fig, planetary_params)\n    \n    # Configure the layout\n    fig.update_layout(\n        title=\"Satellite System Transformation Debug\",\n        scene=dict(\n            aspectmode='data'\n        )\n    )\n    \n    fig.show()",
    "start_line": 860,
    "end_line": 884,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function debug_satellite_systems",
    "component_id": "idealized_orbits.debug_satellite_systems"
  },
  "idealized_orbits.rotate_points": {
    "id": "idealized_orbits.rotate_points",
    "name": "rotate_points",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [],
    "source_code": "def rotate_points(x, y, z, angle, axis='z'):\n    \"\"\"\n    Rotates points (x,y,z) about the given axis by 'angle' radians.\n    Returns (xr, yr, zr) as numpy arrays.\n    \n    Parameters:\n        x (array-like): x coordinates\n        y (array-like): y coordinates\n        z (array-like): z coordinates\n        angle (float): rotation angle in radians\n        axis (str): axis of rotation ('x', 'y', or 'z')\n        \n    Returns:\n        tuple: (xr, yr, zr) rotated coordinates\n    \"\"\"\n    # Convert inputs to numpy arrays if they aren't already\n    x = np.array(x, copy=True)\n    y = np.array(y, copy=True)\n    z = np.array(z, copy=True)\n\n    # Initialize rotated coordinates\n    xr = x.copy()\n    yr = y.copy()\n    zr = z.copy()\n\n    # Perform rotation based on specified axis\n    if axis == 'z':\n        # Rotate about z-axis\n        xr = x * np.cos(angle) - y * np.sin(angle)\n        yr = x * np.sin(angle) + y * np.cos(angle)\n        # zr remains the same\n    elif axis == 'x':\n        # Rotate about x-axis\n        yr = y * np.cos(angle) - z * np.sin(angle)\n        zr = y * np.sin(angle) + z * np.cos(angle)\n        # xr remains the same\n    elif axis == 'y':\n        # Rotate about y-axis\n        zr = z * np.cos(angle) - x * np.sin(angle)\n        xr = z * np.sin(angle) + x * np.cos(angle)\n        # yr remains the same\n    else:\n        raise ValueError(f\"Unknown rotation axis: {axis}. Use 'x', 'y', or 'z'.\")\n\n    return xr, yr, zr",
    "start_line": 886,
    "end_line": 930,
    "has_docstring": true,
    "docstring": "Rotates points (x,y,z) about the given axis by 'angle' radians.\nReturns (xr, yr, zr) as numpy arrays.\n\nParameters:\n    x (array-like): x coordinates\n    y (array-like): y coordinates\n    z (array-like): z coordinates\n    angle (float): rotation angle in radians\n    axis (str): axis of rotation ('x', 'y', or 'z')\n    \nReturns:\n    tuple: (xr, yr, zr) rotated coordinates",
    "parameters": [
      "x",
      "y",
      "z",
      "angle",
      "axis"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function rotate_points",
    "component_id": "idealized_orbits.rotate_points"
  },
  "idealized_orbits.plot_jupiter_moon_osculating_orbit": {
    "id": "idealized_orbits.plot_jupiter_moon_osculating_orbit",
    "name": "plot_jupiter_moon_osculating_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "idealized_orbits.rotate_points",
      "osculating_cache_manager.load_cache"
    ],
    "source_code": "def plot_jupiter_moon_osculating_orbit(fig, satellite_name, date, color, show_apsidal_markers=False):\n    \"\"\"\n    Plot osculating orbit for Jupiter satellites.\n    \n    CRITICAL: Jupiter moon osculating elements are in ECLIPTIC frame (J2000.0)\n    This is DIFFERENT from analytical elements which are in Jupiter equatorial frame.\n    \n    Pattern follows Mars moons:\n    - Analytical: Parent equatorial [OK] ecliptic (needs rotation)\n    - Osculating: Already in ecliptic (NO rotation!)\n    \n    Special case: Thebe shows anomalous behavior (i_osc ~ i_analytical)\n    \n    Parameters:\n        fig: Plotly figure to add trace to\n        satellite_name: Name of Jupiter moon ('Io', 'Europa', etc.)\n        date: Date for osculating elements\n        color: Orbit color\n        show_apsidal_markers: Whether to show apsides (not implemented yet)\n        \n    Returns:\n        Updated figure with osculating orbit trace\n    \"\"\"\n    # Jupiter moon Horizons IDs\n    JUPITER_MOON_IDS = {\n        'Metis': '516',\n        'Adrastea': '515',\n        'Amalthea': '505',\n        'Thebe': '514',\n        'Io': '501',\n        'Europa': '502',\n        'Ganymede': '503',\n        'Callisto': '504'\n    }\n    \n    horizons_id = JUPITER_MOON_IDS.get(satellite_name)\n    if not horizons_id:\n        print(f\"Warning: No Horizons ID for {satellite_name}\", flush=True)\n        return fig\n    \n    try:\n        # Load from cache (pre-fetch already prompted user, so just use cache)\n        # This matches Mars moons pattern - don't fetch again!\n        from osculating_cache_manager import load_cache\n        \n        print(f\"\\n[OSCULATING] Loading cached elements for {satellite_name}...\", flush=True)\n        \n        cache = load_cache()\n        \n        # Check if we have cached elements\n        if satellite_name in cache:\n            elements = cache[satellite_name]['elements']\n            epoch = elements.get('epoch', f\"{date.strftime('%Y-%m-%d')}\")\n            print(f\"  [OK] Using cached osculating elements (epoch: {epoch})\", flush=True)\n        elif satellite_name in planetary_params:\n            # Fallback to hardcoded analytical elements\n            elements = planetary_params[satellite_name]\n            epoch = 'analytical'\n            print(f\"  [WARN] Using fallback analytical elements from planetary_params\", flush=True)\n        else:\n            print(f\"  [WARN] No elements available for {satellite_name}, skipping orbit plot\", flush=True)\n            return fig\n\n        # Extract elements\n        a = elements.get('a', 0)  # AU\n        e = elements.get('e', 0)\n        i = elements.get('i', 0)  # degrees - ECLIPTIC FRAME!\n        omega = elements.get('omega', 0)  # degrees\n        Omega = elements.get('Omega', 0)  # degrees\n        epoch = elements.get('epoch', 'unknown')\n       \n        print(f\"\\nPlotting osculating orbit for {satellite_name}\", flush=True)\n        print(f\"  Inclination: {i:.4f} deg (ecliptic frame)\", flush=True)\n        print(f\"  Epoch: {epoch}\", flush=True)\n        \n        # Generate orbit points\n        theta = np.linspace(0, 2*np.pi, 360)\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        \n        x_orbit = r * np.cos(theta)\n        y_orbit = r * np.sin(theta)\n        z_orbit = np.zeros_like(theta)\n        \n        # Convert to radians\n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n        \n        # CRITICAL: Osculating elements rotation sequence\n        # Different from analytical! (omega, i, Omega vs Omega, i, omega)\n        # This is the \"inside-out\" sequence\n        \n        # 1. Argument of periapsis (omega) around z-axis\n        x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, omega_rad, 'z')\n        \n        # 2. Inclination (i) around x-axis\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n        \n        # 3. Longitude of ascending node (Omega) around z-axis\n        x_final, y_final, z_final = rotate_points(x_temp, y_temp, z_temp, Omega_rad, 'z')\n        \n        # CRITICAL: NO Jupiter rotation!\n        # Osculating elements already in ecliptic frame\n        # (Except possibly Thebe - see special handling below)\n        \n        # Special case for Thebe (anomalous behavior)\n        if satellite_name == 'Thebe':\n            # Thebe's osculating i ~ 1.18 deg suggests Jupiter equatorial frame\n            # Apply Jupiter rotation like analytical orbit\n            jupiter_tilt = np.radians(3.13)\n            # x_final, y_final, z_final = rotate_points(x_final, y_final, z_final, jupiter_tilt, 'y')\n            # Commented out for now - test both ways\n            print(f\"  Note: Thebe shows anomalous reference frame behavior\", flush=True)\n        \n        # Create educational hover text\n        osculating_note = (\n            \"<br><br><i>Osculating orbit uses instantaneous elements<br>\"\n            \"from JPL Horizons at specific epoch.<br>\"\n            \"Shows exact orbital state at epoch time.<br>\"\n            \"<br>Incorporates all physical effects:<br>\"\n            \"* Jupiter equatorial bulge gravitational field (largest effect)<br>\"\n            \"* Solar perturbations<br>\"\n            \"* Other Galilean moon perturbations<br>\"\n            \"* Tidal effects<br>\"\n            \"<br>Reference frame: Ecliptic J2000.0<br>\"\n            \"No Jupiter rotation applied</i>\"\n        )\n        \n        hover_text_osc = (\n            f\"<b>{satellite_name} Osculating Orbit</b><br>\"\n            f\"JPL Horizons snapshot<br>\"\n            f\"Epoch: {epoch}<br>\"\n            f\"a={a:.6f} AU<br>\"\n            f\"e={e:.6f}<br>\"\n            f\"i={i:.4f} deg (ecliptic)\"\n            f\"{osculating_note}\"\n        )\n        \n        # Add dashed line to plot\n        fig.add_trace(go.Scatter3d(\n            x=x_final,\n            y=y_final,\n            z=z_final,\n            mode='lines',\n            line=dict(color=color, width=2, dash='dash'),\n            name=f'{satellite_name} Osculating Orbit (Epoch: {epoch})',\n            text=[hover_text_osc] * len(x_final),\n            customdata=[hover_text_osc] * len(x_final),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ))\n        \n        print(f\"  [OK] Osculating orbit plotted (ecliptic frame, no Jupiter rotation)\", flush=True)\n        \n        return fig\n        \n    except Exception as e:\n        print(f\"Error plotting osculating orbit for {satellite_name}: {e}\", flush=True)\n        import traceback\n        traceback.print_exc()\n        return fig",
    "start_line": 932,
    "end_line": 1092,
    "has_docstring": true,
    "docstring": "Plot osculating orbit for Jupiter satellites.\n\nCRITICAL: Jupiter moon osculating elements are in ECLIPTIC frame (J2000.0)\nThis is DIFFERENT from analytical elements which are in Jupiter equatorial frame.\n\nPattern follows Mars moons:\n- Analytical: Parent equatorial [OK] ecliptic (needs rotation)\n- Osculating: Already in ecliptic (NO rotation!)\n\nSpecial case: Thebe shows anomalous behavior (i_osc ~ i_analytical)\n\nParameters:\n    fig: Plotly figure to add trace to\n    satellite_name: Name of Jupiter moon ('Io', 'Europa', etc.)\n    date: Date for osculating elements\n    color: Orbit color\n    show_apsidal_markers: Whether to show apsides (not implemented yet)\n    \nReturns:\n    Updated figure with osculating orbit trace",
    "parameters": [
      "fig",
      "satellite_name",
      "date",
      "color",
      "show_apsidal_markers"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_jupiter_moon_osculating_orbit",
    "component_id": "idealized_orbits.plot_jupiter_moon_osculating_orbit"
  },
  "idealized_orbits.plot_saturn_moon_osculating_orbit": {
    "id": "idealized_orbits.plot_saturn_moon_osculating_orbit",
    "name": "plot_saturn_moon_osculating_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "idealized_orbits.rotate_points",
      "osculating_cache_manager.load_cache"
    ],
    "source_code": "def plot_saturn_moon_osculating_orbit(fig, satellite_name, date, color, show_apsidal_markers=False):\n    \"\"\"\n    Plot osculating orbit for Saturn satellites.\n    \n    CRITICAL: Saturn moon osculating elements are in ECLIPTIC frame (J2000.0)\n    This is DIFFERENT from analytical elements which are in Saturn equatorial frame.\n    NO Saturn rotation applied to osculating orbits!\n    \"\"\"\n    \n    SATURN_MOON_IDS = {\n        'Pan': '618',\n        'Daphnis': '635',\n        'Prometheus': '616',\n        'Pandora': '617',\n        'Mimas': '601',\n        'Enceladus': '602',\n        'Tethys': '603',\n        'Dione': '604',\n        'Rhea': '605',\n        'Titan': '606',\n        'Hyperion': '607',\n        'Iapetus': '608',\n        'Phoebe': '609'  # Retrograde irregular - has special Laplace plane transformation\n    }\n\n    horizons_id = SATURN_MOON_IDS.get(satellite_name)\n    if not horizons_id:\n        print(f\"Warning: No Horizons ID for {satellite_name}\", flush=True)\n        return fig\n    \n    try:\n        from osculating_cache_manager import load_cache\n        \n        print(f\"\\n[OSCULATING] Loading cached elements for {satellite_name}...\", flush=True)\n        cache = load_cache()\n        \n        if satellite_name in cache:\n            elements = cache[satellite_name]['elements']\n            print(f\"  [OK] Using cached osculating elements\", flush=True)\n        elif satellite_name == 'Daphnis':\n            # Daphnis special case - no ephemeris after 2018-01-17\n            print(f\"  [WARN] Daphnis: JPL ephemeris ends 2018-01-17 (Cassini mission end)\", flush=True)\n            print(f\"  [WARN] No current osculating elements available\", flush=True)\n            \n            # Add informational marker at approximate Keeler Gap location\n            daphnis_a = 0.0009124  # Approximate semi-major axis in AU\n            \n            # Create informational hover text\n            daphnis_info = (\n                f\"<b>Daphnis (S/2005 S1)</b><br>\"\n                f\"Keeler Gap moon - ~8 km diameter<br>\"\n                f\"a ~ 136,500 km (0.000912 AU)<br>\"\n                f\"Period: ~0.594 days<br>\"\n                f\"<br><i>[WARN] JPL ephemeris limited to 2018-01-17<br>\"\n                f\"(Cassini mission end). Current orbital<br>\"\n                f\"elements unavailable. Discovered 2005.</i>\"\n            )\n            \n            # Add a single point marker at approximate location (not a full orbit)\n            # This is informational only - shows where Daphnis should be\n            fig.add_trace(go.Scatter3d(\n                x=[daphnis_a], y=[0], z=[0],\n                mode='markers',\n                marker=dict(size=4, color=color, symbol='x'),\n                name=f'Daphnis (no current ephemeris)',\n                text=[daphnis_info],\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            ))\n            print(f\"  [OK] Added Daphnis informational marker\", flush=True)\n            return fig\n        else:\n            print(f\"  Warning: No osculating elements in cache for {satellite_name}\", flush=True)\n            return fig\n        \n        a = elements.get('a', 0)\n        e = elements.get('e', 0)\n        i = elements.get('i', 0)\n        omega = elements.get('omega', 0)\n        Omega = elements.get('Omega', 0)\n        epoch = elements.get('epoch', 'unknown')\n       \n        print(f\"  Plotting osculating: i={i:.4f} deg (ecliptic), epoch={epoch}\", flush=True)\n        \n        theta = np.linspace(0, 2*np.pi, 360)\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        \n        x_orbit = r * np.cos(theta)\n        y_orbit = r * np.sin(theta)\n        z_orbit = np.zeros_like(theta)\n        \n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n        \n        # Rotation sequence: omega, i, Omega (inside-out for osculating)\n        x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, omega_rad, 'z')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n        x_final, y_final, z_final = rotate_points(x_temp, y_temp, z_temp, Omega_rad, 'z')\n        \n        # NO Saturn rotation - osculating already in ecliptic!\n        # (Saturn analytical orbits not shown due to reference frame complexity)        \n        if satellite_name == 'Phoebe':\n            hover_text_osc = (\n                f\"<b>{satellite_name} Osculating Orbit</b><br>\"\n                f\"Epoch: {epoch}<br>\"\n                f\"a={a:.6f} AU, e={e:.6f}<br>\"\n                f\"i={i:.4f} deg (retrograde, J2000 ecliptic)<br>\"\n                f\"omega={omega:.2f} deg, Omega={Omega:.2f} deg<br>\"\n                f\"<br><i>Phoebe: Irregular retrograde satellite<br>\"\n                f\"Period: ~550 days | Discovered: 1899<br>\"\n                f\"Osculating elements from JPL Horizons.</i>\"\n            )\n        else:\n            hover_text_osc = (\n                f\"<b>{satellite_name} Osculating Orbit</b><br>\"\n                f\"Epoch: {epoch}<br>\"\n                f\"a={a:.6f} AU, e={e:.6f}<br>\"\n                f\"i={i:.4f} deg (J2000 ecliptic)<br>\"\n                f\"omega={omega:.2f} deg, Omega={Omega:.2f} deg<br>\"\n                f\"<br><i>Osculating = instantaneous Keplerian fit<br>\"\n                f\"from JPL Horizons orbital elements.<br>\"\n                f\"Saturn analytical orbits not shown due to<br>\"\n                f\"reference frame complexity (pole RA=40.58 deg).</i>\"\n            )\n\n        fig.add_trace(go.Scatter3d(\n            x=x_final, y=y_final, z=z_final,\n            mode='lines',\n            line=dict(color=color, width=2, dash='dash'),\n            name=f'{satellite_name} Osculating Orbit (Epoch: {epoch})',\n            text=[hover_text_osc] * len(x_final),\n            customdata=[hover_text_osc] * len(x_final),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ))\n        \n        print(f\"  [OK] Osculating orbit plotted (ecliptic frame)\", flush=True)\n        return fig\n        \n    except Exception as e:\n        print(f\"Error plotting osculating orbit for {satellite_name}: {e}\", flush=True)\n        import traceback\n        traceback.print_exc()\n        return fig",
    "start_line": 1095,
    "end_line": 1239,
    "has_docstring": true,
    "docstring": "Plot osculating orbit for Saturn satellites.\n\nCRITICAL: Saturn moon osculating elements are in ECLIPTIC frame (J2000.0)\nThis is DIFFERENT from analytical elements which are in Saturn equatorial frame.\nNO Saturn rotation applied to osculating orbits!",
    "parameters": [
      "fig",
      "satellite_name",
      "date",
      "color",
      "show_apsidal_markers"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_saturn_moon_osculating_orbit",
    "component_id": "idealized_orbits.plot_saturn_moon_osculating_orbit"
  },
  "idealized_orbits.plot_uranus_moon_osculating_orbit": {
    "id": "idealized_orbits.plot_uranus_moon_osculating_orbit",
    "name": "plot_uranus_moon_osculating_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "idealized_orbits.rotate_points",
      "osculating_cache_manager.load_cache"
    ],
    "source_code": "def plot_uranus_moon_osculating_orbit(fig, satellite_name, date, color, show_apsidal_markers=False):\n    \"\"\"\n    Plot osculating orbit for Uranus satellites.\n    \n    CRITICAL: Uranus moon osculating elements are in ECLIPTIC frame (J2000.0)\n    No planet-specific rotation needed - standard Keplerian sequence only.\n    \n    Uranus's extreme axial tilt (97.77 deg) and pole RA (257.31 deg) make analytical\n    reference frame transformations extremely complex. Osculating elements from\n    JPL Horizons are already in ecliptic frame and provide excellent alignment.\n    \n    Following Saturn pattern: osculating-only approach.\n    \"\"\"\n    \n    URANUS_MOON_IDS = {\n        'Miranda': '705',\n        'Ariel': '701',\n        'Umbriel': '702',\n        'Titania': '703',\n        'Oberon': '704',\n        'Portia': '712',\n        'Mab': '726'\n    }\n\n    horizons_id = URANUS_MOON_IDS.get(satellite_name)\n    if not horizons_id:\n        print(f\"Warning: No Horizons ID for {satellite_name}\", flush=True)\n        return fig\n    \n    try:\n        from osculating_cache_manager import load_cache\n        \n        print(f\"\\n[OSCULATING] Loading cached elements for {satellite_name}...\", flush=True)\n        cache = load_cache()\n        \n        if satellite_name in cache:\n            elements = cache[satellite_name]['elements']\n            print(f\"  [OK] Using cached osculating elements\", flush=True)\n        else:\n            print(f\"  Warning: No osculating elements in cache for {satellite_name}\", flush=True)\n            print(f\"  Hint: Use osculating cache manager to fetch from JPL Horizons (ID: {horizons_id})\", flush=True)\n            return fig\n        \n        a = elements.get('a', 0)\n        e = elements.get('e', 0)\n        i = elements.get('i', 0)\n        omega = elements.get('omega', 0)\n        Omega = elements.get('Omega', 0)\n        epoch = elements.get('epoch', 'unknown')\n       \n        print(f\"  Plotting osculating: i={i:.4f} deg (ecliptic), epoch={epoch}\", flush=True)\n        \n        theta = np.linspace(0, 2*np.pi, 360)\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        \n        x_orbit = r * np.cos(theta)\n        y_orbit = r * np.sin(theta)\n        z_orbit = np.zeros_like(theta)\n        \n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n        \n        # Standard Keplerian rotation sequence: omega, i, Omega\n        x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, omega_rad, 'z')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n        x_final, y_final, z_final = rotate_points(x_temp, y_temp, z_temp, Omega_rad, 'z')\n        \n        # NO Uranus rotation - osculating already in ecliptic!\n        # (Uranus analytical orbits not shown due to extreme 98 deg tilt complexity)\n        \n        hover_text_osc = (\n            f\"<b>{satellite_name} Osculating Orbit</b><br>\"\n            f\"Epoch: {epoch}<br>\"\n            f\"a={a:.6f} AU, e={e:.6f}<br>\"\n            f\"i={i:.4f} deg (J2000 ecliptic)<br>\"\n            f\"omega={omega:.2f} deg, Omega={Omega:.2f} deg<br>\"\n            f\"<br><i>Osculating = instantaneous Keplerian fit<br>\"\n            f\"from JPL Horizons orbital elements.<br>\"\n            f\"Uranus analytical orbits not shown due to<br>\"\n            f\"extreme axial tilt (97.77 deg) complexity.</i>\"\n        )\n\n        fig.add_trace(go.Scatter3d(\n            x=x_final, y=y_final, z=z_final,\n            mode='lines',\n            line=dict(color=color, width=2, dash='dash'),\n            name=f'{satellite_name} Osculating Orbit (Epoch: {epoch})',\n            text=[hover_text_osc] * len(x_final),\n            customdata=[hover_text_osc] * len(x_final),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ))\n        \n        print(f\"  [OK] Osculating orbit plotted (ecliptic frame)\", flush=True)\n        return fig\n        \n    except Exception as e:\n        print(f\"Error plotting osculating orbit for {satellite_name}: {e}\", flush=True)\n        import traceback\n        traceback.print_exc()\n        return fig",
    "start_line": 1241,
    "end_line": 1342,
    "has_docstring": true,
    "docstring": "Plot osculating orbit for Uranus satellites.\n\nCRITICAL: Uranus moon osculating elements are in ECLIPTIC frame (J2000.0)\nNo planet-specific rotation needed - standard Keplerian sequence only.\n\nUranus's extreme axial tilt (97.77 deg) and pole RA (257.31 deg) make analytical\nreference frame transformations extremely complex. Osculating elements from\nJPL Horizons are already in ecliptic frame and provide excellent alignment.\n\nFollowing Saturn pattern: osculating-only approach.",
    "parameters": [
      "fig",
      "satellite_name",
      "date",
      "color",
      "show_apsidal_markers"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_uranus_moon_osculating_orbit",
    "component_id": "idealized_orbits.plot_uranus_moon_osculating_orbit"
  },
  "idealized_orbits.plot_neptune_moon_osculating_orbit": {
    "id": "idealized_orbits.plot_neptune_moon_osculating_orbit",
    "name": "plot_neptune_moon_osculating_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "idealized_orbits.rotate_points",
      "osculating_cache_manager.load_cache"
    ],
    "source_code": "def plot_neptune_moon_osculating_orbit(fig, satellite_name, date, color, show_apsidal_markers=False):\n    \"\"\"\n    Plot osculating orbit for Neptune satellites.\n    \n    CRITICAL: Neptune moon osculating elements are in ECLIPTIC frame (J2000.0)\n    No planet-specific rotation needed - standard Keplerian sequence only.\n    \n    Neptune's pole RA (299.36 deg) is ~29 deg from ecliptic pole, and Triton's retrograde\n    orbit makes analytical transformations complex. Osculating elements from JPL\n    Horizons are already in ecliptic frame and handle retrograde orbits automatically.\n    \n    Following Saturn/Uranus pattern: osculating-only approach.\n    \n    Special moons:\n    - Triton: Retrograde (i~157 deg) - largest, doomed to break up in ~3.6 billion years\n    - Nereid: Highly eccentric (e~0.75) - captured object\n    \"\"\"\n    \n    NEPTUNE_MOON_IDS = {\n        'Triton': '801',\n        'Nereid': '802',\n        'Naiad': '803',\n        'Thalassa': '804',\n        'Despina': '805',\n        'Galatea': '806',\n        'Larissa': '807',\n        'Proteus': '808'\n    }\n\n    horizons_id = NEPTUNE_MOON_IDS.get(satellite_name)\n    if not horizons_id:\n        print(f\"Warning: No Horizons ID for {satellite_name}\", flush=True)\n        return fig\n    \n    try:\n        from osculating_cache_manager import load_cache\n        \n        print(f\"\\n[OSCULATING] Loading cached elements for {satellite_name}...\", flush=True)\n        cache = load_cache()\n        \n        if satellite_name in cache:\n            elements = cache[satellite_name]['elements']\n            print(f\"  [OK] Using cached osculating elements\", flush=True)\n        else:\n            print(f\"  Warning: No osculating elements in cache for {satellite_name}\", flush=True)\n            print(f\"  Hint: Use osculating cache manager to fetch from JPL Horizons (ID: {horizons_id})\", flush=True)\n            return fig\n        \n        a = elements.get('a', 0)\n        e = elements.get('e', 0)\n        i = elements.get('i', 0)\n        omega = elements.get('omega', 0)\n        Omega = elements.get('Omega', 0)\n        epoch = elements.get('epoch', 'unknown')\n       \n        print(f\"  Plotting osculating: i={i:.4f} deg (ecliptic), epoch={epoch}\", flush=True)\n        \n        theta = np.linspace(0, 2*np.pi, 360)\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        \n        x_orbit = r * np.cos(theta)\n        y_orbit = r * np.sin(theta)\n        z_orbit = np.zeros_like(theta)\n        \n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n        \n        # Standard Keplerian rotation sequence: omega, i, Omega\n        # Retrograde orbits (i > 90 deg) handled automatically\n        x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, omega_rad, 'z')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n        x_final, y_final, z_final = rotate_points(x_temp, y_temp, z_temp, Omega_rad, 'z')\n        \n        # NO Neptune rotation - osculating already in ecliptic!\n        \n        # Special hover text for Triton and Nereid\n        if satellite_name == 'Triton':\n            hover_text_osc = (\n                f\"<b>{satellite_name} Osculating Orbit</b><br>\"\n                f\"Epoch: {epoch}<br>\"\n                f\"a={a:.6f} AU, e={e:.6f}<br>\"\n                f\"i={i:.4f} deg (retrograde, J2000 ecliptic)<br>\"\n                f\"omega={omega:.2f} deg, Omega={Omega:.2f} deg<br>\"\n                f\"<br><i>Triton: Neptune's largest moon<br>\"\n                f\"Retrograde orbit - likely captured Kuiper Belt object<br>\"\n                f\"Spiraling inward, will break up in ~3.6 billion years<br>\"\n                f\"(Like Phobos around Mars!)</i>\"\n            )\n        elif satellite_name == 'Nereid':\n            hover_text_osc = (\n                f\"<b>{satellite_name} Osculating Orbit</b><br>\"\n                f\"Epoch: {epoch}<br>\"\n                f\"a={a:.6f} AU, e={e:.6f}<br>\"\n                f\"i={i:.4f} deg (J2000 ecliptic)<br>\"\n                f\"omega={omega:.2f} deg, Omega={Omega:.2f} deg<br>\"\n                f\"<br><i>Nereid: Highly eccentric orbit (e~0.75)<br>\"\n                f\"Most eccentric known moon in solar system<br>\"\n                f\"Likely perturbed by Triton's capture</i>\"\n            )\n        else:\n            hover_text_osc = (\n                f\"<b>{satellite_name} Osculating Orbit</b><br>\"\n                f\"Epoch: {epoch}<br>\"\n                f\"a={a:.6f} AU, e={e:.6f}<br>\"\n                f\"i={i:.4f} deg (J2000 ecliptic)<br>\"\n                f\"omega={omega:.2f} deg, Omega={Omega:.2f} deg<br>\"\n                f\"<br><i>Osculating = instantaneous Keplerian fit<br>\"\n                f\"from JPL Horizons orbital elements.<br>\"\n                f\"Neptune analytical orbits not shown due to<br>\"\n                f\"pole orientation and Triton complexity.</i>\"\n            )\n\n        fig.add_trace(go.Scatter3d(\n            x=x_final, y=y_final, z=z_final,\n            mode='lines',\n            line=dict(color=color, width=2, dash='dash'),\n            name=f'{satellite_name} Osculating Orbit (Epoch: {epoch})',\n            text=[hover_text_osc] * len(x_final),\n            customdata=[hover_text_osc] * len(x_final),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ))\n        \n        print(f\"  [OK] Osculating orbit plotted (ecliptic frame)\", flush=True)\n        return fig\n        \n    except Exception as e:\n        print(f\"Error plotting osculating orbit for {satellite_name}: {e}\", flush=True)\n        import traceback\n        traceback.print_exc()\n        return fig",
    "start_line": 1344,
    "end_line": 1475,
    "has_docstring": true,
    "docstring": "Plot osculating orbit for Neptune satellites.\n\nCRITICAL: Neptune moon osculating elements are in ECLIPTIC frame (J2000.0)\nNo planet-specific rotation needed - standard Keplerian sequence only.\n\nNeptune's pole RA (299.36 deg) is ~29 deg from ecliptic pole, and Triton's retrograde\norbit makes analytical transformations complex. Osculating elements from JPL\nHorizons are already in ecliptic frame and handle retrograde orbits automatically.\n\nFollowing Saturn/Uranus pattern: osculating-only approach.\n\nSpecial moons:\n- Triton: Retrograde (i~157 deg) - largest, doomed to break up in ~3.6 billion years\n- Nereid: Highly eccentric (e~0.75) - captured object",
    "parameters": [
      "fig",
      "satellite_name",
      "date",
      "color",
      "show_apsidal_markers"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_neptune_moon_osculating_orbit",
    "component_id": "idealized_orbits.plot_neptune_moon_osculating_orbit"
  },
  "idealized_orbits.plot_pluto_barycenter_orbit": {
    "id": "idealized_orbits.plot_pluto_barycenter_orbit",
    "name": "plot_pluto_barycenter_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "apsidal_markers.add_perihelion_marker",
      "osculating_cache_manager.get_cache_key",
      "apsidal_markers.add_apohelion_marker",
      "idealized_orbits._build_pluto_centered_hover_text",
      "idealized_orbits.rotate_points",
      "idealized_orbits._build_barycenter_mode_hover_text",
      "osculating_cache_manager.load_cache"
    ],
    "source_code": "def plot_pluto_barycenter_orbit(fig, object_name, date, color, show_apsidal_markers=False, center_id='Pluto'):\n    \"\"\"\n    Plot osculating orbit for objects in Pluto binary system.\n    \n    Supports TWO center modes:\n    1. center_id='Pluto' - Traditional view, moons orbit Pluto\n    2. center_id='Pluto-Charon Barycenter' - Binary view, ALL objects orbit barycenter\n    \n    When \"Pluto-Charon Barycenter\" is the center:\n    - Pluto orbits the barycenter (tiny orbit ~0.0000137 AU)\n    - Charon orbits the barycenter (larger orbit ~0.000117 AU, same period)\n    - Other moons orbit the barycenter (wider orbits)\n    \n    All osculating elements from JPL Horizons are in ECLIPTIC frame (J2000.0).\n    \n    Binary System Parameters (from New Horizons):\n    - Total separation: 19,596 km = 0.000131 AU\n    - Period: 6.387 days (both tidally locked)\n    - Mass ratio: M_Charon/M_Pluto = 0.122\n    - Barycenter: 2,035 km from Pluto center (OUTSIDE Pluto's 1,188 km radius!)\n    - System inclination to ecliptic: ~119.6 deg (retrograde)\n    \"\"\"\n    \n    # Horizons IDs for Pluto system objects\n    PLUTO_SYSTEM_IDS = {\n        'Pluto': '999',    # Body center (orbits barycenter in Mode 3)\n        'Charon': '901',   # Largest moon (binary partner)\n        'Styx': '905',     # Tiny irregular\n        'Nix': '902',      # Elongated\n        'Kerberos': '904', # Dark surface\n        'Hydra': '903'     # Most distant\n    }\n    \n    # Binary system physical parameters (from New Horizons mission)\n    BINARY_PARAMS = {\n        'separation_au': 0.000131,        # 19,596 km total separation\n        'period_days': 6.387,             # Orbital period\n        'mass_ratio': 0.122,              # M_Charon / M_Pluto\n        'eccentricity': 0.0002,           # Nearly circular\n        # Fallback angular elements (only used if cache unavailable)\n        'inclination_ecliptic': 119.6,    # To J2000 ecliptic (retrograde)\n        'Omega_ecliptic': 223.0,          # Longitude of ascending node (approximate)\n        'omega': 0.0,                     # Argument of periapsis (circular orbit)\n    }\n    \n    mass_ratio = BINARY_PARAMS['mass_ratio']\n    separation = BINARY_PARAMS['separation_au']\n\n    horizons_id = PLUTO_SYSTEM_IDS.get(object_name)\n    if not horizons_id:\n        print(f\"Warning: No Horizons ID for {object_name}\", flush=True)\n        return fig\n    \n    is_barycenter_mode = (center_id == 'Pluto-Charon Barycenter')\n    \n    try:\n        # Always load cache - we need it for angular elements even in barycenter mode\n    #    from osculating_cache_manager import load_cache\n    #    cache = load_cache()\n        \n        from osculating_cache_manager import load_cache, get_cache_key\n        cache = load_cache()\n        \n        # Determine cache key suffix based on view mode\n        if is_barycenter_mode:\n            center_suffix = '@9'  # Barycentric view\n        else:\n            center_suffix = '@999'  # Pluto-centered view (or None for default)\n\n        # Determine which orbital elements to use\n\n\n        \"\"\"\n        if is_barycenter_mode and object_name in ['Pluto', 'Charon']:\n            # BARYCENTER MODE for Pluto/Charon:\n            # - Semi-major axis: CALCULATED from mass ratio (different from Pluto-centered)\n            # - Angular elements (i, omega, Omega): FROM CACHE (same orbital plane regardless of center)\n            \n            # Calculate semi-major axis from mass ratio\n            if object_name == 'Pluto':\n                a = separation * mass_ratio / (1 + mass_ratio)  # ~0.0000142 AU\n            else:  # Charon\n                a = separation * 1.0 / (1 + mass_ratio)  # ~0.000117 AU\n            \n            e = BINARY_PARAMS['eccentricity']  # Nearly circular\n            \n            # Get angular elements from Charon's cache (defines the orbital plane)\n            # Both Pluto and Charon share the same orbital plane\n            if 'Charon' in cache:\n                cached_elements = cache['Charon']['elements']\n                i = cached_elements.get('i', BINARY_PARAMS['inclination_ecliptic'])\n                omega = cached_elements.get('omega', BINARY_PARAMS['omega'])\n                Omega = cached_elements.get('Omega', BINARY_PARAMS['Omega_ecliptic'])\n                epoch = cached_elements.get('epoch', f\"{date.strftime('%Y-%m-%d')}\")\n                print(f\"\\n[BARYCENTER MODE] {object_name}: using Charon's cached angular elements\", flush=True)\n            else:\n                # Fallback to approximations if no cache\n                i = BINARY_PARAMS['inclination_ecliptic']\n                omega = BINARY_PARAMS['omega']\n                Omega = BINARY_PARAMS['Omega_ecliptic']\n                epoch = f\"{date.strftime('%Y-%m-%d')} (approx)\"\n                print(f\"\\n[BARYCENTER MODE] {object_name}: using fallback angular elements (no cache)\", flush=True)\n            \n            print(f\"  a={a:.7f} AU ({a * 149597870.7:.1f} km from barycenter)\", flush=True)\n            print(f\"  i={i:.2f} deg, Omega={Omega:.2f} deg, omega={omega:.2f} deg (from cache)\", flush=True)\n            \"\"\"\n        \n\n        if is_barycenter_mode and object_name in ['Pluto', 'Charon']:\n            # BARYCENTER MODE for Pluto/Charon:\n            # Try to use barycentric osculating elements from cache first\n            # Fall back to calculated values if not available\n            \n            cache_key = get_cache_key(object_name, '@9')  # e.g., 'Pluto@9', 'Charon@9'\n            \n            if cache_key in cache:\n                # USE ACTUAL BARYCENTRIC OSCULATING ELEMENTS\n                elements = cache[cache_key]['elements']\n                a = elements.get('a', 0)\n                e = elements.get('e', BINARY_PARAMS['eccentricity'])\n                i = elements.get('i', BINARY_PARAMS['inclination_ecliptic'])\n                omega = elements.get('omega', BINARY_PARAMS['omega'])\n                Omega = elements.get('Omega', BINARY_PARAMS['Omega_ecliptic'])\n                epoch = elements.get('epoch', f\"{date.strftime('%Y-%m-%d')}\")\n                print(f\"\\n[BARYCENTER MODE] {object_name}: using barycentric osculating elements ({cache_key})\", flush=True)\n                print(f\"  a={a:.7f} AU ({a * 149597870.7:.1f} km from barycenter)\", flush=True)\n                print(f\"  e={e:.6f}, i={i:.2f} deg, Omega={Omega:.2f} deg, omega={omega:.2f} deg\", flush=True)\n            else:\n                # FALLBACK: Calculate from mass ratio + angular elements from Pluto-centered cache\n                print(f\"\\n[BARYCENTER MODE] {object_name}: no barycentric cache ({cache_key}), using calculated values\", flush=True)\n                \n                # Calculate semi-major axis from mass ratio\n                if object_name == 'Pluto':\n                    a = separation * mass_ratio / (1 + mass_ratio)  # ~0.0000142 AU\n                else:  # Charon\n                    a = separation * 1.0 / (1 + mass_ratio)  # ~0.000117 AU\n                \n                e = BINARY_PARAMS['eccentricity']  # Nearly circular\n                \n                # Get angular elements from Charon's Pluto-centered cache (defines the orbital plane)\n                if 'Charon' in cache:\n                    cached_elements = cache['Charon']['elements']\n                    i = cached_elements.get('i', BINARY_PARAMS['inclination_ecliptic'])\n                    omega = cached_elements.get('omega', BINARY_PARAMS['omega'])\n                    Omega = cached_elements.get('Omega', BINARY_PARAMS['Omega_ecliptic'])\n                    epoch = cached_elements.get('epoch', f\"{date.strftime('%Y-%m-%d')}\")\n                    print(f\"  Using Charon's Pluto-centered angular elements as fallback\", flush=True)\n                else:\n                    # Final fallback to approximations\n                    i = BINARY_PARAMS['inclination_ecliptic']\n                    omega = BINARY_PARAMS['omega']\n                    Omega = BINARY_PARAMS['Omega_ecliptic']\n                    epoch = f\"{date.strftime('%Y-%m-%d')} (approx)\"\n                    print(f\"  Using fallback angular elements (no cache)\", flush=True)\n                \n                print(f\"  a={a:.7f} AU ({a * 149597870.7:.1f} km from barycenter)\", flush=True)\n                print(f\"  i={i:.2f} deg, Omega={Omega:.2f} deg, omega={omega:.2f} deg (from cache)\", flush=True)\n\n        else:\n            # PLUTO-CENTERED MODE or outer moons:\n            # Use cached osculating elements with appropriate center\n            \n            # Determine the correct cache key based on view\n            if is_barycenter_mode:\n                cache_key = get_cache_key(object_name, '@9')  # e.g., 'Styx@9'\n                fallback_key = object_name  # Fall back to Pluto-centered if barycentric not available\n            else:\n                cache_key = object_name  # Pluto-centered (default)\n                fallback_key = None\n            \n            print(f\"\\n[OSCULATING] Loading cached elements for {object_name}...\", flush=True)\n            \n            if cache_key in cache:\n                elements = cache[cache_key]['elements']\n                print(f\"  [OK] Using cached osculating elements ({cache_key})\", flush=True)\n            elif fallback_key and fallback_key in cache:\n                elements = cache[fallback_key]['elements']\n                print(f\"  [WARN] Using fallback cache key ({fallback_key}) - barycentric elements not cached\", flush=True)\n            else:\n                # Try fetching from planetary_params for moons\n                if object_name in planetary_params:\n                    elements = planetary_params[object_name]\n                    print(f\"  [OK] Using analytical elements from planetary_params\", flush=True)\n                else:\n                    print(f\"  Warning: No osculating elements in cache for {object_name}\", flush=True)\n                    return fig\n            \n            a = elements.get('a', 0)\n            e = elements.get('e', 0)\n            i = elements.get('i', 0)\n            omega = elements.get('omega', 0)\n            Omega = elements.get('Omega', 0)\n            epoch = elements.get('epoch', 'analytical')\n        \n        # Skip if no valid semi-major axis\n        if a == 0:\n            print(f\"  Warning: Zero semi-major axis for {object_name}\", flush=True)\n            return fig\n        \n        print(f\"  Plotting: a={a:.7f} AU, i={i:.4f} deg (ecliptic), epoch={epoch}\", flush=True)\n        \n        # Generate orbital path\n        theta = np.linspace(0, 2*np.pi, 360)\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        \n        x_orbit = r * np.cos(theta)\n        y_orbit = r * np.sin(theta)\n        z_orbit = np.zeros_like(theta)\n        \n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n        \n        # Standard Keplerian rotation sequence\n        x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, omega_rad, 'z')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n        x_final, y_final, z_final = rotate_points(x_temp, y_temp, z_temp, Omega_rad, 'z')\n        \n        # Build hover text based on mode and object\n        if is_barycenter_mode:\n            hover_text_osc = _build_barycenter_mode_hover_text(object_name, a, e, i, epoch, BINARY_PARAMS)\n        else:\n            hover_text_osc = _build_pluto_centered_hover_text(object_name, a, e, i, epoch)\n        \n        # Determine line style\n        if is_barycenter_mode and object_name in ['Pluto', 'Charon']:\n            # Dashed lines for osculating orbits (to distinguish from actual orbits)\n            line_style = dict(color=color, width=2, dash='dash')\n\n            orbit_label = f'{object_name} Osculating Orbit (Epoch: {epoch})'\n\n        else:\n            # Dashed for osculating orbits\n            line_style = dict(color=color, width=2, dash='dash')\n            orbit_label = f'{object_name} Osculating Orbit (Epoch: {epoch})'\n        \n        fig.add_trace(go.Scatter3d(\n            x=x_final, y=y_final, z=z_final,\n            mode='lines',\n            line=line_style,\n            name=orbit_label,\n            text=[hover_text_osc] * len(x_final),\n            customdata=[hover_text_osc] * len(x_final),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ))\n        \n#        print(f\"  [OK] Orbit plotted (ecliptic frame)\", flush=True)\n#        return fig\n\n        # Add apsidal markers using standard method\n        if show_apsidal_markers and e > 0.001:  # Skip for nearly circular orbits\n            from apsidal_markers import add_perihelion_marker, add_apohelion_marker\n            \n            # Find periapsis and apoapsis indices\n            periapsis_idx = np.argmin(r)\n            apoapsis_idx = np.argmax(r)\n            \n            # Build orbital parameters dict for apsidal marker functions\n            orbital_params = {\n                'a': a,\n                'e': e,\n                'i': i,\n                'omega': omega,\n                'Omega': Omega\n            }\n            \n            # Determine center body for proper terminology\n            center_body = center_id if center_id != 'Pluto-Charon Barycenter' else 'Pluto-Charon Barycenter'\n            \n            # Add periapsis marker\n            add_perihelion_marker(\n                fig,\n                x_final[periapsis_idx],\n                y_final[periapsis_idx],\n                z_final[periapsis_idx],\n                object_name,\n                a,\n                e,\n                date if date else datetime.now(),\n                {'x': x_final[periapsis_idx], 'y': y_final[periapsis_idx], 'z': z_final[periapsis_idx]},\n                orbital_params,\n                lambda x: color,\n                q=r[periapsis_idx],\n                center_body=center_body\n            )\n            \n            # Add apoapsis marker\n            add_apohelion_marker(\n                fig,\n                x_final[apoapsis_idx],\n                y_final[apoapsis_idx],\n                z_final[apoapsis_idx],\n                object_name,\n                a,\n                e,\n                date if date else datetime.now(),\n                {'x': x_final[apoapsis_idx], 'y': y_final[apoapsis_idx], 'z': z_final[apoapsis_idx]},\n                orbital_params,\n                lambda x: color,\n                center_body=center_body\n            )\n        \n        print(f\"  [OK] Orbit plotted (ecliptic frame)\", flush=True)\n        return fig\n\n    except Exception as e:\n        print(f\"Error plotting orbit for {object_name}: {e}\", flush=True)\n        import traceback\n        traceback.print_exc()\n        return fig",
    "start_line": 1477,
    "end_line": 1787,
    "has_docstring": true,
    "docstring": "Plot osculating orbit for objects in Pluto binary system.\n\nSupports TWO center modes:\n1. center_id='Pluto' - Traditional view, moons orbit Pluto\n2. center_id='Pluto-Charon Barycenter' - Binary view, ALL objects orbit barycenter\n\nWhen \"Pluto-Charon Barycenter\" is the center:\n- Pluto orbits the barycenter (tiny orbit ~0.0000137 AU)\n- Charon orbits the barycenter (larger orbit ~0.000117 AU, same period)\n- Other moons orbit the barycenter (wider orbits)\n\nAll osculating elements from JPL Horizons are in ECLIPTIC frame (J2000.0).\n\nBinary System Parameters (from New Horizons):\n- Total separation: 19,596 km = 0.000131 AU\n- Period: 6.387 days (both tidally locked)\n- Mass ratio: M_Charon/M_Pluto = 0.122\n- Barycenter: 2,035 km from Pluto center (OUTSIDE Pluto's 1,188 km radius!)\n- System inclination to ecliptic: ~119.6 deg (retrograde)",
    "parameters": [
      "fig",
      "object_name",
      "date",
      "color",
      "show_apsidal_markers",
      "center_id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_pluto_barycenter_orbit",
    "component_id": "idealized_orbits.plot_pluto_barycenter_orbit"
  },
  "idealized_orbits.plot_tno_satellite_orbit": {
    "id": "idealized_orbits.plot_tno_satellite_orbit",
    "name": "plot_tno_satellite_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "apsidal_markers.add_perihelion_marker",
      "osculating_cache_manager.load_cache",
      "apsidal_markers.add_apohelion_marker"
    ],
    "source_code": "def plot_tno_satellite_orbit(fig, satellite_name, parent_name, date, color, show_apsidal_markers=False):\n    \"\"\"\n    Plot osculating orbit for TNO (Trans-Neptunian Object) satellites.\n    \n    Handles satellites of:\n    - Eris (Dysnomia)\n    - Gonggong (Xiangliu)\n    - Orcus (Vanth)\n    - Quaoar (Weywot)\n    - Haumea (Hi'iaka, Namaka)\n    - Makemake (MK2)\n    \n    All use JPL satellite ephemeris solutions with barycenter-relative positioning.\n    Osculating elements from JPL Horizons are in ECLIPTIC frame (J2000.0).\n    \n    Unlike major planet moons, TNO satellites have no reliable analytical elements,\n    so we display osculating orbits ONLY (no dual-orbit comparison).\n    \"\"\"\n    \n    # JPL Horizons IDs for TNO satellites (satellite ephemeris solutions)\n    TNO_SATELLITE_IDS = {\n        # Eris system (barycenter: 20136199)\n        'Dysnomia': '120136199',\n        # Gonggong system (barycenter: 20137863)\n        'Xiangliu': '92250881',\n        # Orcus system (barycenter: 20137111)\n        'Vanth': '120090482',\n        # Quaoar system (barycenter: 20136826)\n        'Weywot': '120050000',\n        # Haumea system (barycenter: 20136108)\n        \"Hi'iaka\": '120136108',\n        'Namaka': '220136108',\n        # Makemake system (barycenter: 20136472)\n        'MK2': '120136472',\n    }\n    \n    horizons_id = TNO_SATELLITE_IDS.get(satellite_name)\n    if not horizons_id:\n        print(f\"Warning: No Horizons ID for TNO satellite {satellite_name}\", flush=True)\n        return fig\n    \n    try:\n        # Load osculating cache\n        from osculating_cache_manager import load_cache\n        cache = load_cache()\n        \n        print(f\"\\n[TNO SATELLITE] Loading cached elements for {satellite_name}...\", flush=True)\n        \n        # These TNO moons have no usable JPL parent-centered ephemeris\n        # Horizons returns heliocentric data which is wrong for satellite visualization\n    #    ANALYTICAL_ONLY_SATELLITES = ['MK2', 'Xiangliu', 'Vanth', 'Weywot']\n        ANALYTICAL_ONLY_SATELLITES = ['MK2', 'Xiangliu', 'Vanth']  \n\n        if satellite_name in ANALYTICAL_ONLY_SATELLITES and satellite_name in planetary_params:\n            # Force analytical path - skip cache even if present\n            elements = planetary_params[satellite_name]\n            epoch = \"analytical (J2000, theta=0)\"\n            orbit_type = \"Analytical\"\n\n            if satellite_name == 'MK2':\n                orbit_source = (\"Analytical orbit from Hubble observations<br>\"\n                               \"(Bamberger 2025, arXiv:2509.05880)<br>\"\n                               \"No JPL ephemeris available<br>\"\n                               \"<i>Orientation unconstrained</i>\")\n            elif satellite_name == 'Xiangliu':\n                orbit_source = (\"Analytical orbit from Hubble observations<br>\"\n                               \"(Kiss et al. 2017)<br>\"\n                               \"No JPL ephemeris available<br>\"\n                               \"<i>Orientation unconstrained</i>\")\n            elif satellite_name == 'Vanth':\n                orbit_source = (\"Analytical orbit from Hubble observations<br>\"\n                               \"(Brown et al. 2010)<br>\"\n                               \"Heliocentric JPL ephemeris not useful<br>\"\n                               \"<i>Orientation unconstrained</i>\")\n            elif satellite_name == 'Weywot':\n                orbit_source = (\"Analytical orbit from occultation data<br>\"\n                               \"(Fraser et al. 2013, updated 2019)<br>\"\n                               \"Heliocentric JPL ephemeris not useful<br>\"\n                               \"<i>Orientation unconstrained</i>\")\n            else:\n                orbit_source = (\"Analytical orbit from idealized elements<br>\"\n                               \"(No JPL ephemeris available)<br>\"\n                               \"<i>Orientation unconstrained</i>\")\n            print(f\"  [WARN] Using analytical elements for {satellite_name} (no usable JPL ephemeris)\", flush=True)\n            \n            a = elements.get('a', 0)\n            e = elements.get('e', 0)\n            i = elements.get('i', 0)\n            omega = elements.get('omega', 0)\n            Omega = elements.get('Omega', 0)\n\n        elif satellite_name in cache:\n            elements = cache[satellite_name]['elements']\n            epoch = elements.get('epoch', f\"{date.strftime('%Y-%m-%d')}\")\n            orbit_type = \"Osculating\"\n            orbit_source = \"Osculating orbit from JPL Horizons<br>satellite ephemeris solution\"            \n            print(f\"  [OK] Using cached osculating elements (epoch: {epoch})\", flush=True)\n            \n            a = elements.get('a', 0)\n            e = elements.get('e', 0)\n            i = elements.get('i', 0)\n            omega = elements.get('omega', 0)\n            Omega = elements.get('Omega', 0)\n            \n    #    else:\n    #        print(f\"  [WARN] No cached elements for {satellite_name}, skipping orbit plot\", flush=True)\n    #        return fig\n        \n        elif satellite_name in planetary_params:\n            # Fallback to idealized elements when osculating cache is empty\n            elements = planetary_params[satellite_name]\n            epoch = \"analytical (J2000, theta=0)\"\n            orbit_type = \"Analytical\"\n\n            if satellite_name == 'MK2':\n                orbit_source = (\"Analytical orbit from Hubble observations<br>\"\n                               \"(Bamberger 2025, arXiv:2509.05880)<br>\"\n                               \"No JPL ephemeris available<br>\"\n                               \"<i>Orientation unconstrained</i>\")\n            elif satellite_name == 'Xiangliu':\n                orbit_source = (\"Analytical orbit from Hubble observations<br>\"\n                               \"(Kiss et al. 2017)<br>\"\n                               \"No JPL ephemeris available<br>\"\n                               \"<i>Orientation unconstrained</i>\")\n            elif satellite_name == 'Vanth':\n                orbit_source = (\"Analytical orbit from Hubble observations<br>\"\n                               \"(Brown et al. 2010)<br>\"\n                               \"Heliocentric JPL ephemeris not useful<br>\"\n                               \"<i>Orientation unconstrained</i>\")\n            elif satellite_name == 'Weywot':\n                orbit_source = (\"Analytical orbit from occultation data<br>\"\n                               \"(Fraser et al. 2013, updated 2019)<br>\"\n                               \"Heliocentric JPL ephemeris not useful<br>\"\n                               \"<i>Orientation unconstrained</i>\")\n            else:\n                orbit_source = (\"Analytical orbit from idealized elements<br>\"\n                               \"(No JPL ephemeris available)<br>\"\n                               \"<i>Orientation unconstrained</i>\")\n            print(f\"  [WARN] No cached osculating elements for {satellite_name}, using fallback idealized elements\", flush=True)\n            \n            a = elements.get('a', 0)\n            e = elements.get('e', 0)\n            i = elements.get('i', 0)\n            omega = elements.get('omega', 0)\n            Omega = elements.get('Omega', 0)\n            \n        else:\n            print(f\"  [WARN] No elements for {satellite_name}, skipping orbit plot\", flush=True)\n            return fig\n\n        print(f\"  Elements: a={a:.6f} AU, e={e:.4f}, i={i:.2f} deg, omega={omega:.2f} deg, Omega={Omega:.2f} deg\", flush=True)\n        \n        # Generate orbit points\n    #    theta = np.linspace(0, 2*np.pi, 360)\n                \n        # For eccentric orbits (e > 0.1), ensure theta=pi is included for accurate apoapsis\n        if e > 0.1:\n            theta_first_half = np.linspace(0, np.pi, 181)\n            theta_second_half = np.linspace(np.pi, 2*np.pi, 181)[1:]\n            theta = np.concatenate([theta_first_half, theta_second_half])\n        else:\n            theta = np.linspace(0, 2*np.pi, 360)\n\n        # Skip if semi-major axis is invalid\n        if a <= 0:\n            print(f\"  [WARN] Invalid semi-major axis for {satellite_name}\", flush=True)\n            return fig\n            \n        # Calculate orbit in orbital plane\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        x_orbit = r * np.cos(theta)\n        y_orbit = r * np.sin(theta)\n        z_orbit = np.zeros_like(theta)\n        \n        # Convert angles to radians\n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n        \n        # Apply 3D rotation (standard Keplerian to ecliptic transformation)\n        # Rotation 1: Around z-axis by argument of periapsis (omega)\n        x1 = x_orbit * np.cos(omega_rad) - y_orbit * np.sin(omega_rad)\n        y1 = x_orbit * np.sin(omega_rad) + y_orbit * np.cos(omega_rad)\n        z1 = z_orbit\n        \n        # Rotation 2: Around x-axis by inclination (i)\n        x2 = x1\n        y2 = y1 * np.cos(i_rad) - z1 * np.sin(i_rad)\n        z2 = y1 * np.sin(i_rad) + z1 * np.cos(i_rad)\n        \n        # Rotation 3: Around z-axis by longitude of ascending node (Omega)\n        x_final = x2 * np.cos(Omega_rad) - y2 * np.sin(Omega_rad)\n        y_final = x2 * np.sin(Omega_rad) + y2 * np.cos(Omega_rad)\n        z_final = z2\n        \n        # Create hover text\n        hover_text = (\n            f\"<b>{satellite_name} {orbit_type} Orbit</b><br>\"\n            f\"Parent: {parent_name}<br>\"\n            f\"Epoch: {epoch}<br>\"\n            f\"<br>\"\n            f\"<b>Orbital Elements:</b><br>\"\n            f\"a = {a:.6f} AU ({a * 149597870.7:.0f} km)<br>\"\n            f\"e = {e:.4f}<br>\"\n            f\"i = {i:.2f} deg<br>\"\n            f\"omega = {omega:.2f} deg<br>\"\n            f\"Omega = {Omega:.2f} deg<br>\"\n            f\"<br>\"\n            f\"<i>{orbit_source}</i>\"\n        )\n        \n        # Add orbit trace\n        fig.add_trace(go.Scatter3d(\n            x=x_final.tolist(),\n            y=y_final.tolist(),\n            z=z_final.tolist(),\n            mode='lines',\n            line=dict(color=color, width=2, dash='dash'),\n            name=f\"{satellite_name} {orbit_type} Orbit\",\n            text=[hover_text] * len(x_final),\n            customdata=[f\"{satellite_name} {orbit_type} Orbit\"] * len(x_final),\n            hoverinfo='text',\n            showlegend=True\n        ))\n        \n        print(f\"  [OK] Plotted {satellite_name} {orbit_type.lower()} orbit\", flush=True)\n\n        # Add apsidal markers using standard method\n        if show_apsidal_markers and e > 0.001:  # Skip for nearly circular orbits            \n\n            from apsidal_markers import add_perihelion_marker, add_apohelion_marker\n            \n            # Find periapsis and apoapsis indices\n            periapsis_idx = np.argmin(r)\n            apoapsis_idx = np.argmax(r)\n            \n            # Build orbital parameters dict for apsidal marker functions\n            orbital_params = {\n                'a': a,\n                'e': e,\n                'i': i,\n                'omega': omega,\n                'Omega': Omega\n            }\n            \n            # Add periapsis marker\n            add_perihelion_marker(\n                fig,\n                x_final[periapsis_idx],\n                y_final[periapsis_idx],\n                z_final[periapsis_idx],\n                satellite_name,\n                a,\n                e,\n                date if date else datetime.now(),\n                {'x': x_final[periapsis_idx], 'y': y_final[periapsis_idx], 'z': z_final[periapsis_idx]},\n                orbital_params,\n                lambda x: color,\n                q=r[periapsis_idx],\n                center_body=parent_name\n            )\n            \n            # Add apoapsis marker\n            add_apohelion_marker(\n                fig,\n                x_final[apoapsis_idx],\n                y_final[apoapsis_idx],\n                z_final[apoapsis_idx],\n                satellite_name,\n                a,\n                e,\n                date if date else datetime.now(),\n                {'x': x_final[apoapsis_idx], 'y': y_final[apoapsis_idx], 'z': z_final[apoapsis_idx]},\n                orbital_params,\n                lambda x: color,\n                center_body=parent_name\n            )\n        \n        return fig        \n        \n    except Exception as e:\n        print(f\"Error plotting TNO satellite orbit for {satellite_name}: {e}\", flush=True)\n        import traceback\n        traceback.print_exc()\n        return fig",
    "start_line": 1790,
    "end_line": 2074,
    "has_docstring": true,
    "docstring": "Plot osculating orbit for TNO (Trans-Neptunian Object) satellites.\n\nHandles satellites of:\n- Eris (Dysnomia)\n- Gonggong (Xiangliu)\n- Orcus (Vanth)\n- Quaoar (Weywot)\n- Haumea (Hi'iaka, Namaka)\n- Makemake (MK2)\n\nAll use JPL satellite ephemeris solutions with barycenter-relative positioning.\nOsculating elements from JPL Horizons are in ECLIPTIC frame (J2000.0).\n\nUnlike major planet moons, TNO satellites have no reliable analytical elements,\nso we display osculating orbits ONLY (no dual-orbit comparison).",
    "parameters": [
      "fig",
      "satellite_name",
      "parent_name",
      "date",
      "color",
      "show_apsidal_markers"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_tno_satellite_orbit",
    "component_id": "idealized_orbits.plot_tno_satellite_orbit"
  },
  "idealized_orbits._build_barycenter_mode_hover_text": {
    "id": "idealized_orbits._build_barycenter_mode_hover_text",
    "name": "_build_barycenter_mode_hover_text",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [],
    "source_code": "def _build_barycenter_mode_hover_text(object_name, a, e, i, epoch, binary_params):\n    \"\"\"Build hover text for barycenter-centered view.\"\"\"\n    \n    if object_name == 'Pluto':\n        return (\n            f\"<b>Pluto's Osculating Orbit around Barycenter</b><br>\"\n            f\"<i>The smaller orbit of the binary pair</i><br><br>\"\n            f\"<b>Orbital Elements (Epoch: {epoch}):</b><br>\"\n            f\"a = {a:.7f} AU ({a * 149597870.7:.0f} km) <i>[calculated]</i><br>\"\n            f\"e = {e:.4f} (nearly circular)<br>\"\n            f\"i = {i:.1f} deg to ecliptic <i>[osculating]</i><br>\"\n            f\"Period: {binary_params['period_days']:.3f} days<br><br>\"\n            f\"<b>Why Pluto's orbit is smaller:</b><br>\"\n            f\"<i>Pluto is ~8x more massive than Charon,<br>\"\n            f\"so it orbits closer to the barycenter.<br>\"\n            f\"Like a heavy adult on a see-saw sitting<br>\"\n            f\"closer to the pivot point!</i><br><br>\"\n            f\"<b>The barycenter is OUTSIDE Pluto!</b><br>\"\n            f\"<i>2,035 km from Pluto's center,<br>\"\n            f\"but Pluto's radius is only 1,188 km.<br>\"\n            f\"This makes Pluto-Charon a true binary.</i><br><br>\"\n            f\"<b>Note:</b> <i>Semi-major axis calculated from<br>\"\n            f\"mass ratio; angles from Charon's osculating<br>\"\n            f\"elements (same orbital plane).</i>\"\n        )\n    \n    elif object_name == 'Charon':\n        return (\n            f\"<b>Charon's Osculating Orbit around Barycenter</b><br>\"\n            f\"<i>The larger orbit of the binary pair</i><br><br>\"\n            f\"<b>Orbital Elements (Epoch: {epoch}):</b><br>\"\n            f\"a = {a:.7f} AU ({a * 149597870.7:.0f} km) <i>[calculated]</i><br>\"\n            f\"e = {e:.4f} (nearly circular)<br>\"\n            f\"i = {i:.1f} deg to ecliptic <i>[osculating]</i><br>\"\n            f\"Period: {binary_params['period_days']:.3f} days<br><br>\"\n            f\"<b>Why Charon's orbit is larger:</b><br>\"\n            f\"<i>Charon is only 12% of Pluto's mass,<br>\"\n            f\"so it orbits farther from the barycenter.<br>\"\n            f\"Like a child on a see-saw sitting<br>\"\n            f\"farther from the pivot point!</i><br><br>\"\n            f\"<b>The Dance:</b><br>\"\n            f\"<i>Watch Pluto and Charon orbit together,<br>\"\n            f\"always on opposite sides of their<br>\"\n            f\"mutual center of mass. Tidally locked,<br>\"\n            f\"they always show the same face to each other.</i><br><br>\"\n            f\"<b>Note:</b> <i>Semi-major axis calculated from<br>\"\n            f\"mass ratio; angles from osculating elements<br>\"\n            f\"(same orbital plane as Pluto).</i>\"\n        )\n    \n    else:\n        # Outer moons (Styx, Nix, Kerberos, Hydra) - unchanged\n        return (\n            f\"<b>{object_name} Orbit</b><br>\"\n            f\"<i>(around Pluto-Charon barycenter)</i><br><br>\"\n            f\"a = {a:.7f} AU ({a * 149597870.7:.0f} km)<br>\"\n            f\"e = {e:.4f}<br>\"\n            f\"i = {i:.2f} deg to ecliptic<br><br>\"\n            f\"<b>Orbital Resonance:</b><br>\"\n            f\"<i>The outer moons orbit in near-resonance<br>\"\n            f\"with Charon's 6.387-day period:<br>\"\n            f\"* Styx: ~3:1 (~20.2 days)<br>\"\n            f\"* Nix: ~4:1 (~24.9 days)<br>\"\n            f\"* Kerberos: ~5:1 (~32.2 days)<br>\"\n            f\"* Hydra: ~6:1 (~38.2 days)</i><br><br>\"\n            f\"<b>Why orbits diverge:</b><br>\"\n            f\"<i>Osculating orbit 'kisses' actual position<br>\"\n            f\"at epoch. Perturbations from Pluto-Charon<br>\"\n            f\"binary cause deviations over time.</i>\"\n        )",
    "start_line": 2077,
    "end_line": 2146,
    "has_docstring": true,
    "docstring": "Build hover text for barycenter-centered view.",
    "parameters": [
      "object_name",
      "a",
      "e",
      "i",
      "epoch",
      "binary_params"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _build_barycenter_mode_hover_text",
    "component_id": "idealized_orbits._build_barycenter_mode_hover_text"
  },
  "idealized_orbits._build_pluto_centered_hover_text": {
    "id": "idealized_orbits._build_pluto_centered_hover_text",
    "name": "_build_pluto_centered_hover_text",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [],
    "source_code": "def _build_pluto_centered_hover_text(object_name, a, e, i, epoch):\n    \"\"\"Build hover text for traditional Pluto-centered view.\"\"\"\n    \n    if object_name == 'Charon':\n        return (\n            f\"<b>Charon Osculating Orbit</b><br>\"\n            f\"<i>(around Pluto center)</i><br><br>\"\n            f\"Epoch: {epoch}<br>\"\n            f\"a = {a:.6f} AU, e = {e:.6f}<br>\"\n            f\"i = {i:.4f} deg (J2000 ecliptic)<br>\"\n            f\"Period: 6.387 days (tidally locked)<br><br>\"\n            f\"<b>Why orbit appears non-circular:</b><br>\"\n            f\"<i>Charon's orbit is nearly circular (e~0.0002),<br>\"\n            f\"but we're viewing from Pluto's CENTER,<br>\"\n            f\"not the barycenter. Pluto itself moves<br>\"\n            f\"in a small counter-orbit, making Charon's<br>\"\n            f\"path appear to wobble slightly.</i>\"\n        )\n    else:\n        return (\n            f\"<b>{object_name} Osculating Orbit</b><br>\"\n            f\"<i>(around Pluto center)</i><br><br>\"\n            f\"Epoch: {epoch}<br>\"\n            f\"a = {a:.6f} AU, e = {e:.6f}<br>\"\n            f\"i = {i:.4f} deg (J2000 ecliptic)<br><br>\"\n            f\"<b>Why orbits diverge:</b><br>\"\n            f\"<i>'Osculating' means 'kissing' - this ellipse<br>\"\n            f\"matches position & velocity at epoch only.<br>\"\n            f\"Real orbits deviate due to:<br>\"\n            f\"* Charon's gravity (11.7% of Pluto's mass)<br>\"\n            f\"* Orbital resonances between moons<br>\"\n            f\"* The Pluto-Charon binary 'wobble'<br>\"\n            f\"The divergence you see IS the perturbation!</i>\"\n        )",
    "start_line": 2149,
    "end_line": 2182,
    "has_docstring": true,
    "docstring": "Build hover text for traditional Pluto-centered view.",
    "parameters": [
      "object_name",
      "a",
      "e",
      "i",
      "epoch"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _build_pluto_centered_hover_text",
    "component_id": "idealized_orbits._build_pluto_centered_hover_text"
  },
  "idealized_orbits.add_pluto_barycenter_marker": {
    "id": "idealized_orbits.add_pluto_barycenter_marker",
    "name": "add_pluto_barycenter_marker",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "constants_new.color_map"
    ],
    "source_code": "def add_pluto_barycenter_marker(fig, date, charon_position=None):\n    \"\"\"\n    Add the Pluto-Charon barycenter marker to Pluto-centered view.\n    \n    The barycenter is ~2,035 km from Pluto's center toward Charon.\n    This is OUTSIDE Pluto's surface (radius ~1,188 km)!\n    \n    Parameters:\n        fig: Plotly figure\n        date: Current date for position calculation\n        charon_position: Dict with Charon's x, y, z position (if available)\n    \"\"\"\n    # Barycenter distance from Pluto center in AU\n    # Calculation: separation x (m_charon / (m_pluto + m_charon))\n    # = 19,596 km x (0.122 / 1.122) ~ 2,131 km ~ 0.0000142 AU\n    BARYCENTER_DIST_AU = 0.0000142\n    \n    if charon_position and charon_position.get('x') is not None:\n        # Calculate unit vector from Pluto toward Charon\n        cx, cy, cz = charon_position['x'], charon_position['y'], charon_position['z']\n        charon_dist = (cx**2 + cy**2 + cz**2)**0.5\n        \n        if charon_dist > 0:\n            # Barycenter is along the Pluto-Charon line\n            bary_x = BARYCENTER_DIST_AU * (cx / charon_dist)\n            bary_y = BARYCENTER_DIST_AU * (cy / charon_dist)\n            bary_z = BARYCENTER_DIST_AU * (cz / charon_dist)\n        else:\n            bary_x, bary_y, bary_z = BARYCENTER_DIST_AU, 0, 0\n    else:\n        # Fallback: place on +X axis\n        bary_x, bary_y, bary_z = BARYCENTER_DIST_AU, 0, 0\n    \n    hover_text = (\n        f\"<b>Pluto-Charon Barycenter</b><br>\"\n        f\"<i>Center of mass of the binary system</i><br><br>\"\n        f\"Distance from Pluto center: ~2,035 km<br>\"\n        f\"Distance from Pluto surface: ~847 km<br>\"\n        f\"<br><b>Why this matters:</b><br>\"\n        f\"<i>The barycenter is OUTSIDE Pluto!<br>\"\n        f\"Both Pluto and Charon orbit this point.<br>\"\n        f\"This makes Pluto-Charon a true binary<br>\"\n        f\"system - unique in our solar system.<br><br>\"\n        f\"For comparison, Earth-Moon barycenter<br>\"\n        f\"is 4,671 km from Earth's center -<br>\"\n        f\"still inside Earth (radius 6,371 km).</i>\"\n    )\n    \n    fig.add_trace(go.Scatter3d(\n        x=[bary_x], y=[bary_y], z=[bary_z],\n        mode='markers',\n        marker=dict(\n            size=8,\n    #        color='yellow',\n            color=color_map('Pluto'),\n            symbol='square-open',\n    #        line=dict(color='yellow', width=2)\n        ),\n        name='Pluto-Charon Barycenter',\n        text=[hover_text],\n        hovertemplate='%{text}<extra></extra>',\n        showlegend=True\n    ))\n    \n    print(f\"  [OK] Added barycenter marker at ({bary_x:.7f}, {bary_y:.7f}, {bary_z:.7f}) AU\", flush=True)\n    \n    return fig",
    "start_line": 2184,
    "end_line": 2250,
    "has_docstring": true,
    "docstring": "Add the Pluto-Charon barycenter marker to Pluto-centered view.\n\nThe barycenter is ~2,035 km from Pluto's center toward Charon.\nThis is OUTSIDE Pluto's surface (radius ~1,188 km)!\n\nParameters:\n    fig: Plotly figure\n    date: Current date for position calculation\n    charon_position: Dict with Charon's x, y, z position (if available)",
    "parameters": [
      "fig",
      "date",
      "charon_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_pluto_barycenter_marker",
    "component_id": "idealized_orbits.add_pluto_barycenter_marker"
  },
  "idealized_orbits.plot_orcus_barycenter_orbit": {
    "id": "idealized_orbits.plot_orcus_barycenter_orbit",
    "name": "plot_orcus_barycenter_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "idealized_orbits.rotate_points",
      "osculating_cache_manager.load_cache"
    ],
    "source_code": "def plot_orcus_barycenter_orbit(fig, object_name, date, color, show_apsidal_markers=False, center_id='Orcus'):\n    \"\"\"\n    Plot osculating orbit for objects in the Orcus-Vanth binary system.\n    \n    Supports TWO center modes:\n    1. center_id='Orcus' - Traditional view, Vanth orbits Orcus\n    2. center_id='Orcus-Vanth Barycenter' - Binary view, BOTH objects orbit barycenter\n    \n    Orcus-Vanth has the HIGHEST mass ratio (16%) of any known planet/dwarf planet system!\n    \n    Binary System Parameters (from ALMA 2016 & Brown et al. 2010):\n    - Total separation: 9,000 km = 0.0000601 AU\n    - Period: 9.54 days (both likely tidally locked)\n    - Mass ratio: M_Vanth/M_Orcus = 0.16 (highest known!)\n    - Barycenter: ~1,230 km from Orcus center (OUTSIDE Orcus's ~455 km radius!)\n    - Vanth from barycenter: ~7,770 km\n    - System inclination to ecliptic: ~90 deg (face-on from Earth)\n    \"\"\"\n\n    # Horizons IDs for Orcus system objects  \n    # NOTE: JPL Horizons has specific IDs for Orcus system:\n    #   '90482;' or '20090482' = satellite solution barycenter (use this as center!)\n    #   '920090482' = primary body (Orcus)\n    #   '120090482' = Vanth satellite\n    ORCUS_SYSTEM_IDS = {\n        'Orcus': '920090482',    # PRIMARY body ID (not small body designation)\n        'Vanth': '120090482',    # Satellite ephemeris solution\n    }\n    \n    # Binary system physical parameters (from ALMA 2016 and Brown et al. 2010)\n\n    BINARY_PARAMS = {\n        'separation_au': 0.0000601,       # 9,000 km total separation\n        'period_days': 9.54,              # Orbital period\n        'mass_ratio': 0.16,               # M_Vanth / M_Orcus (HIGHEST KNOWN!)\n        'eccentricity': 0.007,            # Nearly circular\n        # Angular elements derived from JPL Vanth positions to match orbit plane\n        # Fitted to ensure JPL position vectors lie in the drawn orbit plane\n        'inclination_ecliptic': 83.0,     # Fitted to JPL positions (Jan 2026)\n        'Omega_ecliptic': 216.0,          # Fitted to JPL positions\n    #    'omega': 0.0,                     # Argument of periapsis (circular orbit)\n        'omega': 65.0,                    # Fitted to align orbit with JPL positions\n    }\n\n    mass_ratio = BINARY_PARAMS['mass_ratio']\n    separation = BINARY_PARAMS['separation_au']\n    \n    horizons_id = ORCUS_SYSTEM_IDS.get(object_name)\n    if not horizons_id:\n        print(f\"Warning: No Horizons ID for {object_name}\", flush=True)\n        return fig\n    \n    is_barycenter_mode = (center_id == 'Orcus-Vanth Barycenter')\n    \n    try:\n        from osculating_cache_manager import load_cache, get_cache_key\n        cache = load_cache()\n        \n        if is_barycenter_mode and object_name in ['Orcus', 'Vanth']:\n            # BARYCENTER MODE: JPL Actual Orbit traces now handle this\n            # ALMA orbit circles removed - JPL data is the real orbit\n            # (ALMA orbit was a workaround before we could derive barycentric positions)\n            print(f\"\\n[ORCUS BARYCENTER MODE] {object_name}: using JPL Actual Orbit (ALMA orbit removed)\", flush=True)\n            return fig\n                    \n            if object_name == 'Orcus':\n                # Orcus orbits closer to barycenter\n                a = separation * mass_ratio / (1 + mass_ratio)  # ~0.00000822 AU (~1,230 km)\n            else:  # Vanth\n                # Vanth orbits farther from barycenter\n                a = separation * 1.0 / (1 + mass_ratio)  # ~0.0000518 AU (~7,770 km)\n            \n            e = BINARY_PARAMS['eccentricity']\n            \n            # IMPORTANT: For barycenter mode, ALWAYS use analytical binary orbit elements!\n            # The cached elements are for Vanth's orbit relative to Orcus in heliocentric frame,\n            # NOT the binary orbit plane orientation. The binary orbit is face-on (i=90 deg).\n            i = BINARY_PARAMS['inclination_ecliptic']\n            omega = BINARY_PARAMS['omega']\n            Omega = BINARY_PARAMS['Omega_ecliptic']\n            epoch = f\"{date.strftime('%Y-%m-%d')} (binary orbit)\"\n            print(f\"\\n[ORCUS BARYCENTER MODE] {object_name}: using analytical binary orbit elements\", flush=True)\n    #        print(f\"  (NOTE: Binary orbit is face-on from Earth, i=90 deg to ecliptic)\", flush=True)\n            print(f\"  (NOTE: Binary orbit i={i:.1f} deg, Omega={Omega:.1f} deg to ecliptic)\", flush=True)\n            \n            print(f\"  a={a:.7f} AU ({a * 149597870.7:.1f} km from barycenter)\", flush=True)\n    #        print(f\"  i={i:.2f} deg (face-on!), Omega={Omega:.2f} deg, omega={omega:.2f} deg\", flush=True)\n            print(f\"  i={i:.2f} deg, Omega={Omega:.2f} deg, omega={omega:.2f} deg\", flush=True)\n        \n        else:\n            # ORCUS-CENTERED MODE or non-barycenter lookup\n            # Use cached osculating elements or analytical fallback\n            \n            print(f\"\\n[OSCULATING] Loading cached elements for {object_name}...\", flush=True)\n            \n            if object_name in cache:\n                elements = cache[object_name]['elements']\n                print(f\"  [OK] Using cached osculating elements\", flush=True)\n            elif object_name in planetary_params:\n                elements = planetary_params[object_name]\n                print(f\"  [OK] Using analytical elements from planetary_params\", flush=True)\n            else:\n                print(f\"  Warning: No elements found for {object_name}\", flush=True)\n                return fig\n            \n            a = elements.get('a', 0)\n            e = elements.get('e', 0)\n            i = elements.get('i', BINARY_PARAMS['inclination_ecliptic'])\n            omega = elements.get('omega', 0)\n            Omega = elements.get('Omega', 0)\n            epoch = elements.get('epoch', 'analytical')\n        \n        # Skip if no valid semi-major axis\n        if a == 0:\n            print(f\"  Warning: Zero semi-major axis for {object_name}\", flush=True)\n            return fig\n        \n        print(f\"  Plotting: a={a:.7f} AU, i={i:.4f} deg (ecliptic), epoch={epoch}\", flush=True)\n        \n        # Generate orbital path\n        theta = np.linspace(0, 2*np.pi, 360)\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        \n        x_orbit = r * np.cos(theta)\n        y_orbit = r * np.sin(theta)\n        z_orbit = np.zeros_like(theta)\n        \n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n        \n        # Standard Keplerian rotation sequence\n        x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, omega_rad, 'z')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n        x_final, y_final, z_final = rotate_points(x_temp, y_temp, z_temp, Omega_rad, 'z')\n        \n        # Build hover text based on mode\n        if is_barycenter_mode:\n            if object_name == 'Orcus':\n                hover_text_osc = (\n                    f\"<b>{object_name} ALMA Orbit (Brown & Butler 2023)</b><br>\"\n                    f\"<br>Orbital radius: {a:.7f} AU ({a * 149597870.7:.1f} km)<br>\"\n                    f\"Period: {BINARY_PARAMS['period_days']:.2f} days<br>\"\n                    f\"Eccentricity: ~0.007 (nearly circular)<br>\"\n                    f\"Inclination: {i:.1f} deg, Omega: {Omega:.1f} deg<br>\"\n                    f\"<br><b>Binary System - Highest Mass Ratio Known!</b><br>\"\n                    f\"Mass ratio (Vanth/Orcus): 0.16 +/- 0.02<br>\"\n                    f\"(Charon/Pluto is only 0.12)<br>\"\n                    f\"Orcus orbits 13.7% of separation from barycenter<br>\"\n                    f\"Barycenter is OUTSIDE Orcus surface (~455 km radius)!<br>\"\n                    f\"<br><b>Position: Derived from Vanth</b><br>\"\n                    f\"<i>Vanth position from JPL Horizons (ID 120090482).<br>\"\n                    f\"Orcus derived assuming tidal lock (180 deg opposite).<br>\"\n                    f\"Positions projected onto ALMA orbit radii.</i><br>\"\n                    f\"<br><b>Orbit Plane:</b><br>\"\n                    f\"<i>i, Omega fitted to JPL Vanth positions (Jan 2026)<br>\"\n                    f\"to ensure markers lie on drawn orbit circles.</i><br>\"\n                    f\"<br><b>Data Sources:</b><br>\"\n                    f\"Orbit radii: Brown & Butler 2023, PSJ 4:193<br>\"\n                    f\"Orbit plane: Fitted to JPL satellite solution<br>\"\n                    f\"Positions: JPL Horizons ID 120090482\"\n                )\n            else:  # Vanth\n                hover_text_osc = (\n                    f\"<b>{object_name} ALMA Orbit (Brown & Butler 2023)</b><br>\"\n                    f\"<br>Orbital radius: {a:.7f} AU ({a * 149597870.7:.1f} km)<br>\"\n                    f\"Period: {BINARY_PARAMS['period_days']:.2f} days<br>\"\n                    f\"Eccentricity: ~0.007 (nearly circular)<br>\"\n                    f\"Inclination: {i:.1f} deg, Omega: {Omega:.1f} deg<br>\"\n                    f\"<br><b>Binary System - Highest Mass Ratio Known!</b><br>\"\n                    f\"Mass ratio (Vanth/Orcus): 0.16 +/- 0.02<br>\"\n                    f\"(Charon/Pluto is only 0.12)<br>\"\n                    f\"Vanth orbits 86.3% of separation from barycenter<br>\"\n                    f\"Diameter: 443 +/- 10 km (nearly half of Orcus!)<br>\"\n                    f\"Likely a largely-intact impactor from giant collision<br>\"\n                    f\"<br><b>Position: From JPL Horizons</b><br>\"\n                    f\"<i>Vanth position from JPL satellite solution (ID 120090482)<br>\"\n                    f\"projected onto ALMA orbit radius.</i><br>\"\n                    f\"<br><b>Orbit Plane:</b><br>\"\n                    f\"<i>i, Omega fitted to JPL Vanth positions (Jan 2026)<br>\"\n                    f\"to ensure markers lie on drawn orbit circles.</i><br>\"\n                    f\"<br><b>Data Sources:</b><br>\"\n                    f\"Orbit radii: Brown & Butler 2023, PSJ 4:193<br>\"\n                    f\"Orbit plane: Fitted to JPL satellite solution<br>\"\n                    f\"Positions: JPL Horizons ID 120090482\"\n                )\n\n        else:\n            hover_text_osc = (\n                f\"<b>{object_name} Osculating Orbit</b><br>\"\n                f\"Epoch: {epoch}<br>\"\n                f\"<br>a={a:.7f} AU ({a * 149597870.7:.1f} km)<br>\"\n                f\"e={e:.6f}<br>\"\n                f\"i={i:.2f} deg\"\n            )\n                \n        # Determine line style\n        if is_barycenter_mode:\n            line_style = dict(color=color, width=2, dash='dash')\n            orbit_label = f'{object_name} ALMA Orbit (Brown & Butler 2023)'\n        else:\n            line_style = dict(color=color, width=1, dash='dash')\n            orbit_label = f'{object_name} Osculating Orbit (Epoch: {epoch})'\n\n        # Add orbit trace\n        fig.add_trace(go.Scatter3d(\n            x=x_final, y=y_final, z=z_final,\n            mode='lines',\n            line=line_style,\n            name=orbit_label,\n            text=[hover_text_osc] * len(x_final),\n            customdata=[hover_text_osc] * len(x_final),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ))\n        \n        print(f\"  [OK] Added {object_name} orbit (center: {center_id})\", flush=True)\n        return fig\n        \n    except Exception as e:\n        print(f\"Error plotting {object_name} orbit: {e}\", flush=True)\n        traceback.print_exc()\n        return fig",
    "start_line": 2252,
    "end_line": 2474,
    "has_docstring": true,
    "docstring": "Plot osculating orbit for objects in the Orcus-Vanth binary system.\n\nSupports TWO center modes:\n1. center_id='Orcus' - Traditional view, Vanth orbits Orcus\n2. center_id='Orcus-Vanth Barycenter' - Binary view, BOTH objects orbit barycenter\n\nOrcus-Vanth has the HIGHEST mass ratio (16%) of any known planet/dwarf planet system!\n\nBinary System Parameters (from ALMA 2016 & Brown et al. 2010):\n- Total separation: 9,000 km = 0.0000601 AU\n- Period: 9.54 days (both likely tidally locked)\n- Mass ratio: M_Vanth/M_Orcus = 0.16 (highest known!)\n- Barycenter: ~1,230 km from Orcus center (OUTSIDE Orcus's ~455 km radius!)\n- Vanth from barycenter: ~7,770 km\n- System inclination to ecliptic: ~90 deg (face-on from Earth)",
    "parameters": [
      "fig",
      "object_name",
      "date",
      "color",
      "show_apsidal_markers",
      "center_id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_orcus_barycenter_orbit",
    "component_id": "idealized_orbits.plot_orcus_barycenter_orbit"
  },
  "idealized_orbits.add_orcus_barycenter_marker": {
    "id": "idealized_orbits.add_orcus_barycenter_marker",
    "name": "add_orcus_barycenter_marker",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "constants_new.color_map"
    ],
    "source_code": "def add_orcus_barycenter_marker(fig, date, vanth_position=None):\n    \"\"\"\n    Add the Orcus-Vanth barycenter marker to Orcus-centered view.\n    \n    The barycenter is ~1,230 km from Orcus's center toward Vanth.\n    This is OUTSIDE Orcus's surface (radius ~455 km)!\n    \n    Parameters:\n        fig: Plotly figure\n        date: Current date for position calculation\n        vanth_position: Dict with Vanth's x, y, z position (if available)\n    \"\"\"\n    # Barycenter distance from Orcus center in AU\n    # Calculation: separation x (m_vanth / (m_orcus + m_vanth))\n    # = 9,000 km x (0.16 / 1.16) ~ 1,241 km ~ 0.0000083 AU\n    BARYCENTER_DIST_AU = 0.0000083\n    \n    if vanth_position and vanth_position.get('x') is not None:\n        # Calculate unit vector from Orcus toward Vanth\n        vx, vy, vz = vanth_position['x'], vanth_position['y'], vanth_position['z']\n        vanth_dist = (vx**2 + vy**2 + vz**2)**0.5\n        \n        if vanth_dist > 0:\n            # Barycenter is along the Orcus-Vanth line\n            bary_x = BARYCENTER_DIST_AU * (vx / vanth_dist)\n            bary_y = BARYCENTER_DIST_AU * (vy / vanth_dist)\n            bary_z = BARYCENTER_DIST_AU * (vz / vanth_dist)\n        else:\n            bary_x, bary_y, bary_z = BARYCENTER_DIST_AU, 0, 0\n    else:\n        # Fallback: place on +X axis\n        bary_x, bary_y, bary_z = BARYCENTER_DIST_AU, 0, 0\n    \n    hover_text = (\n        f\"<b>Orcus-Vanth Barycenter</b><br>\"\n        f\"<i>Center of mass - HIGHEST mass ratio binary!</i><br><br>\"\n        f\"Distance from Orcus center: ~1,230 km<br>\"\n        f\"Distance from Orcus surface: ~775 km<br>\"\n        f\"<br><b>Why this matters:</b><br>\"\n        f\"<i>The barycenter is OUTSIDE Orcus!<br>\"\n        f\"Both Orcus and Vanth orbit this point.<br>\"\n        f\"Mass ratio: 16% (higher than Pluto-Charon!)<br><br>\"\n        f\"ALMA 2016 directly resolved this<br>\"\n        f\"barycentric wobble for the first time.<br><br>\"\n        f\"Vanth is likely an intact impactor<br>\"\n        f\"from a giant collision early in<br>\"\n        f\"solar system history.</i>\"\n    )\n    \n    fig.add_trace(go.Scatter3d(\n        x=[bary_x], y=[bary_y], z=[bary_z],\n        mode='markers',\n        marker=dict(\n            size=8,\n            color=color_map('Orcus'),\n            symbol='square-open',\n        ),\n        name='Orcus-Vanth Barycenter',\n        text=[hover_text],\n        hovertemplate='%{text}<extra></extra>',\n        showlegend=True\n    ))\n    \n    print(f\"  [OK] Added Orcus-Vanth barycenter marker at ({bary_x:.7f}, {bary_y:.7f}, {bary_z:.7f}) AU\", flush=True)\n    \n    return fig",
    "start_line": 2477,
    "end_line": 2542,
    "has_docstring": true,
    "docstring": "Add the Orcus-Vanth barycenter marker to Orcus-centered view.\n\nThe barycenter is ~1,230 km from Orcus's center toward Vanth.\nThis is OUTSIDE Orcus's surface (radius ~455 km)!\n\nParameters:\n    fig: Plotly figure\n    date: Current date for position calculation\n    vanth_position: Dict with Vanth's x, y, z position (if available)",
    "parameters": [
      "fig",
      "date",
      "vanth_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_orcus_barycenter_marker",
    "component_id": "idealized_orbits.add_orcus_barycenter_marker"
  },
  "idealized_orbits.plot_gonggong_xiangliu_orbit": {
    "id": "idealized_orbits.plot_gonggong_xiangliu_orbit",
    "name": "plot_gonggong_xiangliu_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [],
    "source_code": "def plot_gonggong_xiangliu_orbit(fig, object_name, date, color, show_apsidal_markers=False, center_id='Gonggong'):\n    \"\"\"\n    Plot analytical orbit for Xiangliu around Gonggong.\n    \n    Gonggong-centered only (barycenter mode removed - mass ratio ~0.013 means\n    barycenter is only ~312 km from Gonggong center, inside the ~615 km body).\n    \n    Binary System Parameters (from Kiss et al. 2017, 2019; Astronoo):\n    - Total separation: 24,021 km = 0.0001606 AU\n    - Period: 25.22 days (Xiangliu likely tidally locked)\n    - Mass ratio: M_Xiangliu/M_Gonggong = 0.013\n    - Eccentricity: 0.29 (highly eccentric - unusual for TNO binaries)\n    - Inclination to ecliptic: ~83 deg (nearly pole-on from Earth)\n    \n    NOTE: Neither 920225088 (primary) nor 120225088 (secondary) work at JPL Horizons.\n    Only the barycenter (20225088) has ephemeris. All component orbits are analytical.\n    \"\"\"\n    \n    # Binary system physical parameters\n    BINARY_PARAMS = {\n        'separation_km': 24021,                # Total separation (Kiss et al. 2017)\n        'separation_au': 0.0001606,            # = 24,021 km in AU\n        'period_days': 25.22,                  # Orbital period\n        'eccentricity': 0.29,                  # Highly eccentric (Kiss et al. 2017)\n        'inclination_ecliptic': 83.0,          # Inclination to ecliptic (degrees)\n        'Omega_ecliptic': 0.0,                 # LAN unknown - assume 0\n        'omega': 0.0,                          # Arg of periapsis unknown - assume 0\n    }\n    \n    if object_name != 'Xiangliu':\n        print(f\"Warning: plot_gonggong_xiangliu_orbit only handles Xiangliu, got {object_name}\", flush=True)\n        return fig\n    \n    try:\n        # Xiangliu orbits Gonggong at full separation\n        a = BINARY_PARAMS['separation_au']  # 0.0001606 AU\n        e = BINARY_PARAMS['eccentricity']\n        i = BINARY_PARAMS['inclination_ecliptic']\n        omega = BINARY_PARAMS['omega']\n        Omega = BINARY_PARAMS['Omega_ecliptic']\n        period = BINARY_PARAMS['period_days']\n        \n        epoch_str = f\"{date.strftime('%Y-%m-%d')} osc.\"\n        \n        print(f\"\\n[GONGGONG-CENTERED] Xiangliu: using Kiss et al. 2017/2019 analytical orbit\", flush=True)\n        print(f\"  a = {a:.10f} AU ({a * 149597870.7:.1f} km from Gonggong)\", flush=True)\n        print(f\"  e = {e:.4f}, i = {i:.1f} deg, Omega = {Omega:.1f} deg\", flush=True)\n        \n        # Generate ellipse points\n        theta = np.linspace(0, 2*np.pi, 360)\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        \n        # Orbital plane coordinates\n        x_orb = r * np.cos(theta)\n        y_orb = r * np.sin(theta)\n        z_orb = np.zeros_like(theta)\n        \n        # Rotate to ecliptic frame\n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n        \n        x_ecl, y_ecl, z_ecl = [], [], []\n        for x0, y0, z0 in zip(x_orb, y_orb, z_orb):\n            # Rotation by argument of periapsis (omega)\n            x1 = x0 * np.cos(omega_rad) - y0 * np.sin(omega_rad)\n            y1 = x0 * np.sin(omega_rad) + y0 * np.cos(omega_rad)\n            z1 = z0\n            \n            # Rotation by inclination (i)\n            x2 = x1\n            y2 = y1 * np.cos(i_rad) - z1 * np.sin(i_rad)\n            z2 = y1 * np.sin(i_rad) + z1 * np.cos(i_rad)\n            \n            # Rotation by longitude of ascending node (Omega)\n            x3 = x2 * np.cos(Omega_rad) - y2 * np.sin(Omega_rad)\n            y3 = x2 * np.sin(Omega_rad) + y2 * np.cos(Omega_rad)\n            z3 = z2\n            \n            x_ecl.append(x3)\n            y_ecl.append(y3)\n            z_ecl.append(z3)\n        \n        # Create hover text\n        hover_text = (\n            f\"<b>Xiangliu Analytical Orbit</b><br>\"\n            f\"Orbit around Gonggong<br>\"\n            f\"<br>a = {a*149597870.7:.1f} km ({a:.2e} AU)<br>\"\n            f\"P = {period:.2f} days<br>\"\n            f\"e = {e:.2f} (highly eccentric - unusual for TNO binaries)<br>\"\n            f\"i = {i:.1f} deg (to ecliptic, nearly pole-on)<br>\"\n            f\"<br><b>Xiangliu</b><br>\"\n            f\"Diameter: ~100 km (upper limit from tidal evolution)<br>\"\n            f\"Nine-headed serpent minister of water god Gonggong<br>\"\n            f\"<br><b>Data Sources:</b><br>\"\n            f\"Orbit: Kiss et al. 2017, 2019 (ApJ Letters, Icarus)\"\n        )\n        \n        # Plot the orbit\n        fig.add_trace(\n            go.Scatter3d(\n                x=x_ecl,\n                y=y_ecl,\n                z=z_ecl,\n                mode='lines',\n                line=dict(color=color, width=2, dash='dash'),\n                name=f\"Xiangliu Analytical Orbit (Epoch: {epoch_str})\",\n                text=[hover_text] * len(x_ecl),\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            )\n        )\n        \n        print(f\"  [OK] Plotted Xiangliu analytical orbit ({len(x_ecl)} points)\", flush=True)\n        \n        # Apsidal markers for eccentric orbit (e=0.29, so meaningful)\n        if show_apsidal_markers and e > 0.001:\n            # Periapsis (closest approach)\n            peri_r = a * (1 - e)\n            peri_x_orb = peri_r  # Along x-axis in orbital plane\n            \n            # Rotate periapsis to ecliptic\n            x1 = peri_x_orb * np.cos(omega_rad)\n            y1 = peri_x_orb * np.sin(omega_rad)\n            z1 = 0.0\n            x2 = x1\n            y2 = y1 * np.cos(i_rad)\n            z2 = y1 * np.sin(i_rad)\n            peri_x = x2 * np.cos(Omega_rad) - y2 * np.sin(Omega_rad)\n            peri_y = x2 * np.sin(Omega_rad) + y2 * np.cos(Omega_rad)\n            peri_z = z2\n            \n            peri_hover = (\n                f\"<b>Xiangliu Keplerian Periapsis</b><br>\"\n                f\"q = {peri_r:.7f} AU ({peri_r * 149597870.7:.1f} km)<br>\"\n                f\"e = {e:.2f}\"\n            )\n            \n            fig.add_trace(go.Scatter3d(\n                x=[peri_x], y=[peri_y], z=[peri_z],\n                mode='markers',\n                marker=dict(color=color, size=6, symbol='square-open'),\n                name=f\"Xiangliu Keplerian Periapsis\",\n                text=[peri_hover],\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            ))\n            \n            # Apoapsis (farthest point)\n            apo_r = a * (1 + e)\n            apo_x_orb = -apo_r  # Opposite direction in orbital plane\n            \n            # Rotate apoapsis to ecliptic\n            x1 = apo_x_orb * np.cos(omega_rad)\n            y1 = apo_x_orb * np.sin(omega_rad)\n            z1 = 0.0\n            x2 = x1\n            y2 = y1 * np.cos(i_rad)\n            z2 = y1 * np.sin(i_rad)\n            apo_x = x2 * np.cos(Omega_rad) - y2 * np.sin(Omega_rad)\n            apo_y = x2 * np.sin(Omega_rad) + y2 * np.cos(Omega_rad)\n            apo_z = z2\n            \n            apo_hover = (\n                f\"<b>Xiangliu Keplerian Apoapsis</b><br>\"\n                f\"Q = {apo_r:.7f} AU ({apo_r * 149597870.7:.1f} km)<br>\"\n                f\"e = {e:.2f}\"\n            )\n            \n            fig.add_trace(go.Scatter3d(\n                x=[apo_x], y=[apo_y], z=[apo_z],\n                mode='markers',\n                marker=dict(color=color, size=6, symbol='square-open'),\n                name=f\"Xiangliu Keplerian Apoapsis\",\n                text=[apo_hover],\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            ))\n            \n            print(f\"  [OK] Added apsidal markers: q={peri_r*149597870.7:.1f} km, Q={apo_r*149597870.7:.1f} km\", flush=True)\n        \n        return fig\n        \n    except Exception as ex:\n        print(f\"Error plotting Xiangliu orbit: {ex}\", flush=True)\n        traceback.print_exc()\n        return fig",
    "start_line": 2545,
    "end_line": 2731,
    "has_docstring": true,
    "docstring": "Plot analytical orbit for Xiangliu around Gonggong.\n\nGonggong-centered only (barycenter mode removed - mass ratio ~0.013 means\nbarycenter is only ~312 km from Gonggong center, inside the ~615 km body).\n\nBinary System Parameters (from Kiss et al. 2017, 2019; Astronoo):\n- Total separation: 24,021 km = 0.0001606 AU\n- Period: 25.22 days (Xiangliu likely tidally locked)\n- Mass ratio: M_Xiangliu/M_Gonggong = 0.013\n- Eccentricity: 0.29 (highly eccentric - unusual for TNO binaries)\n- Inclination to ecliptic: ~83 deg (nearly pole-on from Earth)\n\nNOTE: Neither 920225088 (primary) nor 120225088 (secondary) work at JPL Horizons.\nOnly the barycenter (20225088) has ephemeris. All component orbits are analytical.",
    "parameters": [
      "fig",
      "object_name",
      "date",
      "color",
      "show_apsidal_markers",
      "center_id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_gonggong_xiangliu_orbit",
    "component_id": "idealized_orbits.plot_gonggong_xiangliu_orbit"
  },
  "idealized_orbits.plot_patroclus_barycenter_orbit": {
    "id": "idealized_orbits.plot_patroclus_barycenter_orbit",
    "name": "plot_patroclus_barycenter_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [],
    "source_code": "def plot_patroclus_barycenter_orbit(fig, object_name, date, color, show_apsidal_markers=False, center_id='Patroclus-Menoetius Barycenter'):\n    \"\"\"\n    Plot analytical orbit for objects in the Patroclus-Menoetius binary Trojan system.\n    \n    When \"Patroclus-Menoetius Barycenter\" is the center:\n    - Patroclus orbits the barycenter (~152 km from center, 78% of mass)\n    - Menoetius orbits the barycenter (~540 km from center, 22% of mass)\n    \n    Binary System Parameters (from Brozovic et al. 2024, AJ 167:104):\n    - Total separation: 692.5 +/- 4.0 km = 0.00000463 AU\n    - Period: 4.282680 +/- 0.000063 days (doubly synchronous)\n    - Mass ratio: M_Patroclus/M_total = 0.7798, M_Menoetius/M_total = 0.2202\n    - Eccentricity: 0.004 +/- 0.004 (nearly circular)\n    - System GM: 0.09498 km^3/s^2\n    \n    Orbital plane orientation from JPL Horizons osculating elements:\n    - Inclination: 152.53 deg (to J2000 ecliptic)\n    - Longitude of Ascending Node: 324.12 deg\n    \n    Phase reference from JPL Horizons vectors (Patroclus @ barycenter):\n    - Epoch: 2033-Mar-03 00:00:00 TDB (JD 2463659.5)\n    - Position: X=104.24, Y=-109.12, Z=14.35 km\n    \"\"\"\n    import numpy as np\n    import plotly.graph_objects as go\n    from datetime import datetime\n    \n    # Binary system physical parameters (from Brozovic et al. 2024)\n    BINARY_PARAMS = {\n        'separation_km': 692.5,               # Total separation in km\n        'separation_au': 692.5 / 149597870.7, # 0.00000463 AU\n        'period_days': 4.282680,              # Orbital period (doubly synchronous)\n        'mass_fraction_patroclus': 0.7798,    # Patroclus mass / total mass\n        'mass_fraction_menoetius': 0.2202,    # Menoetius mass / total mass\n        'eccentricity': 0.004,                # Nearly circular\n        # Orbital plane from JPL Horizons osculating elements (barycenter-centered):\n        'inclination_ecliptic': 152.53,       # From Horizons IN value\n        'Omega_ecliptic': 324.12,             # From Horizons OM value\n        'omega': 0.0,                         # Argument of periapsis (undefined for circular)\n    }\n    \n    # Phase reference from JPL Horizons vectors\n    # Patroclus position relative to barycenter on 2033-Mar-03 00:00:00 TDB\n    PHASE_REFERENCE = {\n        'jd_epoch': 2463659.5,                # 2033-Mar-03 00:00:00 TDB\n        'patroclus_x_km': 104.2448,           # X position (km)\n        'patroclus_y_km': -109.1216,          # Y position (km)  \n        'patroclus_z_km': 14.3532,            # Z position (km)\n    }\n    \n    separation = BINARY_PARAMS['separation_au']\n    \n    is_barycenter_mode = (center_id == 'Patroclus-Menoetius Barycenter')\n    \n    if not is_barycenter_mode:\n        print(f\"Warning: plot_patroclus_barycenter_orbit only supports barycenter mode\", flush=True)\n        return fig\n    \n    if object_name not in ['Patroclus', 'Menoetius']:\n        print(f\"Warning: {object_name} is not part of Patroclus-Menoetius system\", flush=True)\n        return fig\n    \n    try:\n        # Calculate semi-major axis from mass fractions\n        # Heavier body (Patroclus, 78%) is CLOSER to barycenter\n        # Lighter body (Menoetius, 22%) is FARTHER from barycenter\n        if object_name == 'Patroclus':\n            a = separation * BINARY_PARAMS['mass_fraction_menoetius']  # ~152 km\n            phase_offset = 0.0  # Patroclus is the reference\n        else:  # Menoetius\n            a = separation * BINARY_PARAMS['mass_fraction_patroclus']  # ~540 km\n            phase_offset = 180.0  # Menoetius is opposite Patroclus\n        \n        e = BINARY_PARAMS['eccentricity']\n        i = BINARY_PARAMS['inclination_ecliptic']\n        omega = BINARY_PARAMS['omega']\n        Omega = BINARY_PARAMS['Omega_ecliptic']\n        period = BINARY_PARAMS['period_days']\n        \n        # Calculate the reference phase angle from Horizons position\n        # First, we need to transform the ecliptic XYZ to orbital plane coordinates\n        # to find the true anomaly at the reference epoch\n        \n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n        \n        # Reference position in ecliptic coordinates (km -> AU)\n        ref_x = PHASE_REFERENCE['patroclus_x_km'] / 149597870.7\n        ref_y = PHASE_REFERENCE['patroclus_y_km'] / 149597870.7\n        ref_z = PHASE_REFERENCE['patroclus_z_km'] / 149597870.7\n        \n        # Inverse rotation: Ecliptic -> Orbital plane\n        # Step 1: Rotate by -Omega around Z\n        x1 = ref_x * np.cos(-Omega_rad) - ref_y * np.sin(-Omega_rad)\n        y1 = ref_x * np.sin(-Omega_rad) + ref_y * np.cos(-Omega_rad)\n        z1 = ref_z\n        \n        # Step 2: Rotate by -i around X\n        x2 = x1\n        y2 = y1 * np.cos(-i_rad) - z1 * np.sin(-i_rad)\n        z2 = y1 * np.sin(-i_rad) + z1 * np.cos(-i_rad)\n        \n        # Step 3: Rotate by -omega around Z\n        x_orb = x2 * np.cos(-omega_rad) - y2 * np.sin(-omega_rad)\n        y_orb = x2 * np.sin(-omega_rad) + y2 * np.cos(-omega_rad)\n        \n        # Now x_orb, y_orb are in the orbital plane\n        # The true anomaly at reference epoch\n        ref_true_anomaly = np.degrees(np.arctan2(y_orb, x_orb))\n        \n        # Calculate current epoch's Julian Date\n        # Python datetime to JD approximation\n        jd_2000 = 2451545.0  # J2000.0 = 2000-Jan-01 12:00:00\n        days_since_2000 = (date - datetime(2000, 1, 1, 12, 0, 0)).total_seconds() / 86400.0\n        current_jd = jd_2000 + days_since_2000\n        \n        # Days elapsed since reference epoch\n        days_elapsed = current_jd - PHASE_REFERENCE['jd_epoch']\n        \n        # Orbital phase change (degrees) - for nearly circular orbit, mean anomaly ~ true anomaly\n        phase_change = 360.0 * (days_elapsed / period)\n        \n        # Current true anomaly for this object\n        current_phase = ref_true_anomaly + phase_change + phase_offset\n        \n        epoch_str = f\"{date.strftime('%Y-%m-%d')} osc.\"\n        \n        print(f\"\\n[PATROCLUS BARYCENTER] {object_name}: using Brozovic et al. 2024 + Horizons phase\", flush=True)\n        print(f\"  a = {a:.10f} AU ({a * 149597870.7:.1f} km from barycenter)\", flush=True)\n        print(f\"  e = {e:.4f}, i = {i:.1f} deg, Omega = {Omega:.1f} deg\", flush=True)\n        print(f\"  Reference phase (Patroclus): {ref_true_anomaly:.1f} deg at JD {PHASE_REFERENCE['jd_epoch']}\", flush=True)\n        print(f\"  Days from reference: {days_elapsed:.2f}, Phase change: {phase_change:.1f} deg\", flush=True)\n        print(f\"  Current phase for {object_name}: {current_phase % 360:.1f} deg\", flush=True)\n        \n        # Generate ellipse points starting from current phase\n        # This ensures the orbit is drawn in the correct orientation\n        theta = np.linspace(0, 2*np.pi, 360)\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        \n        # Orbital plane coordinates (periapsis along x-axis)\n        x_orb = r * np.cos(theta)\n        y_orb = r * np.sin(theta)\n        z_orb = np.zeros_like(theta)\n        \n        # Rotate to ecliptic frame using standard orbital element rotations\n        x_ecl, y_ecl, z_ecl = [], [], []\n        for x0, y0, z0 in zip(x_orb, y_orb, z_orb):\n            # Rotation by argument of periapsis (omega)\n            x1 = x0 * np.cos(omega_rad) - y0 * np.sin(omega_rad)\n            y1 = x0 * np.sin(omega_rad) + y0 * np.cos(omega_rad)\n            z1 = z0\n            \n            # Rotation by inclination (i)\n            x2 = x1\n            y2 = y1 * np.cos(i_rad) - z1 * np.sin(i_rad)\n            z2 = y1 * np.sin(i_rad) + z1 * np.cos(i_rad)\n            \n            # Rotation by longitude of ascending node (Omega)\n            x3 = x2 * np.cos(Omega_rad) - y2 * np.sin(Omega_rad)\n            y3 = x2 * np.sin(Omega_rad) + y2 * np.cos(Omega_rad)\n            z3 = z2\n            \n            x_ecl.append(x3)\n            y_ecl.append(y3)\n            z_ecl.append(z3)\n        \n        # Create hover text\n        hover_text = (\n            f\"<b>{object_name} Analytical Orbit</b><br>\"\n            f\"Binary orbit around barycenter<br>\"\n            f\"a = {a*149597870.7:.1f} km ({a:.2e} AU)<br>\"\n            f\"P = {period:.3f} days<br>\"\n            f\"e = {e:.4f}<br>\"\n            f\"i = {i:.1f} deg (to ecliptic)<br>\"\n            f\"Source: Brozovic et al. 2024 (AJ 167:104)\"\n        )\n        \n        # Plot the orbit\n        fig.add_trace(\n            go.Scatter3d(\n                x=x_ecl,\n                y=y_ecl,\n                z=z_ecl,\n                mode='lines',\n                line=dict(color=color, width=2, dash='dot'),\n                name=f\"{object_name} Analytical Orbit (Epoch: {epoch_str})\",\n                text=[hover_text] * len(x_ecl),\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            )\n        )\n        \n        print(f\"  [OK] Plotted {object_name} analytical orbit ({len(x_ecl)} points)\", flush=True)\n        \n        # Add current position marker based on calculated phase\n        if show_apsidal_markers:\n            # Calculate current position using current_phase\n            current_phase_rad = np.radians(current_phase)\n            r_current = a * (1 - e**2) / (1 + e * np.cos(current_phase_rad))\n            \n            # Position in orbital plane\n            x_pos = r_current * np.cos(current_phase_rad)\n            y_pos = r_current * np.sin(current_phase_rad)\n            z_pos = 0\n            \n            # Rotate to ecliptic\n            x1 = x_pos * np.cos(omega_rad) - y_pos * np.sin(omega_rad)\n            y1 = x_pos * np.sin(omega_rad) + y_pos * np.cos(omega_rad)\n            z1 = z_pos\n            \n            x2 = x1\n            y2 = y1 * np.cos(i_rad) - z1 * np.sin(i_rad)\n            z2 = y1 * np.sin(i_rad) + z1 * np.cos(i_rad)\n            \n            x_curr_ecl = x2 * np.cos(Omega_rad) - y2 * np.sin(Omega_rad)\n            y_curr_ecl = x2 * np.sin(Omega_rad) + y2 * np.cos(Omega_rad)\n            z_curr_ecl = z2\n            \n            pos_hover = (\n                f\"<b>{object_name} Keplerian Position</b><br>\"\n                f\"Phase: {current_phase % 360:.1f} deg<br>\"\n                f\"r = {r_current*149597870.7:.1f} km ({r_current:.2e} AU)<br>\"\n                f\"e = {e:.4f} (nearly circular)<br>\"\n                f\"<i>Note: For nearly circular orbits, periapsis is undefined.</i><br>\"\n                f\"<i>This marker shows the current calculated position,</i><br>\"\n                f\"<i>which should match the Horizons actual position.</i>\"\n            )\n            \n            fig.add_trace(\n                go.Scatter3d(\n                    x=[x_curr_ecl],\n                    y=[y_curr_ecl],\n                    z=[z_curr_ecl],\n                    mode='markers',\n                    marker=dict(color=color, size=6, symbol='square'),\n                    name=f\"{object_name} Keplerian Periapsis\",\n                    text=[pos_hover],\n                    hovertemplate='%{text}<extra></extra>',\n                    showlegend=True\n                )\n            )\n        \n    except Exception as ex:\n        import traceback\n        print(f\"Error plotting {object_name} barycenter orbit: {ex}\", flush=True)\n        traceback.print_exc()\n    \n    return fig",
    "start_line": 2734,
    "end_line": 2982,
    "has_docstring": true,
    "docstring": "Plot analytical orbit for objects in the Patroclus-Menoetius binary Trojan system.\n\nWhen \"Patroclus-Menoetius Barycenter\" is the center:\n- Patroclus orbits the barycenter (~152 km from center, 78% of mass)\n- Menoetius orbits the barycenter (~540 km from center, 22% of mass)\n\nBinary System Parameters (from Brozovic et al. 2024, AJ 167:104):\n- Total separation: 692.5 +/- 4.0 km = 0.00000463 AU\n- Period: 4.282680 +/- 0.000063 days (doubly synchronous)\n- Mass ratio: M_Patroclus/M_total = 0.7798, M_Menoetius/M_total = 0.2202\n- Eccentricity: 0.004 +/- 0.004 (nearly circular)\n- System GM: 0.09498 km^3/s^2\n\nOrbital plane orientation from JPL Horizons osculating elements:\n- Inclination: 152.53 deg (to J2000 ecliptic)\n- Longitude of Ascending Node: 324.12 deg\n\nPhase reference from JPL Horizons vectors (Patroclus @ barycenter):\n- Epoch: 2033-Mar-03 00:00:00 TDB (JD 2463659.5)\n- Position: X=104.24, Y=-109.12, Z=14.35 km",
    "parameters": [
      "fig",
      "object_name",
      "date",
      "color",
      "show_apsidal_markers",
      "center_id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_patroclus_barycenter_orbit",
    "component_id": "idealized_orbits.plot_patroclus_barycenter_orbit"
  },
  "idealized_orbits.create_planet_transformation_matrix": {
    "id": "idealized_orbits.create_planet_transformation_matrix",
    "name": "create_planet_transformation_matrix",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [],
    "source_code": "def create_planet_transformation_matrix(planet_name):\n    \"\"\"\n    Create a transformation matrix for a planet based on its pole direction.\n    Transforms from planet's equatorial coordinates to ecliptic coordinates.\n    \n    Parameters:\n        planet_name (str): Name of the planet\n        \n    Returns:\n        numpy.ndarray: 3x3 transformation matrix\n    \"\"\"\n    if planet_name not in planet_poles:\n        # For planets without explicit pole directions, use the axial tilt\n        if planet_name in planet_tilts:\n            tilt_rad = np.radians(planet_tilts[planet_name])\n            # Simple rotation matrix around the x-axis\n            return np.array([\n                [1, 0, 0],\n                [0, np.cos(tilt_rad), -np.sin(tilt_rad)],\n                [0, np.sin(tilt_rad), np.cos(tilt_rad)]\n            ])\n        return np.identity(3)  # Identity matrix if no data available\n    \n    # Get pole direction\n    pole = planet_poles[planet_name]\n    ra_pole = np.radians(pole['ra'])\n    dec_pole = np.radians(pole['dec'])\n    \n    # Calculate the rotation matrix from planet's equatorial to ecliptic\n    sin_dec = np.sin(dec_pole)\n    cos_dec = np.cos(dec_pole)\n    sin_ra = np.sin(ra_pole)\n    cos_ra = np.cos(ra_pole)\n    \n    # Planet's north pole vector in ecliptic coordinates\n    x_pole = cos_dec * cos_ra\n    y_pole = cos_dec * sin_ra\n    z_pole = sin_dec\n    \n    # Find the ascending node of planet's equator on the ecliptic\n    # This is perpendicular to the pole and in the ecliptic plane\n    x_node = -y_pole / np.sqrt(x_pole**2 + y_pole**2)\n    y_node = x_pole / np.sqrt(x_pole**2 + y_pole**2)\n    z_node = 0\n    \n    # Create orthogonal basis vectors\n    x_basis = np.array([x_node, y_node, z_node])\n    z_basis = np.array([x_pole, y_pole, z_pole])\n    y_basis = np.cross(z_basis, x_basis)\n    \n    # Construct the transformation matrix\n    transform_matrix = np.vstack((x_basis, y_basis, z_basis)).T\n    \n    return transform_matrix",
    "start_line": 2984,
    "end_line": 3037,
    "has_docstring": true,
    "docstring": "Create a transformation matrix for a planet based on its pole direction.\nTransforms from planet's equatorial coordinates to ecliptic coordinates.\n\nParameters:\n    planet_name (str): Name of the planet\n    \nReturns:\n    numpy.ndarray: 3x3 transformation matrix",
    "parameters": [
      "planet_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_planet_transformation_matrix",
    "component_id": "idealized_orbits.create_planet_transformation_matrix"
  },
  "idealized_orbits.plot_satellite_orbit": {
    "id": "idealized_orbits.plot_satellite_orbit",
    "name": "plot_satellite_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "idealized_orbits.calculate_saturn_satellite_elements",
      "apsidal_markers.add_perihelion_marker",
      "idealized_orbits.calculate_jupiter_satellite_elements",
      "apsidal_markers.add_apohelion_marker",
      "idealized_orbits.calculate_mars_satellite_elements",
      "idealized_orbits.rotate_points"
    ],
    "source_code": "def plot_satellite_orbit(satellite_name, planetary_params, parent_planet, color, fig=None, \n                         date=None, days_to_plot=None, current_position=None,\n                         show_apsidal_markers=False):\n    \"\"\"\n    Plot the Keplerian orbit of a satellite around its parent planet.\n    \n    Parameters:\n        satellite_name (str): Name of the satellite\n        planetary_params (dict): Dictionary containing orbital parameters for all objects\n        parent_planet (str): Name of the parent planet\n        color (str): Color to use for the orbit line\n        fig (plotly.graph_objects.Figure): Existing figure to add the orbit to\n        date (datetime): Date for the calculation\n        days_to_plot (float): Number of days to plot\n        current_position (dict): Current position with 'x', 'y', 'z' keys\n        \n    Returns:\n        plotly.graph_objects.Figure: Figure with the satellite orbit added\n    \"\"\"\n    if fig is None:\n        fig = go.Figure()\n    \n    try:\n        # Get the orbital parameters for this specific satellite\n        if satellite_name not in planetary_params:\n            print(f\"Error: No orbital parameters found for {satellite_name}\", flush=True)\n            return fig\n            \n        orbital_params = planetary_params[satellite_name]\n        \n        # Extract orbital elements\n        a = orbital_params.get('a', 0)  # Semi-major axis in AU\n        e = orbital_params.get('e', 0)  # Eccentricity\n        i = orbital_params.get('i', 0)  # Inclination in degrees\n        omega = orbital_params.get('omega', 0)  # Argument of periapsis in degrees\n        Omega = orbital_params.get('Omega', 0)  # Longitude of ascending node in degrees\n        \n        print(f\"\\nPlotting {satellite_name} orbit around {parent_planet}\", flush=True)\n        print(f\"Orbital elements: a={a}, e={e}, i={i} deg, omega={omega} deg, Omega={Omega} deg\", flush=True)\n        \n        # Calculate angular range based on days_to_plot\n        if days_to_plot is not None and days_to_plot > 0:\n            # Get the satellite's orbital period\n            if 'orbital_period_days' in orbital_params:\n                period_days = orbital_params['orbital_period_days']\n            else:\n                # Use KNOWN_ORBITAL_PERIODS from constants_new.py\n                from constants_new import KNOWN_ORBITAL_PERIODS\n                \n                if satellite_name in KNOWN_ORBITAL_PERIODS:\n                    period_value = KNOWN_ORBITAL_PERIODS[satellite_name]\n\n                    if period_value is None:\n                        # Handle hyperbolic/parabolic objects - use Kepler's law\n                        period_days = 365.25 * np.sqrt(abs(a)**3) if a else 365.25\n\n                    else:\n                        # Already in days\n                        period_days = period_value\n                else:\n                    # Fallback for unknown satellites\n                    print(f\"  Warning: No known period for {satellite_name}, using default\", flush=True)\n                    period_days = 10  # Default fallback\n            \n            orbital_fraction = days_to_plot / period_days\n            max_angle = 2 * np.pi * orbital_fraction\n            \n            # Generate orbit points only for the requested time range\n            num_points = max(30, int(360 * min(orbital_fraction, 1.0)))  # At least 30 points\n            theta = np.linspace(0, max_angle, num_points)\n            print(f\"  Plotting {days_to_plot} days = {orbital_fraction:.2f} orbits (period: {period_days:.3f} days)\", flush=True)\n        else:\n            # Full orbit\n            theta = np.linspace(0, 2*np.pi, 360)  # 360 points for smoothness\n\n        # Generate ellipse in orbital plane\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        \n        x_orbit = r * np.cos(theta)\n        y_orbit = r * np.sin(theta)\n        z_orbit = np.zeros_like(theta)\n\n        # Convert angles to radians\n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n\n        # Standard orbital element rotation sequence\n        # 1. Longitude of ascending node (Omega) around z-axis\n        x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, Omega_rad, 'z')\n        # 2. Inclination (i) around x-axis\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n        # 3. Argument of periapsis (omega) around z-axis\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, omega_rad, 'z')\n        \n        # Transformation from a planet's equatorial frame to ecliptic frame:\n        # \n        # This solution follows an important pattern we discovered across multiple planetary systems:\n        # - For Mars satellites: Y-axis rotation of 25.19 deg (Mars's axial tilt) aligns orbits properly\n        # - For Uranus satellites: Matching X and Y rotations of 97.77 deg (Uranus's axial tilt) creates proper alignment\n        #\n        # General principle: When satellite orbital elements are defined in a planet's equatorial reference frame\n        # (as documented by JPL), the transformation to the ecliptic frame must incorporate the planet's axial tilt\n        # in a manner that reflects the planet's specific orientation in space.\n        #\n        # For planets with moderate axial tilts (Mars), a single rotation may suffice.\n        # For planets with extreme axial tilts (Uranus), compound rotations around multiple axes are required.\n        #\n        # This transformation correctly maps from the satellite's native reference frame (the planet's equator)\n        # to the ecliptic reference frame used in our visualization.\n\n        # Apply transformation based on the planet\n        if parent_planet == 'Mars':\n            # This 25 deg value is particularly interesting because it's very close to Mars' axial tilt of 25.19 deg. \n            # This suggests there might be a direct relationship between Mars' axial tilt and the reference frame used \n            # for defining its satellites' orbital elements. The fact that Deimos aligns better at 25 deg while Phobos aligns \n            # better at 26 deg could be related to: 1) Small differences in how each moon's orbital elements were measured or \n            # calculated. 2) The fact that Phobos orbits much closer to Mars and might be more affected by Mars' non-spherical \n            # gravity field 3) Possible time-dependent variations in the orbital planes. To put this discovery in context: we've \n            # essentially found that Mars' moons' orbital elements are defined in a reference frame that requires a Y-axis \n            # rotation approximately equal to Mars' axial tilt to align with the ecliptic reference frame used in your \n            # visualization. This makes intuitive sense astronomically, as it suggests the orbital elements are defined relative \n            # to Mars' equatorial plane.\n            #\n            # Using Mars' exact axial tilt (25.19 deg) as the Y-axis rotation value creates a perfect astronomical justification \n            # for the transformation. It strongly suggests that the orbital elements for Mars' satellites are indeed defined \n            # relative to Mars' equatorial plane, which makes sense from a planetary science perspective.\n            #\n            # \"Reference Frame Note: The orbital elements for Mars' satellites (Phobos and Deimos) are provided relative to \n            # Mars' equatorial plane. When transforming these elements to ecliptic coordinates for visualization, a rotation \n            # of 25.19 deg around the Y-axis (equivalent to Mars' axial tilt) should be applied after the standard orbital element \n            # rotations.\"\n            # \n            # A Y-axis rotation (not X) is needed because it represents a rotation around \n            # the ecliptic plane's normal axis, which correctly positions the orbital planes\n            # of Phobos and Deimos relative to Mars' orbital plane.\n\n            # Transform from Mars equatorial to ecliptic coordinates\n            # Using Mars' axial tilt. Note: A small (~10-20 deg) offset remains\n            # between Keplerian and actual orbits, likely due to JPL's specific\n            # convention for defining the ascending node reference.\n\n            #Different reference conventions: JPL might use a slightly different convention for defining the ascending node that \n            # we haven't identified         \n            # Small systematic errors: The ~10-20 deg offset might be inherent to how the orbital elements are defined\n            # Time-dependent effects: Small variations in Mars' orientation that aren't captured in a static transformation\n\n            # Your time-varying elements are working correctly:\n            # Omega change: -157.9 deg per year (matches expected -158 deg)\n            # omega change: 27.0 deg per year (matches expected +27 deg)\n            #This confirms the precession calculations are accurate.\n\n            if date is not None:\n                # Override static orbital elements with time-varying ones\n                orbital_params = calculate_mars_satellite_elements(date, satellite_name)\n                print(f\"Using time-varying elements for {satellite_name} at {date}\", flush=True)\n                \n                # Re-extract the updated orbital elements\n                a = orbital_params.get('a', 0)\n                e = orbital_params.get('e', 0)\n                i = orbital_params.get('i', 0)\n                omega = orbital_params.get('omega', 0)\n                Omega = orbital_params.get('Omega', 0)\n                \n                print(f\"  Time-varying: a={a:.6f} AU, e={e:.6f}, i={i:.2f} deg, omega={omega:.2f} deg, Omega={Omega:.2f} deg\", flush=True)\n\n                # Regenerate the orbit with new elements\n                theta = np.linspace(0, 2*np.pi, 360)\n                r = a * (1 - e**2) / (1 + e * np.cos(theta))\n                \n                x_orbit = r * np.cos(theta)\n                y_orbit = r * np.sin(theta)\n                z_orbit = np.zeros_like(theta)\n                \n                # Convert updated angles to radians\n                i_rad = np.radians(i)\n                omega_rad = np.radians(omega)\n                Omega_rad = np.radians(Omega)\n                \n                # Apply standard orbital rotations with updated elements\n                x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, Omega_rad, 'z')\n                x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n                x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, omega_rad, 'z')\n\n            # The Y-rotation of 25.19 deg suggests the node reference is already \n            # aligned with the ecliptic in some way. However, there's still\n            # a visible offset in your plot.\n            \n            # Try this refined approach: -- not used because it does not resolve the discrepancy\n            # 1. First apply a small Z-rotation to account for the remaining offset\n    #        z_adjustment = np.radians(15)  # Tune this based on the visual offset. \n    #        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, z_adjustment, 'z')\n            \n            # 2. Then apply the Mars tilt\n\n            mars_y_rotation = np.radians(25.19)\n            x_final, y_final, z_final = rotate_points(x_temp, y_temp, z_temp, mars_y_rotation, 'y')\n            print(f\"Transformation applied: Mars with Y-axis rotation of 25.19 deg\", flush=True)   \n\n    #        z_adjustment = np.radians(10)  # Shift the z adjustment after the y adjustment -- does not improve the discrepancy\n    #        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, z_adjustment, 'z') \n\n        elif parent_planet == 'Jupiter':\n            # Jupiter moons with time-varying MEAN elements\n            JUPITER_MOONS = ['Io', 'Europa', 'Ganymede', 'Callisto', \n                             'Metis', 'Adrastea', 'Amalthea', 'Thebe']\n            \n            if satellite_name in JUPITER_MOONS and date is not None:\n                # Get time-varying mean elements\n                time_varying_params = calculate_jupiter_satellite_elements(date, satellite_name)\n                \n                if time_varying_params is not None:\n                    print(f\"Using time-varying MEAN elements for {satellite_name} at {date}\", flush=True)\n                    \n                    # Re-extract updated elements\n                    a = time_varying_params.get('a', 0)\n                    e = time_varying_params.get('e', 0)\n                    i = time_varying_params.get('i', 0)\n                    omega = time_varying_params.get('omega', 0)\n                    Omega = time_varying_params.get('Omega', 0)\n                    \n                    print(f\"  Mean elements: a={a:.6f} AU, e={e:.6f}, i={i:.4f} deg (Jupiter eq)\", flush=True)\n                    \n                    # Regenerate orbit with updated elements\n                    theta = np.linspace(0, 2*np.pi, 360)\n                    r = a * (1 - e**2) / (1 + e * np.cos(theta))\n                    \n                    x_orbit = r * np.cos(theta)\n                    y_orbit = r * np.sin(theta)\n                    z_orbit = np.zeros_like(theta)\n                    \n                    # Apply rotations\n                    i_rad = np.radians(i)\n                    omega_rad = np.radians(omega)\n                    Omega_rad = np.radians(Omega)\n                    \n                    x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, Omega_rad, 'z')\n                    x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n                    x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, omega_rad, 'z')\n            \n            # Transform from Jupiter equatorial to ecliptic\n            jupiter_tilt = np.radians(3.13)\n            x_final, y_final, z_final = rotate_points(x_temp, y_temp, z_temp, jupiter_tilt, 'x')\n            print(f\"  Transform: Jupiter equatorial [OK] ecliptic (3.13 deg X-rotation)\", flush=True)\n\n        elif parent_planet == 'Saturn':\n            if satellite_name == 'Phoebe':\n                # Special transformation for Phoebe - irregular retrograde satellite\n                # From JPL Horizons header: \"mean values with respect to local Laplace plane\"\n                \n                # Transform from Laplace plane to ecliptic:\n                # 1. First align with Saturn's orbital plane\n                saturn_orbit_inc = np.radians(2.485)  # Saturn's orbital inclination\n                saturn_orbit_node = np.radians(113.665)  # Saturn's ascending node\n                \n                # 2. Apply a partial rotation between Saturn's equator and orbital plane\n                # Phoebe is far enough that Laplace plane is tilted from equatorial plane\n                laplace_tilt = np.radians(17.0)  # Increased from 15 deg based on residuals\n                \n                # 3. Additional node alignment correction\n                # Based on the Y-component difference in normals, we need a Z rotation\n                node_correction = np.radians(-30.0)  # Empirical adjustment\n                \n                # Apply transformations in sequence:\n                # a) Rotate from Laplace plane toward Saturn's orbital plane\n                x_rot1, y_rot1, z_rot1 = rotate_points(x_temp, y_temp, z_temp, -laplace_tilt, 'x')\n                \n                # b) Apply node correction to align ascending nodes\n                x_rot2, y_rot2, z_rot2 = rotate_points(x_rot1, y_rot1, z_rot1, node_correction, 'z')\n                \n                # c) Transform to ecliptic using Saturn's orbital elements\n                x_rot3, y_rot3, z_rot3 = rotate_points(x_rot2, y_rot2, z_rot2, -saturn_orbit_node, 'z')\n                x_final, y_final, z_final = rotate_points(x_rot3, y_rot3, z_rot3, -saturn_orbit_inc, 'x')\n                \n                print(f\"Transformation applied: Phoebe from Laplace plane to ecliptic (enhanced)\", flush=True)\n\n# Saturn moons (except Phoebe) - follows Jupiter pattern. The calculate_saturn_satellite_elements() function currently only has \n# elements for the 8 major moons (Mimas through Iapetus). For Pan, Daphnis, Prometheus, and Pandora, it returns None and prints a warning.\n            else:\n                # Saturn moons with time-varying MEAN elements (same pattern as Jupiter)\n                if satellite_name in SATURN_MOONS and date is not None:\n                    # Get time-varying mean elements\n                    time_varying_params = calculate_saturn_satellite_elements(date, satellite_name)\n                    \n                    if time_varying_params is not None:\n                        print(f\"Using time-varying MEAN elements for {satellite_name} at {date}\", flush=True)\n                        \n                        # Re-extract updated elements\n                        a = time_varying_params.get('a', 0)\n                        e = time_varying_params.get('e', 0)\n                        i = time_varying_params.get('i', 0)\n                        omega = time_varying_params.get('omega', 0)\n                        Omega = time_varying_params.get('Omega', 0)\n                        \n                        print(f\"  Mean elements: a={a:.6f} AU, e={e:.6f}, i={i:.4f} deg (Saturn eq)\", flush=True)\n                        \n                        # Regenerate FULL orbit with updated elements\n                        theta = np.linspace(0, 2*np.pi, 360)\n                        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n                        \n                        x_orbit = r * np.cos(theta)\n                        y_orbit = r * np.sin(theta)\n                        z_orbit = np.zeros_like(theta)\n                        \n                        # Apply rotations with updated elements\n                        i_rad = np.radians(i)\n                        omega_rad = np.radians(omega)\n                        Omega_rad = np.radians(Omega)\n                        \n                        x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, Omega_rad, 'z')\n                        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n                        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, omega_rad, 'z')\n                \n                # Transform from Saturn equatorial to ecliptic (same as Jupiter pattern)\n                saturn_tilt = np.radians(-26.73)  # Saturn's axial tilt (negative for correct direction)\n                x_final, y_final, z_final = rotate_points(x_temp, y_temp, z_temp, saturn_tilt, 'x')\n                print(f\"  Transform: Saturn equatorial [OK] ecliptic (-26.73 deg X-rotation)\", flush=True)\n\n        elif parent_planet == 'Uranus':\n            # Transformation from Uranus's equatorial frame to ecliptic frame:\n            # \n            # The orbital elements in JPL Horizons are defined relative to Uranus's\n            # equatorial plane (per JPL documentation), requiring a transformation\n            # to the ecliptic reference frame used in our visualization.\n            #\n            # Our optimal transformation uses two sequential rotations:\n            # 1. First rotation (X+): 105 deg rotation around the X-axis\n            # 2. Second rotation (Y+): 105 deg rotation around the Y-axis\n            #\n            # This compound rotation of 105 deg (rather than Uranus's nominal axial tilt of 97.77 deg)\n            # was determined through empirical testing to provide the best alignment between\n            # Keplerian and actual satellite orbits. The 7 deg difference may account for:\n            #   - Reference frame subtleties not captured in simple transformations\n            #   - Uranus's magnetic field orientation (which is offset from its rotation axis)\n            #   - The combined effect of Uranus's obliquity and orbital inclination\n            #   - Possible reference epoch differences\n            #\n            # This solution follows a pattern we discovered across planetary systems:\n            # - For Mars: Y-axis rotation of ~25 deg (Mars's axial tilt) aligns satellite orbits\n            # - For Uranus: Matching X and Y rotations of 105 deg creates optimal alignment\n            #\n            # The need for dual-axis rotation reflects Uranus's unique 3D orientation\n            # in space, where its equatorial plane is nearly perpendicular to its orbital plane.\n\n            uranus_tilt = 105  # uranus tilt is 97.77 degrees            \n            \n            # First apply rotation around x-axis\n            x_rot1, y_rot1, z_rot1 = rotate_points(x_temp, y_temp, z_temp, np.radians(uranus_tilt), 'x')\n            \n            # Then apply rotation around y-axis with the same angle\n            x_final, y_final, z_final = rotate_points(x_rot1, y_rot1, z_rot1, np.radians(uranus_tilt), 'y')\n            \n            print(f\"Transformation applied: Uranus with X and Y rotations of {uranus_tilt} deg\", flush=True)\n            \n            # This transformation was determined by testing and provides the best visual alignment\n            # between the Keplerian orbits and the actual orbits of Uranian satellites\n\n        elif parent_planet == 'Neptune':\n            if satellite_name == 'Triton':\n                # Special transformation for Triton, Neptune's largest moon\n                # Triton's orbital elements are defined relative to Neptune's equatorial plane\n                # To transform to ecliptic coordinates, we use Neptune's pole orientation\n                \n                # Step 1: Rotate around z-axis by Neptune's pole Right Ascension\n                # This aligns the x-axis with the line of nodes (intersection of Neptune's equator and the ecliptic)\n                ra_pole = np.radians(planet_poles['Neptune']['ra'])\n                x_rot1, y_rot1, z_rot1 = rotate_points(x_temp, y_temp, z_temp, ra_pole, 'z')\n                \n                # Step 2: Rotate around x-axis by (90 deg - Neptune's pole Declination)\n                # This tilts the orbital plane to match Neptune's equatorial tilt relative to the ecliptic\n                dec_pole = np.radians(90 - planet_poles['Neptune']['dec'])\n                x_rot2, y_rot2, z_rot2 = rotate_points(x_rot1, y_rot1, z_rot1, dec_pole, 'x')\n                \n                # Step 3: Fine-tuning with a 3 deg z-axis rotation\n                # This small adjustment compensates for reference frame differences between\n                # Neptune's pole coordinates and Triton's orbital elements\n                x_final, y_final, z_final = rotate_points(x_rot2, y_rot2, z_rot2, np.radians(3), 'z')\n                \n                print(f\"Transformation applied: Triton with Neptune pole orientation + 3 deg z-axis adjustment\", flush=True)\n            else:\n                # Standard transformation for other Neptune satellites\n                tilt_rad = np.radians(planet_tilts['Neptune'])\n                x_final, y_final, z_final = rotate_points(x_temp, y_temp, z_temp, tilt_rad, 'x')\n\n        elif parent_planet == 'Pluto':\n            # Special case for Pluto's satellites\n            # Apply the optimized transformation: X-Tilt->Y-Tilt->Z-105\n            \n            # Get Pluto's axial tilt\n            pluto_tilt = planet_tilts.get('Pluto', -122.53)\n            pluto_tilt_rad = np.radians(pluto_tilt)\n            \n            # 1. X-axis rotation by Pluto's tilt\n            x_rotated, y_rotated, z_rotated = rotate_points(x_temp, y_temp, z_temp, pluto_tilt_rad, 'x')\n            # 2. Y-axis rotation by Pluto's tilt\n            x_rotated, y_rotated, z_rotated = rotate_points(x_rotated, y_rotated, z_rotated, pluto_tilt_rad, 'y')\n            # 3. Z-axis rotation by -105 degrees\n            z_angle = np.radians(-105)\n            x_final, y_final, z_final = rotate_points(x_rotated, y_rotated, z_rotated, z_angle, 'z')\n            \n            print(f\"Transformation applied: Pluto X-Tilt->Y-Tilt->Z-105\", flush=True)\n\n        elif parent_planet in planet_tilts:\n            # Use recorded tilt for other planets\n            tilt_rad = np.radians(planet_tilts[parent_planet])\n            x_final, y_final, z_final = rotate_points(x_temp, y_temp, z_temp, tilt_rad, 'x')\n            print(f\"Transformation applied: {parent_planet} with tilt={planet_tilts[parent_planet]} deg\", flush=True)\n            \n        else:\n            # No transformation for planets without tilt data\n            x_final, y_final, z_final = x_temp, y_temp, z_temp\n            print(f\"No transformation applied for {parent_planet} (no tilt data available)\", flush=True)\n        \n        # Create hover text for the orbit\n        # Check if epoch exists in orbital_params (from planetary_params)\n        # Do this BEFORE the Mars conditional so it's available for all satellites\n        epoch_from_data = orbital_params.get('epoch', None)\n        \n        # Special analytical note for Mars moons with time-varying elements\n\n        if parent_planet == 'Mars' and satellite_name in ['Phobos', 'Deimos']:\n            analytical_note = (\n                \"<br><br><i>Analytical orbit uses time-varying elements<br>\"\n                \"calculated for this specific date.<br>\"\n                \"<br>Elements updated based on secular variations:<br>\"\n                \"* Apsidal precession (omega changes with time)<br>\"\n                \"* Nodal regression (Omega changes with time)<br>\"\n                \"* Mars equatorial bulge gravitational field effects<br>\"\n                \"* Solar gravitational perturbations<br>\"\n                \"<br>Shows general orbital geometry valid<br>\"\n                \"over months for this epoch.</i>\"\n            )\n            date_str = date.strftime('%Y-%m-%d %H:%M UTC') if date else 'N/A'\n            hover_text = (\n                f\"{satellite_name} Analytical Orbit<br>\"\n                f\"Elements calculated for: {date_str}<br>\"\n                f\"a={a:.6f} AU<br>\"\n                f\"e={e:.6f}<br>\"\n                f\"i={i:.2f} deg\"\n                f\"{analytical_note}\"\n            )\n\n            # Check if epoch exists in orbital_params (from planetary_params)\n\n\n            # Build orbit label - use epoch from data if it exists\n            if epoch_from_data:\n                orbit_label = f\"{satellite_name} Analytical Orbit (Epoch: {epoch_from_data})\"\n            else:\n                # For Mars moons with time-varying elements, show the calculation date\n                epoch_str = date.strftime('%Y-%m-%d') if date else 'epoch'\n                orbit_label = f\"{satellite_name} Analytical Orbit (Epoch: {epoch_str})\"\n        \n        elif parent_planet == 'Jupiter' and satellite_name in ['Io', 'Europa', 'Ganymede', 'Callisto', \n                                                                'Metis', 'Adrastea', 'Amalthea', 'Thebe']:\n            # Special analytical note for Jupiter moons with time-varying elements\n            analytical_note = (\n                \"<br><br><i>Analytical orbit uses mean elements<br>\"\n                \"in Jupiter equatorial frame.<br>\"\n                \"<br>Mean orbital parameters account for:<br>\"\n                \"* Jupiter equatorial bulge gravitational field (oblateness)<br>\"\n                \"* Time-averaged perturbations<br>\"\n                \"* Orbital precession effects<br>\"\n                \"* Other Galilean moon interactions<br>\"\n                \"<br>Transformed from Jupiter equatorial<br>\"\n                \"to ecliptic frame (+3.13 deg tilt).<br>\"\n                \"<br>Shows time-averaged orbital geometry<br>\"\n                \"valid over orbital periods.</i>\"\n            )\n            date_str = date.strftime('%Y-%m-%d %H:%M UTC') if date else 'N/A'\n            hover_text = (\n                f\"{satellite_name} Analytical Orbit<br>\"\n                f\"Mean elements (Jupiter equatorial frame)<br>\"\n                f\"Calculation date: {date_str}<br>\"\n                f\"a={a:.6f} AU<br>\"\n                f\"e={e:.6f}<br>\"\n                f\"i={i:.2f} deg (before transform)\"\n                f\"{analytical_note}\"\n            )\n            \n            # Build orbit label\n            if epoch_from_data:\n                orbit_label = f\"{satellite_name} Analytical Orbit (Epoch: {epoch_from_data})\"\n            else:\n                # For Jupiter moons with time-varying elements, don't show epoch (mean elements)\n                orbit_label = f\"{satellite_name} Analytical Orbit\"\n        \n        else:\n            # All other satellites - use epoch from data if it exists\n            if epoch_from_data:\n                # Epoch exists in data - use it\n                hover_text = f\"{satellite_name} Analytical Orbit<br>Epoch: {epoch_from_data}<br>a={a:.6f} AU<br>e={e:.6f}<br>i={i:.2f} deg\"\n                orbit_label = f\"{satellite_name} Analytical Orbit (Epoch: {epoch_from_data})\"\n            else:\n                # No epoch in data - don't show one\n                hover_text = f\"{satellite_name} Analytical Orbit<br>a={a:.6f} AU<br>e={e:.6f}<br>i={i:.2f} deg\"\n                orbit_label = f\"{satellite_name} Analytical Orbit\"\n\n        # Add the orbit trace to the figure\n        fig.add_trace(\n            go.Scatter3d(\n                x=x_final,\n                y=y_final,\n                z=z_final,\n                mode='lines',\n                line=dict(dash='dot', width=1, color=color),\n                name=orbit_label,\n                text=[hover_text] * len(x_final),\n                customdata=[hover_text] * len(x_final),\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            )\n        )\n\n        # Add markers at key points\n        # Get semi-major axis in km for distance calculations        \n        # Convert semi-major axis from AU to km\n        a_km = a * 149597870.7  # 1 AU = 149,597,870.7 km\n        \n        # Find periapsis (closest approach to parent)\n        periapsis_idx = np.argmin(r)\n        \n        # Prepare orbital parameters for apsidal markers\n        orbital_params = planetary_params[satellite_name]\n        \n        # Add periapsis marker with proper date calculation\n        if show_apsidal_markers:  # ADD THIS CONDITION\n            add_perihelion_marker(\n                fig,\n                x_final[periapsis_idx],\n                y_final[periapsis_idx],\n                z_final[periapsis_idx],\n                satellite_name,\n                a,\n                e,\n                date if date else datetime.now(),\n                current_position,\n                orbital_params,\n                lambda x: color,  # Simple color function\n                q=r[periapsis_idx], # Pass the periapsis distance\n                center_body=parent_planet  # Use parent planet for terminology\n            )\n\n        # Find apoapsis (farthest point from parent)\n        apoapsis_idx = np.argmax(r)\n        \n        # Add apoapsis marker with proper date calculation\n        if show_apsidal_markers:  # ADD THIS CONDITION\n            add_apohelion_marker(\n                fig,\n                x_final[apoapsis_idx],\n                y_final[apoapsis_idx],\n                z_final[apoapsis_idx],\n                satellite_name,\n                a,\n                e,\n                date if date else datetime.now(),\n                current_position,\n                orbital_params,\n                lambda x: color,  # Simple color function\n                center_body=parent_planet  # Use parent planet for terminology\n            )\n        \n        return fig\n    \n    except Exception as e:\n        print(f\"Error plotting {satellite_name} orbit: {e}\", flush=True)\n        return fig",
    "start_line": 3039,
    "end_line": 3606,
    "has_docstring": true,
    "docstring": "Plot the Keplerian orbit of a satellite around its parent planet.\n\nParameters:\n    satellite_name (str): Name of the satellite\n    planetary_params (dict): Dictionary containing orbital parameters for all objects\n    parent_planet (str): Name of the parent planet\n    color (str): Color to use for the orbit line\n    fig (plotly.graph_objects.Figure): Existing figure to add the orbit to\n    date (datetime): Date for the calculation\n    days_to_plot (float): Number of days to plot\n    current_position (dict): Current position with 'x', 'y', 'z' keys\n    \nReturns:\n    plotly.graph_objects.Figure: Figure with the satellite orbit added",
    "parameters": [
      "satellite_name",
      "planetary_params",
      "parent_planet",
      "color",
      "fig",
      "date",
      "days_to_plot",
      "current_position",
      "show_apsidal_markers"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_satellite_orbit",
    "component_id": "idealized_orbits.plot_satellite_orbit"
  },
  "idealized_orbits.calculate_moon_orbital_elements": {
    "id": "idealized_orbits.calculate_moon_orbital_elements",
    "name": "calculate_moon_orbital_elements",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [],
    "source_code": "def calculate_moon_orbital_elements(date):\n    \"\"\"\n    Calculate Moon's orbital elements for a specific date\n    Using time-varying mean elements with major perturbations\n    \n    Parameters:\n        date (datetime): Date for which to calculate elements\n        \n    Returns:\n        dict: Dictionary containing orbital elements {a, e, i, omega, Omega}\n    \"\"\"\n    # Calculate Julian centuries since J2000.0\n    j2000 = datetime(2000, 1, 1, 12, 0, 0)  # J2000.0 epoch\n    T = (date - j2000).total_seconds() / (36525.0 * 86400.0)  # Julian centuries\n    \n    # Mean orbital elements with secular variations\n    # These values are from JPL and are relative to the ecliptic\n    a = 0.002570  # AU (384,400 km) - relatively stable\n    \n    # Base eccentricity with secular variation\n    e_base = 0.0549  # Mean eccentricity\n    \n    # Inclination to ecliptic (not Earth's equator!)\n    i = 5.145  # degrees - mean inclination to ecliptic\n    \n    # Node regression (retrograde motion)\n    # The Moon's node completes one cycle in about 18.6 years\n    Omega = 125.08 - 0.0529538083 * (date - j2000).days  # degrees/day\n    \n    # Apsidal precession\n    # The Moon's line of apsides completes one cycle in about 8.85 years  \n    omega = 318.15 + 0.1643573223 * (date - j2000).days  # degrees/day\n    \n    # Calculate perturbations for more accuracy\n    # Days since J2000\n    d = (date - j2000).days\n    \n    # Mean anomalies\n    M_moon = (134.963 + 13.064993 * d) % 360  # Moon's mean anomaly\n    M_sun = (357.529 + 0.98560028 * d) % 360   # Sun's mean anomaly\n    D = (297.850 + 12.190749 * d) % 360        # Mean elongation\n    \n    # Convert to radians\n    M_moon_rad = np.radians(M_moon)\n    M_sun_rad = np.radians(M_sun)\n    D_rad = np.radians(D)\n    \n    # Apply perturbations to eccentricity\n    # Evection (largest perturbation)\n    e_evection = 0.01098 * np.cos(2*D_rad - M_moon_rad)\n    e = e_base + e_evection\n    \n    # Ensure physical bounds\n    e = max(0.026, min(e, 0.077))\n    \n    # Normalize angles\n    omega = omega % 360.0\n    Omega = Omega % 360.0\n    \n    return {\n        'a': a,\n        'e': e,\n        'i': i,\n        'omega': omega,\n        'Omega': Omega\n    }",
    "start_line": 3610,
    "end_line": 3675,
    "has_docstring": true,
    "docstring": "Calculate Moon's orbital elements for a specific date\nUsing time-varying mean elements with major perturbations\n\nParameters:\n    date (datetime): Date for which to calculate elements\n    \nReturns:\n    dict: Dictionary containing orbital elements {a, e, i, omega, Omega}",
    "parameters": [
      "date"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_moon_orbital_elements",
    "component_id": "idealized_orbits.calculate_moon_orbital_elements"
  },
  "idealized_orbits.plot_mars_moon_osculating_orbit": {
    "id": "idealized_orbits.plot_mars_moon_osculating_orbit",
    "name": "plot_mars_moon_osculating_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "idealized_orbits.rotate_points",
      "osculating_cache_manager.load_cache"
    ],
    "source_code": "def plot_mars_moon_osculating_orbit(fig, satellite_name, horizons_id, date, color, parent_planet='Mars'):\n    \"\"\"\n    Plot osculating orbit for Mars satellites (Phobos/Deimos)\n    Similar to Moon's osculating orbit implementation\n    \n    Parameters:\n        fig: Plotly figure object\n        satellite_name: Name of satellite ('Phobos' or 'Deimos')\n        horizons_id: JPL Horizons ID for the satellite\n        date: datetime object for the epoch\n        color: Color for the orbit line\n        parent_planet: Name of parent planet (should be 'Mars')\n        \n    Returns:\n        fig: Updated Plotly figure\n    \"\"\"\n\n    print(f\"\\n[OSCULATING] Fetching elements for {satellite_name}...\", flush=True)\n    \n    # Load from cache (pre-fetch already prompted user, so just use cache)\n    from osculating_cache_manager import load_cache\n    cache = load_cache()\n    \n    # Check if we have cached elements\n    if satellite_name in cache:\n#        osc_elements = cache[satellite_name]\n        osc_elements = cache[satellite_name]['elements']  # Access 'elements' sub-dict\n        print(f\"  Using cached osculating elements\", flush=True)\n\n    else:\n        print(f\"  Warning: No osculating elements in cache for {satellite_name}\", flush=True)\n        return fig\n    \n    # Extract elements\n    a_osc = osc_elements['a']\n    e_osc = osc_elements['e']\n    i_osc = osc_elements['i']\n    omega_osc = osc_elements['omega']\n    Omega_osc = osc_elements['Omega']\n    epoch_osc = osc_elements.get('epoch', 'N/A')\n    \n    print(f\"\\n[OSCULATING] {satellite_name} orbital elements:\", flush=True)\n    print(f\"  Epoch: {epoch_osc}\", flush=True)\n    print(f\"  a = {a_osc:.6f} AU\", flush=True)\n    print(f\"  e = {e_osc:.6f}\", flush=True)\n    print(f\"  i = {i_osc:.2f} deg\", flush=True)\n    print(f\"  omega = {omega_osc:.2f} deg\", flush=True)\n    print(f\"  Omega = {Omega_osc:.2f} deg\", flush=True)\n    \n    # Generate orbit points (full orbit)\n    theta = np.linspace(0, 2*np.pi, 360)\n    \n    # Calculate radius for each point\n    r_osc = a_osc * (1 - e_osc**2) / (1 + e_osc * np.cos(theta))\n    \n    # Convert to Cartesian coordinates in orbital plane\n    x_orbit_osc = r_osc * np.cos(theta)\n    y_orbit_osc = r_osc * np.sin(theta)\n    z_orbit_osc = np.zeros_like(theta)\n    \n    # Apply orbital element rotations\n    i_rad_osc = np.radians(i_osc)\n    omega_rad_osc = np.radians(omega_osc)\n    Omega_rad_osc = np.radians(Omega_osc)\n    \n# Standard orbital rotation sequence\n    # NOTE: JPL osculating elements for Mars satellites come in ECLIPTIC frame (i ~ 27 deg)\n    # This is DIFFERENT from analytical elements which are in Mars equatorial frame (i ~ 1-2 deg)\n    # Therefore we do NOT apply the Mars Y-rotation here!\n    \n    # 1. Rotate by argument of periapsis (omega) around z-axis\n    x_temp, y_temp, z_temp = rotate_points(x_orbit_osc, y_orbit_osc, z_orbit_osc, omega_rad_osc, 'z')\n    # 2. Rotate by inclination (i) around x-axis  \n    x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad_osc, 'x')\n    # 3. Rotate by longitude of ascending node (Omega) around z-axis\n    x_final_osc, y_final_osc, z_final_osc = rotate_points(x_temp, y_temp, z_temp, Omega_rad_osc, 'z')\n    \n    # NO Mars Y-rotation needed - elements are already in ecliptic frame!\n    print(f\"  Note: Osculating elements are in ecliptic frame (i={i_osc:.2f} deg), no Mars rotation applied\", flush=True)\n    \n    # Create hover text\n    date_str = date.strftime('%Y-%m-%d %H:%M UTC')\n    osculating_note = (\n        \"<br><br><i>Osculating orbit uses instantaneous elements<br>\"\n        \"from JPL Horizons at specific epoch.<br>\"\n        \"Shows exact orbital state at epoch time.<br>\"\n        \"<br>Incorporates all physical effects:<br>\"\n        \"* Mars equatorial bulge gravitational field<br>\"\n        \"* Solar perturbations<br>\"\n        \"* Tidal effects<br>\"\n        \"* N-body gravitational interactions</i>\"\n    )\n    hover_text_osc = (\n        f\"{satellite_name} Osculating Orbit<br>\"\n        f\"Epoch: {epoch_osc}<br>\"\n        f\"a={a_osc:.6f} AU<br>\"\n        f\"e={e_osc:.6f}<br>\"\n        f\"i={i_osc:.2f} deg\"\n        f\"{osculating_note}\"\n    )\n    \n    # Add osculating trace (dashed line)\n    fig.add_trace(\n        go.Scatter3d(\n            x=x_final_osc,\n            y=y_final_osc,\n            z=z_final_osc,\n            mode='lines',\n            line=dict(dash='dash', width=2, color=color),\n            name=f\"{satellite_name} Osculating Orbit (Epoch: {epoch_osc})\",\n            text=[hover_text_osc] * len(x_final_osc),\n            customdata=[hover_text_osc] * len(x_final_osc),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    )\n    \n    print(f\"  [OK] Added osculating orbit trace for {satellite_name}\", flush=True)\n    \n    return fig",
    "start_line": 3678,
    "end_line": 3797,
    "has_docstring": true,
    "docstring": "Plot osculating orbit for Mars satellites (Phobos/Deimos)\nSimilar to Moon's osculating orbit implementation\n\nParameters:\n    fig: Plotly figure object\n    satellite_name: Name of satellite ('Phobos' or 'Deimos')\n    horizons_id: JPL Horizons ID for the satellite\n    date: datetime object for the epoch\n    color: Color for the orbit line\n    parent_planet: Name of parent planet (should be 'Mars')\n    \nReturns:\n    fig: Updated Plotly figure",
    "parameters": [
      "fig",
      "satellite_name",
      "horizons_id",
      "date",
      "color",
      "parent_planet"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_mars_moon_osculating_orbit",
    "component_id": "idealized_orbits.plot_mars_moon_osculating_orbit"
  },
  "idealized_orbits.plot_moon_ideal_orbit": {
    "id": "idealized_orbits.plot_moon_ideal_orbit",
    "name": "plot_moon_ideal_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "apsidal_markers.add_perihelion_marker",
      "constants_new.color_map",
      "apsidal_markers.add_apohelion_marker",
      "idealized_orbits.rotate_points",
      "idealized_orbits.calculate_moon_orbital_elements"
    ],
    "source_code": "def plot_moon_ideal_orbit(fig, date, center_object_name='Earth', color=None, days_to_plot=None, \n                          current_position=None, show_apsidal_markers=False, planetary_params=None): \n\n    \"\"\"\n    Plot BOTH the Moon's analytical and osculating orbits for educational comparison.\n    \n    Parameters:\n        fig: Plotly figure object\n        date: datetime object for the calculation epoch\n        center_object_name: Name of the central body (should be 'Earth' for Moon)\n        color: Color for the orbit line\n        days_to_plot: Number of days to plot\n        current_position: Dict with 'x', 'y', 'z' keys for current position\n        planetary_params: Dictionary containing osculating elements (if available)\n    \"\"\"\n    \n    # Debug: Show current position if provided\n    if current_position:\n        print(f\"[INFO] Moon current position: x={current_position['x']:.6f}, y={current_position['y']:.6f}, z={current_position['z']:.6f} AU\", flush=True)    \n\n    # Use default Moon color if not specified\n    if color is None:\n        from constants_new import color_map\n        color = color_map('Moon')\n    \n    # Calculate angular range based on days_to_plot\n    if days_to_plot is not None and days_to_plot > 0:\n        # Get Moon's orbital period from constants\n        moon_period_days = KNOWN_ORBITAL_PERIODS.get('Moon', 27.321661)\n        orbital_fraction = days_to_plot / moon_period_days\n        max_angle = 2 * np.pi * orbital_fraction\n    else:\n        # Default to one complete orbit\n        max_angle = 2 * np.pi\n        orbital_fraction = 1.0\n    \n    # Generate the orbit points\n    if orbital_fraction < 1:\n        num_points = max(180, int(360 * orbital_fraction))\n    else:\n        num_points = int(360 * max(1, orbital_fraction))\n        num_points = min(num_points, 7200)\n    \n    theta = np.linspace(0, max_angle, num_points)\n    \n    # ==================== PLOT ANALYTICAL ORBIT ====================\n    # Always plot the analytical orbit (time-averaged elements)\n    analytical_elements = calculate_moon_orbital_elements(date)\n    \n    a_ana = analytical_elements['a']\n    e_ana = analytical_elements['e']\n    i_ana = analytical_elements['i']\n    omega_ana = analytical_elements['omega']\n    Omega_ana = analytical_elements['Omega']\n    \n    print(f\"\\n[ANALYTICAL] Moon orbital elements for {date.strftime('%Y-%m-%d')}:\", flush=True)\n    print(f\"  a = {a_ana:.6f} AU\", flush=True)\n    print(f\"  e = {e_ana:.6f}\", flush=True)\n    print(f\"  i = {i_ana:.2f} deg\", flush=True)\n    print(f\"  omega = {omega_ana:.2f} deg\", flush=True)\n    print(f\"  Omega = {Omega_ana:.2f} deg\", flush=True)\n    \n    # Calculate analytical orbit\n    r_ana = a_ana * (1 - e_ana**2) / (1 + e_ana * np.cos(theta))\n    x_orbit_ana = r_ana * np.cos(theta)\n    y_orbit_ana = r_ana * np.sin(theta)\n    z_orbit_ana = np.zeros_like(theta)\n    \n    # Apply rotations for analytical orbit\n    i_rad_ana = np.radians(i_ana)\n    omega_rad_ana = np.radians(omega_ana)\n    Omega_rad_ana = np.radians(Omega_ana)\n    \n    x_temp, y_temp, z_temp = rotate_points(x_orbit_ana, y_orbit_ana, z_orbit_ana, omega_rad_ana, 'z')\n    x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad_ana, 'x')\n    x_final_ana, y_final_ana, z_final_ana = rotate_points(x_temp, y_temp, z_temp, Omega_rad_ana, 'z')\n    \n    # Create hover text for analytical orbit\n    date_str = date.strftime('%Y-%m-%d %H:%M UTC')\n\n    analytical_note = (\n        \"<br><br><i>Analytical orbit uses time-varying elements<br>\"\n        \"calculated for this specific date.<br>\"\n        \"<br>Elements updated based on secular variations:<br>\"\n        \"* Apsidal precession (omega changes with time)<br>\"\n        \"* Nodal regression (Omega changes with time)<br>\"\n        \"* Solar gravitational perturbations<br>\"\n        \"* Earth's gravitational effects<br>\"\n        \"<br>Shows general orbital geometry valid<br>\"\n        \"over months for this epoch.</i>\"\n    )\n\n    hover_text_ana = f\"Moon Analytical Orbit<br>Date: {date_str}<br>a={a_ana:.6f} AU<br>e={e_ana:.6f}<br>i={i_ana:.2f} deg{analytical_note}\"\n    \n    # Add analytical trace\n    fig.add_trace(\n        go.Scatter3d(\n            x=x_final_ana,\n            y=y_final_ana,\n            z=z_final_ana,\n            mode='lines',\n            line=dict(dash='dot', width=2, color=color),\n            name=f\"Moon Analytical Orbit (Epoch: {date.strftime('%Y-%m-%d')})\",\n            text=[hover_text_ana] * len(x_final_ana),\n            customdata=[hover_text_ana] * len(x_final_ana),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    )\n    \n    # ==================== PLOT OSCULATING ORBIT (if available) ====================\n        \n    if planetary_params is not None:\n        # planetary_params is already the Moon's elements dict (not the full dict)\n        osc_elements = planetary_params\n\n        a_osc = osc_elements['a']\n        e_osc = osc_elements['e']\n        i_osc = osc_elements['i']\n        omega_osc = osc_elements['omega']\n        Omega_osc = osc_elements['Omega']\n        epoch_osc = osc_elements.get('epoch', 'N/A')\n        \n        print(f\"\\n[OSCULATING] Moon orbital elements:\", flush=True)\n        print(f\"  Epoch: {epoch_osc}\", flush=True)\n        print(f\"  a = {a_osc:.6f} AU\", flush=True)\n        print(f\"  e = {e_osc:.6f}\", flush=True)\n        print(f\"  i = {i_osc:.2f} deg\", flush=True)\n        print(f\"  omega = {omega_osc:.2f} deg\", flush=True)\n        print(f\"  Omega = {Omega_osc:.2f} deg\", flush=True)\n        \n        # Calculate osculating orbit\n        r_osc = a_osc * (1 - e_osc**2) / (1 + e_osc * np.cos(theta))\n        x_orbit_osc = r_osc * np.cos(theta)\n        y_orbit_osc = r_osc * np.sin(theta)\n        z_orbit_osc = np.zeros_like(theta)\n        \n        # Apply rotations for osculating orbit\n        i_rad_osc = np.radians(i_osc)\n        omega_rad_osc = np.radians(omega_osc)\n        Omega_rad_osc = np.radians(Omega_osc)\n        \n        x_temp, y_temp, z_temp = rotate_points(x_orbit_osc, y_orbit_osc, z_orbit_osc, omega_rad_osc, 'z')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad_osc, 'x')\n        x_final_osc, y_final_osc, z_final_osc = rotate_points(x_temp, y_temp, z_temp, Omega_rad_osc, 'z')\n        \n        # Create hover text for osculating orbit\n        osculating_note = (\n            \"<br><br><i>Osculating orbit 'kisses' actual position at epoch,<br>\"\n            \"then diverges as perturbations accumulate from:<br>\"\n            \"* Solar gravity (largest effect)<br>\"\n            \"* Earth's oblateness (J2 - equatorial bulge)<br>\"\n            \"  causes nodal precession (Omega rotates ~19.3 deg/yr)<br>\"\n            \"* Tidal forces<br>\"\n            \"<br>It fits only the present position, not past or future positions.<br>\"\n            \"<br>See 'Orbital Parameter Visualization' for equatorial bulge details</i>\"\n        )\n        hover_text_osc = f\"Moon Osculating Orbit<br>Epoch: {epoch_osc}<br>a={a_osc:.6f} AU<br>e={e_osc:.6f}<br>i={i_osc:.2f} deg{osculating_note}\"\n        \n        # Add osculating trace with different line style\n        fig.add_trace(\n            go.Scatter3d(\n                x=x_final_osc,\n                y=y_final_osc,\n                z=z_final_osc,\n                mode='lines',\n                line=dict(dash='dash', width=2, color=color),  # Dashed line to distinguish from analytical\n                name=f\"Moon Osculating Orbit (Epoch: {epoch_osc})\",\n                text=[hover_text_osc] * len(x_final_osc),\n                customdata=[hover_text_osc] * len(x_final_osc),\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            )\n        )\n    else:\n        print(f\"[INFO] No osculating elements available for Moon - showing analytical orbit only\", flush=True)\n    \n    # ==================== APSIDAL MARKERS ====================\n    if show_apsidal_markers:\n        # Use analytical elements for apsidal marker positions\n        # Calculate positions using analytical orbit\n        r_ana = a_ana * (1 - e_ana**2) / (1 + e_ana * np.cos(theta))\n        \n        # Find periapsis (closest approach - perigee for Moon)\n        periapsis_idx = np.argmin(r_ana)\n        \n        # Prepare orbital parameters dictionary\n        orbital_params = {\n            'a': a_ana,\n            'e': e_ana,\n            'i': i_ana,\n            'omega': omega_ana,\n            'Omega': Omega_ana\n        }\n        \n        # Add TP if available from analytical elements\n        if 'TP' in analytical_elements:\n            orbital_params['TP'] = analytical_elements['TP']\n        \n        # Import standard apsidal marker functions\n        from apsidal_markers import add_perihelion_marker, add_apohelion_marker\n        \n        # Add perigee marker (uses standard function)\n        add_perihelion_marker(\n            fig,\n            x_final_ana[periapsis_idx],\n            y_final_ana[periapsis_idx],\n            z_final_ana[periapsis_idx],\n            'Moon',\n            a_ana,\n            e_ana,\n            date,\n            current_position,\n            orbital_params,\n            lambda x: color,  # Color function\n            q=r_ana[periapsis_idx],  # Periapsis distance\n            center_body='Earth'  # Will use \"Perigee\" terminology\n        )\n        \n        # Find apoapsis (farthest point - apogee for Moon)\n        apoapsis_idx = np.argmax(r_ana)\n        \n        # Add apogee marker (uses standard function)\n        add_apohelion_marker(\n            fig,\n            x_final_ana[apoapsis_idx],\n            y_final_ana[apoapsis_idx],\n            z_final_ana[apoapsis_idx],\n            'Moon',\n            a_ana,\n            e_ana,\n            date,\n            current_position,\n            orbital_params,\n            lambda x: color,  # Color function\n            center_body='Earth'  # Will use \"Apogee\" terminology\n        )\n    \n    return fig",
    "start_line": 3800,
    "end_line": 4038,
    "has_docstring": true,
    "docstring": "Plot BOTH the Moon's analytical and osculating orbits for educational comparison.\n\nParameters:\n    fig: Plotly figure object\n    date: datetime object for the calculation epoch\n    center_object_name: Name of the central body (should be 'Earth' for Moon)\n    color: Color for the orbit line\n    days_to_plot: Number of days to plot\n    current_position: Dict with 'x', 'y', 'z' keys for current position\n    planetary_params: Dictionary containing osculating elements (if available)",
    "parameters": [
      "fig",
      "date",
      "center_object_name",
      "color",
      "days_to_plot",
      "current_position",
      "show_apsidal_markers",
      "planetary_params"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_moon_ideal_orbit",
    "component_id": "idealized_orbits.plot_moon_ideal_orbit"
  },
  "idealized_orbits.plot_earth_moon_barycenter_orbit": {
    "id": "idealized_orbits.plot_earth_moon_barycenter_orbit",
    "name": "plot_earth_moon_barycenter_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "idealized_orbits.rotate_points",
      "osculating_cache_manager.get_cache_key",
      "osculating_cache_manager.load_cache"
    ],
    "source_code": "def plot_earth_moon_barycenter_orbit(fig, object_name, date, color, show_apsidal_markers=False, center_id='Earth'):\n    \"\"\"\n    Plot osculating orbit for objects in the Earth-Moon binary system.\n    \n    Supports TWO center modes:\n    1. center_id='Earth' - Traditional view, Moon orbits Earth\n    2. center_id='Earth-Moon Barycenter' - Binary view, BOTH objects orbit barycenter\n    \n    When \"Earth-Moon Barycenter\" is the center:\n    - Earth orbits the barycenter (tiny orbit ~0.0000312 AU = ~4,670 km)\n    - Moon orbits the barycenter (large orbit ~0.00254 AU = ~379,730 km)\n    \n    Unlike Pluto-Charon or Orcus-Vanth, the barycenter is INSIDE Earth.\n    But Earth still wobbles around it every 27.32 days!\n    \n    All osculating elements from JPL Horizons are in ECLIPTIC frame (J2000.0).\n    JPL Horizons has direct ephemeris for both 399@3 (Earth at EMB) and 301@3 (Moon at EMB).\n    \n    Binary System Parameters:\n    - Average separation: 384,400 km = 0.00257 AU\n    - Period: 27.32 days (sidereal)\n    - Mass ratio: M_Moon/M_Earth = 0.01230 (1.23%)\n    - Barycenter: ~4,670 km from Earth center (INSIDE Earth, radius 6,371 km)\n    - Moon's orbital inclination to ecliptic: ~5.145 deg\n    \"\"\"\n    \n    # Horizons IDs for Earth-Moon system objects\n    EARTH_MOON_IDS = {\n        'Earth': '399',    # Earth body center\n        'Moon': '301',     # Moon body center\n    }\n    \n    # Binary system physical parameters\n    BINARY_PARAMS = {\n        'separation_au': 0.002570,        # 384,400 km average separation\n        'period_days': 27.321582,         # Sidereal orbital period\n        'mass_ratio': 0.01230,            # M_Moon / M_Earth\n        'eccentricity': 0.0549,           # Moon's orbital eccentricity\n        # Fallback angular elements (only used if cache unavailable)\n        'inclination_ecliptic': 5.145,    # To J2000 ecliptic\n        'Omega_ecliptic': 125.0,          # Longitude of ascending node (precesses with 18.6 yr period)\n        'omega': 318.0,                   # Argument of periapsis (approximate)\n    }\n    \n    mass_ratio = BINARY_PARAMS['mass_ratio']\n    separation = BINARY_PARAMS['separation_au']\n    \n    horizons_id = EARTH_MOON_IDS.get(object_name)\n    if not horizons_id:\n        print(f\"Warning: No Horizons ID for {object_name} in Earth-Moon system\", flush=True)\n        return fig\n    \n    is_barycenter_mode = (center_id == 'Earth-Moon Barycenter')\n    \n    try:\n        from osculating_cache_manager import load_cache, get_cache_key\n        cache = load_cache()\n        \n        if is_barycenter_mode and object_name in ['Earth', 'Moon']:\n            # BARYCENTER MODE for Earth/Moon:\n            # Try to use barycentric osculating elements from cache first\n            # Fall back to calculated values if not available\n            \n            cache_key = get_cache_key(object_name, '@3')  # e.g., 'Earth@3', 'Moon@3'\n            \n            if cache_key in cache:\n                # USE ACTUAL BARYCENTRIC OSCULATING ELEMENTS\n                elements = cache[cache_key]['elements']\n                a = elements.get('a', 0)\n                e = elements.get('e', BINARY_PARAMS['eccentricity'])\n                i = elements.get('i', BINARY_PARAMS['inclination_ecliptic'])\n                omega = elements.get('omega', BINARY_PARAMS['omega'])\n                Omega = elements.get('Omega', BINARY_PARAMS['Omega_ecliptic'])\n                epoch = elements.get('epoch', f\"{date.strftime('%Y-%m-%d')}\")\n                print(f\"\\n[EMB BARYCENTER MODE] {object_name}: using barycentric osculating elements ({cache_key})\", flush=True)\n                print(f\"  a={a:.7f} AU ({a * 149597870.7:.1f} km from barycenter)\", flush=True)\n                print(f\"  e={e:.6f}, i={i:.2f} deg, Omega={Omega:.2f} deg, omega={omega:.2f} deg\", flush=True)\n            else:\n                # FALLBACK: Calculate from mass ratio + angular elements from Moon's Earth-centered cache\n                print(f\"\\n[EMB BARYCENTER MODE] {object_name}: no barycentric cache ({cache_key}), using calculated values\", flush=True)\n                \n                # Calculate semi-major axis from mass ratio\n                if object_name == 'Earth':\n                    a = separation * mass_ratio / (1 + mass_ratio)  # ~0.0000312 AU (~4,670 km)\n                else:  # Moon\n                    a = separation * 1.0 / (1 + mass_ratio)  # ~0.00254 AU (~379,730 km)\n                \n                e = BINARY_PARAMS['eccentricity']\n                \n                # Get angular elements from Moon's Earth-centered cache (defines the orbital plane)\n                if 'Moon' in cache:\n                    cached_elements = cache['Moon']['elements']\n                    i = cached_elements.get('i', BINARY_PARAMS['inclination_ecliptic'])\n                    omega = cached_elements.get('omega', BINARY_PARAMS['omega'])\n                    Omega = cached_elements.get('Omega', BINARY_PARAMS['Omega_ecliptic'])\n                    epoch = cached_elements.get('epoch', f\"{date.strftime('%Y-%m-%d')}\")\n                    print(f\"  Using Moon's Earth-centered angular elements as fallback\", flush=True)\n                else:\n                    # Final fallback to approximations\n                    i = BINARY_PARAMS['inclination_ecliptic']\n                    omega = BINARY_PARAMS['omega']\n                    Omega = BINARY_PARAMS['Omega_ecliptic']\n                    epoch = f\"{date.strftime('%Y-%m-%d')} (approx)\"\n                    print(f\"  Using fallback angular elements (no cache)\", flush=True)\n                \n                print(f\"  a={a:.7f} AU ({a * 149597870.7:.1f} km from barycenter)\", flush=True)\n                print(f\"  i={i:.2f} deg, Omega={Omega:.2f} deg, omega={omega:.2f} deg\", flush=True)\n\n        else:\n            # EARTH-CENTERED MODE (traditional view):\n            # Use Moon's cached osculating elements directly\n            print(f\"\\n[OSCULATING] Loading cached elements for {object_name} (Earth-Moon)...\", flush=True)\n            \n            if object_name in cache:\n                elements = cache[object_name]['elements']\n                print(f\"  [OK] Using cached osculating elements\", flush=True)\n            elif object_name in planetary_params:\n                elements = planetary_params[object_name]\n                print(f\"  [OK] Using analytical elements from planetary_params\", flush=True)\n            else:\n                print(f\"  Warning: No elements found for {object_name}\", flush=True)\n                return fig\n            \n            a = elements.get('a', 0)\n            e = elements.get('e', 0)\n            i = elements.get('i', 0)\n            omega = elements.get('omega', 0)\n            Omega = elements.get('Omega', 0)\n            epoch = elements.get('epoch', 'analytical')\n        \n        # Skip if no valid semi-major axis\n        if a == 0:\n            print(f\"  Warning: Zero semi-major axis for {object_name}\", flush=True)\n            return fig\n        \n        print(f\"  Plotting: a={a:.7f} AU, i={i:.4f} deg (ecliptic), epoch={epoch}\", flush=True)\n        \n        # Generate orbital path\n        theta = np.linspace(0, 2*np.pi, 360)\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        \n        x_orbit = r * np.cos(theta)\n        y_orbit = r * np.sin(theta)\n        z_orbit = np.zeros_like(theta)\n        \n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n        \n        # Standard Keplerian rotation sequence\n        x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, omega_rad, 'z')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n        x_final, y_final, z_final = rotate_points(x_temp, y_temp, z_temp, Omega_rad, 'z')\n        \n        # Build hover text based on mode and object\n        if is_barycenter_mode:\n            if object_name == 'Earth':\n                hover_text_osc = (\n                    f\"<b>Earth's Osculating Orbit around Barycenter</b><br>\"\n                    f\"<i>The tiny wobble of our home planet</i><br><br>\"\n                    f\"<b>Orbital Elements (Epoch: {epoch}):</b><br>\"\n                    f\"a = {a:.7f} AU ({a * 149597870.7:.0f} km) <i>[calculated]</i><br>\"\n                    f\"e = {e:.4f}<br>\"\n                    f\"i = {i:.1f} deg to ecliptic <i>[osculating]</i><br>\"\n                    f\"Period: {BINARY_PARAMS['period_days']:.2f} days<br><br>\"\n                    f\"<b>Why Earth's orbit is tiny:</b><br>\"\n                    f\"<i>Earth is ~81x more massive than the Moon,<br>\"\n                    f\"so it orbits much closer to the barycenter.<br>\"\n                    f\"Like a heavy adult on a see-saw sitting<br>\"\n                    f\"right next to the pivot point!</i><br><br>\"\n                    f\"<b>The barycenter is INSIDE Earth!</b><br>\"\n                    f\"<i>~4,670 km from center (~1,700 km below surface)<br>\"\n                    f\"Between the outer core and lower mantle.<br>\"\n                    f\"Compare: Pluto-Charon barycenter is OUTSIDE Pluto!</i><br><br>\"\n                    f\"<b>Note:</b> <i>This wobble affects Earth's<br>\"\n                    f\"heliocentric orbit - the Sun sees Earth<br>\"\n                    f\"oscillating monthly around the EMB.</i>\"\n                )\n            elif object_name == 'Moon':\n                hover_text_osc = (\n                    f\"<b>Moon's Osculating Orbit around Barycenter</b><br>\"\n                    f\"<i>The larger orbit of the pair</i><br><br>\"\n                    f\"<b>Orbital Elements (Epoch: {epoch}):</b><br>\"\n                    f\"a = {a:.7f} AU ({a * 149597870.7:.0f} km) <i>[calculated]</i><br>\"\n                    f\"e = {e:.4f}<br>\"\n                    f\"i = {i:.1f} deg to ecliptic <i>[osculating]</i><br>\"\n                    f\"Period: {BINARY_PARAMS['period_days']:.2f} days<br><br>\"\n                    f\"<b>Why Moon's orbit is larger:</b><br>\"\n                    f\"<i>The Moon is only 1.23% of Earth's mass,<br>\"\n                    f\"so it orbits much farther from the barycenter.<br>\"\n                    f\"Like a child on a see-saw sitting<br>\"\n                    f\"far from the pivot point!</i><br><br>\"\n                    f\"<b>The Dance:</b><br>\"\n                    f\"<i>Earth and Moon orbit their common center<br>\"\n                    f\"of mass every 27.32 days. The Moon's orbit<br>\"\n                    f\"is inclined ~5.1 deg to the ecliptic,<br>\"\n                    f\"causing the barycenter to bob up and down<br>\"\n                    f\"relative to Earth's orbital plane.</i>\"\n                )\n            else:\n                hover_text_osc = (\n                    f\"<b>{object_name} Osculating Orbit</b><br>\"\n                    f\"Epoch: {epoch}<br>\"\n                    f\"a={a:.7f} AU, e={e:.6f}, i={i:.2f} deg\"\n                )\n        else:\n            hover_text_osc = (\n                f\"<b>{object_name} Osculating Orbit</b><br>\"\n                f\"<i>(around Earth center)</i><br><br>\"\n                f\"Epoch: {epoch}<br>\"\n                f\"a = {a:.6f} AU, e = {e:.6f}<br>\"\n                f\"i = {i:.4f} deg (J2000 ecliptic)\"\n            )\n        \n        # Determine line style\n        line_style = dict(color=color, width=2, dash='dash')\n        orbit_label = f'{object_name} Osculating Orbit (Epoch: {epoch})'\n        \n        fig.add_trace(go.Scatter3d(\n            x=x_final, y=y_final, z=z_final,\n            mode='lines',\n            line=line_style,\n            name=orbit_label,\n            text=[hover_text_osc] * len(x_final),\n            customdata=[hover_text_osc] * len(x_final),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ))\n        \n        print(f\"  [OK] Added {object_name} orbit (center: {center_id})\", flush=True)\n        return fig\n        \n    except Exception as e:\n        print(f\"Error plotting {object_name} Earth-Moon orbit: {e}\", flush=True)\n        traceback.print_exc()\n        return fig",
    "start_line": 4041,
    "end_line": 4276,
    "has_docstring": true,
    "docstring": "Plot osculating orbit for objects in the Earth-Moon binary system.\n\nSupports TWO center modes:\n1. center_id='Earth' - Traditional view, Moon orbits Earth\n2. center_id='Earth-Moon Barycenter' - Binary view, BOTH objects orbit barycenter\n\nWhen \"Earth-Moon Barycenter\" is the center:\n- Earth orbits the barycenter (tiny orbit ~0.0000312 AU = ~4,670 km)\n- Moon orbits the barycenter (large orbit ~0.00254 AU = ~379,730 km)\n\nUnlike Pluto-Charon or Orcus-Vanth, the barycenter is INSIDE Earth.\nBut Earth still wobbles around it every 27.32 days!\n\nAll osculating elements from JPL Horizons are in ECLIPTIC frame (J2000.0).\nJPL Horizons has direct ephemeris for both 399@3 (Earth at EMB) and 301@3 (Moon at EMB).\n\nBinary System Parameters:\n- Average separation: 384,400 km = 0.00257 AU\n- Period: 27.32 days (sidereal)\n- Mass ratio: M_Moon/M_Earth = 0.01230 (1.23%)\n- Barycenter: ~4,670 km from Earth center (INSIDE Earth, radius 6,371 km)\n- Moon's orbital inclination to ecliptic: ~5.145 deg",
    "parameters": [
      "fig",
      "object_name",
      "date",
      "color",
      "show_apsidal_markers",
      "center_id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_earth_moon_barycenter_orbit",
    "component_id": "idealized_orbits.plot_earth_moon_barycenter_orbit"
  },
  "idealized_orbits.add_earth_moon_barycenter_marker": {
    "id": "idealized_orbits.add_earth_moon_barycenter_marker",
    "name": "add_earth_moon_barycenter_marker",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "constants_new.color_map"
    ],
    "source_code": "def add_earth_moon_barycenter_marker(fig, date, moon_position=None):\n    \"\"\"\n    Add the Earth-Moon barycenter marker to Earth-centered view.\n    \n    The barycenter is ~4,670 km from Earth's center toward the Moon.\n    This is INSIDE Earth's surface (radius ~6,371 km)!\n    It sits between the outer core and lower mantle.\n    \n    Parameters:\n        fig: Plotly figure\n        date: Current date for position calculation\n        moon_position: Dict with Moon's x, y, z position (if available)\n    \"\"\"\n    # Barycenter distance from Earth center in AU\n    # Calculation: separation x (m_moon / (m_earth + m_moon))\n    # = 384,400 km x (0.01230 / 1.01230) ~ 4,672 km ~ 0.0000312 AU\n    BARYCENTER_DIST_AU = 0.0000312\n    \n    if moon_position and moon_position.get('x') is not None:\n        # Calculate unit vector from Earth toward Moon\n        mx, my, mz = moon_position['x'], moon_position['y'], moon_position['z']\n        moon_dist = (mx**2 + my**2 + mz**2)**0.5\n        \n        if moon_dist > 0:\n            # Barycenter is along the Earth-Moon line\n            bary_x = BARYCENTER_DIST_AU * (mx / moon_dist)\n            bary_y = BARYCENTER_DIST_AU * (my / moon_dist)\n            bary_z = BARYCENTER_DIST_AU * (mz / moon_dist)\n        else:\n            bary_x, bary_y, bary_z = BARYCENTER_DIST_AU, 0, 0\n    else:\n        # Fallback: place on +X axis\n        bary_x, bary_y, bary_z = BARYCENTER_DIST_AU, 0, 0\n    \n    hover_text = (\n        f\"<b>Earth-Moon Barycenter</b><br>\"\n        f\"<i>Center of mass of the Earth-Moon system</i><br><br>\"\n        f\"Distance from Earth center: ~4,670 km<br>\"\n        f\"Distance below Earth surface: ~1,700 km<br>\"\n        f\"Location: between outer core and lower mantle<br>\"\n        f\"<br><b>Why this matters:</b><br>\"\n        f\"<i>Earth WOBBLES around this point every month!<br>\"\n        f\"The barycenter is inside Earth (unlike Pluto-Charon<br>\"\n        f\"where it's outside both bodies), but the wobble<br>\"\n        f\"is real and measurable.<br><br>\"\n        f\"The Sun-EMB Lagrange points (L1-L5) orbit<br>\"\n        f\"this point, not Earth's center. JWST, SOHO,<br>\"\n        f\"and other spacecraft 'orbit' a point defined<br>\"\n        f\"by this barycenter's path around the Sun.<br><br>\"\n        f\"Mass ratio: Moon/Earth = 1.23%<br>\"\n        f\"Highest of any planet-moon system!<br>\"\n        f\"(Compare: Io/Jupiter = 0.005%)</i>\"\n    )\n    \n    fig.add_trace(go.Scatter3d(\n        x=[bary_x], y=[bary_y], z=[bary_z],\n        mode='markers',\n        marker=dict(\n            size=8,\n            color=color_map('Earth'),\n            symbol='square-open',\n        ),\n        name='Earth-Moon Barycenter',\n        text=[hover_text],\n        hovertemplate='%{text}<extra></extra>',\n        showlegend=True\n    ))\n    \n    print(f\"  [OK] Added Earth-Moon barycenter marker at ({bary_x:.7f}, {bary_y:.7f}, {bary_z:.7f}) AU\", flush=True)\n    \n    return fig",
    "start_line": 4279,
    "end_line": 4349,
    "has_docstring": true,
    "docstring": "Add the Earth-Moon barycenter marker to Earth-centered view.\n\nThe barycenter is ~4,670 km from Earth's center toward the Moon.\nThis is INSIDE Earth's surface (radius ~6,371 km)!\nIt sits between the outer core and lower mantle.\n\nParameters:\n    fig: Plotly figure\n    date: Current date for position calculation\n    moon_position: Dict with Moon's x, y, z position (if available)",
    "parameters": [
      "fig",
      "date",
      "moon_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_earth_moon_barycenter_marker",
    "component_id": "idealized_orbits.add_earth_moon_barycenter_marker"
  },
  "idealized_orbits.generate_hyperbolic_orbit_points": {
    "id": "idealized_orbits.generate_hyperbolic_orbit_points",
    "name": "generate_hyperbolic_orbit_points",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "idealized_orbits.rotate_points"
    ],
    "source_code": "def generate_hyperbolic_orbit_points(a, e, i, omega, Omega, rotate_points, max_distance=100):\n    \"\"\"\n    Generate points for a hyperbolic orbit trajectory.\n    Enhanced to handle very high eccentricity cases.\n    \n    Parameters:\n        a: Semi-major axis (negative for hyperbolic orbits)\n        e: Eccentricity (> 1 for hyperbolic orbits)\n        i: Inclination in degrees\n        omega: Argument of perihelion in degrees\n        Omega: Longitude of ascending node in degrees\n        rotate_points: Function to rotate points\n        max_distance: Maximum distance from Sun to plot (AU)\n    \n    Returns:\n        tuple: (x_final, y_final, z_final, q) where q is perihelion distance\n    \"\"\"\n    # Calculate perihelion distance\n    q = abs(a) * (e - 1)\n    \n    # For hyperbolic orbits, the true anomaly range is limited\n    theta_inf = np.arccos(-1/e)  # Asymptotic true anomaly\n    \n    # For very high eccentricity, we need special handling\n    if e > 5:\n        # High eccentricity: focus on the visible region\n        # Calculate the true anomaly where r = max_distance\n        # r = a(e^2 - 1) / (1 + e*cos(theta))\n        # Solving for theta: cos(theta) = (a(e^2 - 1)/r - 1) / e\n        \n        cos_theta_max = ((abs(a) * (e**2 - 1) / max_distance) - 1) / e\n        \n        if cos_theta_max >= -1 and cos_theta_max <= 1:\n            theta_visible = np.arccos(cos_theta_max)\n            # Use the smaller angle\n            theta_limit = min(theta_inf - 0.01, theta_visible)\n        else:\n            # Very extreme case - just show near perihelion\n            theta_limit = min(theta_inf - 0.01, np.pi/4)  # Max 45 degrees\n        \n        # Use more points for smoother curve\n        num_points = 1000\n    else:\n        # Standard approach for moderate eccentricity\n        theta_limit = theta_inf - 0.1  # Use 0.1 radian margin\n        num_points = 500\n    \n    # Create array of true anomaly values\n    theta = np.linspace(-theta_limit, theta_limit, num_points)\n    \n    # Calculate radius for each true anomaly\n    r = abs(a) * (e**2 - 1) / (1 + e * np.cos(theta))\n    \n    # Filter out points that are too far from the Sun\n    valid_mask = (r > 0) & (r <= max_distance)\n    \n    # Check if we have enough valid points\n    if np.sum(valid_mask) < 50:\n        # If too few points, focus on perihelion region\n        if e > 10:\n            # For extremely high eccentricity, use very small angle range\n            theta_perihelion = np.linspace(-0.05, 0.05, 200)  # +/-2.9 degrees\n        else:\n            # For high eccentricity, use small angle range\n            theta_perihelion = np.linspace(-np.pi/6, np.pi/6, 500)  # +/-30 degrees\n        \n        r_perihelion = abs(a) * (e**2 - 1) / (1 + e * np.cos(theta_perihelion))\n        valid_perihelion = (r_perihelion > 0) & (r_perihelion <= max_distance * 1.5)\n        \n        if np.sum(valid_perihelion) > 10:\n            theta = theta_perihelion[valid_perihelion]\n            r = r_perihelion[valid_perihelion]\n        else:\n            # Last resort: just create a small arc at perihelion\n            print(f\"Warning: Extremely high eccentricity (e={e:.6f}), showing minimal trajectory\", flush=True)\n            theta = np.linspace(-0.01, 0.01, 20)\n            r = abs(a) * (e**2 - 1) / (1 + e * np.cos(theta))\n    else:\n        theta = theta[valid_mask]\n        r = r[valid_mask]\n    \n    # Convert to Cartesian coordinates in orbital plane\n    x_orbit = r * np.cos(theta)\n    y_orbit = r * np.sin(theta)\n    z_orbit = np.zeros_like(theta)\n    \n    # Convert angles to radians\n    i_rad = np.radians(i)\n    omega_rad = np.radians(omega)\n    Omega_rad = np.radians(Omega)\n    \n    # Apply orbital element rotations\n    x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, omega_rad, 'z')\n    x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n    x_final, y_final, z_final = rotate_points(x_temp, y_temp, z_temp, Omega_rad, 'z')\n    \n    return x_final, y_final, z_final, q",
    "start_line": 4352,
    "end_line": 4448,
    "has_docstring": true,
    "docstring": "Generate points for a hyperbolic orbit trajectory.\nEnhanced to handle very high eccentricity cases.\n\nParameters:\n    a: Semi-major axis (negative for hyperbolic orbits)\n    e: Eccentricity (> 1 for hyperbolic orbits)\n    i: Inclination in degrees\n    omega: Argument of perihelion in degrees\n    Omega: Longitude of ascending node in degrees\n    rotate_points: Function to rotate points\n    max_distance: Maximum distance from Sun to plot (AU)\n\nReturns:\n    tuple: (x_final, y_final, z_final, q) where q is perihelion distance",
    "parameters": [
      "a",
      "e",
      "i",
      "omega",
      "Omega",
      "rotate_points",
      "max_distance"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate_hyperbolic_orbit_points",
    "component_id": "idealized_orbits.generate_hyperbolic_orbit_points"
  },
  "idealized_orbits.plot_idealized_orbits": {
    "id": "idealized_orbits.plot_idealized_orbits",
    "name": "plot_idealized_orbits",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "palomas_orrery.fetch_position",
      "apsidal_markers.add_keplerian_position_marker",
      "idealized_orbits.plot_satellite_orbit",
      "idealized_orbits.plot_pluto_barycenter_orbit",
      "idealized_orbits.plot_tno_satellite_orbit",
      "apsidal_markers.calculate_exact_apsides",
      "apsidal_markers.fetch_positions_for_apsidal_dates",
      "idealized_orbits.get_planet_perturbation_note",
      "idealized_orbits.plot_mars_moon_osculating_orbit",
      "apsidal_markers.compute_apsidal_dates_from_tp",
      "idealized_orbits.plot_earth_moon_barycenter_orbit",
      "idealized_orbits.plot_gonggong_xiangliu_orbit",
      "idealized_orbits.add_orcus_barycenter_marker",
      "idealized_orbits.add_pluto_barycenter_marker",
      "apsidal_markers.add_actual_apsidal_markers_enhanced",
      "idealized_orbits.add_earth_moon_barycenter_marker",
      "apsidal_markers.add_apsidal_range_note",
      "idealized_orbits.rotate_points",
      "idealized_orbits.plot_uranus_moon_osculating_orbit",
      "idealized_orbits.plot_neptune_moon_osculating_orbit",
      "idealized_orbits.plot_orcus_barycenter_orbit",
      "idealized_orbits.plot_jupiter_moon_osculating_orbit",
      "idealized_orbits.plot_patroclus_barycenter_orbit",
      "idealized_orbits.plot_saturn_moon_osculating_orbit",
      "idealized_orbits.plot_moon_ideal_orbit",
      "idealized_orbits.generate_hyperbolic_orbit_points",
      "constants_new.color_map"
    ],
    "source_code": "def plot_idealized_orbits(fig, objects_to_plot, center_id='Sun', objects=None, \n                          planetary_params=None, parent_planets=None, color_map=None, \n                          date=None, days_to_plot=None, current_positions=None, fetch_position=None, \n                          show_apsidal_markers=False, parent_window=None):\n    \"\"\"\n    Plot Keplerian orbits for planets, dwarf planets, asteroids, KBOs, and moons.\n    For non-Sun centers, only plots moons of that center body.\n    \n    Parameters:\n        fig (plotly.graph_objects.Figure): The figure to add orbits to\n        objects_to_plot (list): List of object names to potentially plot orbits for\n        center_id (str): The central body ('Sun' or a planet name)\n        objects (list): List of object dictionaries with metadata\n        planetary_params (dict): Dictionary of orbital parameters for each object\n        parent_planets (dict): Dictionary mapping parent planets to their satellites\n        color_map (callable): Function to get color for an object by name\n        date (datetime): Date for time-varying orbital elements (used for Moon)\n        \n    Returns:\n        plotly.graph_objects.Figure: Figure with Keplerian orbits added\n    \"\"\"\n    # CRITICAL: Import numpy at the function level\n    import numpy as np\n    import plotly.graph_objects as go\n    from datetime import datetime, timedelta\n\n    # Create name to object mapping\n    obj_dict = {obj['name']: obj for obj in objects} if objects else {}\n\n    # If current_positions not provided, try to extract from objects parameter\n    if current_positions is None and objects is not None:\n        current_positions = {}\n        for obj in objects:\n            if hasattr(obj, 'name') and hasattr(obj, 'x') and hasattr(obj, 'y') and hasattr(obj, 'z'):\n                current_positions[obj.name] = {\n                    'x': obj.x,\n                    'y': obj.y, \n                    'z': obj.z\n                }\n\n    # Track skipped objects by category\n    skipped = {\n        'satellites': [],\n        'comets': [],\n        'missions': [],\n        'no_params': [],\n        'invalid_orbit': [],\n        'error': []  # ADD THIS LINE\n    }\n\n    plotted = []\n\n    # If days_to_plot not provided, try to get from GUI\n    if days_to_plot is None:\n#        try:\n#            days_to_plot = int(days_to_plot_entry.get())\n#        except:\n        days_to_plot = 365  # Default fallback\n\n    # Add date parameter default\n    if date is None:\n        from datetime import datetime\n        date = datetime.now()\n\n    # If objects parameter is None, handle gracefully\n    if objects is None:\n        print(\"Warning: objects list is None, cannot determine object properties\", flush=True)\n        return fig\n        \n    # If planetary_params is None, handle gracefully\n    if planetary_params is None:\n        print(\"Warning: planetary_params is None, cannot plot Keplerian orbits\", flush=True)\n        return fig\n        \n    # If parent_planets is None, handle gracefully\n    if parent_planets is None:\n        print(\"Warning: parent_planets is None, cannot determine satellite relationships\", flush=True)\n        return fig\n        \n    # If color_map is None, use a default function\n    if color_map is None:\n        from constants_new import color_map       \n\n    # In the section where we plot satellites of the center object:\n    if center_id != 'Sun':\n        # Get list of moons for this center\n        moons = parent_planets.get(center_id, [])\n        \n        # Filter objects_to_plot to only include moons of this center\n        objects_to_plot = [obj for obj in objects_to_plot if obj in moons]\n        \n        # For each satellite of the center object\n        for moon_name in objects_to_plot:\n            # Find the object in the objects list\n            moon_info = next((obj for obj in objects if obj['name'] == moon_name), None)\n            if moon_info is None:\n                continue\n                 \n            # Special handling for Earth's Moon with time-varying elements\n            if moon_name == 'Moon' and center_id == 'Earth':\n                # Get Moon's current position from current_positions\n                moon_current_pos = current_positions.get('Moon') if current_positions else None\n                moon_params = planetary_params.get('Moon') if planetary_params else None\n\n                fig = plot_moon_ideal_orbit(fig, date, center_id, color_map(moon_name), days_to_plot,\n                                            current_position=moon_current_pos,\n                                            show_apsidal_markers=show_apsidal_markers,\n                                            planetary_params=moon_params)\n\n                # NEW: Add barycenter marker for Earth-centered view\n                moon_pos = current_positions.get('Moon') if current_positions else None\n                fig = add_earth_moon_barycenter_marker(fig, date, moon_position=moon_pos)\n\n            # NEW: Earth-Moon BARYCENTER mode\n            elif center_id == 'Earth-Moon Barycenter' and moon_name in ['Earth', 'Moon']:\n                if date:\n                    fig = plot_earth_moon_barycenter_orbit(\n                        fig, moon_name, date, color_map(moon_name),\n                        show_apsidal_markers=show_apsidal_markers,\n                        center_id=center_id\n                    )\n\n            # Special handling for Mars moons with dual-orbit system\n            elif moon_name in ['Phobos', 'Deimos'] and center_id == 'Mars':\n                # Get satellite's current position\n                satellite_current_pos = current_positions.get(moon_name) if current_positions else None\n                \n                # Plot analytical orbit (time-varying elements - dotted line)\n                fig = plot_satellite_orbit(\n                    moon_name, \n                    planetary_params,\n                    center_id, \n                    color_map(moon_name), \n                    fig,\n                    date=date,\n                    days_to_plot=days_to_plot,\n                    current_position=satellite_current_pos,\n                    show_apsidal_markers=show_apsidal_markers\n                )\n                                \n                # Plot osculating orbit (JPL elements - dashed line)\n                # Get Horizons ID from objects list\n                horizons_id = None\n                for obj in objects:\n                    if obj['name'] == moon_name:\n                        horizons_id = obj.get('id')\n                        break\n                \n                if horizons_id and date:\n                    fig = plot_mars_moon_osculating_orbit(\n                        fig,\n                        moon_name,\n                        horizons_id,\n                        date,\n                        color_map(moon_name),\n                        parent_planet='Mars'\n                    )\n                else:\n                    print(f\"  Warning: Could not plot osculating orbit for {moon_name} (missing ID or date)\", flush=True)\n\n            # Special handling for Jupiter moons with dual-orbit system\n            elif moon_name in JUPITER_MOONS and center_id == 'Jupiter':\n                # Get satellite's current position\n                satellite_current_pos = current_positions.get(moon_name) if current_positions else None\n                \n                # Plot analytical orbit (time-varying elements - dotted line)\n                fig = plot_satellite_orbit(\n                    moon_name, \n                    planetary_params,\n                    center_id, \n                    color_map(moon_name), \n                    fig,\n                    date=date,\n                    days_to_plot=days_to_plot,\n                    current_position=satellite_current_pos,\n                    show_apsidal_markers=show_apsidal_markers\n                )\n                \n                # Plot osculating orbit (JPL elements - dashed line)\n                if date:\n                    fig = plot_jupiter_moon_osculating_orbit(\n                        fig,\n                        moon_name,\n                        date,\n                        color_map(moon_name),\n                        show_apsidal_markers=show_apsidal_markers\n                    )\n                else:\n                    print(f\"  Warning: Could not plot osculating orbit for {moon_name} (missing date)\", flush=True)\n\n# Special handling for Saturn moons with dual-orbit system\n            elif moon_name in SATURN_MOONS and center_id == 'Saturn':\n                # Get satellite's current position\n                satellite_current_pos = current_positions.get(moon_name) if current_positions else None\n                \n                # DECISION: Skip analytical orbits for Saturn moons\n                # Saturn's pole orientation (RA=40.58 deg) is far from ecliptic pole (~270 deg),\n                # making reference frame transformation complex. Osculating elements from\n                # JPL are already in ecliptic frame and provide excellent alignment.\n                # See: SATURN_IMPLEMENTATION_HANDOFF.md for technical details.\n                \n                # Special handling for Daphnis - no ephemeris after 2018\n                if moon_name == 'Daphnis':\n                    print(f\"  [DAPHNIS] [WARN] JPL ephemeris ends 2018-01-17 (Cassini mission end)\", flush=True)\n                    print(f\"  [DAPHNIS] Limited orbital data - osculating orbit may not be available\", flush=True)\n                \n                # Plot osculating orbit ONLY (JPL elements - dashed line, already ecliptic)\n                if date:\n                    fig = plot_saturn_moon_osculating_orbit(\n                        fig,\n                        moon_name,\n                        date,\n                        color_map(moon_name),\n                        show_apsidal_markers=show_apsidal_markers\n                    )\n                else:\n                    print(f\"  Warning: Could not plot osculating orbit for {moon_name} (missing date)\", flush=True)\n\n# Special handling for Uranus moons with osculating-only system\n            elif moon_name in URANUS_MOONS and center_id == 'Uranus':\n                # Get satellite's current position\n                satellite_current_pos = current_positions.get(moon_name) if current_positions else None\n                \n                # DECISION: Skip analytical orbits for Uranus moons\n                # Uranus's extreme axial tilt (97.77 deg) makes reference frame transformation\n                # extremely complex. Osculating elements from JPL are already in ecliptic\n                # frame and provide excellent alignment.\n                # See: SATELLITE_DUAL_ORBIT_HANDOFF.md for technical details.\n                \n                # Plot osculating orbit ONLY (JPL elements - dashed line, already ecliptic)\n                if date:\n                    fig = plot_uranus_moon_osculating_orbit(\n                        fig,\n                        moon_name,\n                        date,\n                        color_map(moon_name),\n                        show_apsidal_markers=show_apsidal_markers\n                    )\n                else:\n                    print(f\"  Warning: Could not plot osculating orbit for {moon_name} (missing date)\", flush=True)\n\n# Special handling for Neptune moons with osculating-only system\n            elif moon_name in NEPTUNE_MOONS and center_id == 'Neptune':\n                # Get satellite's current position\n                satellite_current_pos = current_positions.get(moon_name) if current_positions else None\n                \n                # DECISION: Skip analytical orbits for Neptune moons\n                # Neptune's pole RA (299.36 deg) and Triton's retrograde orbit make\n                # analytical transformations complex. Osculating elements from JPL\n                # are already in ecliptic frame and handle retrograde automatically.\n                # See: SATELLITE_DUAL_ORBIT_HANDOFF.md for technical details.\n                \n                # Plot osculating orbit ONLY (JPL elements - dashed line, already ecliptic)\n                if date:\n                    fig = plot_neptune_moon_osculating_orbit(\n                        fig,\n                        moon_name,\n                        date,\n                        color_map(moon_name),\n                        show_apsidal_markers=show_apsidal_markers\n                    )\n                else:\n                    print(f\"  Warning: Could not plot osculating orbit for {moon_name} (missing date)\", flush=True)\n\n# Special handling for Pluto-Charon BINARY SYSTEM\n            # Two modes: traditional Pluto-centered, or barycenter-centered\n            \n            # Mode 1: Barycenter-centered (binary planet mode)\n        #    if center_id == 'Pluto-Charon Barycenter' and moon_name in PLUTO_BARYCENTER_ORBITERS:\n            elif center_id == 'Pluto-Charon Barycenter' and moon_name in PLUTO_BARYCENTER_ORBITERS:\n                # In barycenter mode, BOTH Pluto and Charon orbit the barycenter\n                # Plus the four smaller moons (Styx, Nix, Kerberos, Hydra)\n                if date:\n                    fig = plot_pluto_barycenter_orbit(\n                        fig,\n                        moon_name,  # Can be 'Pluto', 'Charon', or other moons\n                        date,\n                        color_map(moon_name),\n                        show_apsidal_markers=show_apsidal_markers,\n                        center_id=center_id  # ADD THIS\n                    )\n\n                else:\n                    print(f\"  Warning: Could not plot osculating orbit for {moon_name} (missing date)\", flush=True)\n            \n            # Mode 2: Traditional Pluto-centered (for compatibility)\n            elif moon_name in PLUTO_MOONS and center_id == 'Pluto':\n                # Skip analytical orbit - only plot osculating\n                # (Pluto pole RA=132.99 deg far from ecliptic, analytical transformations fail)\n                if date:\n                    fig = plot_pluto_barycenter_orbit(\n                        fig,\n                        moon_name,\n                        date,\n                        color_map(moon_name),\n                        show_apsidal_markers=show_apsidal_markers,\n                        center_id=center_id  # ADD THIS\n                    )\n\n                else:\n                    print(f\"  Warning: Could not plot osculating orbit for {moon_name} (missing date)\", flush=True)\n                \n                # Add barycenter marker for Pluto-centered view (once, after processing Charon)\n                if moon_name == 'Charon':\n                    charon_pos = current_positions.get('Charon') if current_positions else None\n                    fig = add_pluto_barycenter_marker(fig, date, charon_position=charon_pos)\n\n            # Special handling for Orcus-Vanth BINARY SYSTEM\n            # Two modes: traditional Orcus-centered, or barycenter-centered\n            # Orcus-Vanth has the HIGHEST mass ratio (16%) of any known system!\n            \n            # Mode 1: Barycenter-centered (binary dwarf planet mode)\n            elif center_id == 'Orcus-Vanth Barycenter' and moon_name in ORCUS_BARYCENTER_ORBITERS:\n                # In barycenter mode, BOTH Orcus and Vanth orbit the barycenter\n                if date:\n                    fig = plot_orcus_barycenter_orbit(\n                        fig,\n                        moon_name,  # Can be 'Orcus' or 'Vanth'\n                        date,\n                        color_map(moon_name),\n                        show_apsidal_markers=show_apsidal_markers,\n                        center_id=center_id\n                    )\n                else:\n                    print(f\"  Warning: Could not plot osculating orbit for {moon_name} (missing date)\", flush=True)\n            \n            # Mode 2: Traditional Orcus-centered (Vanth orbits Orcus)\n            elif moon_name == 'Vanth' and center_id == 'Orcus':\n                # Plot Vanth's orbit around Orcus using the new function\n                if date:\n                    fig = plot_orcus_barycenter_orbit(\n                        fig,\n                        moon_name,\n                        date,\n                        color_map(moon_name),\n                        show_apsidal_markers=show_apsidal_markers,\n                        center_id=center_id\n                    )\n                    \n                    # Add barycenter marker for Orcus-centered view\n                    vanth_pos = current_positions.get('Vanth') if current_positions else None\n                    fig = add_orcus_barycenter_marker(fig, date, vanth_position=vanth_pos)\n                else:\n                    print(f\"  Warning: Could not plot osculating orbit for {moon_name} (missing date)\", flush=True)\n\n            # Special handling for Gonggong-Xiangliu system\n            # Source: Kiss et al. 2017, 2019 (ApJ Letters, Icarus)\n            # Separation: 24,021 km, Period: 25.22 days, e=0.29\n            # NOTE: Barycenter mode removed - mass ratio ~0.013, barycenter inside Gonggong\n            # NOTE: Neither 920225088 nor 120225088 work at Horizons - analytical only\n            elif moon_name == 'Xiangliu' and center_id == 'Gonggong':\n                if date:\n                    fig = plot_gonggong_xiangliu_orbit(\n                        fig,\n                        moon_name,\n                        date,\n                        color_map(moon_name),\n                        show_apsidal_markers=show_apsidal_markers,\n                        center_id=center_id\n                    )\n                else:\n                    print(f\"  Warning: Could not plot analytical orbit for {moon_name} (missing date)\", flush=True)\n\n            # Special handling for Patroclus-Menoetius BINARY TROJAN SYSTEM (Lucy target)\n            # Source: Brozovic et al. 2024 (AJ 167:104)\n            # Binary separation: 692.5 km, Period: 4.283 days\n            elif center_id == 'Patroclus-Menoetius Barycenter' and moon_name in PATROCLUS_BARYCENTER_ORBITERS:\n                # In barycenter mode, BOTH Patroclus and Menoetius orbit the barycenter\n                if date:\n                    fig = plot_patroclus_barycenter_orbit(\n                        fig,\n                        moon_name,  # Can be 'Patroclus' or 'Menoetius'\n                        date,\n                        color_map(moon_name),\n                        show_apsidal_markers=show_apsidal_markers,\n                        center_id=center_id\n                    )\n                else:\n                    print(f\"  Warning: Could not plot analytical orbit for {moon_name} (missing date)\", flush=True)\n\n            # Special handling for TNO satellites (Eris, Haumea, Makemake, etc. moons)\n            # These have no reliable analytical elements - osculating only\n            # Note: Vanth is now handled above, but other TNO moons still use this path\n            elif moon_name in TNO_MOONS and moon_name != 'Vanth':\n\n                if date:\n                    fig = plot_tno_satellite_orbit(\n                        fig,\n                        moon_name,\n                        center_id,  # parent name\n                        date,\n                        color_map(moon_name),\n                        show_apsidal_markers=show_apsidal_markers\n                    )\n                else:\n                    print(f\"  Warning: Could not plot osculating orbit for {moon_name} (missing date)\", flush=True)\n\n            else:\n                # Use the standard satellite plotting function for other moons\n                # Get satellite's current position\n                satellite_current_pos = current_positions.get(moon_name) if current_positions else None\n\n                fig = plot_satellite_orbit(\n                    moon_name, \n                    planetary_params,\n                    center_id, \n                    color_map(moon_name), \n                    fig,\n                    date=date,\n                    days_to_plot=days_to_plot,\n                    current_position=satellite_current_pos,\n                    show_apsidal_markers=show_apsidal_markers\n                )\n                        \n            plotted.append(moon_name)\n        \n        # COMPLETE CODE: Add After Line 2323 in Keplerian_orbits.py\n        # This version loads TP from osculating_cache.json for satellites\n\n        # ========== ADD ACTUAL APSIDAL MARKERS FOR ALL SATELLITES ==========\n        if show_apsidal_markers and fetch_position:\n            print(\"\\n[ACTUAL APSIDAL] Checking satellites for apsidal markers...\", flush=True)\n            \n            from apsidal_markers import (\n                fetch_positions_for_apsidal_dates,\n                add_actual_apsidal_markers_enhanced,\n                calculate_exact_apsides,\n                compute_apsidal_dates_from_tp\n            )\n            from datetime import timedelta\n            import json\n            from pathlib import Path\n            from astropy.time import Time\n            \n            # Load osculating cache once for all satellites\n            osc_cache = {}\n            try:\n                cache_path = Path('data/osculating_cache.json')\n                if cache_path.exists():\n                    with open(cache_path, 'r') as f:\n                        osc_cache = json.load(f)\n            except Exception as e:\n                print(f\"  [WARN] Could not load osculating cache: {e}\")\n            \n            for moon_name in plotted:\n                moon_info = next((obj for obj in objects if obj['name'] == moon_name), None)\n                \n                if moon_info and moon_info.get('object_type') == 'satellite':\n                    moon_params = planetary_params.get(moon_name)\n                    \n                    if moon_params:\n\n                        # For satellites, get TP and epoch from osculating cache if not in params\n                        # Skip for analytical-only satellites (their osculating cache has wrong heliocentric data)\n                #        ANALYTICAL_ONLY_SATELLITES = ['MK2', 'Xiangliu', 'Vanth', 'Weywot']\n                        ANALYTICAL_ONLY_SATELLITES = ['MK2', 'Xiangliu', 'Vanth']  \n                        if 'TP' not in moon_params and moon_name in osc_cache and moon_name not in ANALYTICAL_ONLY_SATELLITES:\n\n                            try:\n                                osc_elements = osc_cache[moon_name].get('elements', {})\n                                if 'TP' in osc_elements:\n                                    tp_jd = osc_elements['TP']\n                                    tp_time = Time(tp_jd, format='jd')\n                                    moon_params['TP'] = tp_time.datetime.strftime('%Y-%m-%d %H:%M:%S')\n                                    print(f\"  Loaded TP from osculating cache for {moon_name}: {moon_params['TP']}\")\n                                # ALSO load epoch from osculating cache\n                                if 'epoch' in osc_elements:\n                                    moon_params['epoch'] = osc_elements['epoch']\n                                    print(f\"  Loaded epoch from osculating cache for {moon_name}: {moon_params['epoch']}\")\n                            except Exception as e:\n                                print(f\"  Could not load TP/epoch for {moon_name}: {e}\")\n                        \n                        if 'TP' in moon_params:\n                            obj_id = moon_info.get('id')\n                            id_type = moon_info.get('id_type', None)\n                            \n                            if obj_id:\n                                try:\n                                    print(f\"\\n[ACTUAL APSIDAL] Processing {moon_name}\", flush=True)\n                                    print(f\"  Object ID: {obj_id}\", flush=True)\n                                    print(f\"  Center: {center_id}\", flush=True)\n                                    \n                                    # Compute apsidal dates from TP\n                                    next_periapsis, next_apoapsis = compute_apsidal_dates_from_tp(\n                                        moon_name,\n                                        moon_params,\n                                        current_date=date\n                                    )\n                                    \n                                    # Store dates in params\n                                    if next_periapsis:\n                                        moon_params['perihelion_dates'] = [next_periapsis.strftime('%Y-%m-%d %H:%M:%S')]\n                                        print(f\"  Next periapsis: {next_periapsis}\")\n                                    if next_apoapsis:\n                                        moon_params['aphelion_dates'] = [next_apoapsis.strftime('%Y-%m-%d %H:%M:%S')]\n                                        print(f\"  Next apoapsis: {next_apoapsis}\")\n                                    \n                                    # Calculate Keplerian apsides\n                                    apsides = calculate_exact_apsides(\n                                        moon_params.get('a'),\n                                        moon_params.get('e'),\n                                        moon_params.get('i'),\n                                        moon_params.get('omega'),\n                                        moon_params.get('Omega'),\n                                        rotate_points\n                                    )\n                                                                        \n                                    # Use numeric center ID for satellites\n                                    # First check if center is in objects list (covers TNO systems)\n                                    center_id_numeric = None\n                                    if objects:\n                                        for obj in objects:\n                                            if obj['name'] == center_id:\n                                                center_id_numeric = obj['id']\n                                                break\n                                    # Fallback to hardcoded planet IDs\n                                    if not center_id_numeric:\n                                        satellite_center_ids = {\n                                            'Sun': '10',\n                                            'Earth': '399',   # Geocenter\n                                            'Mars': '499',    # Mars\n                                            'Jupiter': '599', # Jupiter\n                                            'Saturn': '699',  # Saturn\n                                            'Uranus': '799',  # Uranus\n                                            'Neptune': '899', # Neptune\n                                            'Pluto': '999'    # Pluto\n                                        }\n                                        center_id_numeric = satellite_center_ids.get(center_id, center_id)\n\n                                    # Fetch actual positions\n                                    positions_dict = fetch_positions_for_apsidal_dates(\n                                        obj_id=obj_id,\n                                        params=moon_params,\n                                        date_range=None,\n                                        center_id=center_id_numeric,  # Use numeric ID!\n                                        id_type=id_type,\n                                        is_satellite=True,\n                                        fetch_position=fetch_position\n                                    )\n                                    \n                                    if positions_dict:\n                                        print(f\"  Fetched {len(positions_dict)} positions\", flush=True)\n                                        \n                                        add_actual_apsidal_markers_enhanced(\n                                            fig,\n                                            moon_name,\n                                            moon_params,\n                                            date_range=(date - timedelta(days=365), date + timedelta(days=365)),\n                                            positions_dict=positions_dict,\n                                            color_map=color_map,\n                                            center_body=center_id,\n                                            is_satellite=True,\n                                            ideal_apsides=apsides,\n                                            filter_by_date_range=False\n                                        )\n                                        \n                                        print(f\"  [OK] Added actual apsidal markers for {moon_name}\", flush=True)\n                                    else:\n                                        print(f\"  [WARN] No positions fetched for {moon_name}\", flush=True)\n                                        \n                                except Exception as e:\n                                    print(f\"  [WARN] Error adding actual markers for {moon_name}: {e}\", flush=True)\n                                    import traceback\n                                    traceback.print_exc()\n                        else:\n                            print(f\"  [WARN] {moon_name} has no TP in params or osculating cache\", flush=True)\n\n    # If center is the Sun, plot orbits for selected heliocentric objects\n    else:\n        for obj_name in objects_to_plot:\n            # Find the object in the objects list\n            obj_info = next((obj for obj in objects if obj['name'] == obj_name), None)\n            # Get current position for this object\n            current_pos = current_positions.get(obj_name) if current_positions else None\n            if obj_info is None:\n                continue\n                \n            # Check each skip condition and record the reason\n            if obj_name not in planetary_params:\n                skipped['no_params'].append(obj_name)\n                continue\n\n            # Check if this is a satellite of another object (but not of the center)\n            # Only skip if object_type is 'satellite' - this excludes primary bodies like Pluto\n            # which appear in parent_planets['Pluto-Charon Barycenter'] for binary visualization\n            is_satellite_of_another = False\n            if obj_info.get('object_type') == 'satellite':\n                for planet, moons in parent_planets.items():\n                    if obj_name in moons and planet != center_id:\n                        is_satellite_of_another = True\n                        break\n\n            if is_satellite_of_another:\n                # Skip satellites when centered on Sun (they orbit their parent, not Sun directly)\n                skipped['satellites'].append(obj_name)\n                continue\n\n            elif obj_info.get('is_mission', False):\n                skipped['missions'].append(obj_name)\n                continue\n            \n# USE THE DATA PASSED FROM MAIN THREAD\n            # planetary_params already contains the fresh data from the pre-fetch in palomas_orrery.py\n            if obj_name in planetary_params:\n                params = planetary_params[obj_name]\n                \n                a = params.get('a', 0)\n                e = params.get('e', 0)\n                i = params.get('i', 0)\n                omega = params.get('omega', 0)\n                Omega = params.get('Omega', 0)\n            else:\n                # Object not available anywhere\n                print(f\"[WARN] Skipping {obj_name}: No parameters found\", flush=True)\n                skipped['no_params'].append(obj_name)\n                continue\n\n            # Add this debug line\n            print(f\"\\n[DEBUG] Processing {obj_name}\", flush=True)\n            print(f\"[DEBUG] params keys: {params.keys()}\", flush=True)            \n\n# Improved code for the hyperbolic section in idealized_orbits.py\n# Based on the working pattern from orbital_param_viz.py\n\n# Check if this is a hyperbolic orbit (e > 1)\n            if e > 1:\n                try:\n                    x_final, y_final, z_final, q = generate_hyperbolic_orbit_points(a, e, i, omega, Omega, rotate_points)\n                    \n                    epoch_str = \"\"\n                    if 'epoch' in params:\n                        epoch_str = f\" (Epoch: {params['epoch']})\"\n\n                    # Plot the hyperbolic orbit path\n                    fig.add_trace(\n                        go.Scatter3d(\n                            x=x_final,\n                            y=y_final,\n                            z=z_final,\n                            mode='lines',\n                            line=dict(dash='dot', width=1, color=color_map(obj_name)),\n                            name=f\"{obj_name} Keplerian Orbit{epoch_str}\",\n                    #        text=[f\"{obj_name} Hyperbolic Orbit<br>eccentricity, e={e:.6f}<br>periapsis distance, q={q:.6f} AU\"] * len(x_final),\n                            text=[f\"{obj_name} Hyperbolic Orbit<br>e={e:.6f}<br>q={q:.6f} AU{get_planet_perturbation_note(obj_name)}\"] * len(x_final),\n                            customdata=[f\"{obj_name} Keplerian Orbit\"] * len(x_final),\n                            hovertemplate='%{text}<extra></extra>',\n                            showlegend=True                    \n                        )\n                    )\n                  \n                    # ========== CALCULATE EXACT PERIAPSIS AT THETA=0 FOR HYPERBOLIC ==========\n                    from apsidal_markers import calculate_exact_apsides\n\n                    # Calculate exact apsidal positions (only periapsis for hyperbolic)\n                    apsides = calculate_exact_apsides(abs(a), e, i, omega, Omega, rotate_points)\n\n                    # ========== ADD Keplerian PERIAPSIS MARKER ==========\n                    if show_apsidal_markers:  # ADD THIS CONDITION\n                        if apsides['periapsis']:\n                            peri = apsides['periapsis']\n                            \n                            # Get date from TP for hyperbolic orbits\n                            date_str = \"\"\n                            if 'TP' in params:\n                                from astropy.time import Time\n                                tp_time = Time(params['TP'], format='jd')\n                                perihelion_datetime = tp_time.datetime\n                                date_str = f\"<br>Date: {perihelion_datetime.strftime('%Y-%m-%d %H:%M:%S')} UTC\"\n                                \n                                # Store for later use\n                                params['perihelion_datetime'] = perihelion_datetime\n                                params['perihelion_dates'] = [perihelion_datetime.strftime('%Y-%m-%d %H:%M:%S')]\n                            \n                            # Add perturbation assessment for hyperbolic orbits\n                            accuracy_note = \"\"\n                            if e > 10:\n                                accuracy_note = \"<br><i>Note: Extreme eccentricity - strong perturbations expected</i>\"\n                            elif e > 5:\n                                accuracy_note = \"<br><i>Note: Very high eccentricity - significant perturbations expected</i>\"\n                            elif e > 2:\n                                accuracy_note = \"<br><i>Note: High eccentricity - moderate perturbations expected</i>\"\n                            else:\n                                accuracy_note = \"<br><i>Note: Near-parabolic - perturbations possible</i>\"\n                            \n                            hover_text = (\n                                f\"<b>{obj_name} Keplerian Periapsis</b>\"\n                                f\"{date_str}\"\n                                f\"<br>q={peri['distance']:.6f} AU\"\n                                f\"<br>Theoretical minimum distance (theta=0 deg)\"\n                                f\"<br>One-time passage (hyperbolic)\"\n                                f\"<br>Unperturbed Keplerian position at actual periapsis time\"\n                                f\"{accuracy_note}\"\n                            )\n                            \n                            fig.add_trace(\n                                go.Scatter3d(\n                                    x=[peri['x']],\n                                    y=[peri['y']],\n                                    z=[peri['z']],\n                                    mode='markers',\n                                    marker=dict(\n                                        size=6,\n                                        color=color_map(obj_name),\n                                        symbol='square-open'\n                                    ),\n                                    name=f\"{obj_name} Keplerian Periapsis\",\n                                    text=[hover_text],\n                            #        hoverinfo='text',\n                                    customdata=[f\"{obj_name} Keplerian Periapsis\"],\n                                    hovertemplate='%{text}<extra></extra>',                                    \n                                    showlegend=True\n                                )\n                            )\n                            print(f\"  Added Keplerian periapsis for {obj_name} at distance {peri['distance']:.6f} AU (hyperbolic)\", flush=True)\n                    \n                    # ========== GENERATE ACTUAL PERIHELION DATE FROM TP ==========\n                    if 'TP' in params:\n                        from datetime import timedelta\n                        from astropy.time import Time\n                        \n                        # For hyperbolic orbits, TP gives us the exact perihelion date and time\n                        tp_jd = params['TP']\n                        tp_time = Time(tp_jd, format='jd')\n                        perihelion_datetime = tp_time.datetime\n                        \n                        # Store with full precision for display\n                        params['perihelion_datetime'] = perihelion_datetime\n                        # Store as string for compatibility (with time)\n                        params['perihelion_dates'] = [perihelion_datetime.strftime('%Y-%m-%d %H:%M:%S')]\n                        print(f\"  [HYPERBOLIC] Perihelion: {params['perihelion_dates'][0]} UTC\", flush=True)\n                    else:\n                        print(f\"  [HYPERBOLIC] No TP in params for {obj_name}\", flush=True)\n                    \n                    # ========== SIMPLIFIED ACTUAL MARKER FETCHING FOR HYPERBOLIC ==========\n                    # This avoids the datetime parsing issues by fetching with date-only\n                    if show_apsidal_markers:  # ADD THIS CONDITION\n                        if 'perihelion_dates' in params:\n                            print(f\"\\n[DEBUG] Attempting simplified fetch for hyperbolic {obj_name}\", flush=True)\n                            \n                            # Get the full datetime string and extract just the date part\n                            perihelion_full = params['perihelion_dates'][0]\n                            perihelion_date_only = perihelion_full.split(' ')[0]  # Get just YYYY-MM-DD\n                            print(f\"  Full datetime: {perihelion_full}\", flush=True)\n                            print(f\"  Date only for fetch: {perihelion_date_only}\", flush=True)\n                            \n                            # Get object ID\n                            obj_id = None\n                            id_type = None\n                            for obj in objects:\n                                if obj['name'] == obj_name:\n                                    obj_id = obj['id']\n                                    id_type = obj.get('id_type', None)\n                                    break\n                            \n                            print(f\"  Object ID: {obj_id}, ID type: {id_type}\", flush=True)\n                            \n                            if obj_id and fetch_position:\n                                try:\n                                    # Create a datetime object with just the date (midnight)\n                                    from datetime import datetime\n                                    date_obj = datetime.strptime(perihelion_date_only, '%Y-%m-%d')\n                                    print(f\"  Fetching position for {date_obj}\", flush=True)\n                                    \n                                    # Fetch the position\n                                    pos_data = fetch_position(obj_id, date_obj, center_id=center_id, id_type=id_type)\n                                    \n                                    if pos_data and 'x' in pos_data:\n                                        print(f\"  SUCCESS: Got position ({pos_data['x']:.3f}, {pos_data['y']:.3f}, {pos_data['z']:.3f})\", flush=True)\n                                        \n                                        # Calculate distance for hover text\n                                        import numpy as np\n                                        distance_au = np.sqrt(pos_data['x']**2 + pos_data['y']**2 + pos_data['z']**2)\n                                        distance_km = distance_au * 149597870.7\n                                        \n                                        # Manually add the actual perihelion marker\n                                        fig.add_trace(\n                                            go.Scatter3d(\n                                                x=[pos_data['x']],\n                                                y=[pos_data['y']],\n                                                z=[pos_data['z']],\n                                                mode='markers',\n                                                marker=dict(\n                                                    size=8,\n                                                    color='white',\n                                                    symbol='square-open'\n                                                ),\n                                                \n                                                name=f\"{obj_name} Actual Perihelion\",\n                                                text=[\n                                                    f\"<b>{obj_name} at Perihelion (Actual)</b><br>\"\n                                                    f\"Date/Time: {perihelion_full} UTC<br>\"\n                                                    f\"Distance from {center_id}: {distance_au:.6f} AU<br>\"\n                                                    f\"Distance: {distance_km:.0f} km\"\n                                                ],  # Full hover content in text\n                                                customdata=[f\"{obj_name} Actual Perihelion\"],  # Added customdata\n                                                hovertemplate='%{text}<extra></extra>',  # Standard template\n\n                                                showlegend=True\n                                            )\n                                        )\n                                        print(f\"  Added actual perihelion marker for {obj_name}\", flush=True)\n                                    else:\n                                        print(f\"  WARNING: No position data returned for {obj_name}\", flush=True)\n                                        print(f\"  This might be due to limited ephemeris data for this object\", flush=True)\n                                        \n                                except Exception as e:\n                                    print(f\"  ERROR fetching position: {e}\", flush=True)\n                                    print(f\"  Error type: {type(e).__name__}\", flush=True)\n                                    \n                                    # If it's still the NoneType * float error, it might be in fetch_position itself\n                                    if \"NoneType\" in str(e) and \"float\" in str(e):\n                                        print(f\"  This appears to be the period calculation issue\", flush=True)\n                                        print(f\"  The object may have limited ephemeris data in JPL Horizons\", flush=True)\n                            else:\n                                if not obj_id:\n                                    print(f\"  Could not find object ID for {obj_name}\", flush=True)\n                                if not fetch_position:\n                                    print(f\"  fetch_position function not available\", flush=True)\n                        \n                        plotted.append(obj_name)\n                        print(f\"Plotted hyperbolic orbit for {obj_name}: e={e:.5f}, q={q:.5f} AU\", flush=True)\n\n                except Exception as err:\n                    print(f\"Error plotting hyperbolic orbit for {obj_name}: {err}\", flush=True)\n                    import traceback\n                    traceback.print_exc()\n                    skipped['error'].append(obj_name)\n                \n                continue  # Skip to next object, don't run elliptical orbit code\n            \n            # For elliptical orbits (e <= 1), continue with existing code:\n            # Generate ellipse in orbital plane\n        #    theta = np.linspace(0, 2*np.pi, 360)  # 360 points for smoothness\n        #    r = a * (1 - e**2) / (1 + e * np.cos(theta))\n            \n            # For elliptical orbits (e <= 1), continue with existing code:\n            # Generate ellipse in orbital plane\n            # CRITICAL FIX: For near-parabolic orbits (e > 0.99), ensure theta=pi is included\n            # Otherwise the orbit trace won't pass through the exact apoapsis point\n            if e > 0.99:\n                # For near-parabolic: create array that includes exactly 0, pi, and 2*pi\n                theta_first_half = np.linspace(0, np.pi, 181)  # 0 to pi, including both endpoints\n                theta_second_half = np.linspace(np.pi, 2*np.pi, 181)[1:]  # pi to 2*pi, excluding pi (already included)\n                theta = np.concatenate([theta_first_half, theta_second_half])\n            else:\n                theta = np.linspace(0, 2*np.pi, 360)  # 360 points for smoothness\n            r = a * (1 - e**2) / (1 + e * np.cos(theta))\n\n            x_orbit = r * np.cos(theta)\n            y_orbit = r * np.sin(theta)\n            z_orbit = np.zeros_like(theta)\n\n            # Convert angles to radians\n            i_rad = np.radians(i)\n            omega_rad = np.radians(omega)\n            Omega_rad = np.radians(Omega)\n\n            # Rotate ellipse by argument of periapsis (omega) around z-axis\n            x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, omega_rad, 'z')\n            # Then rotate by inclination (i) around x-axis\n            x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n            # Then rotate by longitude of ascending node (Omega) around z-axis\n            x_final, y_final, z_final = rotate_points(x_temp, y_temp, z_temp, Omega_rad, 'z')\n\n            # ADD THIS CODE to check for epoch\n            epoch_str = \"\"\n            if 'epoch' in params:\n                epoch_str = f\" (Epoch: {params['epoch']})\"\n\n            # PLOT THE ORBIT LINE - THIS IS CRITICAL!\n            fig.add_trace(\n                go.Scatter3d(\n                    x=x_final,\n                    y=y_final,\n                    z=z_final,\n                    mode='lines',\n                    line=dict(dash='dot', width=1, color=color_map(obj_name)),\n                    name=f\"{obj_name} Keplerian Orbit{epoch_str}\",\n            #        text=[f\"{obj_name} Keplerian Orbit\"] * len(x_final),\n                    text=[f\"{obj_name} Keplerian Orbit<br>a={a:.6f} AU, e={e:.6f}, i={i:.2f} deg{get_planet_perturbation_note(obj_name)}\"] * len(x_final),\n                    customdata=[f\"{obj_name} Keplerian Orbit\"] * len(x_final),\n                    hovertemplate='%{text}<extra></extra>',\n                    showlegend=True                    \n                )\n            )\n\n            # ========== CALCULATE EXACT APSIDES AT THETA=0 AND THETA=PI ==========\n            from apsidal_markers import calculate_exact_apsides, compute_apsidal_dates_from_tp\n\n            # Calculate exact apsidal positions\n            apsides = calculate_exact_apsides(a, e, i, omega, Omega, rotate_points)\n\n            # Get dates for the apsides\n            if 'TP' in params:\n                next_perihelion, next_aphelion = compute_apsidal_dates_from_tp(\n                    obj_name, params, current_date=date\n                )\n            else:\n                next_perihelion = next_aphelion = None\n\n            # ========== ADD Keplerian PERIAPSIS MARKER ==========\n            if show_apsidal_markers:  # ADD THIS CONDITION\n                if apsides['periapsis']:\n                    peri = apsides['periapsis']\n                    \n                    # Create hover text with date if available\n                    date_str = \"\"\n                    if next_perihelion:\n                        date_str = f\"<br>Date: {next_perihelion.strftime('%Y-%m-%d %H:%M:%S')} UTC\"\n                    \n                    # Add perturbation assessment\n                    accuracy_note = \"\"\n                    if e > 0.15:\n                        accuracy_note = \"<br><i>Note: High eccentricity - strong perturbations expected</i>\"\n                    elif e > 0.05:\n                        accuracy_note = \"<br><i>Note: Moderate eccentricity - perturbations expected</i>\"\n                    \n            #        hover_text = (\n            #            f\"<b>{obj_name} Keplerian Periapsis</b>\"\n            #            f\"{date_str}\"\n            #            f\"<br>q={peri['distance']:.6f} AU\"\n            #            f\"<br>Theoretical minimum distance (theta=0 deg)\"\n            #            f\"<br>Unperturbed Keplerian position at actual periapsis time\"\n            #            f\"{accuracy_note}\"\n            #        )\n                    \n                    # Calculate distance from surface if center body radius is known\n                    from constants_new import CENTER_BODY_RADII\n                    surface_distance_text = \"\"\n                    if center_id in CENTER_BODY_RADII:\n                        center_radius_km = CENTER_BODY_RADII[center_id]\n                        center_radius_au = center_radius_km / 149597870.7\n                        surface_distance_au = peri['distance'] - center_radius_au\n                        surface_distance_km = surface_distance_au * 149597870.7\n                        surface_distance_text = f\"<br>Distance from surface: {surface_distance_au:.6f} AU ({surface_distance_km:,.0f} km)\"\n                    \n                    hover_text = (\n                        f\"<b>{obj_name} Keplerian Periapsis</b>\"\n                        f\"{date_str}\"\n                        f\"<br>q={peri['distance']:.6f} AU\"\n                        f\"{surface_distance_text}\"\n                        f\"<br>Theoretical minimum distance (theta=0 deg)\"\n                        f\"<br>Unperturbed Keplerian position at actual periapsis time\"\n                        f\"{accuracy_note}\"\n                    )\n\n                    fig.add_trace(\n                        go.Scatter3d(\n                            x=[peri['x']],\n                            y=[peri['y']],\n                            z=[peri['z']],\n                            mode='markers',\n                            marker=dict(\n                                size=6,\n                                color=color_map(obj_name),\n                                symbol='square-open'\n                            ),\n                            name=f\"{obj_name} Keplerian Periapsis\",\n                            text=[hover_text],\n                    #        hoverinfo='text',\n                            customdata=[f\"{obj_name} Keplerian Periapsis\"],\n                            hovertemplate='%{text}<extra></extra>',\n                            showlegend=True\n                        )\n                    )\n                    print(f\"  Added Keplerian periapsis for {obj_name} at distance {peri['distance']:.6f} AU\", flush=True)\n\n            # ========== ADD Keplerian APOAPSIS MARKER ==========\n            if show_apsidal_markers:  # ADD THIS CONDITION\n                if apsides['apoapsis']:\n                    apo = apsides['apoapsis']\n                    \n                    # Create hover text with date if available\n                    date_str = \"\"\n                    position_description = \"\"\n                    \n                    if next_aphelion:\n                        date_str = f\"<br>Date: {next_aphelion.strftime('%Y-%m-%d %H:%M:%S')} UTC\"\n                        position_description = \"<br>Unperturbed Keplerian position at actual apoapsis time\"\n                    elif e < 1 and 'TP' in params:\n                        # Calculate Keplerian aphelion date if no Tapo provided\n                        from astropy.time import Time\n                        from datetime import timedelta\n                        from constants_new import KNOWN_ORBITAL_PERIODS\n                        \n                        # NOW check if obj_name is in it\n                        if obj_name in KNOWN_ORBITAL_PERIODS:\n                            period_days = KNOWN_ORBITAL_PERIODS.get(obj_name)\n                            if period_days and period_days not in [None, 1e99]:\n                                tp_time = Time(params['TP'], format='jd')\n                                tp_datetime = tp_time.datetime\n\n                            # SAFE CALCULATION WITH OVERFLOW PROTECTION\n                            half_period_days = period_days / 2\n                            \n                            try:\n                                # Test if calculation would work\n                                keplerian_aphelion = tp_datetime + timedelta(days=half_period_days)\n                                date_str = f\"<br>Date: {keplerian_aphelion.strftime('%Y-%m-%d %H:%M:%S')} UTC (Keplerian estimate)\"\n                                position_description = \"<br>Unperturbed Keplerian position at Keplerian apoapsis time\"\n                                \n                            except (OverflowError, ValueError, OSError):\n                                # Handle overflow gracefully for extremely long periods\n                                years_to_aphelion = int(half_period_days / 365.25)\n                                date_str = f\"<br>Date: Far future aphelion (~{years_to_aphelion:,} years after perihelion)\"\n                                position_description = \"<br>Aphelion date beyond calculation range\"\n                                print(f\"  Aphelion date overflow for {obj_name} - using fallback message\", flush=True)\n\n                # CONTEXT: This fix ensures that:\n                # - The 3D aphelion marker still appears correctly in the plot\n                # - The hover text shows a meaningful message instead of causing a crash\n                # - Objects with normal periods work exactly as before\n                # - Objects like Leleakuhonua get a \"far future\" message instead of an overflow error\n\n\n                        #        # Aphelion occurs at period/2 after perihelion for Keplerian orbit\n                        #        keplerian_aphelion = tp_datetime + timedelta(days=period_days/2)\n                        #        date_str = f\"<br>Date: {keplerian_aphelion.strftime('%Y-%m-%d %H:%M:%S')} UTC (Keplerian estimate)\"\n                        #        position_description = \"<br>Unperturbed Keplerian position at Keplerian apoapsis time\"\n\n            #        hover_text = (\n            #            f\"<b>{obj_name} Keplerian Apoapsis</b>\"\n            #            f\"{date_str}\"\n            #            f\"<br>Q={apo['distance']:.6f} AU\"\n            #            f\"<br>Theoretical maximum distance (theta=180 deg)\"\n            #            f\"{position_description}\"\n            #            f\"{accuracy_note}\"\n            #        )\n                    \n                    # Calculate distance from surface if center body radius is known\n                    from constants_new import CENTER_BODY_RADII\n                    surface_distance_text = \"\"\n                    if center_id in CENTER_BODY_RADII:\n                        center_radius_km = CENTER_BODY_RADII[center_id]\n                        center_radius_au = center_radius_km / 149597870.7\n                        surface_distance_au = apo['distance'] - center_radius_au\n                        surface_distance_km = surface_distance_au * 149597870.7\n                        surface_distance_text = f\"<br>Distance from surface: {surface_distance_au:.6f} AU ({surface_distance_km:,.0f} km)\"\n                    \n                    hover_text = (\n                        f\"<b>{obj_name} Keplerian Apoapsis</b>\"\n                        f\"{date_str}\"\n                        f\"<br>Q={apo['distance']:.6f} AU\"\n                        f\"{surface_distance_text}\"\n                        f\"<br>Theoretical maximum distance (theta=180 deg)\"\n                        f\"{position_description}\"\n                        f\"{accuracy_note}\"\n                    )\n\n                    fig.add_trace(\n                        go.Scatter3d(\n                            x=[apo['x']],\n                            y=[apo['y']],\n                            z=[apo['z']],\n                            mode='markers',\n                            marker=dict(\n                                size=6,\n                                color=color_map(obj_name),\n                                symbol='square-open'\n                            ),\n                            name=f\"{obj_name} Keplerian Apoapsis\",\n                            text=[hover_text],\n                    #        hoverinfo='text',\n                            customdata=[f\"{obj_name} Keplerian Apoapsis\"],\n                            hovertemplate='%{text}<extra></extra>',\n                            showlegend=True\n                        )\n                    )\n                    print(f\"  Added Keplerian apoapsis for {obj_name} at distance {apo['distance']:.6f} AU\", flush=True)\n\n# Fix for Keplerian_orbits.py around lines 3200-3350\n# Replace the problematic section with this corrected version:\n\n            # ========== NEW: GENERATE APSIDAL DATES FROM TP ==========\n            # Initialize these variables BEFORE any conditional logic\n            next_perihelion = None\n            next_aphelion = None\n            peri_in_range = False\n            apo_in_range = False\n            \n            # After adding Keplerian markers, generate actual dates from TP if available\n            if show_apsidal_markers and 'TP' in params:\n                from datetime import timedelta\n                \n                # Get apsidal dates directly from TP and Tapo\n                next_perihelion, next_aphelion = compute_apsidal_dates_from_tp(\n                    obj_name, params, current_date=date\n                )\n\n                # Check JPL range if needed (optional)\n                JPL_MIN_DATE = datetime(1900, 1, 1)\n                JPL_MAX_DATE = datetime(2199, 12, 29)\n                peri_in_range = next_perihelion and JPL_MIN_DATE <= next_perihelion <= JPL_MAX_DATE\n                apo_in_range = next_aphelion and JPL_MIN_DATE <= next_aphelion <= JPL_MAX_DATE\n                \n                # In idealized_orbits.py, when storing apsidal dates:\n                if next_perihelion and peri_in_range:\n                    # Store with full datetime precision\n                    params['perihelion_dates'] = [next_perihelion.strftime('%Y-%m-%d %H:%M:%S')]\n                    print(f\"  Next perihelion: {params['perihelion_dates'][0]}\", flush=True)\n                elif next_perihelion and not peri_in_range:\n                    print(f\"  Next perihelion: {next_perihelion.strftime('%Y-%m-%d %H:%M:%S')} (outside JPL range)\", flush=True)\n                    \n                if next_aphelion and e < 1 and apo_in_range:\n                    # Store with full datetime precision\n                    params['aphelion_dates'] = [next_aphelion.strftime('%Y-%m-%d %H:%M:%S')]\n                    print(f\"  Next aphelion: {params['aphelion_dates'][0]}\", flush=True)\n                elif next_aphelion and e < 1 and not apo_in_range:\n                    print(f\"  Next aphelion: {next_aphelion.strftime('%Y-%m-%d %H:%M:%S')} (outside JPL range)\", flush=True)\n\n\n            # ========== EXISTING: PLOT ACTUAL APSIDAL MARKERS ==========\n            if show_apsidal_markers:  # ADD THIS CONDITION\n                if 'perihelion_dates' in params or 'aphelion_dates' in params:\n                    print(f\"\\n[DEBUG] Found apsidal dates for {obj_name}\", flush=True)\n                    print(f\"  Perihelion dates: {params.get('perihelion_dates', [])}\", flush=True)\n                    print(f\"  Aphelion dates: {params.get('aphelion_dates', [])}\", flush=True)\n                    \n                    # Get the object ID for fetching positions\n                    obj_id = None\n                    id_type = None\n                    for obj in objects:\n                        if obj['name'] == obj_name:\n                            obj_id = obj['id']\n                            id_type = obj.get('id_type', None)\n                            break\n                    \n                    if obj_id:\n                        # Import the functions we need\n                        from apsidal_markers import fetch_positions_for_apsidal_dates, add_actual_apsidal_markers_enhanced, calculate_exact_apsides, compute_apsidal_dates_from_tp\n                        from datetime import datetime, timedelta\n\n                        # Use the passed fetch_position\n                        if fetch_position is None:\n                            print(\"ERROR: fetch_position not provided to plot_idealized_orbits\", flush=True)\n                        else:\n                            # Calculate apsides HERE, right before use\n                            apsides = calculate_exact_apsides(\n                                params.get('a', a),\n                                params.get('e', e),\n                                params.get('i', i),\n                                params.get('omega', omega),\n                                params.get('Omega', Omega),\n                                rotate_points\n                            )\n                                                \n                            # Resolve center_id to numeric for Horizons queries\n                            center_id_numeric = None\n                            if objects:\n                                for obj in objects:\n                                    if obj['name'] == center_id:\n                                        center_id_numeric = obj['id']\n                                        break\n                            if not center_id_numeric:\n                                satellite_center_ids = {\n                                    'Sun': '10',\n                                    'Earth': '399', 'Mars': '499', 'Jupiter': '599',\n                                    'Saturn': '699', 'Uranus': '799', 'Neptune': '899',\n                                    'Pluto': '999'\n                                }\n                                center_id_numeric = satellite_center_ids.get(center_id, center_id)\n                        \n                            # Fetch positions for the apsidal dates\n                            positions_dict = fetch_positions_for_apsidal_dates(\n                                obj_id=obj_id,\n                                params=params,\n                                date_range=None,  # Don't restrict by date range\n                                center_id=center_id_numeric,  # <-- was center_id\n                                id_type=id_type,\n                                is_satellite=(obj_name in parent_planets.get(center_id, [])),\n                                fetch_position=fetch_position\n                            )\n                                                        \n                            print(f\"  Fetched positions: {len(positions_dict)} dates\", flush=True)\n                            \n                            # Check if fetch failed for dates that passed the initial range check\n                            # This handles satellite ephemeris with shorter ranges than general JPL\n                            perihelion_dates = params.get('perihelion_dates', [])\n                            aphelion_dates = params.get('aphelion_dates', [])\n                            expected_dates = len(perihelion_dates) + len(aphelion_dates)\n                            \n                            if expected_dates > 0 and len(positions_dict) == 0:\n                                # Fetch failed - likely satellite ephemeris range exceeded\n                                print(f\"  [WARN] Fetch failed for {obj_name} apsidal dates - ephemeris range exceeded\", flush=True)\n                                from apsidal_markers import add_apsidal_range_note\n                                \n                                # Get the dates that failed\n                                failed_peri = None\n                                failed_apo = None\n                                if perihelion_dates:\n                                    try:\n                                        failed_peri = datetime.strptime(perihelion_dates[0], '%Y-%m-%d %H:%M:%S')\n                                    except:\n                                        pass\n                                if aphelion_dates:\n                                    try:\n                                        failed_apo = datetime.strptime(aphelion_dates[0], '%Y-%m-%d %H:%M:%S')\n                                    except:\n                                        pass\n                                                            \n                                # Add the range note with appropriate message\n                                add_apsidal_range_note(\n                                    fig,\n                                    obj_name,\n                                    failed_peri,\n                                    failed_apo,\n                                    color_map,\n                                    fetch_failed=True  # Indicates ephemeris limit, not JPL general limit\n                                )\n\n                            # DEBUG: Check what we're passing to enhanced markers\n                            print(f\"[DEBUG] Calling enhanced markers for {obj_name}:\", flush=True)\n                            print(f\"  params has epoch: {'epoch' in params}\", flush=True)\n                            if 'epoch' in params:\n                                print(f\"  epoch value: {params['epoch']}\", flush=True)\n                            print(f\"  ideal_apsides is None: {apsides is None}\", flush=True)\n                            if apsides is not None:\n                                print(f\"  ideal_apsides keys: {apsides.keys()}\", flush=True)\n                            \n                            # Add the actual markers\n                    #        add_actual_apsidal_markers(\n                            add_actual_apsidal_markers_enhanced(    \n                                fig,\n                                obj_name,\n                                params,\n                                date_range=(date - timedelta(days=365), date + timedelta(days=365)),\n                                positions_dict=positions_dict,\n                                color_map=color_map,\n                                center_body=center_id,\n                                is_satellite=(obj_name in parent_planets.get(center_id, [])),\n                                ideal_apsides=apsides,\n                                filter_by_date_range=False\n                            )\n\n            if show_apsidal_markers and 'TP' in params:\n                # Check if we should add a note about out-of-range dates\n                if (next_perihelion and not peri_in_range) or (next_aphelion and not apo_in_range):\n                    from apsidal_markers import add_apsidal_range_note\n                    add_apsidal_range_note(\n                        fig,\n                        obj_name,\n                        next_perihelion if not peri_in_range else None,\n                        next_aphelion if not apo_in_range else None,\n                        color_map\n                    )\n\n            # ========== NEW: ADD KEPLERIAN POSITION MARKER ==========\n            # This shows the analytically calculated current position\n            # based on osculating elements - visible in legend, hidden by default\n            if 'MA' in params and 'epoch' in params:\n                try:\n                    from apsidal_markers import add_keplerian_position_marker\n                    add_keplerian_position_marker(\n                        fig,\n                        obj_name,\n                        params,\n                        date,  # Current datetime\n                        rotate_points,\n                        center_body=center_id\n                    )\n                except Exception as kep_err:\n                    print(f\"[KEPLERIAN POS] Error adding marker for {obj_name}: {kep_err}\", flush=True)\n                    \n            # Mark this object as successfully plotted\n\n            # ========== NEW: ADD LEGEND NOTES FOR OUT-OF-RANGE DATES ==========\n            # Only check these if show_apsidal_markers is True and we have TP\n        #    if show_apsidal_markers and 'TP' in params:\n        #        # Check if we should add a note about out-of-range dates\n        #        if (next_perihelion and not peri_in_range) or (next_aphelion and not apo_in_range):\n        #            from apsidal_markers import add_apsidal_range_note\n        #            add_apsidal_range_note(\n        #                fig,\n        #                obj_name,\n        #                next_perihelion if not peri_in_range else None,\n        #                next_aphelion if not apo_in_range else None,\n        #                color_map\n        #            )\n                    \n            # Mark this object as successfully plotted\n            plotted.append(obj_name)\n\n    # Print summary of plotted and skipped objects\n    print(\"\\nKeplerian Orbit Summary:\", flush=True)\n    print(f\"Plotted Keplerian orbits for {len(plotted)} objects:\", flush=True)\n    for obj in plotted:\n        print(f\"  - {obj}\", flush=True)\n\n    print(\"\\nSkipped Keplerian orbits for:\", flush=True)\n    for category, objects_list in skipped.items():\n        if objects_list:\n            print(f\"\\n{category.capitalize()} ({len(objects_list)}):\", flush=True)\n            for obj in objects_list:\n                print(f\"  - {obj}\", flush=True)\n\n    return fig",
    "start_line": 4450,
    "end_line": 5745,
    "has_docstring": true,
    "docstring": "Plot Keplerian orbits for planets, dwarf planets, asteroids, KBOs, and moons.\nFor non-Sun centers, only plots moons of that center body.\n\nParameters:\n    fig (plotly.graph_objects.Figure): The figure to add orbits to\n    objects_to_plot (list): List of object names to potentially plot orbits for\n    center_id (str): The central body ('Sun' or a planet name)\n    objects (list): List of object dictionaries with metadata\n    planetary_params (dict): Dictionary of orbital parameters for each object\n    parent_planets (dict): Dictionary mapping parent planets to their satellites\n    color_map (callable): Function to get color for an object by name\n    date (datetime): Date for time-varying orbital elements (used for Moon)\n    \nReturns:\n    plotly.graph_objects.Figure: Figure with Keplerian orbits added",
    "parameters": [
      "fig",
      "objects_to_plot",
      "center_id",
      "objects",
      "planetary_params",
      "parent_planets",
      "color_map",
      "date",
      "days_to_plot",
      "current_positions",
      "fetch_position",
      "show_apsidal_markers",
      "parent_window"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_idealized_orbits",
    "component_id": "idealized_orbits.plot_idealized_orbits"
  },
  "idealized_orbits.test_triton_rotations": {
    "id": "idealized_orbits.test_triton_rotations",
    "name": "test_triton_rotations",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "idealized_orbits.rotate_points"
    ],
    "source_code": "def test_triton_rotations(satellite_name, planetary_params, color, fig=None):\n    \"\"\"Test multiple rotation combinations for Triton's orbit\"\"\"\n    if fig is None:\n        fig = go.Figure()\n    \n    try:\n        # Get orbital parameters\n        if satellite_name not in planetary_params:\n            print(f\"Error: No orbital parameters found for {satellite_name}\", flush=True)\n            return fig\n            \n        orbital_params = planetary_params[satellite_name]\n        \n        # Extract orbital elements\n        a = orbital_params.get('a', 0)\n        e = orbital_params.get('e', 0)\n        i = orbital_params.get('i', 0)\n        omega = orbital_params.get('omega', 0)\n        Omega = orbital_params.get('Omega', 0)\n        \n        # Generate ellipse in orbital plane\n        theta = np.linspace(0, 2*np.pi, 360)\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        \n        x_orbit = r * np.cos(theta)\n        y_orbit = r * np.sin(theta)\n        z_orbit = np.zeros_like(theta)\n\n        # Convert angles to radians\n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n\n        # Standard orbital element rotation sequence\n        x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, Omega_rad, 'z')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, omega_rad, 'z')\n        \n        # Neptune's axial tilt is 28.32 degrees\n        neptune_tilt = 28.32\n        \n        # Test combinations\n        combinations = [\n            {\"name\": \"Standard\", \"rotations\": []},\n            {\"name\": \"X+\", \"rotations\": [{\"axis\": 'x', \"angle\": np.radians(neptune_tilt)}]},\n            {\"name\": \"X-\", \"rotations\": [{\"axis\": 'x', \"angle\": np.radians(-neptune_tilt)}]},\n            {\"name\": \"Y+\", \"rotations\": [{\"axis\": 'y', \"angle\": np.radians(neptune_tilt)}]},\n            {\"name\": \"Y-\", \"rotations\": [{\"axis\": 'y', \"angle\": np.radians(-neptune_tilt)}]},\n            {\"name\": \"Z+\", \"rotations\": [{\"axis\": 'z', \"angle\": np.radians(neptune_tilt)}]},\n            {\"name\": \"Z-\", \"rotations\": [{\"axis\": 'z', \"angle\": np.radians(-neptune_tilt)}]},\n            \n            # Compound rotations like what worked for Uranus\n            {\"name\": \"X+Y+\", \"rotations\": [\n                {\"axis\": 'x', \"angle\": np.radians(neptune_tilt)}, \n                {\"axis\": 'y', \"angle\": np.radians(neptune_tilt)}\n            ]},\n            {\"name\": \"X+Y-\", \"rotations\": [\n                {\"axis\": 'x', \"angle\": np.radians(neptune_tilt)}, \n                {\"axis\": 'y', \"angle\": np.radians(-neptune_tilt)}\n            ]},\n            {\"name\": \"X-Y+\", \"rotations\": [\n                {\"axis\": 'x', \"angle\": np.radians(-neptune_tilt)}, \n                {\"axis\": 'y', \"angle\": np.radians(neptune_tilt)}\n            ]},\n            {\"name\": \"X-Y-\", \"rotations\": [\n                {\"axis\": 'x', \"angle\": np.radians(-neptune_tilt)}, \n                {\"axis\": 'y', \"angle\": np.radians(-neptune_tilt)}\n            ]},\n            \n            # Try 90-degree rotations\n            {\"name\": \"X+90\", \"rotations\": [{\"axis\": 'x', \"angle\": np.radians(90)}]},\n            {\"name\": \"Y+90\", \"rotations\": [{\"axis\": 'y', \"angle\": np.radians(90)}]},\n            {\"name\": \"Z+90\", \"rotations\": [{\"axis\": 'z', \"angle\": np.radians(90)}]},\n            \n            # Compound rotations with 90 degrees\n            {\"name\": \"X+90_Y+\", \"rotations\": [\n                {\"axis\": 'x', \"angle\": np.radians(90)}, \n                {\"axis\": 'y', \"angle\": np.radians(neptune_tilt)}\n            ]},\n            {\"name\": \"X+_Y+90\", \"rotations\": [\n                {\"axis\": 'x', \"angle\": np.radians(neptune_tilt)}, \n                {\"axis\": 'y', \"angle\": np.radians(90)}\n            ]},\n            \n            # Try a different approach with pole-based transformation using Neptune's pole\n            {\"name\": \"Neptune Pole\", \"rotations\": [\n                {\"axis\": 'z', \"angle\": np.radians(planet_poles['Neptune']['ra'])},\n                {\"axis\": 'x', \"angle\": np.radians(90 - planet_poles['Neptune']['dec'])}\n            ]},\n\n            # Add these to your combinations list\n            {\"name\": \"Retrograde\", \"rotations\": [\n                {\"axis\": 'z', \"angle\": np.radians(planet_poles['Neptune']['ra'])},\n                {\"axis\": 'x', \"angle\": np.radians(90 - planet_poles['Neptune']['dec'])},\n                {\"axis\": 'z', \"angle\": np.radians(180)}\n            ]},\n            {\"name\": \"Complex\", \"rotations\": [\n                {\"axis\": 'z', \"angle\": np.radians(planet_poles['Neptune']['ra'])},\n                {\"axis\": 'y', \"angle\": np.radians(90 - planet_poles['Neptune']['dec'])},\n                {\"axis\": 'x', \"angle\": np.radians(30)}\n            ]}\n\n        ]\n        \n        # Define line styles and colors for each rotation\n        styles = [\"solid\", \"dash\", \"dot\", \"dashdot\", \"longdash\", \"longdashdot\"]\n        \n        # Apply each rotation combination\n        for idx, combo in enumerate(combinations):\n            x_rotated, y_rotated, z_rotated = x_temp.copy(), y_temp.copy(), z_temp.copy()\n            \n            for rot in combo[\"rotations\"]:\n                x_rotated, y_rotated, z_rotated = rotate_points(\n                    x_rotated, y_rotated, z_rotated, \n                    rot[\"angle\"], rot[\"axis\"]\n                )\n            \n            # Add trace with unique style\n            style = styles[idx % len(styles)]\n            \n            fig.add_trace(\n                go.Scatter3d(\n                    x=x_rotated,\n                    y=y_rotated,\n                    z=z_rotated,\n                    mode='lines',\n                    line=dict(dash=style, width=1, color=color),\n                    name=f\"{satellite_name} {combo['name']}\",\n                    text=[f\"{satellite_name} {combo['name']}\"] * len(x_rotated),\n                    customdata=[f\"{satellite_name} {combo['name']}\"] * len(x_rotated),\n                    hovertemplate='%{text}<extra></extra>',\n                    showlegend=True\n                )\n            )\n        \n        return fig\n        \n    except Exception as e:\n        print(f\"Error in test_triton_rotations: {e}\", flush=True)\n        traceback.print_exc()  # This will print the full stack trace for better debugging\n        return fig",
    "start_line": 5747,
    "end_line": 5887,
    "has_docstring": true,
    "docstring": "Test multiple rotation combinations for Triton's orbit",
    "parameters": [
      "satellite_name",
      "planetary_params",
      "color",
      "fig"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function test_triton_rotations",
    "component_id": "idealized_orbits.test_triton_rotations"
  },
  "idealized_orbits.test_pluto_moon_rotations": {
    "id": "idealized_orbits.test_pluto_moon_rotations",
    "name": "test_pluto_moon_rotations",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "idealized_orbits.rotate_points"
    ],
    "source_code": "def test_pluto_moon_rotations(satellite_name, planetary_params, color, fig=None):\n#def test_pluto_moon_xyz_rotations(satellite_name, planetary_params, color, fig=None):\n    \"\"\"\n    Fine-tuned testing of XYZ rotation combinations for Pluto's moons.\n    This function focuses on variations of X, Y, and Z rotations with different angles.\n    \n    Parameters:\n        satellite_name (str): Name of the satellite (Charon, Styx, Nix, Kerberos or Hydra)\n        planetary_params (dict): Dictionary containing orbital parameters\n        color (str): Color to use for the orbit lines\n        fig (plotly.graph_objects.Figure): Existing figure to add the orbit to\n        \n    Returns:\n        plotly.graph_objects.Figure: Figure with various test orbits added\n    \"\"\"\n    if fig is None:\n        fig = go.Figure()\n    \n    try:\n        # Get orbital parameters\n        if satellite_name not in planetary_params:\n            print(f\"Error: No orbital parameters found for {satellite_name}\", flush=True)\n            return fig\n            \n        orbital_params = planetary_params[satellite_name]\n        \n        # Extract orbital elements\n        a = orbital_params.get('a', 0)\n        e = orbital_params.get('e', 0)\n        i = orbital_params.get('i', 0)\n        omega = orbital_params.get('omega', 0)\n        Omega = orbital_params.get('Omega', 0)\n        \n        print(f\"Testing fine-tuned XYZ rotations for {satellite_name} orbit around Pluto\", flush=True)\n        print(f\"Orbital elements: a={a}, e={e}, i={i} deg, omega={omega} deg, Omega={Omega} deg\", flush=True)\n        \n        # Generate ellipse in orbital plane\n        theta = np.linspace(0, 2*np.pi, 360)\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        \n        x_orbit = r * np.cos(theta)\n        y_orbit = r * np.sin(theta)\n        z_orbit = np.zeros_like(theta)\n\n        # Convert angles to radians\n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n\n        # Standard orbital element rotation sequence\n        x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, Omega_rad, 'z')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, omega_rad, 'z')\n        \n        # Pluto's axial tilt value\n        pluto_tilt = planet_tilts.get('Pluto', -122.53)\n        pluto_tilt_rad = np.radians(pluto_tilt)\n        \n        # Create a list of angles to test\n        # We'll focus on different angles around Pluto's tilt and other relevant values\n        # Using a mix of fixed angles and variations of Pluto's tilt\n        x_angles = [-180, -150, -120, -90, -60, -30, 0, 30, 60, 90, 120, 150, 180]\n        y_angles = [-180, -150, -120, -90, -60, -30, 0, 30, 60, 90, 120, 150, 180]\n        z_angles = [-180, -150, -120, -90, -60, -30, 0, 30, 60, 90, 120, 150, 180]\n        \n        # Define specific combinations to test\n        combinations = []\n        \n        # Base combination that was close\n        combinations.append({\n            \"name\": \"XYZ-Tilt-Base\",\n            \"rotations\": [\n                {\"axis\": 'x', \"angle\": pluto_tilt_rad},\n                {\"axis\": 'y', \"angle\": pluto_tilt_rad},\n                {\"axis\": 'z', \"angle\": pluto_tilt_rad}\n            ]\n        })\n        \n        # Variations around the base XYZ-Tilt rotation\n        # Adjust X rotation\n        for angle in [-135, -125, -115, -110, -105, -100, -95, -90]:\n            combinations.append({\n                \"name\": f\"X{angle}->Y-Tilt->Z-Tilt\",\n                \"rotations\": [\n                    {\"axis\": 'x', \"angle\": np.radians(angle)},\n                    {\"axis\": 'y', \"angle\": pluto_tilt_rad},\n                    {\"axis\": 'z', \"angle\": pluto_tilt_rad}\n                ]\n            })\n        \n        # Adjust Y rotation\n        for angle in [-135, -125, -115, -110, -105, -100, -95, -90]:\n            combinations.append({\n                \"name\": f\"X-Tilt->Y{angle}->Z-Tilt\",\n                \"rotations\": [\n                    {\"axis\": 'x', \"angle\": pluto_tilt_rad},\n                    {\"axis\": 'y', \"angle\": np.radians(angle)},\n                    {\"axis\": 'z', \"angle\": pluto_tilt_rad}\n                ]\n            })\n        \n        # Adjust Z rotation\n        for angle in [-135, -125, -115, -110, -105, -100, -95, -90]:\n            combinations.append({\n                \"name\": f\"X-Tilt->Y-Tilt->Z{angle}\",\n                \"rotations\": [\n                    {\"axis\": 'x', \"angle\": pluto_tilt_rad},\n                    {\"axis\": 'y', \"angle\": pluto_tilt_rad},\n                    {\"axis\": 'z', \"angle\": np.radians(angle)}\n                ]\n            })\n        \n        # Try different rotation orders\n        combinations.append({\n            \"name\": \"YXZ-Tilt\",\n            \"rotations\": [\n                {\"axis\": 'y', \"angle\": pluto_tilt_rad},\n                {\"axis\": 'x', \"angle\": pluto_tilt_rad},\n                {\"axis\": 'z', \"angle\": pluto_tilt_rad}\n            ]\n        })\n        \n        combinations.append({\n            \"name\": \"ZXY-Tilt\",\n            \"rotations\": [\n                {\"axis\": 'z', \"angle\": pluto_tilt_rad},\n                {\"axis\": 'x', \"angle\": pluto_tilt_rad},\n                {\"axis\": 'y', \"angle\": pluto_tilt_rad}\n            ]\n        })\n        \n        # Try modified combinations with 90-degree rotations and Pluto's tilt\n        combinations.append({\n            \"name\": \"X-90->Y-Tilt->Z-Tilt\",\n            \"rotations\": [\n                {\"axis\": 'x', \"angle\": np.radians(-90)},\n                {\"axis\": 'y', \"angle\": pluto_tilt_rad},\n                {\"axis\": 'z', \"angle\": pluto_tilt_rad}\n            ]\n        })\n        \n        combinations.append({\n            \"name\": \"X-Tilt->Y-90->Z-Tilt\",\n            \"rotations\": [\n                {\"axis\": 'x', \"angle\": pluto_tilt_rad},\n                {\"axis\": 'y', \"angle\": np.radians(-90)},\n                {\"axis\": 'z', \"angle\": pluto_tilt_rad}\n            ]\n        })\n        \n        combinations.append({\n            \"name\": \"X-Tilt->Y-Tilt->Z-90\",\n            \"rotations\": [\n                {\"axis\": 'x', \"angle\": pluto_tilt_rad},\n                {\"axis\": 'y', \"angle\": pluto_tilt_rad},\n                {\"axis\": 'z', \"angle\": np.radians(-90)}\n            ]\n        })\n        \n        # Adding some specific combinations that might work well\n        combinations.append({\n            \"name\": \"X-110->Y-115->Z-105\",\n            \"rotations\": [\n                {\"axis\": 'x', \"angle\": np.radians(-110)},\n                {\"axis\": 'y', \"angle\": np.radians(-115)},\n                {\"axis\": 'z', \"angle\": np.radians(-105)}\n            ]\n        })\n        \n        combinations.append({\n            \"name\": \"X-115->Y-115->Z-115\",\n            \"rotations\": [\n                {\"axis\": 'x', \"angle\": np.radians(-115)},\n                {\"axis\": 'y', \"angle\": np.radians(-115)},\n                {\"axis\": 'z', \"angle\": np.radians(-115)}\n            ]\n        })\n        \n        combinations.append({\n            \"name\": \"X-120->Y-120->Z-120\",\n            \"rotations\": [\n                {\"axis\": 'x', \"angle\": np.radians(-120)},\n                {\"axis\": 'y', \"angle\": np.radians(-120)},\n                {\"axis\": 'z', \"angle\": np.radians(-120)}\n            ]\n        })\n        \n        # Fine-tuning around a specific zone\n        for x_angle in [-122, -123]:\n            for y_angle in [-122, -123]:\n                for z_angle in [-122, -123]:\n                    combinations.append({\n                        \"name\": f\"X{x_angle}->Y{y_angle}->Z{z_angle}\",\n                        \"rotations\": [\n                            {\"axis\": 'x', \"angle\": np.radians(x_angle)},\n                            {\"axis\": 'y', \"angle\": np.radians(y_angle)},\n                            {\"axis\": 'z', \"angle\": np.radians(z_angle)}\n                        ]\n                    })\n        \n        # Define line styles for different combinations\n        styles = [\"solid\", \"dash\", \"dot\", \"dashdot\", \"longdash\", \"longdashdot\", \"solid\", \"dash\", \"dot\"]\n        \n        # Apply each rotation combination\n        for idx, combo in enumerate(combinations):\n            x_rotated, y_rotated, z_rotated = x_temp.copy(), y_temp.copy(), z_temp.copy()\n            \n            for rot in combo[\"rotations\"]:\n                x_rotated, y_rotated, z_rotated = rotate_points(\n                    x_rotated, y_rotated, z_rotated, \n                    rot[\"angle\"], rot[\"axis\"]\n                )\n            \n            # Add trace with unique style\n            style = styles[idx % len(styles)]\n            \n            fig.add_trace(\n                go.Scatter3d(\n                    x=x_rotated,\n                    y=y_rotated,\n                    z=z_rotated,\n                    mode='lines',\n                    line=dict(dash=style, width=1, color=color),\n                    name=f\"{satellite_name} {combo['name']}\",\n                    text=[f\"{satellite_name} {combo['name']}\"] * len(x_rotated),\n                    customdata=[f\"{satellite_name} {combo['name']}\"] * len(x_rotated),\n                    hovertemplate='%{text}<extra></extra>',\n                    showlegend=True\n                )\n            )\n        \n        return fig\n        \n    except Exception as e:\n        print(f\"Error in test_pluto_moon_xyz_rotations: {e}\", flush=True)\n        traceback.print_exc()\n        return fig",
    "start_line": 5889,
    "end_line": 6125,
    "has_docstring": true,
    "docstring": "Fine-tuned testing of XYZ rotation combinations for Pluto's moons.\nThis function focuses on variations of X, Y, and Z rotations with different angles.\n\nParameters:\n    satellite_name (str): Name of the satellite (Charon, Styx, Nix, Kerberos or Hydra)\n    planetary_params (dict): Dictionary containing orbital parameters\n    color (str): Color to use for the orbit lines\n    fig (plotly.graph_objects.Figure): Existing figure to add the orbit to\n    \nReturns:\n    plotly.graph_objects.Figure: Figure with various test orbits added",
    "parameters": [
      "satellite_name",
      "planetary_params",
      "color",
      "fig"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function test_pluto_moon_rotations",
    "component_id": "idealized_orbits.test_pluto_moon_rotations"
  },
  "idealized_orbits.very_fine_pluto_rotations": {
    "id": "idealized_orbits.very_fine_pluto_rotations",
    "name": "very_fine_pluto_rotations",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "idealized_orbits.rotate_points"
    ],
    "source_code": "def very_fine_pluto_rotations(satellite_name, planetary_params, color, fig=None, \n                             x_range=(-125, -115), \n                             y_range=(-125, -115), \n                             z_range=(-125, -115),\n                             step=1):\n    \"\"\"\n    Extremely fine-grained testing of XYZ rotation combinations for Pluto's moons.\n    Tests all combinations within specified ranges with the given step size.\n    \n    Parameters:\n        satellite_name (str): Name of the satellite (Charon, Styx, Nix, Kerberos or Hydra)\n        planetary_params (dict): Dictionary containing orbital parameters\n        color (str): Color to use for the orbit lines\n        fig (plotly.graph_objects.Figure): Existing figure to add the orbit to\n        x_range (tuple): Range of X rotation angles to test in degrees (min, max)\n        y_range (tuple): Range of Y rotation angles to test in degrees (min, max)\n        z_range (tuple): Range of Z rotation angles to test in degrees (min, max)\n        step (int): Step size between angles in degrees\n        \n    Returns:\n        plotly.graph_objects.Figure: Figure with various test orbits added\n    \"\"\"\n    if fig is None:\n        fig = go.Figure()\n    \n    try:\n        # Get orbital parameters\n        if satellite_name not in planetary_params:\n            print(f\"Error: No orbital parameters found for {satellite_name}\", flush=True)\n            return fig\n            \n        orbital_params = planetary_params[satellite_name]\n        \n        # Extract orbital elements\n        a = orbital_params.get('a', 0)\n        e = orbital_params.get('e', 0)\n        i = orbital_params.get('i', 0)\n        omega = orbital_params.get('omega', 0)\n        Omega = orbital_params.get('Omega', 0)\n        \n        print(f\"Testing very fine XYZ rotations for {satellite_name} orbit around Pluto\", flush=True)\n        print(f\"X range: {x_range}, Y range: {y_range}, Z range: {z_range}, Step: {step}\", flush=True)\n        \n        # Generate ellipse in orbital plane\n        theta = np.linspace(0, 2*np.pi, 360)\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        \n        x_orbit = r * np.cos(theta)\n        y_orbit = r * np.sin(theta)\n        z_orbit = np.zeros_like(theta)\n\n        # Convert angles to radians\n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n\n        # Standard orbital element rotation sequence\n        x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, Omega_rad, 'z')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, omega_rad, 'z')\n        \n        # Create angle ranges\n        x_angles = range(x_range[0], x_range[1] + 1, step)\n        y_angles = range(y_range[0], y_range[1] + 1, step)\n        z_angles = range(z_range[0], z_range[1] + 1, step)\n        \n        # To limit the number of combinations, we'll only test a few combinations\n        # where all three angles are the same or very similar\n        combinations = []\n        \n        # Same angle for all three rotations\n        for angle in range(max(x_range[0], y_range[0], z_range[0]), \n                           min(x_range[1], y_range[1], z_range[1]) + 1, \n                           step):\n            combinations.append({\n                \"name\": f\"X{angle}->Y{angle}->Z{angle}\",\n                \"rotations\": [\n                    {\"axis\": 'x', \"angle\": np.radians(angle)},\n                    {\"axis\": 'y', \"angle\": np.radians(angle)},\n                    {\"axis\": 'z', \"angle\": np.radians(angle)}\n                ]\n            })\n        \n        # Fixed X, varying Y and Z\n        for x_angle in [x_range[0], (x_range[0] + x_range[1]) // 2, x_range[1]]:\n            for y_angle in y_angles:\n                for z_angle in z_angles:\n                    if abs(y_angle - z_angle) <= step:  # Only when Y and Z are similar\n                        combinations.append({\n                            \"name\": f\"X{x_angle}->Y{y_angle}->Z{z_angle}\",\n                            \"rotations\": [\n                                {\"axis\": 'x', \"angle\": np.radians(x_angle)},\n                                {\"axis\": 'y', \"angle\": np.radians(y_angle)},\n                                {\"axis\": 'z', \"angle\": np.radians(z_angle)}\n                            ]\n                        })\n        \n        # Define line styles for different combinations\n        styles = [\"solid\", \"dash\", \"dot\", \"dashdot\", \"longdash\", \"longdashdot\", \"solid\", \"dash\", \"dot\"]\n        \n        # Apply each rotation combination\n        for idx, combo in enumerate(combinations):\n            x_rotated, y_rotated, z_rotated = x_temp.copy(), y_temp.copy(), z_temp.copy()\n            \n            for rot in combo[\"rotations\"]:\n                x_rotated, y_rotated, z_rotated = rotate_points(\n                    x_rotated, y_rotated, z_rotated, \n                    rot[\"angle\"], rot[\"axis\"]\n                )\n            \n            # Add trace with unique style\n            style = styles[idx % len(styles)]\n            \n            fig.add_trace(\n                go.Scatter3d(\n                    x=x_rotated,\n                    y=y_rotated,\n                    z=z_rotated,\n                    mode='lines',\n                    line=dict(dash=style, width=1, color=color),\n                    name=f\"{satellite_name} {combo['name']}\",\n                    text=[f\"{satellite_name} {combo['name']}\"] * len(x_rotated),\n                    customdata=[f\"{satellite_name} {combo['name']}\"] * len(x_rotated),\n                    hovertemplate='%{text}<extra></extra>',\n                    showlegend=True\n                )\n            )\n        \n        return fig\n        \n    except Exception as e:\n        print(f\"Error in very_fine_pluto_rotations: {e}\", flush=True)\n        traceback.print_exc()\n        return fig",
    "start_line": 6127,
    "end_line": 6260,
    "has_docstring": true,
    "docstring": "Extremely fine-grained testing of XYZ rotation combinations for Pluto's moons.\nTests all combinations within specified ranges with the given step size.\n\nParameters:\n    satellite_name (str): Name of the satellite (Charon, Styx, Nix, Kerberos or Hydra)\n    planetary_params (dict): Dictionary containing orbital parameters\n    color (str): Color to use for the orbit lines\n    fig (plotly.graph_objects.Figure): Existing figure to add the orbit to\n    x_range (tuple): Range of X rotation angles to test in degrees (min, max)\n    y_range (tuple): Range of Y rotation angles to test in degrees (min, max)\n    z_range (tuple): Range of Z rotation angles to test in degrees (min, max)\n    step (int): Step size between angles in degrees\n    \nReturns:\n    plotly.graph_objects.Figure: Figure with various test orbits added",
    "parameters": [
      "satellite_name",
      "planetary_params",
      "color",
      "fig",
      "x_range",
      "y_range",
      "z_range",
      "step"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function very_fine_pluto_rotations",
    "component_id": "idealized_orbits.very_fine_pluto_rotations"
  },
  "idealized_orbits.pluto_system_final_transform": {
    "id": "idealized_orbits.pluto_system_final_transform",
    "name": "pluto_system_final_transform",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [
      "idealized_orbits.rotate_points"
    ],
    "source_code": "def pluto_system_final_transform(satellite_name, planetary_params, color, fig=None, transform=None):\n    \"\"\"\n    Apply a specific optimal transformation to Pluto's moons' orbits.\n    \n    Parameters:\n        satellite_name (str): Name of the satellite (Charon, Styx, Nix, Kerberos or Hydra)\n        planetary_params (dict): Dictionary containing orbital parameters\n        color (str): Color to use for the orbit lines\n        fig (plotly.graph_objects.Figure): Existing figure to add the orbit to\n        transform (dict, optional): Specific transformation to apply, with structure:\n            {\n                \"x_angle\": angle in degrees,\n                \"y_angle\": angle in degrees,\n                \"z_angle\": angle in degrees,\n                \"order\": list of axes in order of rotation, e.g. ['x', 'y', 'z']\n            }\n            \n    Returns:\n        plotly.graph_objects.Figure: Figure with the finalized orbit\n    \"\"\"\n    if fig is None:\n        fig = go.Figure()\n    \n    try:\n        # Get orbital parameters\n        if satellite_name not in planetary_params:\n            print(f\"Error: No orbital parameters found for {satellite_name}\", flush=True)\n            return fig\n            \n        orbital_params = planetary_params[satellite_name]\n        \n        # Extract orbital elements\n        a = orbital_params.get('a', 0)\n        e = orbital_params.get('e', 0)\n        i = orbital_params.get('i', 0)\n        omega = orbital_params.get('omega', 0)\n        Omega = orbital_params.get('Omega', 0)\n        \n        # Default transformation if none provided\n        if transform is None:\n            transform = {\n                \"x_angle\": -120,\n                \"y_angle\": -120,\n                \"z_angle\": -120,\n                \"order\": ['x', 'y', 'z']\n            }\n        \n        print(f\"Applying final transformation to {satellite_name} orbit around Pluto\", flush=True)\n        print(f\"Transformation: X={transform['x_angle']} deg, Y={transform['y_angle']} deg, Z={transform['z_angle']} deg, Order={transform['order']}\", flush=True)\n        \n        # Generate ellipse in orbital plane\n        theta = np.linspace(0, 2*np.pi, 360)\n        r = a * (1 - e**2) / (1 + e * np.cos(theta))\n        \n        x_orbit = r * np.cos(theta)\n        y_orbit = r * np.sin(theta)\n        z_orbit = np.zeros_like(theta)\n\n        # Convert angles to radians\n        i_rad = np.radians(i)\n        omega_rad = np.radians(omega)\n        Omega_rad = np.radians(Omega)\n\n        # Standard orbital element rotation sequence\n        x_temp, y_temp, z_temp = rotate_points(x_orbit, y_orbit, z_orbit, Omega_rad, 'z')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, i_rad, 'x')\n        x_temp, y_temp, z_temp = rotate_points(x_temp, y_temp, z_temp, omega_rad, 'z')\n        \n        # Apply the custom transformation\n        x_rotated, y_rotated, z_rotated = x_temp.copy(), y_temp.copy(), z_temp.copy()\n        \n        # Convert transformation angles to radians\n        x_angle_rad = np.radians(transform['x_angle'])\n        y_angle_rad = np.radians(transform['y_angle'])\n        z_angle_rad = np.radians(transform['z_angle'])\n        \n        # Apply rotations in specified order\n        for axis in transform['order']:\n            if axis == 'x':\n                x_rotated, y_rotated, z_rotated = rotate_points(\n                    x_rotated, y_rotated, z_rotated, x_angle_rad, 'x'\n                )\n            elif axis == 'y':\n                x_rotated, y_rotated, z_rotated = rotate_points(\n                    x_rotated, y_rotated, z_rotated, y_angle_rad, 'y'\n                )\n            elif axis == 'z':\n                x_rotated, y_rotated, z_rotated = rotate_points(\n                    x_rotated, y_rotated, z_rotated, z_angle_rad, 'z'\n                )\n        \n        # Add the finalized orbit trace\n        fig.add_trace(\n            go.Scatter3d(\n                x=x_rotated,\n                y=y_rotated,\n                z=z_rotated,\n                mode='lines',\n                line=dict(width=2, color=color),\n                name=f\"{satellite_name} Final\",\n                text=[f\"{satellite_name} Final Orbit\"] * len(x_rotated),\n                customdata=[f\"{satellite_name} Final Orbit\"] * len(x_rotated),\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            )\n        )\n        \n        return fig\n    \n    except Exception as e:\n        print(f\"Error in pluto_system_final_transform: {e}\", flush=True)\n        traceback.print_exc()\n        return fig",
    "start_line": 6262,
    "end_line": 6374,
    "has_docstring": true,
    "docstring": "Apply a specific optimal transformation to Pluto's moons' orbits.\n\nParameters:\n    satellite_name (str): Name of the satellite (Charon, Styx, Nix, Kerberos or Hydra)\n    planetary_params (dict): Dictionary containing orbital parameters\n    color (str): Color to use for the orbit lines\n    fig (plotly.graph_objects.Figure): Existing figure to add the orbit to\n    transform (dict, optional): Specific transformation to apply, with structure:\n        {\n            \"x_angle\": angle in degrees,\n            \"y_angle\": angle in degrees,\n            \"z_angle\": angle in degrees,\n            \"order\": list of axes in order of rotation, e.g. ['x', 'y', 'z']\n        }\n        \nReturns:\n    plotly.graph_objects.Figure: Figure with the finalized orbit",
    "parameters": [
      "satellite_name",
      "planetary_params",
      "color",
      "fig",
      "transform"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function pluto_system_final_transform",
    "component_id": "idealized_orbits.pluto_system_final_transform"
  },
  "idealized_orbits.calculate_phoebe_correction_from_normals": {
    "id": "idealized_orbits.calculate_phoebe_correction_from_normals",
    "name": "calculate_phoebe_correction_from_normals",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\idealized_orbits.py",
    "relative_path": "idealized_orbits.py",
    "depends_on": [],
    "source_code": "def calculate_phoebe_correction_from_normals():\n    \"\"\"\n    Calculate the optimal rotation to align Keplerian orbit with actual orbit\n    based on their normal vectors.\n    \"\"\"\n    # Normal vectors from your output\n    n_actual = np.array([0.1242, 0.0025, 0.9922])\n    n_ideal = np.array([0.1814, -0.1036, 0.9779])\n    \n    # Calculate rotation axis and angle\n    rotation_axis = np.cross(n_ideal, n_actual)\n    rotation_axis = rotation_axis / np.linalg.norm(rotation_axis)\n    \n    cos_angle = np.dot(n_ideal, n_actual)\n    angle = np.arccos(np.clip(cos_angle, -1, 1))\n    \n    print(f\"Rotation axis: {rotation_axis}\", flush=True)\n    print(f\"Rotation angle: {np.degrees(angle):.2f} deg\", flush=True)\n    \n    # Decompose into X, Y, Z rotations\n    # This is approximate but gives us insight\n    x_component = np.arcsin(rotation_axis[0]) * angle\n    y_component = np.arcsin(rotation_axis[1]) * angle  \n    z_component = np.arcsin(rotation_axis[2]) * angle\n    \n    print(f\"Approximate decomposition:\")\n    print(f\"  X rotation: {np.degrees(x_component):.2f} deg\", flush=True)\n    print(f\"  Y rotation: {np.degrees(y_component):.2f} deg\", flush=True)\n    print(f\"  Z rotation: {np.degrees(z_component):.2f} deg\", flush=True)\n    \n    return rotation_axis, angle",
    "start_line": 6377,
    "end_line": 6407,
    "has_docstring": true,
    "docstring": "Calculate the optimal rotation to align Keplerian orbit with actual orbit\nbased on their normal vectors.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_phoebe_correction_from_normals",
    "component_id": "idealized_orbits.calculate_phoebe_correction_from_normals"
  },
  "inclination_test.rotation_matrix_x": {
    "id": "inclination_test.rotation_matrix_x",
    "name": "rotation_matrix_x",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\inclination_test.py",
    "relative_path": "inclination_test.py",
    "depends_on": [],
    "source_code": "def rotation_matrix_x(angle):\n    \"\"\"Create rotation matrix around X axis\"\"\"\n    c, s = np.cos(angle), np.sin(angle)\n    return np.array([[1, 0, 0], [0, c, -s], [0, s, c]])",
    "start_line": 3,
    "end_line": 6,
    "has_docstring": true,
    "docstring": "Create rotation matrix around X axis",
    "parameters": [
      "angle"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function rotation_matrix_x",
    "component_id": "inclination_test.rotation_matrix_x"
  },
  "inclination_test.rotation_matrix_z": {
    "id": "inclination_test.rotation_matrix_z",
    "name": "rotation_matrix_z",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\inclination_test.py",
    "relative_path": "inclination_test.py",
    "depends_on": [],
    "source_code": "def rotation_matrix_z(angle):\n    \"\"\"Create rotation matrix around Z axis\"\"\"\n    c, s = np.cos(angle), np.sin(angle)\n    return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])",
    "start_line": 8,
    "end_line": 11,
    "has_docstring": true,
    "docstring": "Create rotation matrix around Z axis",
    "parameters": [
      "angle"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function rotation_matrix_z",
    "component_id": "inclination_test.rotation_matrix_z"
  },
  "incremental_cache_manager.CacheMetadata": {
    "id": "incremental_cache_manager.CacheMetadata",
    "name": "CacheMetadata",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\incremental_cache_manager.py",
    "relative_path": "incremental_cache_manager.py",
    "depends_on": [],
    "source_code": "class CacheMetadata:\n    \"\"\"Metadata for cached catalog data.\"\"\"\n    \n    catalog: str  # 'hipparcos', 'gaia', or 'simbad'\n    mode: str  # 'distance' or 'magnitude'\n    limit_value: float  # max distance in ly or magnitude limit\n    \n    # For distance mode\n    min_parallax_mas: Optional[float] = None\n    \n    # Query metadata\n    query_date: str = \"\"\n    entry_count: int = 0\n    file_version: str = \"2.0\"  # Version for compatibility checking\n    \n    # Data ranges actually present in the cache\n    actual_min_distance: Optional[float] = None\n    actual_max_distance: Optional[float] = None\n    actual_min_magnitude: Optional[float] = None\n    actual_max_magnitude: Optional[float] = None\n    \n    def to_dict(self) -> Dict:\n        \"\"\"Convert to dictionary for JSON serialization.\"\"\"\n        return asdict(self)\n    \n    @classmethod\n    def from_dict(cls, data: Dict) -> 'CacheMetadata':\n        \"\"\"Create from dictionary.\"\"\"\n        return cls(**data)\n    \n    def get_cache_key(self) -> str:\n        \"\"\"Generate unique key for this cache configuration.\"\"\"\n        key_parts = [self.catalog, self.mode, str(self.limit_value)]\n        if self.min_parallax_mas:\n            key_parts.append(str(self.min_parallax_mas))\n        key_str = \"_\".join(key_parts)\n        return hashlib.md5(key_str.encode()).hexdigest()[:8]",
    "start_line": 23,
    "end_line": 59,
    "has_docstring": true,
    "docstring": "Metadata for cached catalog data.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class CacheMetadata",
    "component_id": "incremental_cache_manager.CacheMetadata"
  },
  "incremental_cache_manager.IncrementalCacheManager": {
    "id": "incremental_cache_manager.IncrementalCacheManager",
    "name": "IncrementalCacheManager",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\incremental_cache_manager.py",
    "relative_path": "incremental_cache_manager.py",
    "depends_on": [
      "incremental_cache_manager.CacheMetadata"
    ],
    "source_code": "class IncrementalCacheManager:\n    \"\"\"Manages incremental caching for stellar catalog data.\"\"\"\n    \n#    def __init__(self, cache_dir: str = \".\"):\n    def __init__(self, cache_dir: str = \"star_data\"):\n        \"\"\"\n        Initialize cache manager.\n        \n        Args:\n            cache_dir: Directory for cache files\n        \"\"\"\n        self.cache_dir = cache_dir\n        self.metadata_suffix = \"_metadata.json\"\n        \n    def _get_metadata_filename(self, data_filename: str) -> str:\n        \"\"\"Get metadata filename for a data file.\"\"\"\n        base = os.path.splitext(data_filename)[0]\n        return f\"{base}{self.metadata_suffix}\"\n    \n    def load_metadata(self, data_filename: str) -> Optional[CacheMetadata]:\n        \"\"\"Load metadata for a cached data file.\"\"\"\n        metadata_file = self._get_metadata_filename(data_filename)\n        metadata_path = os.path.join(self.cache_dir, metadata_file)\n        \n        if not os.path.exists(metadata_path):\n            return None\n        \n        try:\n            with open(metadata_path, 'r') as f:\n                data = json.load(f)\n            return CacheMetadata.from_dict(data)\n        except Exception as e:\n            logger.warning(f\"Could not load metadata from {metadata_path}: {e}\")\n            return None\n    \n    def save_metadata(self, data_filename: str, metadata: CacheMetadata):\n        \"\"\"Save metadata for a cached data file.\"\"\"\n        metadata_file = self._get_metadata_filename(data_filename)\n        metadata_path = os.path.join(self.cache_dir, metadata_file)\n        \n        try:\n            with open(metadata_path, 'w') as f:\n                json.dump(metadata.to_dict(), f, indent=2)\n            logger.info(f\"Saved metadata to {metadata_path}\")\n        except Exception as e:\n            logger.error(f\"Could not save metadata to {metadata_path}: {e}\")\n    \n    def analyze_data_ranges(self, data: Table, mode: str) -> Dict[str, float]:\n        \"\"\"Analyze actual data ranges in a table.\"\"\"\n        ranges = {}\n        \n        if mode == 'distance' and 'Distance_ly' in data.colnames:\n            distances = data['Distance_ly']\n            valid_distances = distances[np.isfinite(distances)]\n            if len(valid_distances) > 0:\n                ranges['actual_min_distance'] = float(np.min(valid_distances))\n                ranges['actual_max_distance'] = float(np.max(valid_distances))\n        \n        if mode == 'magnitude':\n            # Check various magnitude columns\n            for mag_col in ['Vmag', 'Gmag', 'Estimated_Vmag']:\n                if mag_col in data.colnames:\n                    mags = data[mag_col]\n                    valid_mags = mags[np.isfinite(mags)]\n                    if len(valid_mags) > 0:\n                        ranges['actual_min_magnitude'] = float(np.min(valid_mags))\n                        ranges['actual_max_magnitude'] = float(np.max(valid_mags))\n                        break\n        \n        return ranges\n    \n    def check_cache_validity(self, data_filename: str, mode: str, \n                           limit_value: float) -> Tuple[str, Optional[CacheMetadata]]:\n        \"\"\"\n        Check if cached data is valid for current query parameters.\n        \n        Returns:\n            (status, metadata) where status is one of:\n            - 'exact': Cached data exactly matches requirements\n            - 'subset': Cached data contains more than needed (can filter)\n            - 'expand': Need to fetch additional data (incremental fetch)\n            - 'invalid': Cache is incompatible, need full refetch\n            - 'missing': No cache exists\n        \"\"\"\n        # Check if cache file exists\n        data_path = os.path.join(self.cache_dir, data_filename)\n        if not os.path.exists(data_path):\n            return 'missing', None\n        \n        # Load metadata\n        metadata = self.load_metadata(data_filename)\n        if metadata is None:\n            logger.warning(f\"Cache file {data_filename} exists but has no metadata\")\n            return 'invalid', None\n        \n        # Check compatibility\n        if metadata.mode != mode:\n            logger.info(f\"Cache mode mismatch: {metadata.mode} vs {mode}\")\n            return 'invalid', None\n        \n        # Check limits based on mode\n        if mode == 'distance':\n            if metadata.limit_value == limit_value:\n                return 'exact', metadata\n            elif metadata.limit_value > limit_value:\n                # Cache has more data than needed\n                return 'subset', metadata\n            else:\n                # Need more data\n                return 'expand', metadata\n                \n        elif mode == 'magnitude':\n            if metadata.limit_value == limit_value:\n                return 'exact', metadata\n            elif metadata.limit_value > limit_value:\n                # Cache has fainter stars than needed (can filter)\n                return 'subset', metadata\n            else:\n                # Need fainter stars\n                return 'expand', metadata\n        \n        return 'invalid', None\n    \n    def load_and_filter_cache(self, data_filename: str, metadata: CacheMetadata,\n                             mode: str, limit_value: float) -> Optional[Table]:\n        \"\"\"\n        Load cached data and filter to match current requirements.\n        \n        Args:\n            data_filename: Name of cache file\n            metadata: Cache metadata\n            mode: 'distance' or 'magnitude'\n            limit_value: Current limit value\n            \n        Returns:\n            Filtered table or None if loading fails\n        \"\"\"\n        data_path = os.path.join(self.cache_dir, data_filename)\n        \n        try:\n            # Load cached data\n            logger.info(f\"Loading cached data from {data_filename}\")\n            data = Table.read(data_path, format='votable')\n            \n            # Filter if needed\n            if mode == 'distance' and limit_value < metadata.limit_value:\n                if 'Distance_ly' in data.colnames:\n                    mask = data['Distance_ly'] <= limit_value\n                    data = data[mask]\n                    logger.info(f\"Filtered to {len(data)} stars within {limit_value} ly\")\n                    \n            elif mode == 'magnitude' and limit_value < metadata.limit_value:\n                # Find appropriate magnitude column\n                mag_col = None\n                for col in ['Vmag', 'Gmag', 'Estimated_Vmag']:\n                    if col in data.colnames:\n                        mag_col = col\n                        break\n                \n                if mag_col:\n                    mask = data[mag_col] <= limit_value\n                    data = data[mask]\n                    logger.info(f\"Filtered to {len(data)} stars brighter than {limit_value}\")\n            \n            return data\n            \n        except Exception as e:\n            logger.error(f\"Error loading cache file {data_filename}: {e}\")\n            return None\n    \n    def calculate_incremental_query_params(self, mode: str, old_limit: float,\n                                          new_limit: float) -> Dict[str, Any]:\n        \"\"\"\n        Calculate query parameters for incremental fetch.\n        \n        Returns:\n            Dictionary of query parameters for fetching only new data\n        \"\"\"\n        if mode == 'distance':\n            # For distance, we need stars between old_limit and new_limit\n            # This translates to parallax between new_min and old_min\n            old_min_parallax = (1 / (old_limit / 3.26156)) * 1000  # mas\n            new_min_parallax = (1 / (new_limit / 3.26156)) * 1000  # mas\n            \n            return {\n                'parallax_min': new_min_parallax,\n                'parallax_max': old_min_parallax,\n                'description': f\"stars between {old_limit:.1f} and {new_limit:.1f} ly\"\n            }\n            \n        elif mode == 'magnitude':\n            # For magnitude, we need stars between old_limit and new_limit\n            return {\n                'mag_min': old_limit,\n                'mag_max': new_limit,\n                'description': f\"stars between magnitude {old_limit:.1f} and {new_limit:.1f}\"\n            }\n        \n        return {}\n    \n    def merge_tables(self, existing_data: Table, new_data: Table,\n                    mode: str) -> Table:\n        \"\"\"\n        Merge existing and new data tables, removing duplicates.\n        \n        Args:\n            existing_data: Existing cached data\n            new_data: Newly fetched data\n            mode: 'distance' or 'magnitude'\n            \n        Returns:\n            Merged table without duplicates\n        \"\"\"\n        if new_data is None or len(new_data) == 0:\n            return existing_data\n        \n        if existing_data is None or len(existing_data) == 0:\n            return new_data\n        \n        try:\n            # Combine tables\n            combined = vstack([existing_data, new_data])\n            \n            # Remove duplicates based on unique identifier\n            # Try different ID columns\n            id_columns = ['HIP', 'Source', 'Gaia']\n            \n            for id_col in id_columns:\n                if id_col in combined.colnames:\n                    # Get unique IDs\n                    unique_ids, unique_indices = np.unique(\n                        combined[id_col], return_index=True\n                    )\n                    \n                    # Keep only unique entries\n                    combined = combined[unique_indices]\n                    logger.info(f\"Removed duplicates using {id_col}, \"\n                               f\"{len(combined)} unique entries remain\")\n                    break\n            \n            return combined\n            \n        except Exception as e:\n            logger.error(f\"Error merging tables: {e}\")\n            # Return existing data as fallback\n            return existing_data\n    \n    def save_data_with_metadata(self, data: Table, data_filename: str,\n                               catalog: str, mode: str, limit_value: float,\n                               min_parallax_mas: Optional[float] = None):\n        \"\"\"\n        Save data table with associated metadata.\n        \n        Args:\n            data: Table to save\n            data_filename: Output filename\n            catalog: Catalog name ('hipparcos', 'gaia')\n            mode: Query mode ('distance', 'magnitude')\n            limit_value: Query limit value\n            min_parallax_mas: Minimum parallax for distance queries\n        \"\"\"\n        data_path = os.path.join(self.cache_dir, data_filename)\n        \n        # Analyze data ranges\n        ranges = self.analyze_data_ranges(data, mode)\n        \n        # Create metadata\n        metadata = CacheMetadata(\n            catalog=catalog,\n            mode=mode,\n            limit_value=limit_value,\n            min_parallax_mas=min_parallax_mas,\n            query_date=time.strftime(\"%Y-%m-%d %H:%M:%S\"),\n            entry_count=len(data),\n            **ranges\n        )\n        \n        # Save data\n        try:\n            data.write(data_path, format='votable', overwrite=True)\n            logger.info(f\"Saved {len(data)} entries to {data_filename}\")\n            \n            # Save metadata\n            self.save_metadata(data_filename, metadata)\n            \n        except Exception as e:\n            logger.error(f\"Error saving data to {data_filename}: {e}\")",
    "start_line": 62,
    "end_line": 348,
    "has_docstring": true,
    "docstring": "Manages incremental caching for stellar catalog data.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class IncrementalCacheManager",
    "component_id": "incremental_cache_manager.IncrementalCacheManager"
  },
  "incremental_cache_manager.SimbadCacheManager": {
    "id": "incremental_cache_manager.SimbadCacheManager",
    "name": "SimbadCacheManager",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\incremental_cache_manager.py",
    "relative_path": "incremental_cache_manager.py",
    "depends_on": [],
    "source_code": "class SimbadCacheManager:\n    \"\"\"Manages caching for SIMBAD property queries.\"\"\"\n    \n#    def __init__(self, cache_dir: str = \".\"):\n    def __init__(self, cache_dir: str = \"star_data\"):\n        \"\"\"Initialize SIMBAD cache manager.\"\"\"\n        self.cache_dir = cache_dir\n        self.cache_index_file = os.path.join(cache_dir, \"simbad_cache_index.json\")\n        self.cache_index = self._load_cache_index()\n    \n    def _load_cache_index(self) -> Dict[str, Dict]:\n        \"\"\"Load the cache index that tracks all cached objects.\"\"\"\n        if os.path.exists(self.cache_index_file):\n            try:\n                with open(self.cache_index_file, 'r') as f:\n                    return json.load(f)\n            except Exception as e:\n                logger.warning(f\"Could not load cache index: {e}\")\n        return {}\n    \n    def _save_cache_index(self):\n        \"\"\"Save the cache index.\"\"\"\n        try:\n            with open(self.cache_index_file, 'w') as f:\n                json.dump(self.cache_index, f, indent=2)\n        except Exception as e:\n            logger.error(f\"Could not save cache index: {e}\")\n    \n    def get_cached_objects(self, object_ids: List[str]) -> Tuple[Dict, List[str]]:\n        \"\"\"\n        Get cached SIMBAD properties for a list of objects.\n        \n        Returns:\n            (cached_properties, missing_ids)\n        \"\"\"\n        cached = {}\n        missing = []\n        \n        for obj_id in object_ids:\n            if obj_id in self.cache_index:\n                # Check if cache is recent enough (e.g., less than 30 days old)\n                cache_data = self.cache_index[obj_id]\n                cache_time = cache_data.get('cache_time', 0)\n                age_days = (time.time() - cache_time) / 86400\n                \n                if age_days < 30:  # Cache valid for 30 days\n                    cached[obj_id] = cache_data.get('properties', {})\n                else:\n                    missing.append(obj_id)\n                    logger.info(f\"Cache for {obj_id} is {age_days:.1f} days old, refetching\")\n            else:\n                missing.append(obj_id)\n        \n        logger.info(f\"Found {len(cached)} cached objects, {len(missing)} missing\")\n        return cached, missing\n    \n    def update_cache(self, new_properties: Dict):\n        \"\"\"Update cache with newly fetched properties.\"\"\"\n        for obj_id, props in new_properties.items():\n            self.cache_index[obj_id] = {\n                'properties': props,\n                'cache_time': time.time()\n            }\n        \n        self._save_cache_index()\n        logger.info(f\"Updated cache with {len(new_properties)} objects\")",
    "start_line": 351,
    "end_line": 416,
    "has_docstring": true,
    "docstring": "Manages caching for SIMBAD property queries.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class SimbadCacheManager",
    "component_id": "incremental_cache_manager.SimbadCacheManager"
  },
  "incremental_cache_manager.smart_load_or_fetch_hipparcos": {
    "id": "incremental_cache_manager.smart_load_or_fetch_hipparcos",
    "name": "smart_load_or_fetch_hipparcos",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\incremental_cache_manager.py",
    "relative_path": "incremental_cache_manager.py",
    "depends_on": [
      "incremental_cache_manager.IncrementalCacheManager",
      "data_acquisition.load_or_fetch_hipparcos_data"
    ],
    "source_code": "def smart_load_or_fetch_hipparcos(v, hip_data_file: str, mode: str,\n                                  limit_value: float, **kwargs) -> Optional[Table]:\n    \"\"\"\n    Smart loading/fetching for Hipparcos data with incremental caching.\n    \n    This replaces the existing load_or_fetch_hipparcos_data function.\n    \"\"\"\n    from data_acquisition import load_or_fetch_hipparcos_data\n    \n    cache_mgr = IncrementalCacheManager()\n    \n    # ADD THIS BLOCK (before existing \"Check cache status\" line):\n    # COMPREHENSIVE CACHE PROTECTION\n    # If we have a large comprehensive cache, just filter it instead of fetching\n    cache_path = os.path.join(cache_mgr.cache_dir, hip_data_file)\n    if os.path.exists(cache_path):\n        file_size = os.path.getsize(cache_path)\n        \n        # Check if this is a comprehensive cache (>1MB = likely complete)\n        # Hipparcos has ~118,000 stars, comprehensive cache should be 100KB-1MB+\n        if file_size > 1_000_000:  # >1MB\n            # For magnitude mode with reasonable limits\n            if mode == 'magnitude' and limit_value <= 10.0:\n                logger.info(f\"Using comprehensive Hipparcos magnitude cache (size: {file_size/1e6:.1f}MB)\")\n                try:\n                    data = Table.read(cache_path, format='votable')\n                    \n                    # Filter to requested magnitude\n                    if 'Vmag' in data.colnames:\n                        mask = data['Vmag'] <= limit_value\n                        filtered = data[mask]\n                        logger.info(f\"Filtered Hipparcos cache from {len(data)} to {len(filtered)} stars <= mag {limit_value}\")\n                        return filtered\n                    else:\n                        logger.warning(\"No Vmag column found in Hipparcos cache\")\n                        return data\n                        \n                except Exception as e:\n                    logger.warning(f\"Could not read Hipparcos cache, falling back to normal logic: {e}\")\n            \n            # For distance mode with reasonable limits\n            elif mode == 'distance' and limit_value <= 150:  # Within 150 light-years\n                logger.info(f\"Using comprehensive Hipparcos distance cache (size: {file_size/1e6:.1f}MB)\")\n                try:\n                    data = Table.read(cache_path, format='votable')\n                    \n                    # Filter to requested distance\n                    if 'Distance_ly' in data.colnames:\n                        mask = data['Distance_ly'] <= limit_value\n                        filtered = data[mask]\n                        logger.info(f\"Filtered Hipparcos cache from {len(data)} to {len(filtered)} stars <= {limit_value} ly\")\n                        return filtered\n                    else:\n                        logger.warning(\"No Distance_ly column found in Hipparcos cache\")\n                        return data\n                        \n                except Exception as e:\n                    logger.warning(f\"Could not read Hipparcos cache, falling back to normal logic: {e}\")\n    \n    # Check cache status\n    status, metadata = cache_mgr.check_cache_validity(hip_data_file, mode, limit_value)\n   \n    logger.info(f\"Hipparcos cache status: {status}\")\n    \n    if status == 'exact':\n        # Perfect match, just load\n        return cache_mgr.load_and_filter_cache(hip_data_file, metadata, mode, limit_value)\n    \n    elif status == 'subset':\n        # Have more data than needed, filter it\n        return cache_mgr.load_and_filter_cache(hip_data_file, metadata, mode, limit_value)\n    \n    elif status == 'expand':\n        # Need to fetch additional data\n        logger.info(f\"Incremental fetch needed: {metadata.limit_value} -> {limit_value}\")\n        \n        # Load existing data\n        existing_data = Table.read(os.path.join(cache_mgr.cache_dir, hip_data_file),\n                                  format='votable')\n        \n        # Calculate parameters for incremental fetch\n        params = cache_mgr.calculate_incremental_query_params(\n            mode, metadata.limit_value, limit_value\n        )\n        \n        logger.info(f\"Fetching {params['description']}\")\n        \n        # Fetch only new data\n        # This would need modification of the original fetch function\n        # to accept min/max constraints\n        # For now, we'll fall back to full fetch\n        new_data = load_or_fetch_hipparcos_data(\n            v, f\"temp_{hip_data_file}\", mode=mode,\n            mag_limit=limit_value if mode == 'magnitude' else None,\n            parallax_constraint=kwargs.get('parallax_constraint')\n        )\n        \n        # Merge old and new data\n        if new_data is not None:\n            combined = cache_mgr.merge_tables(existing_data, new_data, mode)\n            \n            # Save merged data\n            min_parallax = None\n            if mode == 'distance':\n                min_parallax = (1 / (limit_value / 3.26156)) * 1000\n            \n            cache_mgr.save_data_with_metadata(\n                combined, hip_data_file, 'hipparcos', mode, \n                limit_value, min_parallax\n            )\n            \n            return combined\n        \n        return existing_data\n    \n    else:  # 'missing' or 'invalid'\n        # Need full fetch\n        data = load_or_fetch_hipparcos_data(\n            v, hip_data_file, mode=mode,\n            mag_limit=limit_value if mode == 'magnitude' else None,\n            parallax_constraint=kwargs.get('parallax_constraint')\n        )\n        \n        if data is not None:\n            # Save with metadata\n            min_parallax = None\n            if mode == 'distance':\n                min_parallax = (1 / (limit_value / 3.26156)) * 1000\n            \n            cache_mgr.save_data_with_metadata(\n                data, hip_data_file, 'hipparcos', mode,\n                limit_value, min_parallax\n            )\n        \n        return data",
    "start_line": 422,
    "end_line": 556,
    "has_docstring": true,
    "docstring": "Smart loading/fetching for Hipparcos data with incremental caching.\n\nThis replaces the existing load_or_fetch_hipparcos_data function.",
    "parameters": [
      "v",
      "hip_data_file",
      "mode",
      "limit_value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function smart_load_or_fetch_hipparcos",
    "component_id": "incremental_cache_manager.smart_load_or_fetch_hipparcos"
  },
  "incremental_cache_manager.smart_load_or_fetch_gaia": {
    "id": "incremental_cache_manager.smart_load_or_fetch_gaia",
    "name": "smart_load_or_fetch_gaia",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\incremental_cache_manager.py",
    "relative_path": "incremental_cache_manager.py",
    "depends_on": [
      "incremental_cache_manager.IncrementalCacheManager",
      "data_acquisition.load_or_fetch_gaia_data"
    ],
    "source_code": "def smart_load_or_fetch_gaia(v, gaia_data_file: str, mode: str,\n                             limit_value: float, **kwargs) -> Optional[Table]:\n    \"\"\"\n    Smart loading/fetching for Gaia data with incremental caching.\n    \n    This replaces the existing load_or_fetch_gaia_data function.\n    \"\"\"\n    from data_acquisition import load_or_fetch_gaia_data\n    \n    cache_mgr = IncrementalCacheManager()\n        \n    # COMPREHENSIVE CACHE PROTECTION\n    # If we have a large comprehensive cache, just filter it instead of fetching\n    cache_path = os.path.join(cache_mgr.cache_dir, gaia_data_file)\n    if os.path.exists(cache_path):\n        file_size = os.path.getsize(cache_path)\n        \n        # Check if this is a comprehensive cache\n        # Gaia has millions of stars, comprehensive cache is >10MB\n        if file_size > 10_000_000:  # >10MB\n            # For magnitude mode with reasonable limits\n            if mode == 'magnitude' and limit_value <= 9.0:\n                logger.info(f\"Using comprehensive Gaia magnitude cache (size: {file_size/1e6:.1f}MB)\")\n                try:\n                    data = Table.read(cache_path, format='votable')\n                    \n                    # Filter to requested magnitude\n                    mag_col = None\n                    for col in ['Gmag', 'Estimated_Vmag']:\n                        if col in data.colnames:\n                            mag_col = col\n                            break\n                    \n                    if mag_col:\n                        mask = data[mag_col] <= limit_value\n                        filtered = data[mask]\n                        logger.info(f\"Filtered Gaia cache from {len(data)} to {len(filtered)} stars <= mag {limit_value}\")\n                        return filtered\n                    else:\n                        logger.warning(\"No magnitude column found in Gaia cache\")\n                        return data\n                        \n                except Exception as e:\n                    logger.warning(f\"Could not read Gaia cache, falling back to normal logic: {e}\")\n            \n            # For distance mode with reasonable limits\n            elif mode == 'distance' and limit_value <= 150:  # Within 150 light-years\n                logger.info(f\"Using comprehensive Gaia distance cache (size: {file_size/1e6:.1f}MB)\")\n                try:\n                    data = Table.read(cache_path, format='votable')\n                    \n                    # Filter to requested distance\n                    if 'Distance_ly' in data.colnames:\n                        mask = data['Distance_ly'] <= limit_value\n                        filtered = data[mask]\n                        logger.info(f\"Filtered Gaia cache from {len(data)} to {len(filtered)} stars <= {limit_value} ly\")\n                        return filtered\n                    else:\n                        logger.warning(\"No Distance_ly column found in Gaia cache\")\n                        return data\n                        \n                except Exception as e:\n                    logger.warning(f\"Could not read Gaia cache, falling back to normal logic: {e}\")\n\n    # NORMAL CACHE LOGIC for all other cases\n    # Check cache status\n    status, metadata = cache_mgr.check_cache_validity(gaia_data_file, mode, limit_value)\n    \n    logger.info(f\"Gaia cache status: {status}\")\n    \n    if status == 'exact':\n        # Perfect match, just load\n        return cache_mgr.load_and_filter_cache(gaia_data_file, metadata, mode, limit_value)\n    \n    elif status == 'subset':\n        # Have more data than needed, filter it\n        return cache_mgr.load_and_filter_cache(gaia_data_file, metadata, mode, limit_value)\n    \n    elif status == 'expand':\n        # For magnitude mode, avoid re-fetching if we have a good cache\n        if mode == 'magnitude':\n            logger.info(f\"Avoiding Gaia magnitude mode expansion - using existing cache\")\n            if metadata:\n                return cache_mgr.load_and_filter_cache(gaia_data_file, metadata, mode, limit_value)\n        \n        # For distance mode, continue with incremental fetch\n        logger.info(f\"Incremental fetch needed: {metadata.limit_value} -> {limit_value}\")\n        \n        # Load existing data\n        existing_data = Table.read(os.path.join(cache_mgr.cache_dir, gaia_data_file),\n                                  format='votable')\n        \n        # Calculate parameters for incremental fetch\n        params = cache_mgr.calculate_incremental_query_params(\n            mode, metadata.limit_value, limit_value\n        )\n        \n        logger.info(f\"Fetching {params['description']}\")\n        \n        # Fetch only new data\n        # For now, fall back to full fetch (would need API modification)\n        new_data = load_or_fetch_gaia_data(\n            v, f\"temp_{gaia_data_file}\", mode=mode,\n            mag_limit=limit_value if mode == 'magnitude' else None,\n            parallax_constraint=kwargs.get('parallax_constraint')\n        )\n        \n        # Merge old and new data\n        if new_data is not None:\n            combined = cache_mgr.merge_tables(existing_data, new_data, mode)\n            \n            # Save merged data\n            min_parallax = None\n            if mode == 'distance':\n                min_parallax = (1 / (limit_value / 3.26156)) * 1000\n            \n            cache_mgr.save_data_with_metadata(\n                combined, gaia_data_file, 'gaia', mode,\n                limit_value, min_parallax\n            )\n            \n            return combined\n        \n        return existing_data\n    \n    else:  # 'missing' or 'invalid'\n        # Need full fetch\n        data = load_or_fetch_gaia_data(\n            v, gaia_data_file, mode=mode,\n            mag_limit=limit_value if mode == 'magnitude' else None,\n            parallax_constraint=kwargs.get('parallax_constraint')\n        )\n        \n        if data is not None:\n            # Save with metadata\n            min_parallax = None\n            if mode == 'distance':\n                min_parallax = (1 / (limit_value / 3.26156)) * 1000\n            \n            cache_mgr.save_data_with_metadata(\n                data, gaia_data_file, 'gaia', mode,\n                limit_value, min_parallax\n            )\n        \n        return data",
    "start_line": 559,
    "end_line": 703,
    "has_docstring": true,
    "docstring": "Smart loading/fetching for Gaia data with incremental caching.\n\nThis replaces the existing load_or_fetch_gaia_data function.",
    "parameters": [
      "v",
      "gaia_data_file",
      "mode",
      "limit_value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function smart_load_or_fetch_gaia",
    "component_id": "incremental_cache_manager.smart_load_or_fetch_gaia"
  },
  "jupiter_visualization_shells.create_ring_points_jupiter": {
    "id": "jupiter_visualization_shells.create_ring_points_jupiter",
    "name": "create_ring_points_jupiter",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\jupiter_visualization_shells.py",
    "relative_path": "jupiter_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_ring_points_jupiter (inner_radius, outer_radius, n_points=100, thickness=0.01):\n    \"\"\"\n    Create points for a ring structure (for planets like Saturn).\n    \n    Parameters:\n        inner_radius (float): Inner radius of the ring in AU\n        outer_radius (float): Outer radius of the ring in AU\n        n_points (int): Number of points to generate for each ring dimension\n        thickness (float): Thickness of the ring in AU\n        \n    Returns:\n        tuple: (x, y, z) coordinates as flattened arrays\n    \"\"\"\n    # Generate radial and angular points\n    radii = np.linspace(inner_radius, outer_radius, n_points // 4)\n    thetas = np.linspace(0, 2*np.pi, n_points)\n    \n    # Create a meshgrid of radii and angles\n    r, theta = np.meshgrid(radii, thetas)\n    \n    # Generate the ring coords on x-y plane\n    x = r * np.cos(theta)\n    y = r * np.sin(theta)\n    \n    # Generate some points along z to give minimal thickness\n    z_values = np.linspace(-thickness/2, thickness/2, 3)\n    \n    # Replicate the x, y coordinates for each z value\n    x_all = []\n    y_all = []\n    z_all = []\n    \n    for z_val in z_values:\n        x_all.append(x.flatten())\n        y_all.append(y.flatten())\n        z_all.append(np.full_like(x.flatten(), z_val))\n    \n    # Combine all points\n    return np.concatenate(x_all), np.concatenate(y_all), np.concatenate(z_all)",
    "start_line": 7,
    "end_line": 45,
    "has_docstring": true,
    "docstring": "Create points for a ring structure (for planets like Saturn).\n\nParameters:\n    inner_radius (float): Inner radius of the ring in AU\n    outer_radius (float): Outer radius of the ring in AU\n    n_points (int): Number of points to generate for each ring dimension\n    thickness (float): Thickness of the ring in AU\n    \nReturns:\n    tuple: (x, y, z) coordinates as flattened arrays",
    "parameters": [
      "inner_radius",
      "outer_radius",
      "n_points",
      "thickness"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_ring_points_jupiter",
    "component_id": "jupiter_visualization_shells.create_ring_points_jupiter"
  },
  "jupiter_visualization_shells.create_jupiter_core_shell": {
    "id": "jupiter_visualization_shells.create_jupiter_core_shell",
    "name": "create_jupiter_core_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\jupiter_visualization_shells.py",
    "relative_path": "jupiter_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_jupiter_core_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Jupiter's core shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.1,  # Approximately 10% of Jupiter's radius\n        'color': 'rgb(175, 175, 255)',  # estimated black body color at about 20,000 K\n        'opacity': 1.0,\n        'name': 'Core',\n        'description': (\n            \"Jupiter's core is believed to be a dense mixture of rock, metal, and hydrogen compounds.<br>\"\n            \"It may be up to 10 times the mass of Earth. Recent models suggest the core might be<br>\"\n            \"partially dissolved or 'fuzzy' rather than a distinct solid structure. Its temperature<br>\"\n            \"is estimated at about 20,000K and up to 40,000K. The color chosen approximates a black body.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * JUPITER_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=4.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Jupiter: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Jupiter: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 57,
    "end_line": 102,
    "has_docstring": true,
    "docstring": "Creates Jupiter's core shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_jupiter_core_shell",
    "component_id": "jupiter_visualization_shells.create_jupiter_core_shell"
  },
  "jupiter_visualization_shells.create_jupiter_metallic_hydrogen_shell": {
    "id": "jupiter_visualization_shells.create_jupiter_metallic_hydrogen_shell",
    "name": "create_jupiter_metallic_hydrogen_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\jupiter_visualization_shells.py",
    "relative_path": "jupiter_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_jupiter_metallic_hydrogen_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Jupiter's metallic hydrogen shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.8,  # Up to about 80% of Jupiter's radius\n        'color': 'rgb(225, 225, 255)',  # estimated black body color at about 10,000 K\n        'opacity': 0.9,\n        'name': 'Metallic Hydrogen Layer',\n        'description': (\n            \"Metallic Hydrogen Layer:<br>\" \n            \"Under extreme pressure, hydrogen transitions to a metallic state in this layer.<br>\"\n            \"It behaves like an electrical conductor and is responsible for generating<br>\"\n            \"Jupiter's powerful magnetic field. Temperatures in this region may reach 10,000K.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * JUPITER_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.5,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Jupiter: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Jupiter: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 111,
    "end_line": 156,
    "has_docstring": true,
    "docstring": "Creates Jupiter's metallic hydrogen shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_jupiter_metallic_hydrogen_shell",
    "component_id": "jupiter_visualization_shells.create_jupiter_metallic_hydrogen_shell"
  },
  "jupiter_visualization_shells.create_jupiter_molecular_hydrogen_shell": {
    "id": "jupiter_visualization_shells.create_jupiter_molecular_hydrogen_shell",
    "name": "create_jupiter_molecular_hydrogen_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\jupiter_visualization_shells.py",
    "relative_path": "jupiter_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_jupiter_molecular_hydrogen_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Jupiter's molecular hydrogen shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.97,  # Up to about 97% of Jupiter's radius\n        'color': 'rgb(255, 255, 200)',  # estimated black body color at about 5,000 K \n        'opacity': 0.5,\n        'name': 'Molecular Hydrogen Layer',\n        'description': (\n            \"Molecular Hydrogen Layer:<br>\" \n            \"This layer consists of hydrogen in its molecular form. The transition from metallic<br>\"\n            \"to molecular hydrogen is gradual. This layer makes up the bulk of Jupiter's mass<br>\"\n            \"and is marked by decreasing temperature and pressure as you move outward. The temperature<br>\"\n            \"ranges from about 5,000K (outer) to 10,000K (inner).\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * JUPITER_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Jupiter: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Jupiter: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 166,
    "end_line": 212,
    "has_docstring": true,
    "docstring": "Creates Jupiter's molecular hydrogen shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_jupiter_molecular_hydrogen_shell",
    "component_id": "jupiter_visualization_shells.create_jupiter_molecular_hydrogen_shell"
  },
  "jupiter_visualization_shells.create_jupiter_cloud_layer_shell": {
    "id": "jupiter_visualization_shells.create_jupiter_cloud_layer_shell",
    "name": "create_jupiter_cloud_layer_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\jupiter_visualization_shells.py",
    "relative_path": "jupiter_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_jupiter_cloud_layer_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Jupiter's cloud layer shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.0,  # The visible \"surface\" - 100% of Jupiter's radius\n        'color': 'rgb(255, 255, 235)',  # optical\n        'opacity': 1.0,\n        'name': 'Cloud Layer',\n        'description': (\n            \"Jupiter Cloud Layer<br>\" \n            \"(Note: toggle off the cloud layer in the legend to better see the interior structure.)<br><br>\"\n            \"Jupiter's visible cloud layer consists of bands of different colors, caused by<br>\"\n            \"variations in chemical composition and atmospheric dynamics. The clouds are primarily<br>\"\n            \"composed of ammonia, ammonium hydrosulfide, and water. The famous Great Red Spot<br>\"\n            \"is a massive storm system located in this layer. Temperature ranges from 120 K in<br>\" \n            \"the highest ammonia ice clouds to about 200 K in the lower ammonium hydrosulfide clouds.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    radius = layer_info['radius_fraction'] * JUPITER_RADIUS_AU\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Create mesh with reasonable resolution for performance\n    resolution = 24  # Reduced from typical 50 for markers\n    \n    # Create a UV sphere\n    phi = np.linspace(0, 2*np.pi, resolution)\n    theta = np.linspace(-np.pi/2, np.pi/2, resolution)\n    phi, theta = np.meshgrid(phi, theta)\n    \n    x = radius * np.cos(theta) * np.cos(phi)\n    y = radius * np.cos(theta) * np.sin(phi)\n    z = radius * np.sin(theta)\n    \n    # Apply center position offset\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    # Create triangulation\n    indices = []\n    for i in range(resolution-1):\n        for j in range(resolution-1):\n            p1 = i * resolution + j\n            p2 = i * resolution + (j + 1)\n            p3 = (i + 1) * resolution + j\n            p4 = (i + 1) * resolution + (j + 1)\n            \n            indices.append([p1, p2, p4])\n            indices.append([p1, p4, p3])\n    \n    # Create main surface\n    surface_trace = go.Mesh3d(\n        x=x.flatten(), \n        y=y.flatten(), \n        z=z.flatten(),\n        i=[idx[0] for idx in indices],\n        j=[idx[1] for idx in indices],\n        k=[idx[2] for idx in indices],\n        color=layer_info['color'],\n        opacity=layer_info['opacity'],\n        name=f\"Jupiter: {layer_info['name']}\",\n        showlegend=True,\n        hoverinfo='none',  # Disable hover on mesh surface\n        # Add these new parameters to make hover text invisible\n        hovertemplate=' ',  # Empty template instead of None\n        hoverlabel=dict(\n    #        bgcolor='rgba(0,0,0,0)',  # Transparent background\n            font=dict(\n                color='rgba(0,0,0,0)',  # Transparent text\n    #            size=0                  # Zero font size\n            ),\n            bordercolor='rgba(0,0,0,0)'  # Transparent border\n        ), \n        # Add these new parameters to eliminate shading\n        flatshading=True,  # Use flat shading instead of smooth\n        lighting=dict(\n            ambient=1.0,     # Set to maximum (1.0)\n            diffuse=0.0,     # Turn off diffuse lighting\n            specular=0.0,    # Turn off specular highlights\n            roughness=1.0,   # Maximum roughness\n            fresnel=0.0      # Turn off fresnel effect\n        ),\n        lightposition=dict(\n            x=0,  # Centered light\n            y=0,  # Centered light\n            z=10000  # Light from very far above to minimize shadows\n        )       \n    )\n        \n    # Use the Fibonacci sphere algorithm for more even point distribution\n    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points\n    \n    # Generate fibonacci sphere points\n    fib_points = fibonacci_sphere(samples=50)  # Originally, 50 hover points evenly distributed\n    \n    # Scale and offset the points\n    x_hover = [p[0] * radius + center_x for p in fib_points]\n    y_hover = [p[1] * radius + center_y for p in fib_points]\n    z_hover = [p[2] * radius + center_z for p in fib_points]\n        \n    # Create a list of repeated descriptions for each point\n    # This is crucial - we need exactly one text entry per point\n    hover_texts = [layer_info['description']] * len(x_hover)\n\n    # Just the name for \"Object Names Only\" mode\n    layer_name = f\"Jupiter: {layer_info['name']}\"\n    minimal_hover_texts = [layer_name] * len(x_hover)\n\n    # Create hover trace with direct text assignment\n    hover_trace = go.Scatter3d(\n        x=x_hover, \n        y=y_hover, \n        z=z_hover,\n        mode='markers',\n        marker=dict(\n            size=2,  # originally 5\n            color='rgb(255, 255, 235)',  # Layer color, originally 'white'\n            opacity=1.0,  # originally 0.8\n            line=dict(  # Add a contrasting outline\n                width=1,\n                color='black'\n            )\n        ),\n        name=f\"Jupiter: {layer_info['name']} (Info)\",\n        text=hover_texts,  # IMPORTANT: Matching length with coordinate arrays\n        customdata=minimal_hover_texts,  # For \"Object Names Only\" mode\n        hovertemplate='%{text}<extra></extra>',  # Use the standard hover template\n        showlegend=False  # Don't show in legend since it's just for hover\n    )\n\n    return [surface_trace, hover_trace]",
    "start_line": 224,
    "end_line": 373,
    "has_docstring": true,
    "docstring": "Creates Jupiter's cloud layer shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_jupiter_cloud_layer_shell",
    "component_id": "jupiter_visualization_shells.create_jupiter_cloud_layer_shell"
  },
  "jupiter_visualization_shells.fibonacci_sphere": {
    "id": "jupiter_visualization_shells.fibonacci_sphere",
    "name": "fibonacci_sphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\jupiter_visualization_shells.py",
    "relative_path": "jupiter_visualization_shells.py",
    "depends_on": [],
    "source_code": "    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points",
    "start_line": 318,
    "end_line": 333,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "samples"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fibonacci_sphere",
    "component_id": "jupiter_visualization_shells.fibonacci_sphere"
  },
  "jupiter_visualization_shells.create_jupiter_upper_atmosphere_shell": {
    "id": "jupiter_visualization_shells.create_jupiter_upper_atmosphere_shell",
    "name": "create_jupiter_upper_atmosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\jupiter_visualization_shells.py",
    "relative_path": "jupiter_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_jupiter_upper_atmosphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Jupiter's upper atmosphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.1,  # Extends about 10% beyond the visible radius\n        'color': 'rgb(220, 240, 255)',  # optical\n        'opacity': 0.5,\n        'name': 'Upper Atmosphere',\n        'description': (\n            \"Jupiter's upper atmosphere includes the stratosphere and thermosphere.<br>\"\n            \"It's less dense than the cloud layer below and contains hydrocarbon haze<br>\"\n            \"produced by solar ultraviolet radiation. Aurora activity can be observed<br>\"\n            \"at Jupiter's poles, caused by interactions with its magnetic field. Temperature<br>\"\n            \"ranges from 200K in the stratosphere to 1000K in the thermosphere and exosphere.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * JUPITER_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Jupiter: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Jupiter: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=layer_radius\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 385,
    "end_line": 438,
    "has_docstring": true,
    "docstring": "Creates Jupiter's upper atmosphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_jupiter_upper_atmosphere_shell",
    "component_id": "jupiter_visualization_shells.create_jupiter_upper_atmosphere_shell"
  },
  "jupiter_visualization_shells.create_jupiter_magnetosphere": {
    "id": "jupiter_visualization_shells.create_jupiter_magnetosphere",
    "name": "create_jupiter_magnetosphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\jupiter_visualization_shells.py",
    "relative_path": "jupiter_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_magnetosphere_shape",
      "shared_utilities.create_sun_direction_indicator"
    ],
    "source_code": "def create_jupiter_magnetosphere(center_position=(0, 0, 0)):\n    \"\"\"Creates Jupiter's main magnetosphere structure.\"\"\"\n    # Parameters for magnetosphere components (in Jupiter radii)\n    params = {\n        # Compressed sunward side\n        'sunward_distance': 50,  # Compressed toward the sun\n        \n        # Equatorial extension (wider than polar)\n        'equatorial_radius': 100,\n        'polar_radius': 80,\n        \n        # Magnetotail parameters\n        'tail_length': 500,  # Length of visible magnetotail\n        'tail_base_radius': 150,  # Radius at the base of the tail\n        'tail_end_radius': 200,  # Radius at the end of the tail\n    }\n    \n    # Scale everything by Jupiter's radius in AU\n    for key in params:\n        params[key] *= JUPITER_RADIUS_AU\n    \n    # Create magnetosphere main shape\n    x, y, z = create_magnetosphere_shape(params)\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Apply center position offset\n    x = np.array(x) + center_x\n    y = np.array(y) + center_y\n    z = np.array(z) + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.0,\n                color='rgb(200, 200, 255)', # Light blue for magnetic field\n                opacity=0.3\n            ),\n            name='Jupiter: Magnetosphere',\n            text=[\"Jupiter's magnetosphere extends up to 100 Jupiter radii on the sunward side<br>\"\n                  \"and forms a magnetotail stretching beyond Saturn's orbit in the opposite direction.<br>\"\n                  \"It traps charged particles, creating intense radiation belts that would be lethal to humans.<br>\"\n                  \"The Bow Shock points towards the Sun along the X-axis. The XY plane is the ecliptic.\"] * len(x),\n            customdata=['Jupiter: Magnetosphere'] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=500 * JUPITER_RADIUS_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 440,
    "end_line": 499,
    "has_docstring": true,
    "docstring": "Creates Jupiter's main magnetosphere structure.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_jupiter_magnetosphere",
    "component_id": "jupiter_visualization_shells.create_jupiter_magnetosphere"
  },
  "jupiter_visualization_shells.create_jupiter_io_plasma_torus": {
    "id": "jupiter_visualization_shells.create_jupiter_io_plasma_torus",
    "name": "create_jupiter_io_plasma_torus",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\jupiter_visualization_shells.py",
    "relative_path": "jupiter_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator"
    ],
    "source_code": "def create_jupiter_io_plasma_torus(center_position=(0, 0, 0)):\n    \"\"\"Creates Jupiter's Io plasma torus.\"\"\"\n    # Parameters\n    io_torus_distance = 5.9 * JUPITER_RADIUS_AU  # Io's orbit is at about 5.9 Jupiter radii\n    io_torus_thickness = 2 * JUPITER_RADIUS_AU\n    io_torus_width = 1 * JUPITER_RADIUS_AU\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Create the Io plasma torus points\n    io_torus_x = []\n    io_torus_y = []\n    io_torus_z = []\n    \n    n_points = 100\n    n_rings = 8\n    \n    for i_ring in range(n_rings):\n        # Vary the radius slightly to create thickness\n        radius_offset = (i_ring / (n_rings-1) - 0.5) * io_torus_thickness\n        torus_radius = io_torus_distance + radius_offset\n        \n        for i in range(n_points):\n            angle = (i / n_points) * 2 * np.pi\n\n            # Position in x-y plane (equatorial)\n            x = torus_radius * np.cos(angle)\n            y = torus_radius * np.sin(angle)\n            z = 0  # In the equatorial plane    \n            \n            # Add some thickness variation\n            jitter = (np.random.random() - 0.5) * io_torus_width\n            \n            io_torus_x.append(x)\n            io_torus_y.append(y)\n            io_torus_z.append(z + jitter)     # Apply jitter to z axis\n    \n    # Apply center position offset\n    io_torus_x = np.array(io_torus_x) + center_x\n    io_torus_y = np.array(io_torus_y) + center_y\n    io_torus_z = np.array(io_torus_z) + center_z\n\n    # Create the Io plasma torus hover text and customdata arrays\n    io_text = [\"Io plasma torus: A donut-shaped region of charged particles emanating from<br>\"\n              \"Jupiter's moon Io due to volcanic activity. These particles become trapped<br>\"\n              \"in Jupiter's magnetic field, forming this distinctive structure.\"] * len(io_torus_x)\n    io_customdata = ['Jupiter: Io Plasma Torus'] * len(io_torus_x)\n    \n    traces = [\n        go.Scatter3d(\n            x=io_torus_x,\n            y=io_torus_y,\n            z=io_torus_z,\n            mode='markers',\n            marker=dict(\n                size=1.5,\n                color='rgb(255, 100, 100)',  # Reddish color for plasma torus\n                opacity=0.3\n            ),\n            name='Jupiter: Io Plasma Torus',\n            text=io_text,\n            customdata=io_customdata,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=io_torus_distance\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 504,
    "end_line": 579,
    "has_docstring": true,
    "docstring": "Creates Jupiter's Io plasma torus.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_jupiter_io_plasma_torus",
    "component_id": "jupiter_visualization_shells.create_jupiter_io_plasma_torus"
  },
  "jupiter_visualization_shells.create_jupiter_radiation_belts": {
    "id": "jupiter_visualization_shells.create_jupiter_radiation_belts",
    "name": "create_jupiter_radiation_belts",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\jupiter_visualization_shells.py",
    "relative_path": "jupiter_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator"
    ],
    "source_code": "def create_jupiter_radiation_belts(center_position=(0, 0, 0)):\n    \"\"\"Creates Jupiter's radiation belts.\"\"\"\n    belt_colors = ['rgb(255, 255, 100)', 'rgb(100, 255, 150)', 'rgb(100, 200, 255)']\n    belt_names = ['Jupiter: Inner Radiation Belt', 'Jupiter: Middle Radiation Belt', 'Jupiter: Outer Radiation Belt']\n    belt_texts = [\n        \"Inner radiation belt: Intense region of trapped high-energy particles near Jupiter\",\n        \"Middle radiation belt: Region of trapped charged particles at intermediate distances from Jupiter\",\n        \"Outer radiation belt: Extended region of trapped particles in Jupiter's outer magnetosphere\"\n    ]\n    \n    # Belt distances in Jupiter radii\n    belt_distances = [1.5, 3.0, 6.0]\n    belt_thickness = 0.5 * JUPITER_RADIUS_AU\n    \n    # Scale distances by Jupiter's radius in AU\n    belt_distances = [d * JUPITER_RADIUS_AU for d in belt_distances]\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    traces = []\n    \n    for i, belt_distance in enumerate(belt_distances):\n        belt_x = []\n        belt_y = []\n        belt_z = []\n        \n        n_points = 80\n        n_rings = 5\n        \n        for i_ring in range(n_rings):\n            # Vary the radius slightly to create thickness\n            radius_offset = (i_ring / (n_rings-1) - 0.5) * belt_thickness\n            belt_radius = belt_distance + radius_offset\n            \n            for j in range(n_points):\n                angle = (j / n_points) * 2 * np.pi\n                \n                # Create a belt around Jupiter's rotational axis\n                x = belt_radius * np.cos(angle)\n                y = belt_radius * np.sin(angle)\n                \n                # Add some z variation based on angle to create the shape of a belt\n                # rather than a perfect torus (thinner near poles)\n                z_scale = 0.2 * belt_radius  # Controls how flat the belts are\n                z = z_scale * np.sin(2 * angle)\n                \n                belt_x.append(x)\n                belt_y.append(y)\n                belt_z.append(z)\n        \n        # Apply center position offset\n        belt_x = np.array(belt_x) + center_x\n        belt_y = np.array(belt_y) + center_y\n        belt_z = np.array(belt_z) + center_z\n        \n        # Create the radiation belt hover text and customdata arrays\n        belt_text = [belt_texts[i]] * len(belt_x)\n        belt_customdata = [belt_names[i]] * len(belt_x)\n\n        traces.append(\n            go.Scatter3d(\n                x=belt_x,\n                y=belt_y,\n                z=belt_z,\n                mode='markers',\n                marker=dict(\n                    size=1.5,\n                    color=belt_colors[i],\n                    opacity=0.3\n                ),\n                name=belt_names[i],\n                text=belt_text,\n                customdata=belt_customdata,\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            )\n        )\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius= 6.0 * JUPITER_RADIUS_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 587,
    "end_line": 673,
    "has_docstring": true,
    "docstring": "Creates Jupiter's radiation belts.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_jupiter_radiation_belts",
    "component_id": "jupiter_visualization_shells.create_jupiter_radiation_belts"
  },
  "jupiter_visualization_shells.create_jupiter_hill_sphere_shell": {
    "id": "jupiter_visualization_shells.create_jupiter_hill_sphere_shell",
    "name": "create_jupiter_hill_sphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\jupiter_visualization_shells.py",
    "relative_path": "jupiter_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_jupiter_hill_sphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Jupiter's Hill sphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 740,  \n        'color': 'rgb(0, 255, 0)',  # Green for Hill sphere\n        'opacity': 0.25,\n        'name': 'Hill Sphere',\n        'description': (\n            \"SET MANUAL SCALE OF AT LEAST 0.5 AU TO VISUALIZE.<br><br>\"\n            \"Jupiter's Hill Sphere (extends to ~740 Jupiter radii)<br><br>\"\n                \"The Hill sphere is the region around a where its own gravity is the dominant force in attracting satellites. For <br>\" \n                \"a planet orbiting a star, it's the region where the planet's gravity is stronger than the star's tidal forces.<br><br>\" \n                \"The Hill Sphere radius can be described in words as follows: it is equal to the planet's average distance from the <br>\" \n                \"Sun (its orbital semi-major axis) multiplied by the cube root of the ratio between the planet's mass and three times <br>\" \n                \"the Sun's mass. In other words, you take how far the planet orbits out from the Sun, then scale that distance by the <br>\" \n                \"cube root of (planet mass / [3 x solar mass]) to find the boundary within which the planet's gravity dominates over the Sun's.\"            \n        )\n    }\n        \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * JUPITER_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Jupiter: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Jupiter: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    # Add a sun direction indicator (arrow pointing toward Sun along negative X-axis)\n#    sun_traces = create_sun_direction_indicator(center_position)\n#    for trace in sun_traces:\n#        traces.append(trace)\n\n    # Add sun direction indicator scaled to this shell's radius\n\n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=layer_radius\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 681,
    "end_line": 744,
    "has_docstring": true,
    "docstring": "Creates Jupiter's Hill sphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_jupiter_hill_sphere_shell",
    "component_id": "jupiter_visualization_shells.create_jupiter_hill_sphere_shell"
  },
  "jupiter_visualization_shells.create_jupiter_ring_system": {
    "id": "jupiter_visualization_shells.create_jupiter_ring_system",
    "name": "create_jupiter_ring_system",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\jupiter_visualization_shells.py",
    "relative_path": "jupiter_visualization_shells.py",
    "depends_on": [
      "jupiter_visualization_shells.create_ring_points_jupiter",
      "shared_utilities.create_sun_direction_indicator"
    ],
    "source_code": "def create_jupiter_ring_system(center_position=(0, 0, 0)):\n    \"\"\"\n    Creates a visualization of Jupiter's ring system.\n    \n    Parameters:\n        center_position (tuple): (x, y, z) position of Jupiter's center\n        \n    Returns:\n        list: A list of plotly traces representing the ring components\n    \"\"\"\n    traces = []\n    \n    # Define Jupiter's ring parameters in kilometers from Jupiter's center\n    # Then convert to Jupiter radii, and finally to AU\n    ring_params = {\n        'main_ring': {\n            'inner_radius_km': 122500,  # Inner edge (in km from Jupiter's center)\n            'outer_radius_km': 129000,  # Outer edge (in km from Jupiter's center)\n            'thickness_km': 30,         # Approximate thickness\n            'color': 'rgb(180, 120, 100)',  # Reddish color\n            'opacity': 0.7,\n            'name': 'Main Ring',\n            'description': (\n                \"Jupiter's Main Ring is a relatively bright and very thin ring.<br>\"\n                \"It extends from about 122,500 km to 129,000 km from Jupiter's center.<br>\"\n                \"Its thickness is only about 30-300 km.<br>\"\n                \"The main ring is reddish and composed of dust ejected from Jupiter's small inner moons,<br>\"\n                \"Metis and Adrastea, due to high-speed impacts by micrometeoroids.\"\n            )\n        },\n        'halo_ring': {\n            'inner_radius_km': 100000,  # Inner edge (in km from Jupiter's center)\n            'outer_radius_km': 122500,  # Outer edge (in km from Jupiter's center)\n            'thickness_km': 12500,      # Approximate thickness (thicker than the main ring)\n            'color': 'rgb(150, 150, 150)',  # Grayish color\n            'opacity': 0.4,\n            'name': 'Halo Ring',\n            'description': (\n                \"The Halo Ring is a faint, thick torus of material.<br>\"\n                \"It extends inward from the main ring to about 100,000 km from Jupiter's center.<br>\"\n                \"It is much thicker than the main ring, extending about 12,500 km vertically.<br>\"\n                \"The ring likely consists of fine dust particles pushed out of the main ring<br>\"\n                \"by electromagnetic forces from Jupiter's powerful magnetosphere.\"\n            )\n        },\n        'amalthea_gossamer': {\n            'inner_radius_km': 129000,  # Inner edge (in km from Jupiter's center)\n            'outer_radius_km': 182000,  # Outer edge (at Amalthea's orbit)\n            'thickness_km': 2000,       # Approximate thickness\n            'color': 'rgb(170, 170, 190)',  # Faint bluish-gray\n            'opacity': 0.2,\n            'name': 'Amalthea Gossamer Ring',\n            'description': (\n                \"The Amalthea Gossamer Ring is an extremely faint and wide ring.<br>\"\n                \"It extends outwards from the main ring (129,000 km) to Amalthea's orbit (182,000 km).<br>\"\n                \"It is composed of dust particles ejected from Amalthea by micrometeoroid impacts.<br>\"\n                \"It is much fainter and more diffuse than the main ring.\"\n            )\n        },\n        'thebe_gossamer': {\n            'inner_radius_km': 129000,  # Inner edge (in km from Jupiter's center)\n            'outer_radius_km': 226000,  # Outer edge (at Thebe's orbit)\n            'thickness_km': 8600,       # Approximate thickness\n            'color': 'rgb(170, 170, 190)',  # Faint bluish-gray (same as Amalthea ring)\n            'opacity': 0.15,\n            'name': 'Thebe Gossamer Ring',\n            'description': (\n                \"The Thebe Gossamer Ring is another very faint and wide ring.<br>\"\n                \"It extends outwards from the main ring (129,000 km) to beyond Thebe's orbit (226,000 km).<br>\"\n                \"It is composed of dust particles ejected from Thebe by micrometeoroid impacts.<br>\"\n                \"It is the faintest of Jupiter's rings, with a vertical extension of about 8,600 km.\"\n            )\n        }\n    }\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Create traces for each ring\n    for ring_name, ring_info in ring_params.items():\n        # Convert km to AU\n        inner_radius_au = ring_info['inner_radius_km'] / KM_PER_AU\n        outer_radius_au = ring_info['outer_radius_km'] / KM_PER_AU\n        thickness_au = ring_info['thickness_km'] / KM_PER_AU\n        \n        # Reduce point count for very large rings to improve performance\n        n_points = 100\n        if 'gossamer' in ring_name:\n            n_points = 80  # Fewer points for larger gossamer rings\n        \n        # Create ring points\n        x, y, z = create_ring_points_jupiter (inner_radius_au, outer_radius_au, n_points, thickness_au)\n        \n        # Apply center position offset\n        x = np.array(x) + center_x\n        y = np.array(y) + center_y\n        z = np.array(z) + center_z\n        \n        # Create a text list for hover information\n        text_array = [ring_info['description'] for _ in range(len(x))]\n        \n        # Add ring trace\n        traces.append(\n            go.Scatter3d(\n                x=x, y=y, z=z,\n                mode='markers',\n                marker=dict(\n                    size=1.5,  # Small markers for rings\n                    color=ring_info['color'],\n                    opacity=ring_info['opacity']\n                ),\n                name=f\"Jupiter: {ring_info['name']}\",\n                text=text_array,\n                customdata=[f\"Jupiter: {ring_info['name']}\"] * len(x),\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            )\n        )\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=226000 / KM_PER_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 763,
    "end_line": 889,
    "has_docstring": true,
    "docstring": "Creates a visualization of Jupiter's ring system.\n\nParameters:\n    center_position (tuple): (x, y, z) position of Jupiter's center\n    \nReturns:\n    list: A list of plotly traces representing the ring components",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_jupiter_ring_system",
    "component_id": "jupiter_visualization_shells.create_jupiter_ring_system"
  },
  "mars_visualization_shells.create_mars_inner_core_shell": {
    "id": "mars_visualization_shells.create_mars_inner_core_shell",
    "name": "create_mars_inner_core_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\mars_visualization_shells.py",
    "relative_path": "mars_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_mars_inner_core_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Mars's inner core shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.5,  # Inner core: 0-50% of Mars's radius\n        'color': 'rgb(255, 180, 140)',  # Orange-red for hot iron core\n        'opacity': 1.0,\n        'name': 'Inner Core',\n        'description': (\n            \"A Solid Inner Core: Based on seismic data from the InSight lander, scientists have strong evidence that Mars <br>\" \n            \"possesses a solid inner core. This inner core is primarily composed of iron and nickel, similar to Earth's.<br><br>\"\n            \"The differentiation into a solid inner core and a liquid outer core is primarily driven by:<br>\"\n            \"* Temperature Gradient: The temperature increases significantly as you move towards the center of the planet. <br>\" \n            \"  The very high pressure at the center raises the melting point of the metallic core material. The inner core <br>\" \n            \"  is where the pressure exceeds the melting point at that temperature, forcing the metal into a solid state. <br>\" \n            \"  The outer core is still hot enough to be liquid at the prevailing pressures.<br>\"\n            \"* Compositional Differences: The presence of lighter elements in the outer core also contributes to its lower <br>\" \n            \"  melting point compared to the purer iron-nickel of the inner core.<br>\"\n            \"* Differences from Earth's Core:\"\n            \"  * Size: Mars' core is proportionally larger relative to the planet's overall size compared to Earth's core.<br>\"\n            \"  * Density: The lower overall density of Mars suggests that its core likely contains a higher percentage of <br>\" \n            \"    lighter elements than Earth's core.<br>\" \n            \"  * Lack of a Global Dynamo (Currently): Earth's liquid outer core is convecting, which, along with the planet's <br>\" \n            \"    rotation, generates our global magnetic field (the geodynamo). The fact that Mars currently lacks a global <br>\" \n            \"    magnetic field suggests that the convection in its liquid outer core is either absent, very weak, or organized <br>\" \n            \"    differently. This could be due to its smaller size, different cooling history, or the higher abundance of <br>\" \n            \"    lighter elements affecting its fluid dynamics.<br>\" \n            \"The precise composition and dynamics of these layers are still subjects of ongoing research and analysis of data.<br><br>\" \n            \"Past Magnetosphere: Scientists believe that early in its history, Mars did possess a global magnetic field, <br>\" \n            \"much like Earth's. This would have created a significant magnetosphere, deflecting much of the solar wind and <br>\" \n            \"cosmic radiation. However, unlike Earth, Mars lost its global magnetic field billions of years ago. The exact <br>\" \n            \"reasons are still being investigated, but theories involve the cooling and solidification of its iron core, which <br>\" \n            \"would have stopped the dynamo process that generates a global magnetic field. Today, Mars doesn't have a planet-wide <br>\" \n            \"magnetosphere generated by a global magnetic field. However, the Mars Global Surveyor mission discovered strong, <br>\" \n            \"localized magnetic fields embedded in certain regions of the Martian crust, particularly in the ancient southern <br>\" \n            \"highlands. These are remnants of the early global field. These localized fields can create small, localized <br>\" \n            \"magnetospheres, but they don't provide planet-wide protection like Earth's magnetosphere.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * MARS_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=4.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Mars: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Mars: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 14,
    "end_line": 83,
    "has_docstring": true,
    "docstring": "Creates Mars's inner core shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_mars_inner_core_shell",
    "component_id": "mars_visualization_shells.create_mars_inner_core_shell"
  },
  "mars_visualization_shells.create_mars_outer_core_shell": {
    "id": "mars_visualization_shells.create_mars_outer_core_shell",
    "name": "create_mars_outer_core_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\mars_visualization_shells.py",
    "relative_path": "mars_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_mars_outer_core_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Mars's outer core shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.8,  # Outer core: 50-80% of Mars's radius\n        'color': 'rgb(255, 140, 0)',  # Deeper orange for liquid metal\n        'opacity': 0.8,\n        'name': 'Outer Core',\n        'description': (\n            \"A Liquid Outer Core: Surrounding the solid inner core is believed to be a liquid outer core, also primarily <br>\" \n            \"made of iron and nickel, but likely containing a significant amount of lighter elements like sulfur, oxygen, <br>\" \n            \"or even hydrogen. The presence of these lighter elements would lower the melting point of the iron-nickel alloy, <br>\" \n            \"allowing it to remain liquid despite the pressure.<br><br>\"\n            \"The differentiation into a solid inner core and a liquid outer core is primarily driven by:<br>\"\n            \"* Temperature Gradient: The temperature increases significantly as you move towards the center of the planet. <br>\" \n            \"  The very high pressure at the center raises the melting point of the metallic core material. The inner core <br>\" \n            \"  is where the pressure exceeds the melting point at that temperature, forcing the metal into a solid state. <br>\" \n            \"  The outer core is still hot enough to be liquid at the prevailing pressures.<br>\"\n            \"* Compositional Differences: The presence of lighter elements in the outer core also contributes to its lower <br>\" \n            \"  melting point compared to the purer iron-nickel of the inner core.<br>\"\n            \"* Differences from Earth's Core:\"\n            \"  * Size: Mars' core is proportionally larger relative to the planet's overall size compared to Earth's core.<br>\"\n            \"  * Density: The lower overall density of Mars suggests that its core likely contains a higher percentage of <br>\" \n            \"    lighter elements than Earth's core.<br>\" \n            \"  * Lack of a Global Dynamo (Currently): Earth's liquid outer core is convecting, which, along with the planet's <br>\" \n            \"    rotation, generates our global magnetic field (the geodynamo). The fact that Mars currently lacks a global <br>\" \n            \"    magnetic field suggests that the convection in its liquid outer core is either absent, very weak, or organized <br>\" \n            \"    differently. This could be due to its smaller size, different cooling history, or the higher abundance of <br>\" \n            \"    lighter elements affecting its fluid dynamics.<br>\" \n            \"The precise composition and dynamics of these layers are still subjects of ongoing research and analysis of data.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * MARS_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.7,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Mars: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Mars: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 92,
    "end_line": 154,
    "has_docstring": true,
    "docstring": "Creates Mars's outer core shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_mars_outer_core_shell",
    "component_id": "mars_visualization_shells.create_mars_outer_core_shell"
  },
  "mars_visualization_shells.create_mars_mantle_shell": {
    "id": "mars_visualization_shells.create_mars_mantle_shell",
    "name": "create_mars_mantle_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\mars_visualization_shells.py",
    "relative_path": "mars_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_mars_mantle_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Mars's mantle shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.98,  # Upper mantle: 80-98% of Mars's radius\n        'color': 'rgb(205, 85, 85)',  # Lighter reddish-brown\n        'opacity': 0.6,\n        'name': 'Mantle',\n        'description': (\n            \"Mantle: Surrounding the core is a silicate mantle, similar to Earth's. It's composed of dense rocks rich in <br>\" \n            \"elements like silicon, oxygen, iron, and magnesium. While \\\"upper mantle\\\" isn't a formal layer name in the <br>\" \n            \"same way as Earth's, scientists do discuss different regions within the mantle based on mineral phase transitions <br>\" \n            \"that occur at different depths and pressures. For example, there might be an upper and lower transition zone <br>\" \n            \"within the mantle, similar in concept to Earth's, although the specific minerals and depths would differ due to <br>\" \n            \"Mars' unique composition and internal pressures.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * MARS_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.1,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Mars: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Mars: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 161,
    "end_line": 208,
    "has_docstring": true,
    "docstring": "Creates Mars's mantle shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_mars_mantle_shell",
    "component_id": "mars_visualization_shells.create_mars_mantle_shell"
  },
  "mars_visualization_shells.create_mars_crust_shell": {
    "id": "mars_visualization_shells.create_mars_crust_shell",
    "name": "create_mars_crust_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\mars_visualization_shells.py",
    "relative_path": "mars_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_mars_crust_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Mars's crust shell using Mesh3d for better performance with improved hover.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.0,  # Crust: 100% of Mars's radius\n        'color': 'rgb(188, 39, 50)',  # Mars red\n        'opacity': 1.0,\n        'name': 'Crust',\n        'description': (\n            \"Mars Crust<br>\" \n            \"(Note: toggle off the crust layer in the legend to better see the interior structure.)<br><br>\" \n            \"Mars has a crust, which is the outermost solid shell. Interestingly, recent findings from marsquakes <br>\" \n            \"suggest that the Martian crust is significantly thicker than Earth's, perhaps averaging around 70 kilometers <br>\" \n            \"(43 miles) or even thicker in some areas.<br><br>\" \n            \"Today, Mars doesn't have a planet-wide magnetosphere generated by a global magnetic field. However, the Mars Global <br>\" \n            \"Surveyor mission discovered strong, localized magnetic fields embedded in certain regions of the Martian crust, <br>\" \n            \"particularly in the ancient southern highlands. These are remnants of the early global field. These localized fields <br>\" \n            \"can create small, localized magnetospheres, but they don't provide planet-wide protection like Earth's magnetosphere.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    radius = layer_info['radius_fraction'] * MARS_RADIUS_AU\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Create mesh with reasonable resolution for performance\n    resolution = 24  # Reduced from typical 50 for markers\n    \n    # Create a UV sphere\n    phi = np.linspace(0, 2*np.pi, resolution)\n    theta = np.linspace(-np.pi/2, np.pi/2, resolution)\n    phi, theta = np.meshgrid(phi, theta)\n    \n    x = radius * np.cos(theta) * np.cos(phi)\n    y = radius * np.cos(theta) * np.sin(phi)\n    z = radius * np.sin(theta)\n    \n    # Apply center position offset\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    # Create triangulation\n    indices = []\n    for i in range(resolution-1):\n        for j in range(resolution-1):\n            p1 = i * resolution + j\n            p2 = i * resolution + (j + 1)\n            p3 = (i + 1) * resolution + j\n            p4 = (i + 1) * resolution + (j + 1)\n            \n            indices.append([p1, p2, p4])\n            indices.append([p1, p4, p3])\n    \n    # Create main surface\n    surface_trace = go.Mesh3d(\n        x=x.flatten(), \n        y=y.flatten(), \n        z=z.flatten(),\n        i=[idx[0] for idx in indices],\n        j=[idx[1] for idx in indices],\n        k=[idx[2] for idx in indices],\n        color=layer_info['color'],\n        opacity=layer_info['opacity'],\n        name=f\"Mars: {layer_info['name']}\",\n        showlegend=True,\n        hoverinfo='none',  # Disable hover on mesh surface\n        # Add these new parameters to make hover text invisible\n        hovertemplate=' ',  # Empty template instead of None\n        hoverlabel=dict(\n    #        bgcolor='rgba(0,0,0,0)',  # Transparent background\n            font=dict(\n                color='rgba(0,0,0,0)',  # Transparent text\n    #            size=0                  # Zero font size\n            ),\n            bordercolor='rgba(0,0,0,0)'  # Transparent border\n        ), \n        # Add these new parameters to eliminate shading\n        flatshading=True,  # Use flat shading instead of smooth\n        lighting=dict(\n            ambient=1.0,     # Set to maximum (1.0)\n            diffuse=0.0,     # Turn off diffuse lighting\n            specular=0.0,    # Turn off specular highlights\n            roughness=1.0,   # Maximum roughness\n            fresnel=0.0      # Turn off fresnel effect\n        ),\n        lightposition=dict(\n            x=0,  # Centered light\n            y=0,  # Centered light\n            z=10000  # Light from very far above to minimize shadows\n        )       \n    )\n        \n    # Use the Fibonacci sphere algorithm for more even point distribution\n    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points\n    \n    # Generate fibonacci sphere points\n    fib_points = fibonacci_sphere(samples=50)  # Originally, 50 hover points evenly distributed\n    \n    # Scale and offset the points\n    x_hover = [p[0] * radius + center_x for p in fib_points]\n    y_hover = [p[1] * radius + center_y for p in fib_points]\n    z_hover = [p[2] * radius + center_z for p in fib_points]\n        \n    # Create a list of repeated descriptions for each point\n    # This is crucial - we need exactly one text entry per point\n    hover_texts = [layer_info['description']] * len(x_hover)\n\n    # Just the name for \"Object Names Only\" mode\n    layer_name = f\"Mars: {layer_info['name']}\"\n    minimal_hover_texts = [layer_name] * len(x_hover)\n\n    # Create hover trace with direct text assignment\n    hover_trace = go.Scatter3d(\n        x=x_hover, \n        y=y_hover, \n        z=z_hover,\n        mode='markers',\n        marker=dict(\n            size=2,  # originally 5\n            color='rgb(188, 39, 50)',  # Layer color, originally 'white'\n            opacity=1.0,  # originally 0.8\n            line=dict(  # Add a contrasting outline\n                width=1,\n                color='black'\n            )\n        ),\n        name=f\"Mars: {layer_info['name']} (Info)\",\n        text=hover_texts,  # IMPORTANT: Matching length with coordinate arrays\n        customdata=minimal_hover_texts,  # For \"Object Names Only\" mode\n        hovertemplate='%{text}<extra></extra>',  # Use the standard hover template\n        showlegend=False  # Don't show in legend since it's just for hover\n    )\n\n    return [surface_trace, hover_trace]",
    "start_line": 216,
    "end_line": 367,
    "has_docstring": true,
    "docstring": "Creates Mars's crust shell using Mesh3d for better performance with improved hover.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_mars_crust_shell",
    "component_id": "mars_visualization_shells.create_mars_crust_shell"
  },
  "mars_visualization_shells.fibonacci_sphere": {
    "id": "mars_visualization_shells.fibonacci_sphere",
    "name": "fibonacci_sphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\mars_visualization_shells.py",
    "relative_path": "mars_visualization_shells.py",
    "depends_on": [],
    "source_code": "    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points",
    "start_line": 312,
    "end_line": 327,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "samples"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fibonacci_sphere",
    "component_id": "mars_visualization_shells.fibonacci_sphere"
  },
  "mars_visualization_shells.create_mars_atmosphere_shell": {
    "id": "mars_visualization_shells.create_mars_atmosphere_shell",
    "name": "create_mars_atmosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\mars_visualization_shells.py",
    "relative_path": "mars_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_mars_atmosphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Mars's lower atmosphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.02,  # Troposphere\n        'color': 'rgb(150, 200, 255)',  # Light blue for atmosphere\n        'opacity': 0.5,\n        'name': 'Lower Atmosphere',\n        'description': (\n            \"Atmosphere: Mars has a thin atmosphere, much less dense than Earth's. It's primarily composed of carbon dioxide <br>\" \n            \"(about 95%), with small amounts of nitrogen, argon, and other gases.<br><br>\" \n            \"Scientists often divide the Martian atmosphere into layers based on temperature profiles, similar to Earth's <br>\" \n            \"atmosphere, although some layers are absent or behave differently:<br>\" \n            \"* Troposphere: This is the lowest layer, extending from the surface up to about 40-50 kilometers (25-31 miles). <br>\" \n            \"  Most of Mars' weather, like dust storms and convection, occurs here. The temperature generally decreases with altitude.<br>\" \n            \"* Mesosphere: Above the troposphere, extending from about 50 to 100 kilometers (31 to 62 miles). This layer has the <br>\" \n            \"  lowest temperatures in the Martian atmosphere as carbon dioxide efficiently radiates heat into space. Carbon dioxide <br>\" \n            \"  ice clouds have even been observed in the Martian mesosphere.<br>\" \n            \"* Thermosphere: Above the mesosphere, starting around 100 kilometers (62 miles) and extending to about 200 kilometers <br>\" \n            \"  (124 miles). This layer is heated by extreme ultraviolet radiation from the Sun, and temperatures increase with <br>\" \n            \"  altitude. However, it's still much colder than Earth's thermosphere.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * MARS_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.5,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Mars: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Mars: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 374,
    "end_line": 427,
    "has_docstring": true,
    "docstring": "Creates Mars's lower atmosphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_mars_atmosphere_shell",
    "component_id": "mars_visualization_shells.create_mars_atmosphere_shell"
  },
  "mars_visualization_shells.create_mars_upper_atmosphere_shell": {
    "id": "mars_visualization_shells.create_mars_upper_atmosphere_shell",
    "name": "create_mars_upper_atmosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\mars_visualization_shells.py",
    "relative_path": "mars_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_mars_upper_atmosphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Mars's upper atmosphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.06,  # Mesosphere, thermosphere, and exosphere\n        'color': 'rgb(100, 150, 255)',  # Lighter blue\n        'opacity': 0.3,\n        'name': 'Upper Atmosphere',\n        'description': (\n            \"Upper Atmosphere: Like Earth, Mars has upper atmospheric layers, including an ionosphere and exosphere, where <br>\" \n            \"the atmosphere becomes very thin and interacts with solar radiation and the solar wind.<br><br>\" \n            \"Exosphere: This is the outermost layer, starting above the thermosphere (around 200 km/124 miles) and gradually <br>\" \n            \"thinning out into space. Atoms and molecules here are so far apart that they can escape the planet's gravity.<br><br>\" \n            \"Interaction with Solar Wind: Without a global magnetosphere, the Martian atmosphere is directly exposed to the <br>\" \n            \"solar wind, a stream of charged particles from the Sun. This interaction is believed to have played a significant <br>\" \n            \"role in stripping away much of Mars' early, potentially thicker atmosphere and contributing to the loss of liquid <br>\" \n            \"water on the surface. Unlike Earth, Mars lacks a stratosphere. On Earth, the stratosphere is characterized by a <br>\" \n            \"temperature inversion due to the absorption of ultraviolet radiation by the ozone layer. Mars has a very thin <br>\" \n            \"atmosphere and no significant ozone layer, so this distinct layer doesn't form.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * MARS_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Mars: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Mars: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=layer_radius\n    )\n    for trace in sun_traces:\n        traces.append(trace) \n\n    return traces",
    "start_line": 442,
    "end_line": 500,
    "has_docstring": true,
    "docstring": "Creates Mars's upper atmosphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_mars_upper_atmosphere_shell",
    "component_id": "mars_visualization_shells.create_mars_upper_atmosphere_shell"
  },
  "mars_visualization_shells.create_mars_magnetosphere_shell": {
    "id": "mars_visualization_shells.create_mars_magnetosphere_shell",
    "name": "create_mars_magnetosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\mars_visualization_shells.py",
    "relative_path": "mars_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_magnetosphere_shape",
      "shared_utilities.create_sun_direction_indicator"
    ],
    "source_code": "def create_mars_magnetosphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Mars' induced magnetosphere and localized crustal magnetic fields.\"\"\"\n    traces = []\n    \n    # Parameters for Mars magnetosphere components (in Mars radii)\n    params = {\n        # Smaller, compressed sunward side\n        'sunward_distance': 1.5,  # Much closer to Mars than Earth's\n        \n        # Smaller equatorial and polar extensions\n        'equatorial_radius': 2.0,\n        'polar_radius': 1.7,\n        \n        # Shorter magnetotail\n        'tail_length': 10.0,  # Much shorter than Earth's\n        'tail_base_radius': 2.5,\n        'tail_end_radius': 4.0,\n    }\n    \n    # Scale everything by Mars's radius in AU\n    for key in params:\n        params[key] *= MARS_RADIUS_AU\n    \n    # Create magnetosphere main shape - reusing Earth's function but with Mars parameters\n    x, y, z = create_magnetosphere_shape(params)\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # 1. Add the main induced magnetosphere structure\n    x = np.array(x) + center_x\n    y = np.array(y) + center_y\n    z = np.array(z) + center_z\n    \n    magnetosphere_text = [\n                            \"Unlike Earth, Mars lacks a global magnetic field generated by its core. Instead, it has:<br>\"\n                            \"1. Induced Magnetosphere: Created by the interaction between the solar wind and Mars' ionosphere. <br>\"\n                            \"   It's much weaker and closer to the planet than Earth's magnetosphere, extending only about 1-2 Mars radii <br>\"\n                            \"   on the Sun-facing side.<br>\"\n                            \"2. Bow Shock: Still forms where the solar wind first encounters Mars' atmosphere and ionosphere, <br>\"\n                            \"   but it's much closer to the planet (around 1.5 Mars radii).<br>\"\n                            \"3. Crustal Magnetic Fields: Localized 'mini-magnetospheres' created by magnetized regions in Mars' crust, <br>\"\n                            \"   particularly in the southern hemisphere. These are remnants of Mars' ancient global magnetic field <br>\"\n                            \"   that existed billions of years ago.\"\n                 ]\n    \n    magnetosphere_customdata = ['Mars: Induced Magnetosphere']\n\n    traces.append(\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=1.5,\n                color='rgb(180, 180, 255)', # Light blue for magnetic field\n                opacity=0.2\n            ),\n            name='Mars: Induced Magnetosphere',\n            text=magnetosphere_text * len(x),\n            customdata=magnetosphere_customdata * len(x),      \n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    )\n    \n    # 2. Create and add bow shock\n    bow_shock_x = []\n    bow_shock_y = []\n    bow_shock_z = []\n    \n    n_phi = 30\n    n_theta = 30\n    bow_shock_standoff = 1.5 * MARS_RADIUS_AU  # Closer to Mars than Earth's bow shock\n    bow_shock_width = 3.0 * MARS_RADIUS_AU\n    \n    # Create a paraboloid for the bow shock\n    for i_phi in range(n_phi):\n        phi = (i_phi / (n_phi-1)) * np.pi  # Only the front half\n        \n        for i_theta in range(n_theta):\n            theta = (i_theta / (n_theta-1)) * 2 * np.pi\n            \n            # Paraboloid shape, flattened in x-direction for bow shock\n            x = -bow_shock_standoff * np.cos(phi)  # Negative for sunward direction\n            rho = bow_shock_width * (1 + np.sin(phi)) / 2  # Wider for larger phi (away from sun)\n            y = rho * np.cos(theta)\n            z = rho * np.sin(theta)\n            \n            bow_shock_x.append(x)\n            bow_shock_y.append(y)\n            bow_shock_z.append(z)\n    \n    # Apply center position offset\n    bow_shock_x = np.array(bow_shock_x) + center_x\n    bow_shock_y = np.array(bow_shock_y) + center_y\n    bow_shock_z = np.array(bow_shock_z) + center_z\n    \n    bow_shock_text = [\"Mars Bow Shock: Forms where the supersonic solar wind first encounters<br>\"\n                \"Mars' atmosphere and ionosphere. It's much closer to Mars (around 1.5 Mars radii)<br>\"\n                \"compared to Earth's bow shock (around 15 Earth radii).<br>\"\n                \"The Bow Shock points towards the Sun along the X-axis. The XY plane is the ecliptic.\"]\n    \n    bow_shock_customdata = ['Mars: Bow Shock']\n\n    traces.append(\n        go.Scatter3d(\n            x=bow_shock_x,\n            y=bow_shock_y,\n            z=bow_shock_z,\n            mode='markers',\n            marker=dict(\n                size=1.5,\n                color='rgb(255, 200, 150)',  # Orange-ish color for bow shock\n                opacity=0.2\n            ),\n            name='Mars: Bow Shock',\n            text=bow_shock_text * len(bow_shock_x),\n            customdata=bow_shock_customdata * len(bow_shock_x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    )\n    \n    # 3. Create localized crustal magnetic fields (unique to Mars)\n    # Focus on southern hemisphere where most are found\n    \n    # Parameters for crustal magnetic anomalies\n    n_anomalies = 7  # Number of distinct magnetic anomalies to show\n    max_field_radius = 0.3 * MARS_RADIUS_AU  # Maximum extent of crustal fields from surface\n    \n    crustal_field_text = [\"Crustal Magnetic Fields: Localized 'mini-magnetospheres' created by magnetized<br>\"\n                  \"regions in Mars' crust, particularly in the southern hemisphere. These are remnants<br>\"\n                  \"of Mars' ancient global magnetic field that existed billions of years ago.\"]\n    \n    crustal_field_customdata = ['Mars: Crustal Magnetic Fields']\n    \n    # Generate random positions for the anomalies, mostly in southern hemisphere\n    np.random.seed(42)  # For reproducibility\n    \n    # Create localized magnetic field lines for each anomaly\n    for i in range(n_anomalies):\n        # Mostly in southern hemisphere (negative z)\n        theta = np.random.uniform(0, np.pi*2)\n        phi = np.random.uniform(np.pi/2, np.pi)  # Southern hemisphere\n        \n        # Position on the surface\n        surf_x = MARS_RADIUS_AU * np.sin(phi) * np.cos(theta)\n        surf_y = MARS_RADIUS_AU * np.sin(phi) * np.sin(theta)\n        surf_z = MARS_RADIUS_AU * np.cos(phi)\n        \n        # Create field lines emanating from this point\n        n_lines = 15\n        points_per_line = 10\n        \n        field_x = []\n        field_y = []\n        field_z = []\n        \n        for j in range(n_lines):\n            # Random direction from the surface point\n            line_theta = np.random.uniform(0, np.pi*2)\n            line_phi = np.random.uniform(0, np.pi)\n            \n            # Create points along the field line\n            for k in range(points_per_line):\n                # Distance from surface increases along the line\n                dist = (k / points_per_line) * max_field_radius\n                \n                # Field lines curve back toward surface (dipole-like)\n                curve_factor = 1.0 - (k / points_per_line) ** 2\n                \n                # Adjusted direction accounting for curvature\n                adj_phi = line_phi * curve_factor\n                \n                # Calculate position\n                x = surf_x + dist * np.sin(adj_phi) * np.cos(line_theta)\n                y = surf_y + dist * np.sin(adj_phi) * np.sin(line_theta)\n                z = surf_z + dist * np.cos(adj_phi)\n                \n                field_x.append(x)\n                field_y.append(y)\n                field_z.append(z)\n        \n        # Apply center position offset\n        field_x = np.array(field_x) + center_x\n        field_y = np.array(field_y) + center_y\n        field_z = np.array(field_z) + center_z\n        \n        traces.append(\n            go.Scatter3d(\n                x=field_x,\n                y=field_y,\n                z=field_z,\n                mode='markers',\n                marker=dict(\n                    size=1.5,\n                    color='rgb(255, 100, 255)',  # Distinct purple color for crustal fields\n                    opacity=0.3\n                ),\n                name='Mars: Crustal Magnetic Fields',\n                text=crustal_field_text * len(field_x),\n                customdata=crustal_field_customdata * len(field_x),\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=i==0  # Only show in legend once\n            )\n        )\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=10 * MARS_RADIUS_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 515,
    "end_line": 729,
    "has_docstring": true,
    "docstring": "Creates Mars' induced magnetosphere and localized crustal magnetic fields.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_mars_magnetosphere_shell",
    "component_id": "mars_visualization_shells.create_mars_magnetosphere_shell"
  },
  "mars_visualization_shells.create_mars_hill_sphere_shell": {
    "id": "mars_visualization_shells.create_mars_hill_sphere_shell",
    "name": "create_mars_hill_sphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\mars_visualization_shells.py",
    "relative_path": "mars_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_mars_hill_sphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Mars's Hill sphere.\"\"\"\n\n    \"\"\"Creates Mars's upper atmosphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 324.5,  \n        'color': 'rgb(0, 255, 0)',  # Green for Hill sphere\n        'opacity': 0.15,\n        'name': 'Hill Sphere',\n        'description': (\n                \"Mars's Hill Sphere (extends to ~324.5 Mars radii or about 1.1 million km), which defines the region of its <br>\" \n                \"gravitational influence and encompasses its two moons.<br><br>\" \n                \"* Definition: The Hill sphere (sometimes called the Roche sphere or gravitational sphere of influence) of a <br>\" \n                \"  celestial body is the region around it where its own gravity is the dominant force attracting satellites. <br>\" \n                \"  Essentially, it's the space where a moon or spacecraft would primarily orbit that body rather than the larger <br>\" \n                \"  body it orbits (in Mars' case, the Sun).<br>\" \n                \"* Mars' Hill Sphere: The size of a planet's Hill sphere depends on its mass and its distance from the Sun. <br>\" \n                \"  Mars, being less massive than Earth and farther from the Sun, has a Hill sphere with a radius of approximately <br>\" \n                \"  1.1 million kilometers (about 0.073 astronomical units).<br>\" \n                \"* Moons Within the Hill Sphere: Mars' two small moons, Phobos and Deimos, orbit well within Mars' Hill sphere, <br>\" \n                \"  which is why they are gravitationally bound to the planet and not the Sun.<br>\" \n                \"* Importance: The concept of the Hill sphere is crucial for understanding the stability of orbits around a planet. <br>\" \n                \"  Any object orbiting Mars within its Hill sphere is more likely to remain a satellite of Mars. If an object's <br>\" \n                \"  orbit extends beyond the Hill sphere, the Sun's gravity would become the dominant influence, potentially pulling <br>\" \n                \"the object into a heliocentric orbit.<br><br>\"\n                \"The Hill sphere is the region around a where its own gravity is the dominant force in attracting satellites. For <br>\" \n                \"a planet orbiting a star, it's the region where the planet's gravity is stronger than the star's tidal forces.<br><br>\" \n                \"The Hill Sphere radius can be described in words as follows: it is equal to the planet's average distance from the <br>\" \n                \"Sun (its orbital semi-major axis) multiplied by the cube root of the ratio between the planet's mass and three times <br>\" \n                \"the Sun's mass. In other words, you take how far the planet orbits out from the Sun, then scale that distance by the <br>\" \n                \"cube root of (planet mass / [3 x solar mass]) to find the boundary within which the planet's gravity dominates over the Sun's.\"               \n        )\n    }\n\n    # Hill sphere radius in Mars radii\n    radius_fraction = 324.5  # Mars's Hill sphere is about 324.5 Mars radii\n    \n    # Calculate radius in AU\n    radius_au = radius_fraction * MARS_RADIUS_AU\n    \n    # Create sphere points with fewer points for memory efficiency\n    n_points = 30  # Reduced for large spheres\n    x, y, z = create_sphere_points(radius_au, n_points=n_points)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=1.0,\n                color='rgb(0, 255, 0)',  # Green for Hill sphere\n                opacity=0.25\n            ),\n            name=f\"Mars: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Mars: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=radius_au\n    )\n    for trace in sun_traces:\n        traces.append(trace) \n\n    return traces",
    "start_line": 737,
    "end_line": 812,
    "has_docstring": true,
    "docstring": "Creates Mars's Hill sphere.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_mars_hill_sphere_shell",
    "component_id": "mars_visualization_shells.create_mars_hill_sphere_shell"
  },
  "mercury_visualization_shells.create_mercury_inner_core_shell": {
    "id": "mercury_visualization_shells.create_mercury_inner_core_shell",
    "name": "create_mercury_inner_core_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\mercury_visualization_shells.py",
    "relative_path": "mercury_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_mercury_inner_core_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Mercury's inner core shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.41,  # Inner core: 0-52% of Mercury's radius\n        'color': 'rgb(255, 180, 140)',  # Orange-red for hot iron core\n        'opacity': 1.0,\n        'name': 'Inner Core',\n        'description': (\n            \"Inner Core: Mercury has a very large metallic core, unlike Earth's which is proportionally smaller.<br>\" \n            \"Evidence suggests that Mercury has a solid inner core, similar to Earth's. It is estimated to be about <br>\" \n            \"1,000 kilometers thick based on Messenger findings (2019).\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * MERCURY_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=4.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Mercury: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Mercury: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 16,
    "end_line": 60,
    "has_docstring": true,
    "docstring": "Creates Mercury's inner core shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_mercury_inner_core_shell",
    "component_id": "mercury_visualization_shells.create_mercury_inner_core_shell"
  },
  "mercury_visualization_shells.create_mercury_outer_core_shell": {
    "id": "mercury_visualization_shells.create_mercury_outer_core_shell",
    "name": "create_mercury_outer_core_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\mercury_visualization_shells.py",
    "relative_path": "mercury_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_mercury_outer_core_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Mercury's outer core shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.85,  # Outer core: 82-85% of Mercury's radius\n        'color': 'rgb(255, 140, 0)',  # Deeper orange for liquid metal\n        'opacity': 0.8,\n        'name': 'Outer Core',\n        'description': (\n            \"Outer Core: Surrounding the solid inner core is a liquid metallic outer core. The movement of this molten iron <br>\" \n            \"is thought to be the source of Mercury's weak magnetic field. About 1074 km thick.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * MERCURY_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.7,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Mercury: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Mercury: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 67,
    "end_line": 110,
    "has_docstring": true,
    "docstring": "Creates Mercury's outer core shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_mercury_outer_core_shell",
    "component_id": "mercury_visualization_shells.create_mercury_outer_core_shell"
  },
  "mercury_visualization_shells.create_mercury_mantle_shell": {
    "id": "mercury_visualization_shells.create_mercury_mantle_shell",
    "name": "create_mercury_mantle_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\mercury_visualization_shells.py",
    "relative_path": "mercury_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_mercury_mantle_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Mercury's mantle shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.98,  # Lower mantle: 85-98% of Earth's radius\n        'color': 'rgb(230, 100, 20)',  # Reddish-brown\n        'opacity': 0.7,\n        'name': 'Mantle',\n        'description': (\n            \"Mantle: Surrounding the core is a rocky mantle. Recent research suggests this mantle might even contain a layer of <br>\" \n            \"diamonds, formed from ancient carbon-rich material under immense pressure. The mantle is significantly thinner than <br>\" \n            \"Earth's, estimated to be only about 331 kilometers thick.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * MERCURY_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.4,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Mercury: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Mercury: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 118,
    "end_line": 162,
    "has_docstring": true,
    "docstring": "Creates Mercury's mantle shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_mercury_mantle_shell",
    "component_id": "mercury_visualization_shells.create_mercury_mantle_shell"
  },
  "mercury_visualization_shells.create_mercury_crust_shell": {
    "id": "mercury_visualization_shells.create_mercury_crust_shell",
    "name": "create_mercury_crust_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\mercury_visualization_shells.py",
    "relative_path": "mercury_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_mercury_crust_shell(center_position=(0, 0, 0)):\n\n    \"\"\"Creates Mercury's crust shell using Mesh3d for better performance with improved hover.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.0,  # Crust: 100% of Mercury's radius\n        'color': 'rgb(128, 128, 128)',   # Description: Dark Gray reflecting Mercury's rocky and heavily cratered surface.\n        'opacity': 1.0,\n        'name': 'Crust',\n        'description': (\n            \"(Note: toggle off the crust layer in the legend to better see the interior structure.)<br><br>\"\n            \"Mercury has a solid silicate crust that is heavily cratered, resembling Earth's Moon. The crust is likely quite thin <br>\" \n            \"compared to Earth's. There's also a theory that a significant portion of Mercury's crust might be made of diamonds, <br>\" \n            \"formed by billions of years of meteorite impacts on a graphite-rich surface. About 35 km thick.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    radius = layer_info['radius_fraction'] * MERCURY_RADIUS_AU\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Create mesh with reasonable resolution for performance\n    resolution = 24  # Reduced from typical 50 for markers\n    \n    # Create a UV sphere\n    phi = np.linspace(0, 2*np.pi, resolution)\n    theta = np.linspace(-np.pi/2, np.pi/2, resolution)\n    phi, theta = np.meshgrid(phi, theta)\n    \n    x = radius * np.cos(theta) * np.cos(phi)\n    y = radius * np.cos(theta) * np.sin(phi)\n    z = radius * np.sin(theta)\n    \n    # Apply center position offset\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    # Create triangulation\n    indices = []\n    for i in range(resolution-1):\n        for j in range(resolution-1):\n            p1 = i * resolution + j\n            p2 = i * resolution + (j + 1)\n            p3 = (i + 1) * resolution + j\n            p4 = (i + 1) * resolution + (j + 1)\n            \n            indices.append([p1, p2, p4])\n            indices.append([p1, p4, p3])\n    \n    # Create main surface\n    surface_trace = go.Mesh3d(\n        x=x.flatten(), \n        y=y.flatten(), \n        z=z.flatten(),\n        i=[idx[0] for idx in indices],\n        j=[idx[1] for idx in indices],\n        k=[idx[2] for idx in indices],\n        color=layer_info['color'],\n        opacity=layer_info['opacity'],\n        name=f\"Mercury: {layer_info['name']}\",\n        showlegend=True,\n        hoverinfo='none',  # Disable hover on mesh surface\n        # Add these new parameters to make hover text invisible\n        hovertemplate=' ',  # Empty template instead of None\n        hoverlabel=dict(\n    #        bgcolor='rgba(0,0,0,0)',  # Transparent background\n            font=dict(\n                color='rgba(0,0,0,0)',  # Transparent text\n    #            size=0                  # Zero font size\n            ),\n            bordercolor='rgba(0,0,0,0)'  # Transparent border\n        ), \n        # Add these new parameters to eliminate shading\n        flatshading=True,  # Use flat shading instead of smooth\n        lighting=dict(\n            ambient=1.0,     # Set to maximum (1.0)\n            diffuse=0.0,     # Turn off diffuse lighting\n            specular=0.0,    # Turn off specular highlights\n            roughness=1.0,   # Maximum roughness\n            fresnel=0.0      # Turn off fresnel effect\n        ),\n        lightposition=dict(\n            x=0,  # Centered light\n            y=0,  # Centered light\n            z=10000  # Light from very far above to minimize shadows\n        )       \n    )\n        \n    # Use the Fibonacci sphere algorithm for more even point distribution\n    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points\n    \n    # Generate fibonacci sphere points\n    fib_points = fibonacci_sphere(samples=50)  # Originally, 50 hover points evenly distributed\n    \n    # Scale and offset the points\n    x_hover = [p[0] * radius + center_x for p in fib_points]\n    y_hover = [p[1] * radius + center_y for p in fib_points]\n    z_hover = [p[2] * radius + center_z for p in fib_points]\n        \n    # Create a list of repeated descriptions for each point\n    # This is crucial - we need exactly one text entry per point\n    hover_texts = [layer_info['description']] * len(x_hover)\n\n    # Just the name for \"Object Names Only\" mode\n    layer_name = f\"Mercury: {layer_info['name']}\"\n    minimal_hover_texts = [layer_name] * len(x_hover)\n\n    # Create hover trace with direct text assignment\n    hover_trace = go.Scatter3d(\n        x=x_hover, \n        y=y_hover, \n        z=z_hover,\n        mode='markers',\n        marker=dict(\n            size=2,  # originally 5\n            color='rgb(128, 128, 128)',   # Description: Dark Gray reflecting Mercury's rocky and heavily cratered surface.\n            opacity=1.0,  # originally 0.8\n            line=dict(  # Add a contrasting outline\n                width=1,\n                color='black'\n            )\n        ),\n        name=f\"Mercury: {layer_info['name']} (Info)\",\n        text=hover_texts,  # IMPORTANT: Matching length with coordinate arrays\n        customdata=minimal_hover_texts,  # For \"Object Names Only\" mode\n        hovertemplate='%{text}<extra></extra>',  # Use the standard hover template\n        showlegend=False  # Don't show in legend since it's just for hover\n    )\n\n    return [surface_trace, hover_trace]",
    "start_line": 171,
    "end_line": 318,
    "has_docstring": true,
    "docstring": "Creates Mercury's crust shell using Mesh3d for better performance with improved hover.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_mercury_crust_shell",
    "component_id": "mercury_visualization_shells.create_mercury_crust_shell"
  },
  "mercury_visualization_shells.fibonacci_sphere": {
    "id": "mercury_visualization_shells.fibonacci_sphere",
    "name": "fibonacci_sphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\mercury_visualization_shells.py",
    "relative_path": "mercury_visualization_shells.py",
    "depends_on": [],
    "source_code": "    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points",
    "start_line": 263,
    "end_line": 278,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "samples"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fibonacci_sphere",
    "component_id": "mercury_visualization_shells.fibonacci_sphere"
  },
  "mercury_visualization_shells.create_mercury_atmosphere_shell": {
    "id": "mercury_visualization_shells.create_mercury_atmosphere_shell",
    "name": "create_mercury_atmosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\mercury_visualization_shells.py",
    "relative_path": "mercury_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_mercury_atmosphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Mercury's atmosphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 2.0,  # Exosphere\n        'color': 'rgb(150, 200, 255)',  # Light blue for atmosphere\n        'opacity': 0.5,\n        'name': 'Exosphere',\n        'description': (\n            \"Exosphere: Unlike Earth's substantial atmosphere, Mercury has an extremely thin exosphere. This exosphere is not <br>\" \n            \"dense enough to trap heat or offer significant protection from space. It is composed mostly of oxygen, sodium, <br>\" \n            \"hydrogen, helium, and potassium atoms that have been blasted off the surface by the solar wind and micrometeoroid impacts.<br><br>\"\n            \"Mercury has what is more accurately described as a tenuous exosphere rather than a substantial atmosphere like Earth's. <br>\" \n            \"This exosphere is extremely thin, and its atoms are so sparse they are more likely to collide with the surface than with <br>\" \n            \"each other. The extent of Mercury's exosphere is not well-defined by a pressure gradient as with a true atmosphere. Instead, <br>\" \n            \"it gradually fades out into space. However, we can consider how far certain exospheric components have been observed:<br>\" \n            \"* Sodium Tail: Due to solar radiation pressure, sodium atoms are pushed away from Mercury, forming a long, comet-like tail. <br>\" \n            \"  This tail has been detected extending to distances of over 24 million kilometers (approximately 10,000 Mercury radii) <br>\" \n            \"  from the planet. This is by far the most extended component of Mercury's exosphere.<br>\" \n            \"* Other Elements: Other elements like hydrogen, helium, oxygen, potassium, calcium, and magnesium are also present in the <br>\" \n            \"  exosphere. These are generally found much closer to the planet's surface, within a few Mercury radii. For instance, calcium <br>\" \n            \"  and magnesium have been observed in the tail but at distances less than 8 Mercury radii.<br>\" \n            \"In summary: While the bulk of Mercury's exospheric atoms are concentrated very close to the surface (within 1 Mercury radius), <br>\" \n            \"the sodium tail is a significant feature that extends incredibly far, up to 10,000 Mercury radii. The main body of the exosphere <br>\" \n            \"is very close to the surface, but the tenuous sodium tail stretches to an immense distance.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * MERCURY_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.5,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Mercury: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Mercury: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=layer_radius\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 327,
    "end_line": 391,
    "has_docstring": true,
    "docstring": "Creates Mercury's atmosphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_mercury_atmosphere_shell",
    "component_id": "mercury_visualization_shells.create_mercury_atmosphere_shell"
  },
  "mercury_visualization_shells.create_mercury_sodium_tail": {
    "id": "mercury_visualization_shells.create_mercury_sodium_tail",
    "name": "create_mercury_sodium_tail",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\mercury_visualization_shells.py",
    "relative_path": "mercury_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_mercury_sodium_tail(center_position=(0, 0, 0)):\n    \"\"\"Creates Mercury's sodium tail visualization extending away from the Sun.\"\"\"\n    \n    # Define layer properties\n    layer_info = {\n        'name': 'Sodium Tail',\n        'description': (\n            \"Sodium Tail: Mercury has a remarkable sodium tail that extends incredibly far into space - up to 10,000 Mercury radii <br>\"\n            \"(approximately 24 million kilometers or 2.4 million km). This tail is created when sodium atoms from Mercury's exosphere <br>\"\n            \"are pushed away by solar radiation pressure. The tail always points away from the Sun, similar to a comet's tail.<br><br>\"\n            \"The sodium tail is highly dynamic and can vary significantly based on Mercury's position in its orbit and solar activity. <br>\"\n            \"It's one of Mercury's most distinctive features and can be observed from Earth using specialized telescopes.\"\n        )\n    }\n    \n    # Sodium tail extends up to ~10,000 Mercury radii away from the Sun\n    max_tail_length = 10000 * MERCURY_RADIUS_AU\n    \n    # Create a conical tail shape pointing away from the Sun\n    # Sun is at origin (0,0,0), so tail points away from (0,0,0) relative to Mercury's position\n    center_x, center_y, center_z = center_position\n    \n    # Calculate direction away from Sun (normalized)\n    distance = math.sqrt(center_x**2 + center_y**2 + center_z**2)\n    if distance > 0:\n        dir_x = center_x / distance\n        dir_y = center_y / distance\n        dir_z = center_z / distance\n    else:\n        # If Mercury is at origin, default to +x direction\n        dir_x, dir_y, dir_z = 1, 0, 0\n    \n    # Create tail as a cone of particles with varying density\n    num_particles = 500\n    tail_points_x = []\n    tail_points_y = []\n    tail_points_z = []\n    \n    for i in range(num_particles):\n        # Distance along tail (0 to max_tail_length)\n        tail_distance = (i / num_particles) * max_tail_length\n        \n        # Cone widens as it extends (opening angle ~5-10 degrees)\n        max_radius = tail_distance * math.tan(math.radians(7))\n        \n        # Random position within cone cross-section\n        theta = np.random.uniform(0, 2 * math.pi)\n        r = np.random.uniform(0, max_radius)\n        \n        # Create perpendicular vectors to tail direction\n        if abs(dir_z) < 0.9:\n            perp1_x = -dir_y\n            perp1_y = dir_x\n            perp1_z = 0\n        else:\n            perp1_x = 1\n            perp1_y = 0\n            perp1_z = -dir_x / dir_z if dir_z != 0 else 0\n        \n        # Normalize perp1\n        perp1_len = math.sqrt(perp1_x**2 + perp1_y**2 + perp1_z**2)\n        if perp1_len > 0:\n            perp1_x /= perp1_len\n            perp1_y /= perp1_len\n            perp1_z /= perp1_len\n        \n        # Cross product for second perpendicular\n        perp2_x = dir_y * perp1_z - dir_z * perp1_y\n        perp2_y = dir_z * perp1_x - dir_x * perp1_z\n        perp2_z = dir_x * perp1_y - dir_y * perp1_x\n        \n        # Position in tail\n        x = center_x + tail_distance * dir_x + r * (math.cos(theta) * perp1_x + math.sin(theta) * perp2_x)\n        y = center_y + tail_distance * dir_y + r * (math.cos(theta) * perp1_y + math.sin(theta) * perp2_y)\n        z = center_z + tail_distance * dir_z + r * (math.cos(theta) * perp1_z + math.sin(theta) * perp2_z)\n        \n        tail_points_x.append(x)\n        tail_points_y.append(y)\n        tail_points_z.append(z)\n    \n    # Create color gradient with alpha channel for fading effect\n    # RGBA colors where alpha decreases with distance\n    colors = []\n    for i in range(num_particles):\n        alpha = 0.6 * (1 - i/num_particles)**2  # Fades with distance\n        # Ensure alpha is at least 0.001 to avoid scientific notation issues\n        alpha = max(alpha, 0.001)\n        colors.append(f'rgba(255, 200, 100, {alpha:.3f})')\n    \n    traces = [\n        go.Scatter3d(\n            x=tail_points_x,\n            y=tail_points_y,\n            z=tail_points_z,\n            mode='markers',\n            marker=dict(\n                size=2.5,\n                color=colors,  # Use RGBA colors for per-point opacity\n            ),\n            name=f\"Mercury: {layer_info['name']}\",\n            text=[layer_info['description']] * len(tail_points_x),\n            customdata=[f\"Mercury: {layer_info['name']}\"] * len(tail_points_x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 405,
    "end_line": 512,
    "has_docstring": true,
    "docstring": "Creates Mercury's sodium tail visualization extending away from the Sun.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_mercury_sodium_tail",
    "component_id": "mercury_visualization_shells.create_mercury_sodium_tail"
  },
  "mercury_visualization_shells.create_mercury_magnetosphere_shell": {
    "id": "mercury_visualization_shells.create_mercury_magnetosphere_shell",
    "name": "create_mercury_magnetosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\mercury_visualization_shells.py",
    "relative_path": "mercury_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_magnetosphere_shape",
      "shared_utilities.create_sun_direction_indicator"
    ],
    "source_code": "def create_mercury_magnetosphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Mercury's magnetosphere.\"\"\"\n    traces = []\n    \n    # Parameters for magnetosphere components (in Mercury radii)\n    params = {\n        # Compressed sunward side\n        'sunward_distance': 10,  # Compressed toward the sun\n        \n        # Equatorial extension (wider than polar)\n        'equatorial_radius': 12,\n        'polar_radius': 10,\n        \n        # Magnetotail parameters\n        'tail_length': 100,  # Length of visible magnetotail\n        'tail_base_radius': 15,  # Radius at the base of the tail\n        'tail_end_radius': 25,  # Radius at the end of the tail\n        \n        # Radiation belts\n    #    'inner_belt_distance': 1.5,  # Distance in Earth radii\n    #    'outer_belt_distance': 4.5,  # Distance in Earth radii\n    #    'belt_thickness': 0.5,\n    }\n    \n    # Scale everything by Earth's radius in AU\n    for key in params:\n        params[key] *= MERCURY_RADIUS_AU\n    \n    # Create magnetosphere main shape\n    x, y, z = create_magnetosphere_shape(params)\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # 1. Add the main magnetosphere structure\n    x = np.array(x) + center_x\n    y = np.array(y) + center_y\n    z = np.array(z) + center_z\n    \n    magnetosphere_text = [\"Magnetosphere: Mercury has a surprisingly active magnetosphere, given its small size and slow rotation. <br>\" \n                          \"However, it is significantly weaker and smaller than Earth's magnetosphere.<br>\" \n                          \"* Intrinsic Magnetic Field: Mercury generates an internal magnetic field, likely due to dynamo action in <br>\" \n                          \"  its partially liquid outer core. This was a significant discovery by Mariner 10 in the 1970s and has been <br>\" \n                          \"  further studied by the MESSENGER and BepiColombo missions.<br>\" \n                          \"* Interaction with the Solar Wind: This weak magnetic field is still strong enough to deflect the solar wind, <br>\" \n                          \"  creating a small magnetosphere around the planet. This magnetosphere has features similar to Earth's, including <br>\" \n                          \"  a bow shock, magnetopause, and magnetotail.<br>\" \n                          \"  Dynamic and Leaky: Due to its proximity to the Sun, Mercury's magnetosphere experiences a much stronger and more <br>\" \n                          \"  dynamic solar wind than Earth. This interaction can lead to magnetic reconnection events and a \\\"leakier\\\" <br>\" \n                          \"  magnetosphere, allowing more solar wind particles to reach the planet's surface and contribute to its exosphere.<br>\" \n                          \"* No Stable Radiation Belts: Unlike Earth's Van Allen radiation belts, Mercury's small and dynamic magnetosphere <br>\" \n                          \"  doesn't have stable regions for trapping high-energy particles for extended periods.<br><br>\" \n                          \"Estimating the dimensions of Mercury's magnetosphere in terms of Mercury radii (~2440 km) involves <br>\" \n                          \"considering its interaction with the solar wind, which is quite dynamic. However, based on observations <br>\" \n                          \"from the MESSENGER and BepiColombo missions, we can provide some approximate ranges and typical values:<br>\" \n                          \"* Sunward Distance (to the Bow Shock): The bow shock is the outermost boundary where the supersonic solar <br>\" \n                          \"  wind is slowed and heated as it encounters Mercury's magnetosphere. This distance is highly variable <br>\" \n                          \"  depending on the solar wind conditions, but a typical sunward distance to the bow shock is estimated to be <br>\" \n                          \"  around 1.4 to 2.0 radii from the center of Mercury.<br>\" \n                          \"* Equatorial Radius (of the Magnetopause): The magnetopause is the boundary where Mercury's magnetic field <br>\" \n                          \"  pressure balances the solar wind pressure. In the equatorial plane (perpendicular to the magnetic poles), the <br>\" \n                          \"  magnetopause typically extends to about 1.1 to 1.5 radii from the center of Mercury. This is quite compressed <br>\" \n                          \"  due to the relatively weak magnetic field and strong solar wind pressure at Mercury's orbit.<br>\" \n                          \"* Polar Radius (of the Magnetopause): Along Mercury's magnetic poles, the magnetopause is closer to the planet than <br>\" \n                          \"  at the equator due to the field line geometry. Estimates for the distance to the magnetopause at the poles range <br>\" \n                          \"  from about 0.8 to 1.2 radii from the center. In some models, it can be very close to the surface.<br>\" \n                          \"* Tail Length (Magnetotail): The magnetotail is the region downstream of the planet, stretched out by the solar wind.<br>\" \n                          \"  Mercury's magnetotail is relatively short and dynamic compared to Earth's. Estimates for its typical length vary, <br>\" \n                          \"  but it's often considered to extend to around 10 to 30 radii downwind. However, it can be significantly longer or <br>\" \n                          \"  shorter depending on solar wind conditions and magnetic reconnection events.<br>\" \n                          \"* Tail Base Radius: The base of the magnetotail is the region just behind the planet where the magnetopause starts to <br>\" \n                          \"  be significantly stretched. The radius of this tail base in the equatorial plane is roughly comparable to the equatorial <br>\" \n                          \"  radius of the magnetopause, so we can estimate it to be around 1.1 to 1.5 radii.<br>\" \n                          \"* Tail End Radius: The \\\"end\\\" of Mercury's magnetotail isn't a sharply defined boundary. As the tail extends downwind, <br>\" \n                          \"  it gradually widens and becomes more turbulent, eventually merging with the interplanetary magnetic field. At the <br>\" \n                          \"  estimated lengths of 10 to 30 radii, the radius of the tail is expected to be larger than at the base, likely in the range <br>\" \n                          \"  of 2 to 5 radii, but this is highly variable and less well-defined.\"]\n    \n    magnetosphere_customdata = ['Mercury: Magnetosphere']\n\n    traces.append(\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.0,\n                color='rgb(180, 180, 255)', # Light blue for magnetic field\n                opacity=0.2\n            ),\n            name='Mercury: Magnetosphere',\n            text=magnetosphere_text * len(x),\n            customdata=magnetosphere_customdata * len(x),      \n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    )\n    \n    # 2. Create and add bow shock\n    bow_shock_x = []\n    bow_shock_y = []\n    bow_shock_z = []\n    \n    n_phi = 30\n    n_theta = 30\n    bow_shock_standoff = 15 * MERCURY_RADIUS_AU\n    bow_shock_width = 25 * MERCURY_RADIUS_AU\n    \n    # Create a paraboloid for the bow shock\n    for i_phi in range(n_phi):\n        phi = (i_phi / (n_phi-1)) * np.pi  # Only the front half\n        \n        for i_theta in range(n_theta):\n            theta = (i_theta / (n_theta-1)) * 2 * np.pi\n            \n            # Paraboloid shape, flattened in x-direction for bow shock\n            x = -bow_shock_standoff * np.cos(phi)  # Negative for sunward direction\n            rho = bow_shock_width * (1 + np.sin(phi)) / 2  # Wider for larger phi (away from sun)\n            y = rho * np.cos(theta)\n            z = rho * np.sin(theta)\n            \n            bow_shock_x.append(x)\n            bow_shock_y.append(y)\n            bow_shock_z.append(z)\n    \n    # Apply center position offset\n    bow_shock_x = np.array(bow_shock_x) + center_x\n    bow_shock_y = np.array(bow_shock_y) + center_y\n    bow_shock_z = np.array(bow_shock_z) + center_z\n    \n    bow_shock_text = [\"Bow Shock: The bow shock is the outermost boundary where the supersonic solar wind is slowed and heated as <br>\" \n                      \"it encounters Mercury's magnetosphere. This distance is highly variable depending on the solar wind conditions, <br>\" \n                      \"but a typical sunward distance to the bow shock is estimated to be around 1.4 to 2.0 radii from the center of Mercury.<br>\"\n                      \"The Bow Shock points towards the Sun along the X-axis. The XY plane is the ecliptic.\"]\n    \n    bow_shock_customdata = ['Mercury: Bow Shock']\n\n    traces.append(\n        go.Scatter3d(\n            x=bow_shock_x,\n            y=bow_shock_y,\n            z=bow_shock_z,\n            mode='markers',\n            marker=dict(\n                size=1.5,\n                color='rgb(255, 200, 150)',  # Orange-ish color for bow shock\n                opacity=0.2\n            ),\n            name='Mercury: Bow Shock',\n            text=bow_shock_text * len(bow_shock_x),\n            customdata=bow_shock_customdata * len(bow_shock_x),  # This was the line causing the error\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    )\n        \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=100 * MERCURY_RADIUS_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 521,
    "end_line": 683,
    "has_docstring": true,
    "docstring": "Creates Mercury's magnetosphere.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_mercury_magnetosphere_shell",
    "component_id": "mercury_visualization_shells.create_mercury_magnetosphere_shell"
  },
  "mercury_visualization_shells.create_mercury_hill_sphere_shell": {
    "id": "mercury_visualization_shells.create_mercury_hill_sphere_shell",
    "name": "create_mercury_hill_sphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\mercury_visualization_shells.py",
    "relative_path": "mercury_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_mercury_hill_sphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Mercury's Hill sphere.\"\"\"\n    # Hill sphere radius in Mercury radii\n    radius_fraction = 94.4  # Mercury's Hill sphere is about 90 Mercury radii\n    \n    # Calculate radius in AU\n    radius_au = radius_fraction * MERCURY_RADIUS_AU\n    \n    # Create sphere points with fewer points for memory efficiency\n    n_points = 30  # Reduced for large spheres\n    x, y, z = create_sphere_points(radius_au, n_points=n_points)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    # Create hover text\n    hover_text = (\"Hill Sphere: Every celestial body has a Hill sphere (also known as the Roche sphere), which is the region around it <br>\" \n                \"where its gravity is the dominant gravitational force. Mercury certainly has a Hill sphere, but its size depends on <br>\" \n                \"its mass and its distance from the Sun. Being the closest planet to the Sun, the Sun's powerful gravity limits the <br>\" \n                \"extent of Mercury's Hill sphere compared to planets farther out.<br><br>\" \n                \"The Hill sphere is the region around a where its own gravity is the dominant force in attracting satellites. For <br>\" \n                \"a planet orbiting a star, it's the region where the planet's gravity is stronger than the star's tidal forces.<br><br>\" \n                \"The Hill Sphere radius can be described in words as follows: it is equal to the planet's average distance from the <br>\" \n                \"Sun (its orbital semi-major axis) multiplied by the cube root of the ratio between the planet's mass and three times <br>\" \n                \"the Sun's mass. In other words, you take how far the planet orbits out from the Sun, then scale that distance by the <br>\" \n                \"cube root of (planet mass / [3 x solar mass]) to find the boundary within which the planet's gravity dominates over the Sun's.\")\n    \n    hover_customdata = [\"Hill Sphere\"]\n\n    # Create the trace\n    traces = [\n        go.Scatter3d(\n            x=x,\n            y=y,\n            z=z,\n            mode='markers',\n            marker=dict(\n                size=1.0,\n                color='rgb(0, 255, 0)',  # Green for Hill sphere\n                opacity=0.25\n            ),\n            name='Mercury: Hill Sphere',\n            text=[hover_text] * len(x),\n            customdata=['Mercury: Hill Sphere'] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n\n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=radius_au\n    )\n    for trace in sun_traces:\n        traces.append(trace)        \n\n    return traces",
    "start_line": 693,
    "end_line": 753,
    "has_docstring": true,
    "docstring": "Creates Mercury's Hill sphere.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_mercury_hill_sphere_shell",
    "component_id": "mercury_visualization_shells.create_mercury_hill_sphere_shell"
  },
  "messier_catalog.get_all_bright_objects": {
    "id": "messier_catalog.get_all_bright_objects",
    "name": "get_all_bright_objects",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\messier_catalog.py",
    "relative_path": "messier_catalog.py",
    "depends_on": [
      "orrery_integration.update"
    ],
    "source_code": "def get_all_bright_objects():\n    \"\"\"Combine all catalogs of bright galactic objects.\"\"\"\n    all_objects = {}\n    catalogs = [\n        bright_planetaries,\n        bright_open_clusters,\n        bright_nebulae\n    ]\n    \n    for catalog in catalogs:\n        all_objects.update(catalog)\n    \n    return all_objects",
    "start_line": 275,
    "end_line": 287,
    "has_docstring": true,
    "docstring": "Combine all catalogs of bright galactic objects.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_all_bright_objects",
    "component_id": "messier_catalog.get_all_bright_objects"
  },
  "messier_catalog.get_objects_brighter_than": {
    "id": "messier_catalog.get_objects_brighter_than",
    "name": "get_objects_brighter_than",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\messier_catalog.py",
    "relative_path": "messier_catalog.py",
    "depends_on": [
      "orrery_integration.update"
    ],
    "source_code": "def get_objects_brighter_than(magnitude):\n    \"\"\"Return all objects brighter than the specified magnitude.\"\"\"\n    visible = {}\n    # Check all catalogs\n    catalogs = [\n        messier_catalog,\n        star_cluster_catalog,\n        bright_planetaries,\n        bright_open_clusters,\n        bright_nebulae\n    ]\n    \n    for catalog in catalogs:\n        visible.update({k: v for k, v in catalog.items() if v['vmag'] <= magnitude})\n    \n    return visible",
    "start_line": 289,
    "end_line": 304,
    "has_docstring": true,
    "docstring": "Return all objects brighter than the specified magnitude.",
    "parameters": [
      "magnitude"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_objects_brighter_than",
    "component_id": "messier_catalog.get_objects_brighter_than"
  },
  "messier_catalog.get_objects_by_type": {
    "id": "messier_catalog.get_objects_by_type",
    "name": "get_objects_by_type",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\messier_catalog.py",
    "relative_path": "messier_catalog.py",
    "depends_on": [
      "orrery_integration.update"
    ],
    "source_code": "def get_objects_by_type(obj_type):\n    \"\"\"Return all objects of a specific type.\"\"\"\n    matching = {}\n    catalogs = [\n        messier_catalog,\n        star_cluster_catalog,\n        bright_planetaries,\n        bright_open_clusters,\n        bright_nebulae\n    ]\n    \n    for catalog in catalogs:\n        matching.update({k: v for k, v in catalog.items() \n                        if obj_type.lower() in v['type'].lower()})\n    \n    return matching",
    "start_line": 306,
    "end_line": 321,
    "has_docstring": true,
    "docstring": "Return all objects of a specific type.",
    "parameters": [
      "obj_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_objects_by_type",
    "component_id": "messier_catalog.get_objects_by_type"
  },
  "messier_catalog.get_nebulae": {
    "id": "messier_catalog.get_nebulae",
    "name": "get_nebulae",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\messier_catalog.py",
    "relative_path": "messier_catalog.py",
    "depends_on": [
      "orrery_integration.update"
    ],
    "source_code": "def get_nebulae():\n    \"\"\"Return all nebulae from both Messier and bright object catalogs.\"\"\"\n    nebulae = {}\n    # Check Messier catalog\n    nebulae.update({k: v for k, v in messier_catalog.items() \n                    if 'Nebula' in v['type'] or 'HII Region' in v['type']})\n    # Add bright nebulae\n    nebulae.update(bright_nebulae)\n    # Add bright planetaries\n    nebulae.update(bright_planetaries)\n    return nebulae",
    "start_line": 323,
    "end_line": 333,
    "has_docstring": true,
    "docstring": "Return all nebulae from both Messier and bright object catalogs.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_nebulae",
    "component_id": "messier_catalog.get_nebulae"
  },
  "messier_catalog.get_star_clusters": {
    "id": "messier_catalog.get_star_clusters",
    "name": "get_star_clusters",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\messier_catalog.py",
    "relative_path": "messier_catalog.py",
    "depends_on": [
      "orrery_integration.update"
    ],
    "source_code": "def get_star_clusters():\n    \"\"\"Return all star clusters from both catalogs.\"\"\"\n    clusters = {}\n    clusters.update(star_cluster_catalog)\n    clusters.update(bright_open_clusters)\n    return clusters",
    "start_line": 335,
    "end_line": 340,
    "has_docstring": true,
    "docstring": "Return all star clusters from both catalogs.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_star_clusters",
    "component_id": "messier_catalog.get_star_clusters"
  },
  "messier_catalog.get_visible_objects": {
    "id": "messier_catalog.get_visible_objects",
    "name": "get_visible_objects",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\messier_catalog.py",
    "relative_path": "messier_catalog.py",
    "depends_on": [],
    "source_code": "def get_visible_objects(mag_limit):\n    \"\"\"Return all objects brighter than the given magnitude.\"\"\"\n    visible = {}\n    # Check all catalogs\n    catalogs = [\n        ('M', messier_catalog),\n        ('SC', star_cluster_catalog),\n        ('PN', bright_planetaries),\n        ('OC', bright_open_clusters),\n        ('NEB', bright_nebulae)\n    ]\n    \n    for prefix, catalog in catalogs:\n        for obj_id, obj in catalog.items():\n            if obj['vmag'] <= mag_limit:\n                visible[obj_id] = obj\n    return visible",
    "start_line": 342,
    "end_line": 358,
    "has_docstring": true,
    "docstring": "Return all objects brighter than the given magnitude.",
    "parameters": [
      "mag_limit"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_visible_objects",
    "component_id": "messier_catalog.get_visible_objects"
  },
  "messier_catalog.get_object_info": {
    "id": "messier_catalog.get_object_info",
    "name": "get_object_info",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\messier_catalog.py",
    "relative_path": "messier_catalog.py",
    "depends_on": [],
    "source_code": "def get_object_info(obj_id):\n    \"\"\"Get detailed information about a specific object.\"\"\"\n    catalogs = [\n        messier_catalog,\n        star_cluster_catalog,\n        bright_planetaries,\n        bright_open_clusters,\n        bright_nebulae\n    ]\n    \n    for catalog in catalogs:\n        if obj_id in catalog:\n            return catalog[obj_id]\n    return None",
    "start_line": 360,
    "end_line": 373,
    "has_docstring": true,
    "docstring": "Get detailed information about a specific object.",
    "parameters": [
      "obj_id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_object_info",
    "component_id": "messier_catalog.get_object_info"
  },
  "messier_catalog.get_catalog_statistics": {
    "id": "messier_catalog.get_catalog_statistics",
    "name": "get_catalog_statistics",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\messier_catalog.py",
    "relative_path": "messier_catalog.py",
    "depends_on": [],
    "source_code": "def get_catalog_statistics():\n    \"\"\"Return statistics about all catalogs.\"\"\"\n    stats = {\n        'total_objects': 0,\n        'by_type': {},\n        'magnitude_ranges': {\n            '<=4.0': 0,\n            '4.1-6.0': 0,\n            '6.1-9.0': 0,\n            '>9.0': 0\n        },\n        'by_catalog': {\n            'Messier': 0,\n            'Star Clusters': 0,\n            'Planetaries': 0,\n            'Open Clusters': 0,\n            'Nebulae': 0\n        }\n    }\n    \n    # Process all catalogs\n    catalog_map = {\n        messier_catalog: 'Messier',\n        star_cluster_catalog: 'Star Clusters',\n        bright_planetaries: 'Planetaries',\n        bright_open_clusters: 'Open Clusters',\n        bright_nebulae: 'Nebulae'\n    }\n    \n    for catalog, catalog_name in catalog_map.items():\n        for obj in catalog.values():\n            stats['total_objects'] += 1\n            stats['by_catalog'][catalog_name] += 1\n            \n            # Count by type\n            obj_type = obj['type']\n            stats['by_type'][obj_type] = stats['by_type'].get(obj_type, 0) + 1\n            \n            # Count by magnitude\n            vmag = obj['vmag']\n            if vmag <= 4.0:\n                stats['magnitude_ranges']['<=4.0'] += 1\n            elif vmag <= 6.0:\n                stats['magnitude_ranges']['4.1-6.0'] += 1\n            elif vmag <= 9.0:\n                stats['magnitude_ranges']['6.1-9.0'] += 1\n            else:\n                stats['magnitude_ranges']['>9.0'] += 1\n            \n    return stats",
    "start_line": 375,
    "end_line": 424,
    "has_docstring": true,
    "docstring": "Return statistics about all catalogs.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_catalog_statistics",
    "component_id": "messier_catalog.get_catalog_statistics"
  },
  "messier_object_data_handler.MessierObjectHandler": {
    "id": "messier_object_data_handler.MessierObjectHandler",
    "name": "MessierObjectHandler",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\messier_object_data_handler.py",
    "relative_path": "messier_object_data_handler.py",
    "depends_on": [
      "messier_catalog.get_star_clusters",
      "messier_catalog.get_nebulae"
    ],
    "source_code": "class MessierObjectHandler:\n    \"\"\"Handles all Messier object related operations.\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize with both nebulae and star cluster catalogs.\"\"\"\n        self.nebulae = get_nebulae()\n        self.clusters = get_star_clusters()\n        \n    def get_visible_objects(self, mag_limit, object_type=None):\n        \"\"\"\n        Get Messier objects visible up to specified magnitude limit.\n        \n        Parameters:\n            mag_limit (float): Maximum apparent magnitude to include\n            object_type (str, optional): Filter by object type \n                ('Nebula', 'Cluster', 'Planetary', 'Emission', etc.)\n        \n        Returns:\n            list: List of visible objects matching criteria\n        \"\"\"\n        visible_objects = []\n        \n        print(f\"\\nFiltering Messier objects to magnitude {mag_limit}\")\n        \n        # Process both catalogs\n        for catalog in [self.nebulae, self.clusters]:\n            for messier_id, data in catalog.items():\n                if data['vmag'] <= mag_limit:\n                    if object_type is None or object_type.lower() in data['type'].lower():\n                        obj_data = {\n                            'messier_id': messier_id,\n                            'name': data['name'],\n                            'type': data['type'],\n                            'vmag': data['vmag'],\n                            'distance_ly': data['distance_ly'],\n                            'ra': data['ra'],\n                            'dec': data['dec'],\n                            'ra_str': data['ra'],  # Original string format like '05h34m31.94s'\n                            'dec_str': data['dec'], # Original string format like '+22 deg00 arcmin52.2 arcsec'                            \n                            'notes': data.get('notes', ''),\n                            'size': data.get('size', None),\n                            'age': data.get('age', None),\n                            'parent_constellation': data.get('constellation', None)\n                        }\n                        visible_objects.append(obj_data)\n        \n        print(f\"Found {len(visible_objects)} visible Messier objects\")\n        if object_type:\n            print(f\"(Filtered to type: {object_type})\")\n            \n        return visible_objects\n    \n    def calculate_3d_coordinates(self, objects):\n        \"\"\"\n        Calculate x, y, z coordinates for Messier objects.\n        \n        Parameters:\n            objects (list): List of Messier objects with ra, dec, and distance\n            \n        Returns:\n            list: Objects with added x, y, z coordinates in light-years\n        \"\"\"\n        for obj in objects:\n            try:\n                # Parse coordinates\n                coords = SkyCoord(obj['ra'], obj['dec'], unit=(u.hourangle, u.deg))\n                distance_pc = obj['distance_ly'] / 3.26156\n                \n                # Create 3D coordinates\n                coord_with_dist = SkyCoord(\n                    ra=coords.ra,\n                    dec=coords.dec,\n                    distance=distance_pc * u.pc\n                )\n                \n                # Convert to light-years\n                obj['x'] = coord_with_dist.cartesian.x.value * 3.26156\n                obj['y'] = coord_with_dist.cartesian.y.value * 3.26156\n                obj['z'] = coord_with_dist.cartesian.z.value * 3.26156\n                \n            except Exception as e:\n                print(f\"Error calculating coordinates for {obj['messier_id']}: {e}\")\n                obj['x'] = obj['y'] = obj['z'] = np.nan\n        \n        return objects\n    \n    def get_visible_objects(self, mag_limit, object_type=None):\n        \"\"\"\n        Get Messier objects visible up to specified magnitude limit.\n        \n        Parameters:\n            mag_limit (float): Maximum apparent magnitude to include\n            object_type (str, optional): Filter by object type \n                ('Nebula', 'Cluster', 'Planetary', 'Emission', etc.)\n        \n        Returns:\n            list: List of visible objects matching criteria\n        \"\"\"\n        visible_objects = []\n        \n        print(f\"\\nFiltering Messier objects to magnitude {mag_limit}\")\n        \n        # Process both catalogs\n        for catalog in [self.nebulae, self.clusters]:\n            for messier_id, data in catalog.items():\n                if data['vmag'] <= mag_limit:\n                    if object_type is None or object_type.lower() in data['type'].lower():\n                        # Parse RA and Dec from string format to degrees\n                        coords = SkyCoord(data['ra'], data['dec'], frame='icrs')\n                        \n                        obj_data = {\n                            'messier_id': messier_id,\n                            'name': data['name'],\n                            'type': data['type'],\n                            'vmag': data['vmag'],\n                            'distance_ly': data['distance_ly'],\n                            'ra': coords.ra.deg,      # Converted to degrees for calculations\n                            'dec': coords.dec.deg,    # Converted to degrees for calculations\n                            'ra_str': data['ra'],     # Keep original string for display\n                            'dec_str': data['dec'],   # Keep original string for display                            \n                            'notes': data.get('notes', ''),\n                            'size': data.get('size', None),\n                            'age': data.get('age', None),\n                            'parent_constellation': data.get('constellation', None)\n                        }\n                        visible_objects.append(obj_data)\n        \n        print(f\"Found {len(visible_objects)} visible Messier objects\")\n        if object_type:\n            print(f\"(Filtered to type: {object_type})\")\n            \n        return visible_objects\n\n    def create_dataframe(self, objects):\n        \"\"\"Convert Messier objects to DataFrame format compatible with stellar data.\"\"\"\n        if not objects:\n            return pd.DataFrame()\n                \n        # Calculate coordinates for each object\n        print(\"\\nCalculating coordinates for Messier objects...\")\n        for obj in objects:\n            try:\n                # Parse coordinates\n        #        coords = SkyCoord(obj['ra'], obj['dec'], unit=(u.hourangle, u.deg))\n\n                coords = SkyCoord(\n                    ra=obj['ra'],\n                    dec=obj['dec'],\n                    unit=(u.deg, u.deg),\n                    frame='icrs'\n                )\n\n                distance_pc = obj['distance_ly'] / 3.26156\n                \n                # Create 3D coordinates\n                coord_with_dist = SkyCoord(\n                    ra=coords.ra,\n                    dec=coords.dec,\n                    distance=distance_pc * u.pc,\n                    frame='icrs'\n                )\n                \n                # Convert to cartesian coordinates\n                cart = coord_with_dist.cartesian\n\n                # Convert to light-years and store\n                obj['x'] = cart.x.value * 3.26156\n                obj['y'] = cart.y.value * 3.26156\n                obj['z'] = cart.z.value * 3.26156\n                \n                print(f\"  {obj['messier_id']}: Calculated coordinates ({obj['x']:.1f}, {obj['y']:.1f}, {obj['z']:.1f}) ly\")\n                \n            except Exception as e:\n                print(f\"Error calculating coordinates for {obj['messier_id']}: {e}\")\n                obj['x'] = obj['y'] = obj['z'] = np.nan\n                \n        # Create DataFrame\n        df = pd.DataFrame(objects)\n        \n        # Add required columns to match stellar data format\n        df['Star_Name'] = df.apply(lambda row: f\"{row['messier_id']}: {row['name']}\", axis=1)\n    #    df['Star_Name'] = df['name']\n        df['Source_Catalog'] = 'Messier'\n        df['Apparent_Magnitude'] = df['vmag']\n        df['Distance_pc'] = df['distance_ly'] / 3.26156\n        df['Distance_ly'] = df['distance_ly']\n        df['Object_Type'] = df['type']\n        df['Object_Type_Desc'] = df.apply(self._create_type_description, axis=1)\n        \n        # Add null values for stellar-specific columns\n        df['Temperature'] = np.nan\n        df['Temperature_Method'] = 'none'  # Added for compatibility\n        df['Temperature_Normalized'] = 0.5  # Middle value for color scale\n        df['Luminosity'] = np.nan\n        df['Luminosity_Estimated'] = False  # Added for compatibility\n        df['B_V'] = np.nan\n        df['Spectral_Type'] = None\n        df['Abs_Mag'] = np.nan  # Added for compatibility\n        \n        # Add visualization properties\n        df['Marker_Size'] = 20  # Fixed larger size for non-stellar objects\n        \n        # Create hover texts\n        df['Hover_Text'] = df.apply(\n            lambda row: (\n                f\"<b>{row['messier_id']}: {row['name']}</b><br>\"\n        #        f\"<b>{row['Star_Name']}</b><br>\"\n                f\"Type: {row['type']}<br>\"\n        #        f\"Apparent Magnitude: {row['Apparent_Magnitude']:.1f}<br>\"\n                f\"Apparent Magnitude: {row['vmag']:.1f}<br>\"\n        #        f\"Distance: {row['Distance_ly']:.1f} ly<br>\"\n                f\"Distance: {row['Distance_pc']:.2f} pc ({row['Distance_ly']:.2f} ly)<br>\"\n        #        f\"Position: ({row['x']:.1f}, {row['y']:.1f}, {row['z']:.1f}) ly<br>\"\n                f\"RA: {row['ra_str']}, Dec: {row['dec_str']} (J2000)<br>\"\n                f\"{unique_notes.get(row['messier_id'], 'None')}<br>\"  # Use unique_notes with messier_id\n        #        f\"Notes: {row['notes']}\"\n            ),\n            axis=1\n        )\n        df['Min_Hover_Text'] = df.apply(\n            lambda row: f\"<b>{row['messier_id']}</b>\", \n    #        lambda row: f\"<b>{row['Star_Name']}</b>\", \n            axis=1)\n        \n        print(f\"\\nProcessed {len(df)} Messier objects with columns:\")\n        print(df.columns.tolist())\n        \n        return df\n\n    def _calculate_marker_size(self, vmag):         # obsolete\n        \"\"\"Calculate marker sizes based on apparent magnitude.\"\"\"\n        def calc_size(mag):\n            if pd.isna(mag):\n                return 20  # Default size for Messier objects\n            mag_min, mag_max = -1.44, 9.0\n            size_min, size_max = 2, 24\n            mag_clipped = np.clip(mag, mag_min, mag_max)\n            log_brightness = -0.4 * mag_clipped\n            log_brightness_min = -0.4 * mag_max\n            log_brightness_max = -0.4 * mag_min\n            normalized_brightness = (log_brightness - log_brightness_min) / (log_brightness_max - log_brightness_min)\n            return np.clip(size_min + (size_max - size_min) * normalized_brightness, size_min, size_max)\n        \n        return vmag.apply(calc_size)\n\n    def _create_hover_text(self, row):      # used?\n        \"\"\"Create hover text for a Messier object.\"\"\"\n        text = [\n            f\"<b>{row['messier_id']}: {row['name']}</b>\",\n            f\"Type: {row['type']}\",\n            f\"Apparent Magnitude: {row['vmag']:.1f}\",\n            f\"Distance: {row['distance_ly']:.1f} light-years\",\n        #    f\"Position: ({row['x']:.1f}, {row['y']:.1f}, {row['z']:.1f}) ly\"\n            f\"RA: {row['ra_str']}, Dec: {row['dec_str']} (J2000)<br>\"\n            f\"{unique_notes.get(row['messier_id'], 'None')}<br>\"  # Use unique_notes with messier_id\n        ]\n        \n        if 'size' in row and pd.notna(row['size']):\n            text.append(f\"Size: {row['size']}\")\n        if 'age' in row and pd.notna(row['age']):\n            text.append(f\"Age: {row['age']}\")\n        if 'notes' in row and pd.notna(row['notes']):\n            text.append(f\"Notes: {row['notes']}\")\n            \n        return '<br>'.join(text)\n    \n    def _create_type_description(self, row):\n        \"\"\"Create detailed type description.\"\"\"\n        desc = row['type']\n        if row.get('age'):\n            desc += f\", Age: {row['age']}\"\n        if row.get('size'):\n            desc += f\", Size: {row['size']}\"\n        return desc\n    \n    def _get_marker_symbol(self, obj_type):     # I don't think we use this function. all objects look the same. \n            \"\"\"\n            Get appropriate marker symbol based on object type.\n            Uses only symbols available in Plotly's Scatter3d:\n            - 'circle'\n            - 'square'\n            - 'diamond'\n            - 'cross'\n            - 'x'\n            - 'triangle-up'\n            - 'triangle-down'\n            \"\"\"\n            if 'Nebula' in obj_type:\n                return 'diamond'  # Compatible with Scatter3d\n            elif 'HII Region' in obj_type:\n                return 'square'   # Changed from 'diamond' for distinction\n            elif 'Cluster' in obj_type:\n                return 'triangle-up'  # Changed from 'cross' for better visibility\n            elif 'Planetary' in obj_type:\n                return 'circle'  # Specific symbol for planetary nebulae\n            elif 'Supernova' in obj_type:\n                return 'cross'  # Specific symbol for supernova remnants\n            return 'diamond'  # Default symbol\n    \n    def _get_marker_color(self, obj_type):          # I don't think we use this function. all objects look the same. \n        \"\"\"Get appropriate color based on object type.\"\"\"\n        if 'Emission' in obj_type or 'HII Region' in obj_type:\n            return 'red'\n        elif 'Planetary' in obj_type:\n            return 'green'\n        elif 'Reflection' in obj_type:\n            return 'blue'\n        elif 'Cluster' in obj_type:\n            return 'yellow'\n        return 'white'\n    \n    def get_object_info(self, messier_id):\n        \"\"\"Get detailed information for a specific Messier object.\"\"\"\n        obj = self.nebulae.get(messier_id) or self.clusters.get(messier_id)\n        if not obj:\n            return \"Object not found in catalog\"\n            \n        info = [\n            f\"{messier_id}\",\n            f\"Name: {obj['name']}\",\n            f\"Type: {obj['type']}\",\n            f\"Apparent Magnitude: {obj['vmag']}\",\n            f\"Distance: {obj['distance_ly']} light-years\"\n        ]\n        \n        if 'size' in obj:\n            info.append(f\"Size: {obj['size']}\")\n        if 'age' in obj:\n            info.append(f\"Age: {obj['age']}\")\n        if 'constellation' in obj:\n            info.append(f\"Constellation: {obj['constellation']}\")\n        if 'notes' in obj:\n            info.append(f\"Notes: {obj['notes']}\")\n            \n        return '\\n'.join(info)\n    \n    def analyze_catalog(self):\n        \"\"\"Analyze the catalog contents.\"\"\"\n        total_objects = len(self.nebulae) + len(self.clusters)\n        type_counts = {}\n        mag_distribution = []\n        \n        for obj in list(self.nebulae.values()) + list(self.clusters.values()):\n            # Count object types\n            obj_type = obj['type']\n            type_counts[obj_type] = type_counts.get(obj_type, 0) + 1\n            \n            # Collect magnitudes\n            mag_distribution.append(obj['vmag'])\n        \n        print(\"\\nNon-stellar Object Catalog Analysis\")\n        print(\"=\" * 50)\n        print(f\"Total Objects: {total_objects}\")\n        print(\"\\nObject Types:\")\n        for obj_type, count in sorted(type_counts.items()):\n            print(f\"  {obj_type}: {count}\")\n            \n        if mag_distribution:\n            print(\"\\nMagnitude Statistics:\")\n            print(f\"  Brightest: {min(mag_distribution):.1f}\")\n            print(f\"  Faintest: {max(mag_distribution):.1f}\")\n            print(f\"  Average: {np.mean(mag_distribution):.1f}\")",
    "start_line": 18,
    "end_line": 379,
    "has_docstring": true,
    "docstring": "Handles all Messier object related operations.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class MessierObjectHandler",
    "component_id": "messier_object_data_handler.MessierObjectHandler"
  },
  "moon_visualization_shells.create_moon_inner_core_shell": {
    "id": "moon_visualization_shells.create_moon_inner_core_shell",
    "name": "create_moon_inner_core_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\moon_visualization_shells.py",
    "relative_path": "moon_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_moon_inner_core_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates the Moon's inner core shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.1485,  \n        'color': 'rgb(255, 100, 0)',  # dark red-orange at 1700K\n        'opacity': 1.0,\n        'name': 'Inner Core',\n        'description': (\n            \"The Moon has a small, partially molten core. Seismic data from Apollo missions and more recent studies of the Moon\\'s wobble suggest:<br>\" \n            \"* Inner Core: Believed to be a solid, iron-rich core, roughly 240 kilometers in radius:<br>\" \n            \"  * Estimates for the temperature of the Moon\\'s inner core vary slightly depending on the studies and methods used, but <br>\" \n            \"    some more recent reanalyses of seismic data suggest temperatures around 1600-1700 K.\" \n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * MOON_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=4.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Moon: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Moon: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 14,
    "end_line": 59,
    "has_docstring": true,
    "docstring": "Creates the Moon's inner core shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_moon_inner_core_shell",
    "component_id": "moon_visualization_shells.create_moon_inner_core_shell"
  },
  "moon_visualization_shells.create_moon_outer_core_shell": {
    "id": "moon_visualization_shells.create_moon_outer_core_shell",
    "name": "create_moon_outer_core_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\moon_visualization_shells.py",
    "relative_path": "moon_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_moon_outer_core_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates the Moon's outer core shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.2083,  \n        'color': 'rgb(255, 50, 0)',  # very dark, deep red, almost a \"charcoal red\" or \"ember red\"\n        'opacity': 0.8,\n        'name': 'Outer Core',\n        'description': (\n            \"Outer Core: Surrounding the inner core, this is thought to be a liquid, iron-rich outer core with a radius of about <br>\" \n            \"330 kilometers. There might also be a small, partially molten layer of silicates around the outer core.<br>:\" \n            \"* The Moon's outer core is generally understood to be hotter than its solid inner core, as it is in a molten or liquid <br>\" \n            \"  state. <br>\" \n            \"* Estimated Temperature: This layer would be slightly cooler than the inner core, but still hot enough to be molten at <br>\" \n            \"  the lower pressures found here. Estimates typically fall around 1300 K to 1600 K. Let's use 1500 K as a representative <br>\" \n            \"  value for the outer core for your model.<br>\" \n            \"* Reasoning: As you move outwards, the temperature gradually decreases, but crucially, the pressure also decreases. At this <br>\" \n            \"  depth and pressure, the temperature is above the melting point of the iron-rich material, allowing it to be liquid.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * MOON_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.7,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Moon: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Moon: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 66,
    "end_line": 116,
    "has_docstring": true,
    "docstring": "Creates the Moon's outer core shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_moon_outer_core_shell",
    "component_id": "moon_visualization_shells.create_moon_outer_core_shell"
  },
  "moon_visualization_shells.create_moon_mantle_shell": {
    "id": "moon_visualization_shells.create_moon_mantle_shell",
    "name": "create_moon_mantle_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\moon_visualization_shells.py",
    "relative_path": "moon_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_moon_mantle_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates the Moon's lower mantle shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.85,  # Lower mantle: 55-85% of Earth's radius\n        'color': 'rgb(0, 50, 0)',  # very dark green for peridotite\n        'opacity': 0.9655,\n        'name': 'Mantle',\n        'description': (\n            \"Above the core lies the Moon's mantle, which makes up the bulk of its interior:<br>\" \n            \"* Composition: Primarily composed of silicate rocks, similar to Earth's mantle, but with different proportions of <br>\" \n            \"  elements. It's thought to be rich in olivine and pyroxene.<br>\" \n            \"* State: The Moon's mantle is largely solid today. However, in its early history, it would have been at least partially <br>\" \n            \"  molten, leading to volcanic activity that formed the vast maria (dark plains) on the lunar surface.<br>\" \n            \"* Lunar Deep Moonquakes: Seismometers left by Apollo missions detected \\\"deep moonquakes\\\" originating in the mantle at <br>\" \n            \"  depths of 700 to 1,200 km (435-745 miles). These are likely caused by tidal stresses from Earth.<br>\" \n            \"* The Moon's mantle is a thick, largely solid layer, and its temperature varies significantly with depth, becoming <br>\" \n            \"  cooler as you move outwards towards the crust.<br>\" \n            \"  * Estimates for the temperature at the boundary between the mantle and the outer core range from 1573 K to 1743 K.<br>\" \n            \"  * Estimates for the crust-mantle boundary are roughly 623 K to 823 K.<br>\" \n            \"* The \\\"Draper point\\\" is around 798 K, which is the approximate temperature at which all solids start to glow a dim <br>\" \n            \"  red. Therefore, the upper mantle, at these temperatures, would not visibly glow from black body radiation in normal <br>\" \n            \"  conditions. Its primary emission would be in the infrared spectrum, invisible to the human eye. For the bulk of the <br>\" \n            \"  mantle, it is primarily composed of silicate rocks like olivine and pyroxene. When seen in rock samples, these tend <br>\" \n            \"  to be dark greenish to black (e.g., peridotite).<br>\" \n            \"* Outer boundary of the mantle (base of the crust) as a fraction of Rm: 1677.4 km/1737.4 km~0.9655\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * MOON_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.4,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Moon: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Moon: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 128,
    "end_line": 186,
    "has_docstring": true,
    "docstring": "Creates the Moon's lower mantle shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_moon_mantle_shell",
    "component_id": "moon_visualization_shells.create_moon_mantle_shell"
  },
  "moon_visualization_shells.create_moon_crust_shell": {
    "id": "moon_visualization_shells.create_moon_crust_shell",
    "name": "create_moon_crust_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\moon_visualization_shells.py",
    "relative_path": "moon_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_moon_crust_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Earth's crust shell using Mesh3d for better performance with improved hover.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.0,  \n        'color': 'rgb(190, 190, 180)',  # slightly warm grey\n        'opacity': 1.0,\n        'name': 'Crust',\n        'description': (\n            \"The outermost layer of the Moon is its crust, which is significantly thicker on the far side than on the near side:<br>\" \n            \"* Composition: Dominated by anorthositic rocks (rich in plagioclase feldspar), which are lighter in color and form the <br>\" \n            \"  lunar highlands. The dark maria, on the other hand, are vast basaltic plains formed by ancient volcanic eruptions that <br>\" \n            \"  filled large impact basins.<br>\" \n            \"* Thickness: The lunar crust varies in thickness. On the near side (facing Earth), it's estimated to be around 30-50 <br>\" \n            \"  kilometers thick. On the far side, it can be much thicker, possibly reaching up to 100 kilometers or more. This <br>\" \n            \"  asymmetry is a major characteristic of the Moon. The most compelling explanations for the Moon's crustal thickness <br>\" \n            \"  asymmetry point to a combination of factors related to its formation in Earth\\'s intense thermal environment and a <br>\" \n            \"  massive early impact that shaped its internal heat distribution and subsequent geological evolution.<br>\" \n            \"* Surface Features: The crust is heavily cratered due to billions of years of impacts from asteroids and comets. Other <br>\" \n            \"  features include rilles (channels, often associated with lava flows), domes, and wrinkle ridges.<br>\" \n            \"* Given the mix of lighter highlands and darker maria, and the overall neutral tone, a medium, slightly warm grey.<br>\" \n            \"* Unlike Earth, the Moon does not have a global, internally generated magnetic field today. However, rocks collected <br>\" \n            \"  during the Apollo missions showed evidence of remnant magnetism, indicating that the Moon did possess a global <br>\" \n            \"  magnetic field in its early history, likely generated by a liquid core dynamo similar to Earth's. Today, there are <br>\" \n            \"  localized magnetic anomalies on the lunar surface, thought to be remnants of this ancient magnetic field or perhaps <br>\" \n            \"  due to impact processes. These regions can sometimes interact with the solar wind, creating small <br>\" \n            \"  \\\"mini-magnetospheres.\\\".<br>\" \n            \"* Solar Wind Interaction: Without a global magnetic field, the Moon is directly exposed to the solar wind, a stream of <br>\" \n            \"  charged particles from the Sun. This constant bombardment contributes to space weathering of the lunar surface.<br>\" \n            \"* Water Ice: One of the most significant discoveries in recent lunar exploration is the confirmed presence of water ice, <br>\" \n            \"  particularly in permanently shadowed regions within craters at the Moon\\'s poles.<br>\" \n            \"* Regolith: The entire lunar surface is covered by a layer of fine, powdery dust and broken rock fragments called regolith. <br>\" \n            \"  It\\'s formed by billions of years of micrometeoroid impacts and varies in thickness from a few meters in the maria to tens <br>\" \n            \"  of meters in the highlands.<br>\" \n            \"* Tidally Locked: The Moon is tidally locked with Earth, meaning the same side of the Moon (the \\\"near side\\\") always faces <br>\" \n            \"  Earth.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    radius = layer_info['radius_fraction'] * MOON_RADIUS_AU\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Create mesh with reasonable resolution for performance\n    resolution = 24  # Reduced from typical 50 for markers\n    \n    # Create a UV sphere\n    phi = np.linspace(0, 2*np.pi, resolution)\n    theta = np.linspace(-np.pi/2, np.pi/2, resolution)\n    phi, theta = np.meshgrid(phi, theta)\n    \n    x = radius * np.cos(theta) * np.cos(phi)\n    y = radius * np.cos(theta) * np.sin(phi)\n    z = radius * np.sin(theta)\n    \n    # Apply center position offset\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    # Create triangulation\n    indices = []\n    for i in range(resolution-1):\n        for j in range(resolution-1):\n            p1 = i * resolution + j\n            p2 = i * resolution + (j + 1)\n            p3 = (i + 1) * resolution + j\n            p4 = (i + 1) * resolution + (j + 1)\n            \n            indices.append([p1, p2, p4])\n            indices.append([p1, p4, p3])\n    \n    # Create main surface\n    surface_trace = go.Mesh3d(\n        x=x.flatten(), \n        y=y.flatten(), \n        z=z.flatten(),\n        i=[idx[0] for idx in indices],\n        j=[idx[1] for idx in indices],\n        k=[idx[2] for idx in indices],\n        color=layer_info['color'],\n        opacity=layer_info['opacity'],\n        name=f\"Moon: {layer_info['name']}\",\n        showlegend=True,\n        hoverinfo='none',  # Disable hover on mesh surface\n        # Add these new parameters to make hover text invisible\n        hovertemplate=' ',  # Empty template instead of None\n        hoverlabel=dict(\n    #        bgcolor='rgba(0,0,0,0)',  # Transparent background\n            font=dict(\n                color='rgba(0,0,0,0)',  # Transparent text\n    #            size=0                  # Zero font size\n            ),\n            bordercolor='rgba(0,0,0,0)'  # Transparent border\n        ), \n        # Add these new parameters to eliminate shading\n        flatshading=True,  # Use flat shading instead of smooth\n        lighting=dict(\n            ambient=1.0,     # Set to maximum (1.0)\n            diffuse=0.0,     # Turn off diffuse lighting\n            specular=0.0,    # Turn off specular highlights\n            roughness=1.0,   # Maximum roughness\n            fresnel=0.0      # Turn off fresnel effect\n        ),\n        lightposition=dict(\n            x=0,  # Centered light\n            y=0,  # Centered light\n            z=10000  # Light from very far above to minimize shadows\n        )       \n    )\n        \n    # Use the Fibonacci sphere algorithm for more even point distribution\n    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points\n    \n    # Generate fibonacci sphere points\n    fib_points = fibonacci_sphere(samples=50)  # Originally, 50 hover points evenly distributed\n    \n    # Scale and offset the points\n    x_hover = [p[0] * radius + center_x for p in fib_points]\n    y_hover = [p[1] * radius + center_y for p in fib_points]\n    z_hover = [p[2] * radius + center_z for p in fib_points]\n        \n    # Create a list of repeated descriptions for each point\n    # This is crucial - we need exactly one text entry per point\n    hover_texts = [layer_info['description']] * len(x_hover)\n\n    # Just the name for \"Object Names Only\" mode\n    layer_name = f\"Moon: {layer_info['name']}\"\n    minimal_hover_texts = [layer_name] * len(x_hover)\n\n    # Create hover trace with direct text assignment\n    hover_trace = go.Scatter3d(\n        x=x_hover, \n        y=y_hover, \n        z=z_hover,\n        mode='markers',\n        marker=dict(\n            size=2,  # originally 5\n            color='rgb(190, 190, 180)',  # Layer color\n            opacity=1.0,  # originally 0.8\n            line=dict(  # Add a contrasting outline\n                width=1,\n                color='black'\n            )\n        ),\n        name=f\"Moon: {layer_info['name']} (Info)\",\n        text=hover_texts,  # IMPORTANT: Matching length with coordinate arrays\n        customdata=minimal_hover_texts,  # For \"Object Names Only\" mode\n        hovertemplate='%{text}<extra></extra>',  # Use the standard hover template\n        showlegend=False  # Don't show in legend since it's just for hover\n    )\n\n    return [surface_trace, hover_trace]",
    "start_line": 202,
    "end_line": 371,
    "has_docstring": true,
    "docstring": "Creates Earth's crust shell using Mesh3d for better performance with improved hover.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_moon_crust_shell",
    "component_id": "moon_visualization_shells.create_moon_crust_shell"
  },
  "moon_visualization_shells.fibonacci_sphere": {
    "id": "moon_visualization_shells.fibonacci_sphere",
    "name": "fibonacci_sphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\moon_visualization_shells.py",
    "relative_path": "moon_visualization_shells.py",
    "depends_on": [],
    "source_code": "    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points",
    "start_line": 316,
    "end_line": 331,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "samples"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fibonacci_sphere",
    "component_id": "moon_visualization_shells.fibonacci_sphere"
  },
  "moon_visualization_shells.create_moon_exosphere_shell": {
    "id": "moon_visualization_shells.create_moon_exosphere_shell",
    "name": "create_moon_exosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\moon_visualization_shells.py",
    "relative_path": "moon_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_moon_exosphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates the Moon's exosphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.06, \n        'color': 'rgb(100, 150, 255)',  # Lighter blue\n        'opacity': 0.3,\n        'name': 'Exosphere',\n        'description': (\n            \"The Moon essentially has no atmosphere in the traditional sense. Instead, it has an exosphere. It's an incredibly <br>\" \n            \"tenuous layer of gases, far less dense than a vacuum on Earth. It's so thin that gas molecules rarely collide with <br>\" \n            \"each other.<br>\" \n            \"* Sources: The exosphere is formed from gases released from the Moon\\'s interior from radioactive decay, outgassing <br>\" \n            \"  from the surface due to solar wind bombardment, and micrometeoroid impacts.<br>\" \n            \"* Composition: Primarily composed of noble gases like argon and helium, along with trace amounts of sodium, potassium, <br>\" \n            \"  hydrogen, and other elements.<br>\" \n            \"* No Weather: Due to its extreme thinness, there's no atmospheric pressure, no wind, no weather, and no significant <br>\" \n            \"  shielding from solar radiation or micrometeoroids.<br>\"  \n            \"* Practical or \\\"Dense\\\" Extent: For most practical purposes, where collisions between particles are still somewhat <br>\" \n            \"  relevant or where density is higher, the exosphere is often considered to extend up to about 100 kilometers above <br>\" \n            \"  the lunar surface. So, a more \\\"dense\\\" part of the exosphere extends from 1.0 Rm to roughly 1.06 Rm.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * MOON_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Moon: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Moon: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 385,
    "end_line": 438,
    "has_docstring": true,
    "docstring": "Creates the Moon's exosphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_moon_exosphere_shell",
    "component_id": "moon_visualization_shells.create_moon_exosphere_shell"
  },
  "moon_visualization_shells.create_moon_hill_sphere_shell": {
    "id": "moon_visualization_shells.create_moon_hill_sphere_shell",
    "name": "create_moon_hill_sphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\moon_visualization_shells.py",
    "relative_path": "moon_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_moon_hill_sphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates the Moon's Hill sphere.\"\"\"\n    # Hill sphere radius in Moonn radii\n    radius_fraction = 34.53  \n    \n    # Calculate radius in AU\n    radius_au = radius_fraction * MOON_RADIUS_AU\n    \n    # Create sphere points with fewer points for memory efficiency\n    n_points = 30  # Reduced for large spheres\n    x, y, z = create_sphere_points(radius_au, n_points=n_points)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    # Create hover text\n    hover_text = (\n            \"The Moon's Hill sphere (also known as the Roche sphere in this context) is the region around it where its own gravity <br>\" \n            \"is the dominant force attracting satellites, as opposed to the much stronger gravitational pull of the Earth. If an <br>\" \n            \"object is outside the Moon\\'s Hill sphere, it would typically end up orbiting Earth instead of the Moon.<br>\" \n            \"* The estimated radius of the Moon's Hill sphere is approximately 60,000 kilometers, approximately 34.53 lunar radii.\" \n                )\n    \n    # Create the trace\n    traces = [\n        go.Scatter3d(\n            x=x,\n            y=y,\n            z=z,\n            mode='markers',\n            marker=dict(\n                size=1.0,\n                color='rgb(0, 255, 0)',  # Green for Hill sphere\n                opacity=0.25\n            ),\n            name='Hill Sphere',\n            text=[hover_text] * len(x),\n            customdata=['Hill Sphere'] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n\n        )\n    ]\n    \n    return traces",
    "start_line": 448,
    "end_line": 495,
    "has_docstring": true,
    "docstring": "Creates the Moon's Hill sphere.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_moon_hill_sphere_shell",
    "component_id": "moon_visualization_shells.create_moon_hill_sphere_shell"
  },
  "neptune_visualization_shells.create_neptune_core_shell": {
    "id": "neptune_visualization_shells.create_neptune_core_shell",
    "name": "create_neptune_core_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\neptune_visualization_shells.py",
    "relative_path": "neptune_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_neptune_core_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Neptune's core shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.25,  # Approximately 25% of Neptune's radius\n        'color': 'rgb(255, 215, 0)',  # estimated black body color at about 5100 degC \n        'opacity': 1.0,\n        'name': 'Core',\n        'description': (\n            \"Neptune core: At Neptune's center lies a relatively small, rocky core composed primarily of iron, nickel, and silicates. <br>\" \n            \"Its mass is estimated to be about 1.2 times that of Earth. The pressure at the core is immense, reaching about 7 million <br>\" \n            \"bars (700 GPa), and the temperature could be as high as 5,100  degC.<br>\" \n            \"* While there isn't a single, precisely agreed-upon value for Neptune's core radius, estimates suggest that the rocky <br>\" \n            \"  core makes up a relatively small fraction of the planet's total radius.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * NEPTUNE_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=4.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Neptune: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Neptune: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 17,
    "end_line": 63,
    "has_docstring": true,
    "docstring": "Creates Neptune's core shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_neptune_core_shell",
    "component_id": "neptune_visualization_shells.create_neptune_core_shell"
  },
  "neptune_visualization_shells.create_neptune_mantle_shell": {
    "id": "neptune_visualization_shells.create_neptune_mantle_shell",
    "name": "create_neptune_mantle_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\neptune_visualization_shells.py",
    "relative_path": "neptune_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_neptune_mantle_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Neptune's mantle shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.85,  # Up to about 85% of neptune's radius\n        'color': 'rgb(255, 138, 18)',  # estimated black body color at about 2,000 K\n        'opacity': 0.9,\n        'name': 'mantle',\n        'description': (\n            \"mantle: Surrounding the core is a dense mantle made up of a hot, highly compressed fluid of water, methane, and ammonia. <br> \" \n            \"This layer constitutes the majority of Neptune's mass, about 10 to 15 Earth masses. The high pressure and temperature create <br>\" \n            \"an environment where these \\\"icy\\\" materials exist in exotic phases, possibly including ionic water and superionic water. <br>\" \n            \"Some theories suggest that at great depths within the mantle, methane may decompose, forming diamond crystals that could <br>\" \n            \"\\\"rain\\\" downwards.<br>\" \n            \"* The mantle makes up a significant portion of the remaining interior. Models suggest it could extend out to approximately <br>\" \n            \"  80-85% of Neptune's total radius.<br>\" \n            \"* It's important to remember that this is still an estimate based on our current understanding of Neptune's interior. <br>\" \n            \"  The transition from the dense fluid mantle to the gaseous atmosphere is likely a gradual one.<br>\" \n            \"* The temperature within Neptune's mantle is incredibly high, ranging from approximately 2,000 K (around 1,700  degC) to <br>\" \n            \"  5,000 K (around 4,700  degC). It's important to understand that Neptune's mantle isn't a solid, icy layer like the name <br>\" \n            \"  \\\"ice giant\\\" might suggest. Instead, it's a hot, dense fluid composed primarily of water, methane, and ammonia under <br>\" \n            \"  immense pressure. This high pressure actually raises the freezing point of these substances significantly. So, even at <br>\" \n            \"  these high temperatures, they can exist in a fluid or even superionic state.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * NEPTUNE_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.5,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Neptune: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Neptune: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 74,
    "end_line": 129,
    "has_docstring": true,
    "docstring": "Creates Neptune's mantle shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_neptune_mantle_shell",
    "component_id": "neptune_visualization_shells.create_neptune_mantle_shell"
  },
  "neptune_visualization_shells.create_neptune_cloud_layer_shell": {
    "id": "neptune_visualization_shells.create_neptune_cloud_layer_shell",
    "name": "create_neptune_cloud_layer_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\neptune_visualization_shells.py",
    "relative_path": "neptune_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_neptune_cloud_layer_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates neptune's cloud layer shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.0,  # the top of the troposphere is actually 1.002\n        'color': 'rgb(0, 128, 255)',  # optical\n        'opacity': 1.0,\n        'name': 'Cloud Layer',\n        'description': (\n            \"Neptune Cloud Layer<br>\" \n            \"(Note: toggle off the cloud layer in the legend to better see the interior structure.)<br><br>\"\n            \"Atmosphere: Neptune's atmosphere is primarily composed of hydrogen (around 80%) and helium (around 19%), with a small <br>\" \n            \"amount of methane (about 1.5%). It's the methane that absorbs red light and reflects blue light, giving Neptune its <br>\" \n            \"characteristic vivid blue color. The atmosphere extends to great depths, gradually merging into the fluid mantle below.<br>\" \n            \"* Cloud Layer: Within the troposphere, the lowest layer of the atmosphere, various cloud layers exist at different <br>\" \n            \"  altitudes. The highest clouds are thought to be composed of methane ice. Below that, there may be clouds of ammonia <br>\" \n            \"  and hydrogen sulfide, followed by ammonium sulfide and water ice clouds at even deeper levels. These clouds are often <br>\" \n            \"  swept around the planet by incredibly strong winds, the fastest in the Solar System, reaching up to 2,100 kilometers <br>\" \n            \"  per hour. Recent observations have shown surprising changes in Neptune's cloud cover, with a significant decrease in <br>\" \n            \"  cloudiness possibly linked to the solar cycle.<br>\" \n            \"* Based on available information, the troposphere extends to a pressure level of about 0.1 bar (10 kPa). The altitude <br>\" \n            \"  at which this pressure occurs is estimated to be around 50 to 80 kilometers above the 1-bar pressure level (which is <br>\" \n            \"  often considered the \\\"surface\\\" of gas giants). Therefore, the radius fraction at the top of Neptune's troposphere <br>\" \n            \"  is approximately 1.002 to 1.003 of Neptune's total radius (using the equatorial radius). In essence, when we talk <br>\" \n            \"  about the planet's radius, it's a defined level within its atmosphere. The troposphere extends a bit further out.<br>\" \n            \"* The predominant visual color of Neptune is a distinct blue. This is primarily due to the absorption of red and infrared <br>\" \n            \"  light by methane in its atmosphere. While the exact shade can vary slightly depending on viewing conditions and image <br>\" \n            \"  processing, a representative RGB value for Neptune's blue could be approximately: R: 0-63, G: 119-159, B: 135-253\"\n            )\n    }\n    \n    # Calculate radius in AU\n    radius = layer_info['radius_fraction'] * NEPTUNE_RADIUS_AU\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Create mesh with reasonable resolution for performance\n    resolution = 24  # Reduced from typical 50 for markers\n    \n    # Create a UV sphere\n    phi = np.linspace(0, 2*np.pi, resolution)\n    theta = np.linspace(-np.pi/2, np.pi/2, resolution)\n    phi, theta = np.meshgrid(phi, theta)\n    \n    x = radius * np.cos(theta) * np.cos(phi)\n    y = radius * np.cos(theta) * np.sin(phi)\n    z = radius * np.sin(theta)\n    \n    # Apply center position offset\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    # Create triangulation\n    indices = []\n    for i in range(resolution-1):\n        for j in range(resolution-1):\n            p1 = i * resolution + j\n            p2 = i * resolution + (j + 1)\n            p3 = (i + 1) * resolution + j\n            p4 = (i + 1) * resolution + (j + 1)\n            \n            indices.append([p1, p2, p4])\n            indices.append([p1, p4, p3])\n    \n    # Create main surface\n    surface_trace = go.Mesh3d(\n        x=x.flatten(), \n        y=y.flatten(), \n        z=z.flatten(),\n        i=[idx[0] for idx in indices],\n        j=[idx[1] for idx in indices],\n        k=[idx[2] for idx in indices],\n        color=layer_info['color'],\n        opacity=layer_info['opacity'],\n        name=f\"Neptune: {layer_info['name']}\",\n        showlegend=True,\n        hoverinfo='none',  # Disable hover on mesh surface\n        # Add these new parameters to make hover text invisible\n        hovertemplate=' ',  # Empty template instead of None\n        hoverlabel=dict(\n    #        bgcolor='rgba(0,0,0,0)',  # Transparent background\n            font=dict(\n                color='rgba(0,0,0,0)',  # Transparent text\n    #            size=0                  # Zero font size\n            ),\n            bordercolor='rgba(0,0,0,0)'  # Transparent border\n        ), \n        # Add these new parameters to eliminate shading\n        flatshading=True,  # Use flat shading instead of smooth\n        lighting=dict(\n            ambient=1.0,     # Set to maximum (1.0)\n            diffuse=0.0,     # Turn off diffuse lighting\n            specular=0.0,    # Turn off specular highlights\n            roughness=1.0,   # Maximum roughness\n            fresnel=0.0      # Turn off fresnel effect\n        ),\n        lightposition=dict(\n            x=0,  # Centered light\n            y=0,  # Centered light\n            z=10000  # Light from very far above to minimize shadows\n        )       \n    )\n        \n    # Use the Fibonacci sphere algorithm for more even point distribution\n    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points\n    \n    # Generate fibonacci sphere points\n    fib_points = fibonacci_sphere(samples=50)  # Originally, 50 hover points evenly distributed\n    \n    # Scale and offset the points\n    x_hover = [p[0] * radius + center_x for p in fib_points]\n    y_hover = [p[1] * radius + center_y for p in fib_points]\n    z_hover = [p[2] * radius + center_z for p in fib_points]\n        \n    # Create a list of repeated descriptions for each point\n    # This is crucial - we need exactly one text entry per point\n    hover_texts = [layer_info['description']] * len(x_hover)\n\n    # Just the name for \"Object Names Only\" mode\n    layer_name = f\"Neptune: {layer_info['name']}\"\n    minimal_hover_texts = [layer_name] * len(x_hover)\n\n    # Create hover trace with direct text assignment\n    hover_trace = go.Scatter3d(\n        x=x_hover, \n        y=y_hover, \n        z=z_hover,\n        mode='markers',\n        marker=dict(\n            size=2,  # originally 5\n            color='rgb(0, 128, 255)',  # Layer color, originally 'white'\n            opacity=1.0,  # originally 0.8\n            line=dict(  # Add a contrasting outline\n                width=1,\n                color='black'\n            )\n        ),\n        name=f\"Neptune: {layer_info['name']} (Info)\",\n        text=hover_texts,  # IMPORTANT: Matching length with coordinate arrays\n        customdata=minimal_hover_texts,  # For \"Object Names Only\" mode\n        hovertemplate='%{text}<extra></extra>',  # Use the standard hover template\n        showlegend=False  # Don't show in legend since it's just for hover\n    )\n\n    return [surface_trace, hover_trace]",
    "start_line": 145,
    "end_line": 306,
    "has_docstring": true,
    "docstring": "Creates neptune's cloud layer shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_neptune_cloud_layer_shell",
    "component_id": "neptune_visualization_shells.create_neptune_cloud_layer_shell"
  },
  "neptune_visualization_shells.fibonacci_sphere": {
    "id": "neptune_visualization_shells.fibonacci_sphere",
    "name": "fibonacci_sphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\neptune_visualization_shells.py",
    "relative_path": "neptune_visualization_shells.py",
    "depends_on": [],
    "source_code": "    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points",
    "start_line": 251,
    "end_line": 266,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "samples"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fibonacci_sphere",
    "component_id": "neptune_visualization_shells.fibonacci_sphere"
  },
  "neptune_visualization_shells.create_neptune_upper_atmosphere_shell": {
    "id": "neptune_visualization_shells.create_neptune_upper_atmosphere_shell",
    "name": "create_neptune_upper_atmosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\neptune_visualization_shells.py",
    "relative_path": "neptune_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_neptune_upper_atmosphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Neptune's upper atmosphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.01,  # more like 1.008 and very approximate.\n        'color': 'rgb(240, 245, 250)',  # optical pale blue\n        'opacity': 0.5,\n        'name': 'Upper Atmosphere',\n        'description': (\n            \"Upper Atmosphere: Above the troposphere lies the stratosphere, where temperature increases with altitude. Higher still <br>\" \n            \"is the thermosphere, characterized by lower pressures. The outermost layer is the exosphere, which gradually fades into space.<br>\" \n            \"* No Solid Surface: Neptune is a gas giant, so its \\\"radius\\\" is defined at a specific pressure level (usually the 1-bar <br>\" \n            \"  level). The atmosphere extends far beyond this.<br>\" \n            \"* Gradual Transition: The thermosphere doesn't have a sharp upper boundary; it gradually fades into the exosphere. The <br>\" \n            \"  altitude where one ends and the other begins (the thermopause) varies.<br>\" \n            \"* Dynamic Conditions: The thermosphere's extent is influenced by solar activity and Neptune's magnetic field, causing it to <br>\" \n            \"  expand and contract.<br>\" \n            \"* Temperature: The upper atmospheres of Uranus and Neptune are known to be inexplicably hot, suggesting significant <br>\" \n            \"  energy input that could lead to a more extended thermosphere than expected based solely on solar heating.<br>\" \n            \"* Estimated Height: The thermosphere on Neptune likely extends a significant distance above the 1-bar radius.<br>\" \n            \"  * The thermosphere begins at pressures below 10^-^5 to 10^-^4 bars (1 to 10 Pa).<br>\" \n            \"  * Barometric Formula: We'll use a simplified version of the barometric formula, which relates pressure and altitude in <br>\" \n            \"    an atmosphere.<br>\" \n            \"    * The pressure at a certain altitude in an atmosphere is equal to the pressure at a reference altitude multiplied <br>\" \n            \"      by the natural exponential function raised to the power of the negative of the altitude difference divided by the <br>\" \n            \"      atmospheric scale height.<br>\" \n            \"    * This exponential relationship is fundamental to how pressure changes with altitude in an atmosphere.<br>\" \n            \"    * The negative sign indicates that pressure generally decreases as altitude increases.<br>\" \n            \"    * The atmospheric scale height is a characteristic distance for a particular atmosphere. It's the vertical distance <br>\" \n            \"      over which the pressure decreases by a factor of 'e'. It depends on the gravity and temperature of the atmosphere.<br>\" \n            \"  * The pressure level of 5 Pa is estimated to be at a radius fraction of approximately 1.008 of Neptune's radius (1-bar).<br>\" \n            \"  * The pressure level of 1 Pa is estimated to be at a radius fraction of approximately 1.0091 of Neptune's radius. This <br>\" \n            \"    is an estimate using a simplified model. At these very low pressures, the actual temperature profile and thus the scale <br>\" \n            \"    height can deviate from the average value used, potentially affecting the accuracy of this calculation.<br>\" \n            \"  * Isothermal Assumption: The simple barometric formula assumes a constant temperature with altitude, which is not entirely <br>\" \n            \"    accurate for Neptune's atmosphere, especially across different layers. However, it provides a reasonable approximation.<br>\" \n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * NEPTUNE_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Neptune: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Neptune: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=layer_radius\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 314,
    "end_line": 389,
    "has_docstring": true,
    "docstring": "Creates Neptune's upper atmosphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_neptune_upper_atmosphere_shell",
    "component_id": "neptune_visualization_shells.create_neptune_upper_atmosphere_shell"
  },
  "neptune_visualization_shells.create_neptune_magnetosphere": {
    "id": "neptune_visualization_shells.create_neptune_magnetosphere",
    "name": "create_neptune_magnetosphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\neptune_visualization_shells.py",
    "relative_path": "neptune_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_magnetosphere_shape",
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.rotate_points",
      "neptune_visualization_shells.create_neptune_magnetic_poles"
    ],
    "source_code": "def create_neptune_magnetosphere(center_position=(0, 0, 0)):\n    \"\"\"Creates Neptune's main magnetosphere structure with proper tilt and offset.\"\"\"\n    import numpy as np\n    import plotly.graph_objs as go\n    from planet_visualization_utilities import NEPTUNE_RADIUS_AU, create_magnetosphere_shape, rotate_points\n    \n    # Parameters for magnetosphere components (in Neptune radii)\n    params = {\n        # Compressed sunward side - Neptune's bow shock standoff distance\n        'sunward_distance': 34,  # Based on Voyager 2 data, ~34 Neptune radii\n        \n        # Equatorial extension (wider than polar)\n        'equatorial_radius': 40,  # Typical equatorial extension\n        'polar_radius': 25,       # Polar extension is smaller\n        \n        # Magnetotail parameters\n        'tail_length': 600,       # Neptune's tail extends far downstream\n        'tail_base_radius': 60,   # Radius at the base of the tail, based on modeling\n        'tail_end_radius': 120,   # Radius at the end of the tail, based on modeling\n    }\n    \n    # Scale everything by Neptune's radius in AU\n    for key in params:\n        params[key] *= NEPTUNE_RADIUS_AU\n    \n    # Create magnetosphere main shape\n    x, y, z = create_magnetosphere_shape(params)\n    \n    # Convert to numpy arrays for efficient rotation\n    x = np.array(x)\n    y = np.array(y)\n    z = np.array(z)\n    \n    # Apply Neptune's magnetic field offset (0.55 Neptune radii, mostly northward)\n    # The offset is applied before rotation to properly represent the field\n    offset_distance = 0.55 * NEPTUNE_RADIUS_AU\n    \n    # Apply the offset primarily in the z-direction (northward)\n    # with small components in x and y to match observations\n    z = z + (0.5 * offset_distance)  # Major component of offset in z\n    x = x + (0.2 * offset_distance)  # Minor component in x\n    y = y + (0.1 * offset_distance)  # Minor component in y\n    \n    # Identify internal vs external magnetosphere regions\n    bow_shock_mask = x < 0\n    tail_mask = x > params['tail_length'] * 0.4  # Far tail\n    internal_mask = ~(bow_shock_mask | tail_mask)\n    \n    # Store regions separately\n    bow_shock_x = x[bow_shock_mask]\n    bow_shock_y = y[bow_shock_mask]\n    bow_shock_z = z[bow_shock_mask]\n    \n    tail_x = x[tail_mask]\n    tail_y = y[tail_mask]\n    tail_z = z[tail_mask]\n    \n    internal_x = x[internal_mask]\n    internal_y = y[internal_mask]\n    internal_z = z[internal_mask]\n    \n    # Apply Neptune's magnetic field rotations to internal magnetosphere only\n    # First, tilt around the y-axis to implement the main magnetic axis tilt\n    magnetic_tilt = np.radians(47)\n    int_x1, int_y1, int_z1 = rotate_points(internal_x, internal_y, internal_z, magnetic_tilt, 'y')\n    \n    # Second rotation to match the observed orientation (around z-axis)\n    azimuthal_angle = np.radians(60)  # Estimated angle based on Voyager data\n    int_x2, int_y2, int_z2 = rotate_points(int_x1, int_y1, int_z1, azimuthal_angle, 'z')\n    \n    # For the tail region, apply a partial rotation to create a smooth transition\n    tail_fraction = 0.3  # Partial effect of Neptune's field on tail\n    tail_x1, tail_y1, tail_z1 = rotate_points(tail_x, tail_y, tail_z, magnetic_tilt * tail_fraction, 'y')\n    tail_x2, tail_y2, tail_z2 = rotate_points(tail_x1, tail_y1, tail_z1, azimuthal_angle * tail_fraction, 'z')\n    \n    # Recombine the components\n    x_final = np.concatenate([bow_shock_x, int_x2, tail_x2])\n    y_final = np.concatenate([bow_shock_y, int_y2, tail_y2])\n    z_final = np.concatenate([bow_shock_z, int_z2, tail_z2])\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Apply center position offset to final coordinates\n    x_final = x_final + center_x\n    y_final = y_final + center_y\n    z_final = z_final + center_z\n    \n    # Detailed description for hover information with explicit sun direction note\n    magnetosphere_text = [\n        \"Neptune's Magnetosphere: Unlike other planets, Neptune's magnetic field is dramatically tilted (47 deg from its rotation axis) and <br>\"\n        \"significantly offset from the planet's center by more than half a Neptune radius. This creates an extremely asymmetric magnetosphere <br>\"\n        \"that varies greatly depending on Neptune's rotation.<br><br>\"\n        \"In this scientifically accurate model:<br>\"\n        \"- The bow shock faces the Sun (negative X-axis) as it would in reality, shaped by the solar wind<br>\"\n        \"- The internal magnetosphere shows Neptune's unique magnetic field configuration with its 47 deg tilt and offset<br>\"\n        \"- The magnetotail stretches away from the Sun but is influenced by Neptune's unusual field<br><br>\"\n        \"This unusual magnetic environment was discovered by Voyager 2 during its 1989 flyby and makes Neptune's magnetosphere <br>\"\n        \"one of the most complex and dynamic in our solar system.\"\n    ] * len(x_final)\n    \n    magnetosphere_customdata = ['Neptune: Magnetosphere'] * len(x_final)\n    \n    # Create main magnetosphere trace\n    traces = [\n        go.Scatter3d(\n            x=x_final, y=y_final, z=z_final,\n            mode='markers',\n            marker=dict(\n                size=2.0,\n                color='rgb(30, 136, 229)',  # More appropriate blue for Neptune\n                opacity=0.3\n            ),\n            name='Neptune: Magnetosphere',\n            text=magnetosphere_text,\n            customdata=magnetosphere_customdata,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=600 * NEPTUNE_RADIUS_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n    \n    # Add magnetic poles and axis visualization - with error handling\n    try:\n        mag_poles_traces = create_neptune_magnetic_poles(center_position, offset_distance, magnetic_tilt, azimuthal_angle)\n        if mag_poles_traces and len(mag_poles_traces) > 0:\n            for trace in mag_poles_traces:\n                traces.append(trace)\n        else:\n            print(\"Warning: create_neptune_magnetic_poles returned empty traces\")\n    except Exception as e:\n        print(f\"Error in magnetic poles visualization: {e}\")\n        # Create a simple fallback trace for the magnetic center\n        fallback_trace = go.Scatter3d(\n            x=[center_x + 0.2 * offset_distance],\n            y=[center_y + 0.1 * offset_distance],\n            z=[center_z + 0.5 * offset_distance],\n            mode='markers',\n            marker=dict(\n                size=10,\n                color='yellow',\n                symbol='diamond'\n            ),\n            name='Neptune: Magnetic Field Center (fallback)',\n            showlegend=True\n        )\n        traces.append(fallback_trace)\n   \n    return traces",
    "start_line": 402,
    "end_line": 556,
    "has_docstring": true,
    "docstring": "Creates Neptune's main magnetosphere structure with proper tilt and offset.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_neptune_magnetosphere",
    "component_id": "neptune_visualization_shells.create_neptune_magnetosphere"
  },
  "neptune_visualization_shells.create_neptune_magnetic_poles": {
    "id": "neptune_visualization_shells.create_neptune_magnetic_poles",
    "name": "create_neptune_magnetic_poles",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\neptune_visualization_shells.py",
    "relative_path": "neptune_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.rotate_points"
    ],
    "source_code": "def create_neptune_magnetic_poles(center_position, offset_distance, tilt, azimuth):\n    \"\"\"Creates a simplified visualization of Neptune's magnetic poles and axis.\"\"\"\n    import numpy as np\n    \n    center_x, center_y, center_z = center_position\n    \n    # Start with offset magnetic center\n    mag_center_x = center_x + (0.2 * offset_distance)\n    mag_center_y = center_y + (0.1 * offset_distance)\n    mag_center_z = center_z + (0.5 * offset_distance)\n    \n    # Create axis points (north and south poles at 20 Neptune radii from magnetic center for better visibility)\n    axis_length = 20 * NEPTUNE_RADIUS_AU\n    \n    # Initial axis points along z-axis - already as numpy arrays for rotate_points\n    north_x = np.array([0])\n    north_y = np.array([0])\n    north_z = np.array([axis_length])\n    \n    south_x = np.array([0])\n    south_y = np.array([0])\n    south_z = np.array([-axis_length])\n    \n    # Apply tilts to match Neptune's magnetic field orientation\n    # First y-axis tilt\n    north_x, north_y, north_z = rotate_points(north_x, north_y, north_z, tilt, 'y')\n    south_x, south_y, south_z = rotate_points(south_x, south_y, south_z, tilt, 'y')\n    \n    # Then z-axis rotation\n    north_x, north_y, north_z = rotate_points(north_x, north_y, north_z, azimuth, 'z')\n    south_x, south_y, south_z = rotate_points(south_x, south_y, south_z, azimuth, 'z')\n    \n    # Add to magnetic center offset (keeping as arrays)\n    north_x = north_x[0] + mag_center_x  # Extract the single value from the array\n    north_y = north_y[0] + mag_center_y\n    north_z = north_z[0] + mag_center_z\n    \n    south_x = south_x[0] + mag_center_x\n    south_y = south_y[0] + mag_center_y\n    south_z = south_z[0] + mag_center_z\n    \n    traces = []\n    \n    # Create magnetic center marker\n    mag_center_trace = go.Scatter3d(\n        x=[mag_center_x],\n        y=[mag_center_y],\n        z=[mag_center_z],\n        mode='markers',\n        marker=dict(\n            size=8,  # Larger for visibility\n            color='yellow',\n            symbol='diamond'\n        ),\n        name='Neptune: Magnetic Field Center',\n        text=[\"Neptune's magnetic field center is offset by ~0.55 Neptune radii from the planet's center<br>\"\n              \"Neptune has one of the most unusual magnetic fields in our solar system. Unlike Earth, where the magnetic field is <br>\" \n              \"roughly aligned with the rotation axis, Neptune's magnetic field is:<br>\" \n              \"* Tilted by approximately 47 degrees relative to its rotation axis.<br>\" \n              \"* Significantly offset from the planet's center by about 0.55 Neptune radii.<br>\" \n              \"This creates the seemingly contradictory visualization you're seeing, where:<br>\" \n              \"* The magnetosphere's bow shock and tail are oriented relative to the solar wind (with the bow shock facing the Sun <br>\" \n              \"  direction)<br>\" \n              \"* The magnetic axis (yellow dashed line) and poles (blue and red markers) appear misaligned with this overall <br>\" \n              \"  magnetosphere structure.<br>\" \n              \"* This unusual configuration creates a highly dynamic and complex magnetosphere that varies dramatically as Neptune <br>\" \n              \"  rotates. The magnetic field's significant tilt and offset cause it to \\\"wobble\\\" in space during Neptune's rotation, <br>\" \n              \"  creating unique interactions with the solar wind.<br>\" \n              \"* What you're seeing is scientifically accurate - Neptune's magnetic field is genuinely this unusual and asymmetric! <br>\" \n              \"  This configuration was discovered by Voyager 2 during its 1989 flyby and remains one of Neptune's most intriguing characteristics.\"],\n        hovertemplate='%{text}<extra></extra>',\n        showlegend=True\n    )\n    traces.append(mag_center_trace)\n    \n    # Create magnetic axis line\n    axis_trace = go.Scatter3d(\n        x=[north_x, mag_center_x, south_x],\n        y=[north_y, mag_center_y, south_y],\n        z=[north_z, mag_center_z, south_z],\n        mode='lines',\n        line=dict(\n            color='yellow',\n            width=6,  # Thicker for visibility\n            dash='dash'\n        ),\n        name='Neptune: Magnetic Axis',\n        text=[\"Neptune's magnetic axis is tilted 47 deg from its rotation axis\"] * 3,\n        hovertemplate='%{text}<extra></extra>',\n        showlegend=True\n    )\n    traces.append(axis_trace)\n    \n    # Create north magnetic pole marker\n    north_pole_trace = go.Scatter3d(\n        x=[north_x],\n        y=[north_y],\n        z=[north_z],\n        mode='markers',\n        marker=dict(\n            size=10,  # Larger for visibility\n            color='blue',\n            symbol='circle'\n        ),\n        name='Neptune: North Magnetic Pole',\n        text=[\"Neptune's north magnetic pole\"],\n        hovertemplate='%{text}<extra></extra>',\n        showlegend=True\n    )\n    traces.append(north_pole_trace)\n    \n    # Create south magnetic pole marker\n    south_pole_trace = go.Scatter3d(\n        x=[south_x],\n        y=[south_y],\n        z=[south_z],\n        mode='markers',\n        marker=dict(\n            size=10,  # Larger for visibility\n            color='red', \n            symbol='circle'\n        ),\n        name='Neptune: South Magnetic Pole',\n        text=[\"Neptune's south magnetic pole\"],\n        hovertemplate='%{text}<extra></extra>',\n        showlegend=True\n    )\n    traces.append(south_pole_trace)\n    \n    # Add debug prints to track the return value\n    print(f\"Returning {len(traces)} magnetic field traces\")\n    return traces",
    "start_line": 558,
    "end_line": 689,
    "has_docstring": true,
    "docstring": "Creates a simplified visualization of Neptune's magnetic poles and axis.",
    "parameters": [
      "center_position",
      "offset_distance",
      "tilt",
      "azimuth"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_neptune_magnetic_poles",
    "component_id": "neptune_visualization_shells.create_neptune_magnetic_poles"
  },
  "neptune_visualization_shells.create_neptune_field_lines": {
    "id": "neptune_visualization_shells.create_neptune_field_lines",
    "name": "create_neptune_field_lines",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\neptune_visualization_shells.py",
    "relative_path": "neptune_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_neptune_field_lines(mag_center_x, mag_center_y, mag_center_z, \n                            north_x, north_y, north_z, \n                            south_x, south_y, south_z,\n                            neptune_radius, tilt, azimuth):\n    \"\"\"Creates a simple visualization of Neptune's magnetic field lines.\"\"\"\n    \n    traces = []\n    \n    # Number of field lines to create\n    n_lines = 8\n    n_points = 40  # Points along each field line\n    \n    # Create field lines radiating from the poles\n    for i in range(n_lines):\n        angle = (i / n_lines) * 2 * np.pi\n        \n        # North pole field lines\n        north_lines_x = []\n        north_lines_y = []\n        north_lines_z = []\n        \n        # South pole field lines\n        south_lines_x = []\n        south_lines_y = []\n        south_lines_z = []\n        \n        # Create curved field lines from each pole\n        for j in range(n_points):\n            # Parameter from 0 to 1\n            t = j / (n_points - 1)\n            \n            # For north pole: lines start at pole and curve toward equatorial plane\n            radius_n = 5 * neptune_radius * t  # Distance from pole\n            curve_factor_n = np.sin(np.pi * t)  # Curvature\n            \n            # For south pole: lines start at pole and curve toward equatorial plane\n            radius_s = 5 * neptune_radius * t  # Distance from pole\n            curve_factor_s = np.sin(np.pi * t)  # Curvature\n            \n            # Calculate positions with curvature\n            # North pole lines\n            n_x = north_x - radius_n * (0.5 + 0.5 * curve_factor_n * np.cos(angle))\n            n_y = north_y + radius_n * (curve_factor_n * np.sin(angle))\n            n_z = north_z - radius_n * (0.7 * curve_factor_n)\n            \n            # South pole lines\n            s_x = south_x + radius_s * (0.5 + 0.5 * curve_factor_s * np.cos(angle + np.pi/n_lines))\n            s_y = south_y + radius_s * (curve_factor_s * np.sin(angle + np.pi/n_lines))\n            s_z = south_z + radius_s * (0.7 * curve_factor_s)\n            \n            north_lines_x.append(n_x)\n            north_lines_y.append(n_y)\n            north_lines_z.append(n_z)\n            \n            south_lines_x.append(s_x)\n            south_lines_y.append(s_y)\n            south_lines_z.append(s_z)\n        \n        # Create traces for these field lines\n        north_line_trace = go.Scatter3d(\n            x=north_lines_x,\n            y=north_lines_y,\n            z=north_lines_z,\n            mode='lines',\n            line=dict(\n                color='rgba(100, 150, 255, 0.4)',\n                width=2\n            ),\n            name='Neptune: Magnetic Field Line',\n            showlegend=False,\n            hoverinfo='none'\n        )\n        \n        south_line_trace = go.Scatter3d(\n            x=south_lines_x,\n            y=south_lines_y,\n            z=south_lines_z,\n            mode='lines',\n            line=dict(\n                color='rgba(255, 100, 100, 0.4)',\n                width=2\n            ),\n            name='Neptune: Magnetic Field Line',\n            showlegend=False,\n            hoverinfo='none'\n        )\n        \n        traces.append(north_line_trace)\n        traces.append(south_line_trace)\n        \n    return traces",
    "start_line": 692,
    "end_line": 782,
    "has_docstring": true,
    "docstring": "Creates a simple visualization of Neptune's magnetic field lines.",
    "parameters": [
      "mag_center_x",
      "mag_center_y",
      "mag_center_z",
      "north_x",
      "north_y",
      "north_z",
      "south_x",
      "south_y",
      "south_z",
      "neptune_radius",
      "tilt",
      "azimuth"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_neptune_field_lines",
    "component_id": "neptune_visualization_shells.create_neptune_field_lines"
  },
  "neptune_visualization_shells.create_neptune_radiation_belts": {
    "id": "neptune_visualization_shells.create_neptune_radiation_belts",
    "name": "create_neptune_radiation_belts",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\neptune_visualization_shells.py",
    "relative_path": "neptune_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "neptune_visualization_shells.create_field_aligned_currents",
      "planet_visualization_utilities.rotate_points"
    ],
    "source_code": "def create_neptune_radiation_belts(center_position=(0, 0, 0)):\n    \"\"\"Creates Neptune's radiation belts with proper structure reflecting the complex magnetospheric environment.\"\"\"\n    # Belt names and descriptions based on current understanding\n    belt_regions = [\n        {\n            'name': 'Proton-Rich Inner Belt',\n            'distance': 1.8,  # Neptune radii from magnetic center\n            'thickness': 0.5,  # Relative thickness\n            'color': 'rgb(80, 180, 255)',  \n            'opacity': 0.4,\n            'description': \"Neptune's innermost radiation belt is dominated by protons. Located approximately 1.2-2.5 Neptune <br>\"\n                          \"radii from the center, it's influenced by Neptune's offset and tilted magnetic field. This region <br>\"\n                          \"shows significant day/night asymmetry as Neptune rotates.<br><br>\" \n                          \"This implementation includes four distinct radiation regions: a proton-rich inner belt; a primary <br>\" \n                          \"electron belt; an outer plasma sheet region; a cusp region where solar wind particles directly enter.<br>\" \n                          \"* Adds field-aligned currents that represent important features in Neptune's magnetosphere, showing how <br>\" \n                          \"  charged particles flow along magnetic field lines.<br>\" \n                          \"* Creates more accurate geometric structures that reflect Neptune's complex magnetic environment: asymmetric <br>\" \n                          \"  shapes that account for the unusual magnetic field.<br>\" \n                          \"* Magnetotail stretching for the outer plasma sheet.<br>\" \n                          \"* Funnel-shaped polar cusps.<br>\" \n                          \"* Maintaining proper magnetic field geometry: 47 deg tilt from the rotation axis; 0.55 Neptune radii offset <br>\" \n                          \"  from the planet's center.<br>\" \n                          \"* Given the scarcity of direct measurements, this represents our best current understanding based on Voyager 2 <br>\" \n                          \"  data and subsequent scientific analysis.\"\n        },\n        {\n            'name': 'Primary Electron Belt',\n            'distance': 3.5,  # Neptune radii from magnetic center\n            'thickness': 0.6,  # Relative thickness\n            'color': 'rgb(120, 150, 230)',  \n            'opacity': 0.35,\n            'description': \"Neptune's middle radiation region contains high-energy electrons. This belt shows notable <br>\"\n                          \"variations in intensity with longitude due to Neptune's unusual magnetic field geometry. <br>\"\n                          \"The trapped electron fluxes here are surprisingly intense, comparable to Earth's electron belts.<br><br>\"\n                          \"This implementation includes four distinct radiation regions: a proton-rich inner belt; a primary <br>\" \n                          \"electron belt; an outer plasma sheet region; a cusp region where solar wind particles directly enter.<br>\" \n                          \"* Adds field-aligned currents that represent important features in Neptune's magnetosphere, showing how <br>\" \n                          \"  charged particles flow along magnetic field lines.<br>\" \n                          \"* Creates more accurate geometric structures that reflect Neptune's complex magnetic environment: asymmetric <br>\" \n                          \"  shapes that account for the unusual magnetic field.<br>\" \n                          \"* Magnetotail stretching for the outer plasma sheet.<br>\" \n                          \"* Funnel-shaped polar cusps.<br>\" \n                          \"* Maintaining proper magnetic field geometry: 47 deg tilt from the rotation axis; 0.55 Neptune radii offset <br>\" \n                          \"  from the planet's center.<br>\" \n                          \"* Given the scarcity of direct measurements, this represents our best current understanding based on Voyager 2 <br>\" \n                          \"  data and subsequent scientific analysis.\"                          \n        },\n        {\n            'name': 'Outer Plasma Sheet',\n            'distance': 6.0,  # Neptune radii from magnetic center\n            'thickness': 0.8,  # Relative thickness\n            'color': 'rgb(150, 130, 210)',  \n            'opacity': 0.3,\n            'description': \"This transition region between the trapped radiation and the magnetotail contains a mix of charged <br>\"\n                          \"particles. Its structure is highly dynamic and asymmetric, with its shape constantly changing as <br>\"\n                          \"Neptune rotates and the solar wind conditions vary.<br><br>\"\n                          \"This implementation includes four distinct radiation regions: a proton-rich inner belt; a primary <br>\" \n                          \"electron belt; an outer plasma sheet region; a cusp region where solar wind particles directly enter.<br>\" \n                          \"* Adds field-aligned currents that represent important features in Neptune's magnetosphere, showing how <br>\" \n                          \"  charged particles flow along magnetic field lines.<br>\" \n                          \"* Creates more accurate geometric structures that reflect Neptune's complex magnetic environment: asymmetric <br>\" \n                          \"  shapes that account for the unusual magnetic field.<br>\" \n                          \"* Magnetotail stretching for the outer plasma sheet.<br>\" \n                          \"* Funnel-shaped polar cusps.<br>\" \n                          \"* Maintaining proper magnetic field geometry: 47 deg tilt from the rotation axis; 0.55 Neptune radii offset <br>\" \n                          \"  from the planet's center.<br>\" \n                          \"* Given the scarcity of direct measurements, this represents our best current understanding based on Voyager 2 <br>\" \n                          \"  data and subsequent scientific analysis.\"\n        },\n        {\n            'name': 'Cusp Region',\n            'distance': 4.2,  # Neptune radii from magnetic center\n            'thickness': 0.4,  # Relative thickness\n            'color': 'rgb(200, 150, 180)',  \n            'opacity': 0.25,\n            'variable_offset': True,  # Special handling for cusp region\n            'description': \"The polar cusps represent funnel-shaped openings where solar wind particles can directly access <br>\"\n                          \"Neptune's magnetosphere. Due to Neptune's tilted magnetic field, these regions demonstrate complex <br>\"\n                          \"behavior and vary dramatically with the planet's rotation.<br><br>\"\n                          \"This implementation includes four distinct radiation regions: a proton-rich inner belt; a primary <br>\" \n                          \"electron belt; an outer plasma sheet region; a cusp region where solar wind particles directly enter.<br>\" \n                          \"* Adds field-aligned currents that represent important features in Neptune's magnetosphere, showing how <br>\" \n                          \"  charged particles flow along magnetic field lines.<br>\" \n                          \"* Creates more accurate geometric structures that reflect Neptune's complex magnetic environment: asymmetric <br>\" \n                          \"  shapes that account for the unusual magnetic field.<br>\" \n                          \"* Magnetotail stretching for the outer plasma sheet.<br>\" \n                          \"* Funnel-shaped polar cusps.<br>\" \n                          \"* Maintaining proper magnetic field geometry: 47 deg tilt from the rotation axis; 0.55 Neptune radii offset <br>\" \n                          \"  from the planet's center.<br>\" \n                          \"* Given the scarcity of direct measurements, this represents our best current understanding based on Voyager 2 <br>\" \n                          \"  data and subsequent scientific analysis.\"\n        }\n    ]\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Apply magnetic field offset (about 0.55 Neptune radii, offset from center)\n    offset_distance = 0.55 * NEPTUNE_RADIUS_AU\n    magnetic_center_x = center_x + (0.2 * offset_distance)\n    magnetic_center_y = center_y + (0.1 * offset_distance)\n    magnetic_center_z = center_z + (0.5 * offset_distance)\n    \n    # Neptune's magnetic axis tilt in radians (47 degrees from rotation axis)\n    magnetic_tilt = np.radians(47)\n    \n    # Additional rotation to match the observed orientation\n    azimuthal_angle = np.radians(60)  # Based on Voyager data\n    \n    traces = []\n    \n    for belt in belt_regions:\n        belt_x = []\n        belt_y = []\n        belt_z = []\n        \n        n_points = 90  # More points for smoother appearance\n        n_rings = 6    # More rings for better volume representation\n        \n        # Scale distances by Neptune's radius in AU\n        belt_distance = belt['distance'] * NEPTUNE_RADIUS_AU\n        belt_thickness = belt['thickness'] * NEPTUNE_RADIUS_AU\n        \n        for i_ring in range(n_rings):\n            # Vary the radius slightly to create thickness\n            radius_offset = (i_ring / (n_rings-1) - 0.5) * belt_thickness\n            ring_radius = belt_distance + radius_offset\n            \n            for j in range(n_points):\n                angle = (j / n_points) * 2 * np.pi\n                \n                # Create a belt around magnetic field axis\n                x = ring_radius * np.cos(angle)\n                y = ring_radius * np.sin(angle)\n                \n                # For the cusp region, create a more funnel-like shape\n                if belt.get('variable_offset', False):\n                    # Create funnel-like shape pointing in the magnetic field direction\n                    z_scale = 0.4 * ring_radius * (1 + 0.5 * np.cos(angle))\n                    z = z_scale * np.sin(angle)\n                    \n                    # Add distortion to create cusp-like features\n                    if np.abs(np.sin(angle)) > 0.7:\n                        z = z * 1.5\n                else:\n                    # For regular belts, add variation to create a more realistic shape\n                    z_scale = 0.2 * ring_radius\n                    z = z_scale * np.sin(2 * angle)\n                    \n                    # Add some longitudinal variation to reflect Neptune's complex field\n                    variation = 0.15 * ring_radius * np.sin(3 * angle)\n                    x += variation * np.cos(angle + np.pi/4)\n                    y += variation * np.sin(angle + np.pi/4)\n                \n                belt_x.append(x)\n                belt_y.append(y)\n                belt_z.append(z)\n        \n        # Convert to numpy arrays for efficient rotation\n        belt_x = np.array(belt_x)\n        belt_y = np.array(belt_y)\n        belt_z = np.array(belt_z)\n        \n        # First apply rotation around y-axis for magnetic tilt\n        x_rotated1, y_rotated1, z_rotated1 = rotate_points(belt_x, belt_y, belt_z, magnetic_tilt, 'y')\n        \n        # Then apply rotation around z-axis for azimuthal orientation\n        x_rotated2, y_rotated2, z_rotated2 = rotate_points(x_rotated1, y_rotated1, z_rotated1, azimuthal_angle, 'z')\n        \n        # Apply additional distortions for more complex shapes\n        # For outer plasma sheet, create magnetotail-like extension\n        if belt['name'] == 'Outer Plasma Sheet':\n            # Apply a gradient to simulate magnetotail stretching\n            stretch_factor = 1.0 + 0.8 * np.clip(-x_rotated2/belt_distance, 0, 1.5)\n            x_rotated2 = x_rotated2 * stretch_factor\n            \n            # Add some flaring to the tail\n            tail_factor = np.clip(-x_rotated2/belt_distance, 0, 1)\n            y_rotated2 = y_rotated2 * (1 + 0.3 * tail_factor)\n            z_rotated2 = z_rotated2 * (1 + 0.3 * tail_factor)\n        \n        # Apply magnetic center offset\n        x_final = x_rotated2 + magnetic_center_x\n        y_final = y_rotated2 + magnetic_center_y\n        z_final = z_rotated2 + magnetic_center_z\n        \n        # Create hover information arrays\n        belt_text = [belt['description']] * len(belt_x)\n        belt_customdata = [f\"Neptune: {belt['name']}\"] * len(belt_x)\n        \n        # Create the trace\n        traces.append(\n            go.Scatter3d(\n                x=x_final,\n                y=y_final,\n                z=z_final,\n                mode='markers',\n                marker=dict(\n                    size=2.0,\n                    color=belt['color'],\n                    opacity=belt['opacity']\n                ),\n                name=f\"Neptune: {belt['name']}\",\n                text=belt_text,\n                customdata=belt_customdata,\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            )\n        )\n    \n    # Add field-aligned current visualization connecting regions\n    # These are important features in Neptune's dynamic magnetosphere\n    current_traces = create_field_aligned_currents(magnetic_center_x, magnetic_center_y, magnetic_center_z, \n                                                 magnetic_tilt, azimuthal_angle)\n    traces.extend(current_traces)\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius= 6.0 * NEPTUNE_RADIUS_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 789,
    "end_line": 1013,
    "has_docstring": true,
    "docstring": "Creates Neptune's radiation belts with proper structure reflecting the complex magnetospheric environment.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_neptune_radiation_belts",
    "component_id": "neptune_visualization_shells.create_neptune_radiation_belts"
  },
  "neptune_visualization_shells.create_field_aligned_currents": {
    "id": "neptune_visualization_shells.create_field_aligned_currents",
    "name": "create_field_aligned_currents",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\neptune_visualization_shells.py",
    "relative_path": "neptune_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.rotate_points"
    ],
    "source_code": "def create_field_aligned_currents(mag_center_x, mag_center_y, mag_center_z, tilt, azimuth):\n    \"\"\"Creates visualization of field-aligned currents in Neptune's magnetosphere.\"\"\"\n    # These are electric currents that flow along magnetic field lines\n    # and are important features of planetary magnetospheres\n    \n    traces = []\n    \n    # Define parameters for currents\n    current_params = [\n        {\n            'start_radius': 2.0 * NEPTUNE_RADIUS_AU,\n            'end_radius': 5.0 * NEPTUNE_RADIUS_AU,\n            'angle_range': (np.pi/4, 3*np.pi/4),  # Angular sector for current\n            'color': 'rgb(200, 200, 255)',\n            'name': 'Dusk Field-Aligned Current',\n            'description': (\"Field-aligned currents are channels of charged particles flowing along magnetic field lines. <br>\"\n                           \"In Neptune's complex magnetic environment, these currents connect different regions of the magnetosphere <br>\"\n                           \"and play an important role in energy transfer. The dusk sector currents flow in the evening \"\n                           \"side of the planet's magnetosphere.\")\n        },\n        {\n            'start_radius': 2.0 * NEPTUNE_RADIUS_AU,\n            'end_radius': 5.0 * NEPTUNE_RADIUS_AU,\n            'angle_range': (5*np.pi/4, 7*np.pi/4),  # Angular sector for current\n            'color': 'rgb(200, 200, 255)',\n            'name': 'Dawn Field-Aligned Current',\n            'description': (\"Field-aligned currents are channels of charged particles flowing along magnetic field lines. <br>\"\n                           \"In Neptune's complex magnetic environment, these currents connect different regions of the magnetosphere <br>\"\n                           \"and play an important role in energy transfer. The dawn sector currents flow in the morning \"\n                           \"side of the planet's magnetosphere.\")\n        }\n    ]\n    \n    for params in current_params:\n        current_x = []\n        current_y = []\n        current_z = []\n        \n        # Number of field lines and points per line\n        n_lines = 15\n        n_points = 20\n        \n        for i in range(n_lines):\n            # Vary the angle within the specified range\n            angle_range = params['angle_range']\n            angle = angle_range[0] + (angle_range[1] - angle_range[0]) * (i / (n_lines-1))\n            \n            # Create points along a curved field line\n            for j in range(n_points):\n                # Parametric position along the field line (0 to 1)\n                t = j / (n_points-1)\n                \n                # Calculate radius that follows magnetic field line shape\n                radius = params['start_radius'] + (params['end_radius'] - params['start_radius']) * t\n                \n                # Add curvature to field line\n                angle_offset = 0.4 * np.sin(np.pi * t)  # Max 0.4 radians (~23 deg) curvature\n                current_angle = angle + angle_offset\n                \n                # Calculate position\n                x = radius * np.cos(current_angle)\n                y = radius * np.sin(current_angle)\n                z = radius * 0.5 * np.sin(np.pi * t)  # Add some z-variation\n                \n                current_x.append(x)\n                current_y.append(y)\n                current_z.append(z)\n        \n        # Convert to numpy arrays for rotation\n        current_x = np.array(current_x)\n        current_y = np.array(current_y)\n        current_z = np.array(current_z)\n        \n        # Apply rotations to align with magnetic field\n        # First apply rotation around y-axis for magnetic tilt\n        x_rot1, y_rot1, z_rot1 = rotate_points(current_x, current_y, current_z, tilt, 'y')\n        \n        # Then apply rotation around z-axis for azimuthal orientation\n        x_rot2, y_rot2, z_rot2 = rotate_points(x_rot1, y_rot1, z_rot1, azimuth, 'z')\n        \n        # Apply magnetic center offset\n        x_final = x_rot2 + mag_center_x\n        y_final = y_rot2 + mag_center_y\n        z_final = z_rot2 + mag_center_z\n        \n        # Create hover text and customdata arrays for consistency with other traces\n        hover_text = [params['description']] * len(current_x)\n        custom_data = [f\"Neptune: {params['name']}\"] * len(current_x)\n        \n        # Create the trace with very small markers to create a line-like effect\n        traces.append(\n            go.Scatter3d(\n                x=x_final,\n                y=y_final,\n                z=z_final,\n                mode='markers',\n                marker=dict(\n                    size=1.0,\n                    color=params['color'],\n                    opacity=0.3\n                ),\n                name=f\"Neptune: {params['name']}\",\n                text=hover_text,\n                customdata=custom_data,\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            )\n        )\n    \n    return traces",
    "start_line": 1015,
    "end_line": 1124,
    "has_docstring": true,
    "docstring": "Creates visualization of field-aligned currents in Neptune's magnetosphere.",
    "parameters": [
      "mag_center_x",
      "mag_center_y",
      "mag_center_z",
      "tilt",
      "azimuth"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_field_aligned_currents",
    "component_id": "neptune_visualization_shells.create_field_aligned_currents"
  },
  "neptune_visualization_shells.create_neptune_ring_system": {
    "id": "neptune_visualization_shells.create_neptune_ring_system",
    "name": "create_neptune_ring_system",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\neptune_visualization_shells.py",
    "relative_path": "neptune_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "saturn_visualization_shells.create_ring_points_saturn",
      "planet_visualization_utilities.rotate_points"
    ],
    "source_code": "def create_neptune_ring_system(center_position=(0, 0, 0)):\n    \"\"\"\n    Creates a visualization of Neptune's ring system with proper alignment.\n    \n    Parameters:\n        center_position (tuple): (x, y, z) position of Neptune's center\n        \n    Returns:\n        list: A list of plotly traces representing Neptune's ring components\n        \n    Notes:\n        Neptune's ring system requires specific transformations to correctly align\n        with its axial tilt (28.32 deg) and pole orientation. Unlike Uranus (which has\n        an extreme axial tilt of ~98 deg), Neptune's rings require a different approach.\n        \n        The transformation uses:\n        1. Standard orbital element rotations for each ring\n        2. Application of Neptune's pole direction (RA: 299.36 deg, Dec: 43.46 deg)\n        3. Proper offsetting relative to Neptune's center\n    \"\"\"\n    traces = []\n    \n    # Define Neptune's ring parameters in kilometers from Neptune's center\n    # Then convert to Neptune radii, and finally to AU\n    ring_params = {\n        'galle_ring': {\n            'inner_radius_km': 41900,  # Inner edge (in km from Neptune's center)\n            'outer_radius_km': 42900,  # Outer edge (in km from Neptune's center)\n            'thickness_km': 15,         # Approximate thickness\n            'color': 'rgb(70, 70, 70)',  \n            'opacity': 0.4,\n            'name': 'Galle Ring (1989N3R)',\n            'description': (\n                \"Galle Ring (1989N3R): Neptune's innermost ring, located about 41,900-42,900 km from Neptune's center.<br>\" \n                \"* Named after Johann Gottfried Galle, who discovered Neptune in 1846.<br>\" \n                \"* Faint, relatively broad ring approximately 2,000 km in width.<br>\" \n                \"* Composed primarily of dust particles, giving it a diffuse appearance.<br>\" \n                \"* Relatively uniform, lacking the clumpy structure seen in some of Neptune's other rings.<br>\"\n                \"* Discovery: First detected by Voyager 2 during its 1989 flyby mission.<br><br>\" \n                \"Unlike Triton, Neptune's rings lie in Neptune's equatorial plane, as is typical for planetary ring systems. This is <br>\" \n                \"due to the physical processes that form and maintain rings - they tend to settle into the equatorial plane due to the <br>\" \n                \"planet's rotational bulge. The other regular satellites of Neptune (like Proteus, Larissa, Galatea, and Despina) orbit <br>\" \n                \"in Neptune's equatorial plane, aligned with the rings. These inner moons play an important role in shepherding and <br>\" \n                \"maintaining the ring structure, particularly:<br>\" \n                \"* Galatea: This moon helps confine the Adams Ring and its distinctive arcs through orbital resonances.<br>\" \n                \"* Despina: Located near the Le Verrier Ring, it may help maintain its structure.<br>\" \n                \"* This misalignment between Triton and the rings/regular moons provides strong evidence for Triton's capture hypothesis <br>\" \n                \"  - it was likely an independent Kuiper Belt Object (similar to Pluto) that was captured by Neptune's gravity rather than <br>\" \n                \"  forming alongside Neptune like the other moons.<br>\" \n                \"* The contrast between the orderly, equatorial system of rings and regular moons versus Triton's highly inclined <br>\" \n                \"  orbit represents two different formation mechanisms in the same planetary system.\"\n            )\n        },\n        \n        'leverrier_ring': {\n            'inner_radius_km': 53200,  # Inner edge (in km from Neptune's center)\n            'outer_radius_km': 53200,  # Outer edge (in km from Neptune's center)\n            'thickness_km': 110,       # Approximate thickness\n            'color': 'rgb(75, 75, 75)',  \n            'opacity': 0.5,\n            'name': 'Leverrier Ring (1989N2R)',\n            'description': (\n                \"Leverrier Ring (1989N2R): A narrow, well-defined ring located about 53,200 km from Neptune's center.<br>\" \n                \"* Named after Urbain Le Verrier, who mathematically predicted Neptune's existence.<br>\" \n                \"* Approximately 110 km in width, much narrower than the Galle ring.<br>\" \n                \"* Higher density of material compared to the Galle ring, giving it a more defined appearance.<br>\" \n                \"* May have small embedded moonlets that help maintain its structure.<br>\"\n                \"* Discovery: First detected by Voyager 2 during its 1989 flyby mission.<br><br>\"\n                \"Unlike Triton, Neptune's rings lie in Neptune's equatorial plane, as is typical for planetary ring systems. This is <br>\" \n                \"due to the physical processes that form and maintain rings - they tend to settle into the equatorial plane due to the <br>\" \n                \"planet's rotational bulge. The other regular satellites of Neptune (like Proteus, Larissa, Galatea, and Despina) orbit <br>\" \n                \"in Neptune's equatorial plane, aligned with the rings. These inner moons play an important role in shepherding and <br>\" \n                \"maintaining the ring structure, particularly:<br>\" \n                \"* Galatea: This moon helps confine the Adams Ring and its distinctive arcs through orbital resonances.<br>\" \n                \"* Despina: Located near the Le Verrier Ring, it may help maintain its structure.<br>\" \n                \"* This misalignment between Triton and the rings/regular moons provides strong evidence for Triton's capture hypothesis <br>\" \n                \"  - it was likely an independent Kuiper Belt Object (similar to Pluto) that was captured by Neptune's gravity rather than <br>\" \n                \"  forming alongside Neptune like the other moons.<br>\" \n                \"* The contrast between the orderly, equatorial system of rings and regular moons versus Triton's highly inclined <br>\" \n                \"  orbit represents two different formation mechanisms in the same planetary system.\"\n            )\n        },\n        \n        'lassell_ring': {\n            'inner_radius_km': 55400,  # Inner edge (in km from Neptune's center)\n            'outer_radius_km': 57600,  # Outer edge (in km from Neptune's center)\n            'thickness_km': 4000,      # Approximate thickness\n            'color': 'rgb(70, 70, 75)',  \n            'opacity': 0.3,\n            'name': 'Lassell Ring',\n            'description': (\n                \"Lassell Ring: A broad, faint plateau-like ring region extending from about 55,400 to 57,600 km from Neptune's center.<br>\" \n                \"* Named after William Lassell, who discovered Neptune's largest moon Triton.<br>\" \n                \"* Sometimes described as a 'plateau' rather than a distinct ring.<br>\" \n                \"* Very faint, with a width of approximately 4,000 km.<br>\" \n                \"* Has a more diffuse, dusty composition.<br>\"\n                \"* Connects the Leverrier and Arago rings, forming part of a broader ring system structure.<br><br>\"\n                \"Unlike Triton, Neptune's rings lie in Neptune's equatorial plane, as is typical for planetary ring systems. This is <br>\" \n                \"due to the physical processes that form and maintain rings - they tend to settle into the equatorial plane due to the <br>\" \n                \"planet's rotational bulge. The other regular satellites of Neptune (like Proteus, Larissa, Galatea, and Despina) orbit <br>\" \n                \"in Neptune's equatorial plane, aligned with the rings. These inner moons play an important role in shepherding and <br>\" \n                \"maintaining the ring structure, particularly:<br>\" \n                \"* Galatea: This moon helps confine the Adams Ring and its distinctive arcs through orbital resonances.<br>\" \n                \"* Despina: Located near the Le Verrier Ring, it may help maintain its structure.<br>\" \n                \"* This misalignment between Triton and the rings/regular moons provides strong evidence for Triton's capture hypothesis <br>\" \n                \"  - it was likely an independent Kuiper Belt Object (similar to Pluto) that was captured by Neptune's gravity rather than <br>\" \n                \"  forming alongside Neptune like the other moons.<br>\" \n                \"* The contrast between the orderly, equatorial system of rings and regular moons versus Triton's highly inclined <br>\" \n                \"  orbit represents two different formation mechanisms in the same planetary system.\"\n            )\n        },\n        \n        'arago_ring': {\n            'inner_radius_km': 57600,  # Inner edge (in km from Neptune's center)\n            'outer_radius_km': 57600,  # Outer edge (in km from Neptune's center)\n            'thickness_km': 100,       # Approximate thickness\n            'color': 'rgb(80, 80, 85)',  \n            'opacity': 0.4,\n            'name': 'Arago Ring',\n            'description': (\n                \"Arago Ring: A narrow ring located at the outer edge of the Lassell Ring, about 57,600 km from Neptune's center.<br>\" \n                \"* Named after Francois Arago, a French mathematician, physicist, and astronomer.<br>\" \n                \"* Approximately 100 km in width.<br>\" \n                \"* Less prominent than the Leverrier and Adams rings.<br>\" \n                \"* Discovery: First observed by Voyager 2 in 1989, though initially not designated as a separate ring.<br><br>\"\n                \"Unlike Triton, Neptune's rings lie in Neptune's equatorial plane, as is typical for planetary ring systems. This is <br>\" \n                \"due to the physical processes that form and maintain rings - they tend to settle into the equatorial plane due to the <br>\" \n                \"planet's rotational bulge. The other regular satellites of Neptune (like Proteus, Larissa, Galatea, and Despina) orbit <br>\" \n                \"in Neptune's equatorial plane, aligned with the rings. These inner moons play an important role in shepherding and <br>\" \n                \"maintaining the ring structure, particularly:<br>\" \n                \"* Galatea: This moon helps confine the Adams Ring and its distinctive arcs through orbital resonances.<br>\" \n                \"* Despina: Located near the Le Verrier Ring, it may help maintain its structure.<br>\" \n                \"* This misalignment between Triton and the rings/regular moons provides strong evidence for Triton's capture hypothesis <br>\" \n                \"  - it was likely an independent Kuiper Belt Object (similar to Pluto) that was captured by Neptune's gravity rather than <br>\" \n                \"  forming alongside Neptune like the other moons.<br>\" \n                \"* The contrast between the orderly, equatorial system of rings and regular moons versus Triton's highly inclined <br>\" \n                \"  orbit represents two different formation mechanisms in the same planetary system.\"\n            )\n        },\n        \n        'adams_ring': {\n            'inner_radius_km': 62932,  # Inner edge (in km from Neptune's center)\n            'outer_radius_km': 62932,  # Outer edge (in km from Neptune's center)\n            'thickness_km': 50,        # Approximate thickness, variable\n            'color': 'rgb(85, 85, 85)',  \n            'opacity': 0.6,\n            'name': 'Adams Ring (1989N1R)',\n            'description': (\n                \"Adams Ring (1989N1R): Neptune's outermost and most prominent discrete ring, located about 62,930 km from Neptune's center.<br>\" \n                \"* Named after John Couch Adams, who independently predicted Neptune's existence around the same time as Le Verrier.<br>\" \n                \"* Has a variable width of approximately 35-50 km, but contains distinctive arc segments.<br>\" \n                \"* Contains five prominent arc segments (Courage, Liberte, Egalite 1 & 2, and Fraternite) that are denser than the rest of the ring.<br>\" \n                \"* These arcs are confined by gravitational resonances with the moon Galatea.<br>\"\n                \"* Most studied of Neptune's rings, with observations from both Voyager 2 and Earth-based telescopes.<br>\"\n                \"* Discovery: Its bright arcs were first detected from Earth in 1984, then confirmed by Voyager 2 in 1989.<br><br>\"\n                \"Unlike Triton, Neptune's rings lie in Neptune's equatorial plane, as is typical for planetary ring systems. This is <br>\" \n                \"due to the physical processes that form and maintain rings - they tend to settle into the equatorial plane due to the <br>\" \n                \"planet's rotational bulge. The other regular satellites of Neptune (like Proteus, Larissa, Galatea, and Despina) orbit <br>\" \n                \"in Neptune's equatorial plane, aligned with the rings. These inner moons play an important role in shepherding and <br>\" \n                \"maintaining the ring structure, particularly:<br>\" \n                \"* Galatea: This moon helps confine the Adams Ring and its distinctive arcs through orbital resonances.<br>\" \n                \"* Despina: Located near the Le Verrier Ring, it may help maintain its structure.<br>\" \n                \"* This misalignment between Triton and the rings/regular moons provides strong evidence for Triton's capture hypothesis <br>\" \n                \"  - it was likely an independent Kuiper Belt Object (similar to Pluto) that was captured by Neptune's gravity rather than <br>\" \n                \"  forming alongside Neptune like the other moons.<br>\" \n                \"* The contrast between the orderly, equatorial system of rings and regular moons versus Triton's highly inclined <br>\" \n                \"  orbit represents two different formation mechanisms in the same planetary system.\"\n            )\n        },\n        \n        'adams_courage_arc': {\n            'inner_radius_km': 62932,  # Inner edge (in km from Neptune's center)\n            'outer_radius_km': 62932,  # Outer edge (in km from Neptune's center)\n            'thickness_km': 50,        # Approximate thickness\n            'arc_length': 4.0,         # Arc length in degrees\n            'arc_center': 0,           # Center angle of the arc in degrees\n            'color': 'rgb(200, 200, 200)',  \n            'opacity': 0.7,\n            'name': 'Courage Arc',\n            'description': (\n                \"Courage Arc: The smallest and faintest of the five arcs in Neptune's Adams Ring.<br>\" \n                \"* Located within the Adams Ring at a distance of about 62,930 km from Neptune's center.<br>\" \n                \"* Spans approximately 1,000 km (4 deg of arc) along the ring.<br>\" \n                \"* Named after one of the three civic virtues from the motto of the French Republic.<br>\"\n                \"* The least stable of the arcs, showing significant changes since its discovery.<br>\"\n                \"* Discovery: First imaged by Voyager 2 in 1989.<br><br>\"\n                \"Unlike Triton, Neptune's rings lie in Neptune's equatorial plane, as is typical for planetary ring systems. This is <br>\" \n                \"due to the physical processes that form and maintain rings - they tend to settle into the equatorial plane due to the <br>\" \n                \"planet's rotational bulge. The other regular satellites of Neptune (like Proteus, Larissa, Galatea, and Despina) orbit <br>\" \n                \"in Neptune's equatorial plane, aligned with the rings. These inner moons play an important role in shepherding and <br>\" \n                \"maintaining the ring structure, particularly:<br>\" \n                \"* Galatea: This moon helps confine the Adams Ring and its distinctive arcs through orbital resonances.<br>\" \n                \"* Despina: Located near the Le Verrier Ring, it may help maintain its structure.<br>\" \n                \"* This misalignment between Triton and the rings/regular moons provides strong evidence for Triton's capture hypothesis <br>\" \n                \"  - it was likely an independent Kuiper Belt Object (similar to Pluto) that was captured by Neptune's gravity rather than <br>\" \n                \"  forming alongside Neptune like the other moons.<br>\" \n                \"* The contrast between the orderly, equatorial system of rings and regular moons versus Triton's highly inclined <br>\" \n                \"  orbit represents two different formation mechanisms in the same planetary system.\"\n            )\n        },\n        \n        'adams_liberte_arc': {\n            'inner_radius_km': 62932,  # Inner edge (in km from Neptune's center)\n            'outer_radius_km': 62932,  # Outer edge (in km from Neptune's center)\n            'thickness_km': 50,        # Approximate thickness\n            'arc_length': 4.5,         # Arc length in degrees\n            'arc_center': 8.0,         # Center angle of the arc in degrees\n            'color': 'rgb(200, 200, 200)',  \n            'opacity': 0.7,\n            'name': 'Liberte Arc',\n            'description': (\n                \"Liberte Arc: The second arc in Neptune's Adams Ring.<br>\" \n                \"* Located within the Adams Ring at a distance of about 62,930 km from Neptune's center.<br>\" \n                \"* Spans approximately 1,100 km (4.5 deg of arc) along the ring.<br>\" \n                \"* Named after 'Liberty' from the motto of the French Republic ('Liberty, Equality, Fraternity').<br>\"\n                \"* Shows brightness variations along its length.<br>\"\n                \"* Has shown evolutionary changes since its discovery, with variations in brightness and length.<br><br>\"\n                \"Unlike Triton, Neptune's rings lie in Neptune's equatorial plane, as is typical for planetary ring systems. This is <br>\" \n                \"due to the physical processes that form and maintain rings - they tend to settle into the equatorial plane due to the <br>\" \n                \"planet's rotational bulge. The other regular satellites of Neptune (like Proteus, Larissa, Galatea, and Despina) orbit <br>\" \n                \"in Neptune's equatorial plane, aligned with the rings. These inner moons play an important role in shepherding and <br>\" \n                \"maintaining the ring structure, particularly:<br>\" \n                \"* Galatea: This moon helps confine the Adams Ring and its distinctive arcs through orbital resonances.<br>\" \n                \"* Despina: Located near the Le Verrier Ring, it may help maintain its structure.<br>\" \n                \"* This misalignment between Triton and the rings/regular moons provides strong evidence for Triton's capture hypothesis <br>\" \n                \"  - it was likely an independent Kuiper Belt Object (similar to Pluto) that was captured by Neptune's gravity rather than <br>\" \n                \"  forming alongside Neptune like the other moons.<br>\" \n                \"* The contrast between the orderly, equatorial system of rings and regular moons versus Triton's highly inclined <br>\" \n                \"  orbit represents two different formation mechanisms in the same planetary system.\"\n            )\n        },\n        \n        'adams_egalite1_arc': {\n            'inner_radius_km': 62932,  # Inner edge (in km from Neptune's center)\n            'outer_radius_km': 62932,  # Outer edge (in km from Neptune's center)\n            'thickness_km': 50,        # Approximate thickness\n            'arc_length': 4.2,         # Arc length in degrees\n            'arc_center': 14.0,        # Center angle of the arc in degrees\n            'color': 'rgb(200, 200, 200)',  \n            'opacity': 0.7,\n            'name': 'Egalite 1 Arc',\n            'description': (\n                \"Egalite 1 Arc: One of two 'Equality' arcs in Neptune's Adams Ring.<br>\" \n                \"* Located within the Adams Ring at a distance of about 62,930 km from Neptune's center.<br>\" \n                \"* Spans approximately 1,000 km (4.2 deg of arc) along the ring.<br>\" \n                \"* Named after 'Equality' from the motto of the French Republic.<br>\"\n                \"* Together with Egalite 2, forms a pair of similar arcs separated by a small gap.<br>\"\n                \"* Has shown some changes in structure since the Voyager 2 observations.<br><br>\"\n                \"Unlike Triton, Neptune's rings lie in Neptune's equatorial plane, as is typical for planetary ring systems. This is <br>\" \n                \"due to the physical processes that form and maintain rings - they tend to settle into the equatorial plane due to the <br>\" \n                \"planet's rotational bulge. The other regular satellites of Neptune (like Proteus, Larissa, Galatea, and Despina) orbit <br>\" \n                \"in Neptune's equatorial plane, aligned with the rings. These inner moons play an important role in shepherding and <br>\" \n                \"maintaining the ring structure, particularly:<br>\" \n                \"* Galatea: This moon helps confine the Adams Ring and its distinctive arcs through orbital resonances.<br>\" \n                \"* Despina: Located near the Le Verrier Ring, it may help maintain its structure.<br>\" \n                \"* This misalignment between Triton and the rings/regular moons provides strong evidence for Triton's capture hypothesis <br>\" \n                \"  - it was likely an independent Kuiper Belt Object (similar to Pluto) that was captured by Neptune's gravity rather than <br>\" \n                \"  forming alongside Neptune like the other moons.<br>\" \n                \"* The contrast between the orderly, equatorial system of rings and regular moons versus Triton's highly inclined <br>\" \n                \"  orbit represents two different formation mechanisms in the same planetary system.\"\n            )\n        },\n        \n        'adams_egalite2_arc': {\n            'inner_radius_km': 62932,  # Inner edge (in km from Neptune's center)\n            'outer_radius_km': 62932,  # Outer edge (in km from Neptune's center)\n            'thickness_km': 50,        # Approximate thickness\n            'arc_length': 4.0,         # Arc length in degrees\n            'arc_center': 22.0,        # Center angle of the arc in degrees\n            'color': 'rgb(200, 200, 200)',  \n            'opacity': 0.7,\n            'name': 'Egalite 2 Arc',\n            'description': (\n                \"Egalite 2 Arc: The second 'Equality' arc in Neptune's Adams Ring.<br>\" \n                \"* Located within the Adams Ring at a distance of about 62,930 km from Neptune's center.<br>\" \n                \"* Spans approximately 1,000 km (4 deg of arc) along the ring.<br>\" \n                \"* Named after 'Equality' from the motto of the French Republic.<br>\"\n                \"* Follows closely after Egalite 1, separated by a small gap.<br>\"\n                \"* The pair of Egalite arcs may be maintained by resonances with nearby moons.<br><br>\"\n                \"Unlike Triton, Neptune's rings lie in Neptune's equatorial plane, as is typical for planetary ring systems. This is <br>\" \n                \"due to the physical processes that form and maintain rings - they tend to settle into the equatorial plane due to the <br>\" \n                \"planet's rotational bulge. The other regular satellites of Neptune (like Proteus, Larissa, Galatea, and Despina) orbit <br>\" \n                \"in Neptune's equatorial plane, aligned with the rings. These inner moons play an important role in shepherding and <br>\" \n                \"maintaining the ring structure, particularly:<br>\" \n                \"* Galatea: This moon helps confine the Adams Ring and its distinctive arcs through orbital resonances.<br>\" \n                \"* Despina: Located near the Le Verrier Ring, it may help maintain its structure.<br>\" \n                \"* This misalignment between Triton and the rings/regular moons provides strong evidence for Triton's capture hypothesis <br>\" \n                \"  - it was likely an independent Kuiper Belt Object (similar to Pluto) that was captured by Neptune's gravity rather than <br>\" \n                \"  forming alongside Neptune like the other moons.<br>\" \n                \"* The contrast between the orderly, equatorial system of rings and regular moons versus Triton's highly inclined <br>\" \n                \"  orbit represents two different formation mechanisms in the same planetary system.\"\n            )\n        },\n        \n        'adams_fraternite_arc': {\n            'inner_radius_km': 62932,  # Inner edge (in km from Neptune's center)\n            'outer_radius_km': 62932,  # Outer edge (in km from Neptune's center)\n            'thickness_km': 50,        # Approximate thickness\n            'arc_length': 9.0,         # Arc length in degrees\n            'arc_center': 40.0,        # Center angle of the arc in degrees\n            'color': 'rgb(200, 200, 200)',  \n            'opacity': 0.7,\n            'name': 'Fraternite Arc',\n            'description': (\n                \"Fraternite Arc: The longest and most prominent arc in Neptune's Adams Ring.<br>\" \n                \"* Located within the Adams Ring at a distance of about 62,930 km from Neptune's center.<br>\" \n                \"* Spans approximately 2,200 km (9 deg of arc) along the ring, making it the longest arc.<br>\" \n                \"* Named after 'Fraternity' from the motto of the French Republic.<br>\"\n                \"* The brightest and most stable of Neptune's ring arcs.<br>\"\n                \"* Discovery: It was the first arc detected from Earth-based observations in 1984.<br><br>\"\n                \"Unlike Triton, Neptune's rings lie in Neptune's equatorial plane, as is typical for planetary ring systems. This is <br>\" \n                \"due to the physical processes that form and maintain rings - they tend to settle into the equatorial plane due to the <br>\" \n                \"planet's rotational bulge. The other regular satellites of Neptune (like Proteus, Larissa, Galatea, and Despina) orbit <br>\" \n                \"in Neptune's equatorial plane, aligned with the rings. These inner moons play an important role in shepherding and <br>\" \n                \"maintaining the ring structure, particularly:<br>\" \n                \"* Galatea: This moon helps confine the Adams Ring and its distinctive arcs through orbital resonances.<br>\" \n                \"* Despina: Located near the Le Verrier Ring, it may help maintain its structure.<br>\" \n                \"* This misalignment between Triton and the rings/regular moons provides strong evidence for Triton's capture hypothesis <br>\" \n                \"  - it was likely an independent Kuiper Belt Object (similar to Pluto) that was captured by Neptune's gravity rather than <br>\" \n                \"  forming alongside Neptune like the other moons.<br>\" \n                \"* The contrast between the orderly, equatorial system of rings and regular moons versus Triton's highly inclined <br>\" \n                \"  orbit represents two different formation mechanisms in the same planetary system.\"\n            )\n        },\n        \n        'unnamed_dusty_ring': {\n            'inner_radius_km': 67500,  # Inner edge (in km from Neptune's center)\n            'outer_radius_km': 73000,  # Outer edge (in km from Neptune's center) \n            'thickness_km': 2000,      # Approximate thickness\n            'color': 'rgb(100, 150, 200)',  # Bluish tint for dusty ring\n            'opacity': 0.1,\n            'name': 'Outer Dusty Ring',\n            'description': (\n                \"Outer Dusty Ring: A faint, diffuse ring extending beyond the Adams Ring.<br>\" \n                \"* Located approximately 67,500-73,000 km from Neptune's center.<br>\" \n                \"* Very faint and difficult to observe, composed primarily of microscopic dust particles.<br>\" \n                \"* May be fed by impacts on Neptune's small inner moons.<br>\"\n                \"* Discovery: First hinted at in Voyager 2 data, later confirmed by Earth-based observations.<br><br>\"\n                \"Unlike Triton, Neptune's rings lie in Neptune's equatorial plane, as is typical for planetary ring systems. This is <br>\" \n                \"due to the physical processes that form and maintain rings - they tend to settle into the equatorial plane due to the <br>\" \n                \"planet's rotational bulge. The other regular satellites of Neptune (like Proteus, Larissa, Galatea, and Despina) orbit <br>\" \n                \"in Neptune's equatorial plane, aligned with the rings. These inner moons play an important role in shepherding and <br>\" \n                \"maintaining the ring structure, particularly:<br>\" \n                \"* Galatea: This moon helps confine the Adams Ring and its distinctive arcs through orbital resonances.<br>\" \n                \"* Despina: Located near the Le Verrier Ring, it may help maintain its structure.<br>\" \n                \"* This misalignment between Triton and the rings/regular moons provides strong evidence for Triton's capture hypothesis <br>\" \n                \"  - it was likely an independent Kuiper Belt Object (similar to Pluto) that was captured by Neptune's gravity rather than <br>\" \n                \"  forming alongside Neptune like the other moons.<br>\" \n                \"* The contrast between the orderly, equatorial system of rings and regular moons versus Triton's highly inclined <br>\" \n                \"  orbit represents two different formation mechanisms in the same planetary system.\"\n            )\n        }\n    }\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Neptune's axial tilt in radians (28.32 degrees)\n    neptune_tilt = np.radians(28.32)\n    \n    # Neptune's pole direction (J2000)\n    pole_ra = np.radians(299.36)  # Right ascension in radians\n    pole_dec = np.radians(43.46)  # Declination in radians\n    \n    # Create traces for each ring\n    for ring_name, ring_info in ring_params.items():\n        # Convert km to AU\n        inner_radius_au = ring_info['inner_radius_km'] / KM_PER_AU\n        outer_radius_au = ring_info['outer_radius_km'] / KM_PER_AU\n        thickness_au = ring_info['thickness_km'] / KM_PER_AU\n        \n        # For arc segments, generate partial rings\n        if 'arc_length' in ring_info and 'arc_center' in ring_info:\n            # Create arc points\n            arc_length = ring_info['arc_length']  # Arc length in degrees\n            arc_center = ring_info['arc_center']  # Center angle of the arc in degrees\n            \n            # Calculate arc start and end angles\n            arc_start = np.radians(arc_center - arc_length/2)\n            arc_end = np.radians(arc_center + arc_length/2)\n            \n            # Generate points along the arc\n            n_points = int(arc_length * 10)  # 10 points per degree for smoothness\n            theta = np.linspace(arc_start, arc_end, n_points)\n            \n            # Generate radial points\n            n_radial = 5  # Number of radial points\n            \n            x = []\n            y = []\n            z = []\n            \n            for r in np.linspace(inner_radius_au, outer_radius_au, n_radial):\n                for t in theta:\n                    x.append(r * np.cos(t))\n                    y.append(r * np.sin(t))\n                    z.append(0)  # Start in xy-plane\n                    \n                    # Add thickness in z-direction\n                    for h in np.linspace(-thickness_au/2, thickness_au/2, 3):\n                        if h != 0:  # Skip duplicate points\n                            x.append(r * np.cos(t))\n                            y.append(r * np.sin(t))\n                            z.append(h)\n            \n        else:\n            # Create complete ring points\n            n_points = 100  # Fewer points for outer dusty rings to improve performance\n            if 'dusty' in ring_name:\n                n_points = 80\n                \n            # Create ring points\n            x, y, z = create_ring_points_saturn(\n                inner_radius_au, outer_radius_au, n_points, thickness_au\n            )\n        \n        # Convert to numpy arrays for rotation\n        x = np.array(x)\n        y = np.array(y)\n        z = np.array(z)\n        \n        # TRANSFORMATION APPROACH:\n        # Neptune's pole is oriented at RA=299.36 deg, DEC=43.46 deg\n        # We'll use a transformation sequence to correctly orient the rings\n        \n        # Step 1: Rotate around z-axis by the Right Ascension\n    #    x_rot1, y_rot1, z_rot1 = rotate_points(x, y, z, pole_ra, 'z')\n        \n        # Step 2: Rotate around x-axis by (90 deg - Declination)\n        # This aligns the z-axis with Neptune's pole\n    #    x_rot2, y_rot2, z_rot2 = rotate_points(x_rot1, y_rot1, z_rot1, np.radians(90) - pole_dec, 'x')\n        \n        # Step 3: Apply final adjustment based on Neptune's specific orientation\n        # This 25 deg rotation adjusts for the reference frame of Neptune's ring observations\n    #    x_final, y_final, z_final = rotate_points(x_rot2, y_rot2, z_rot2, np.radians(25), 'z')\n\n        # SIMPLIFIED TRANSFORMATION:\n        # Instead of using RA/Dec-based transformations, we'll use a direct alignment\n        # to match what we see in the image with Despina and Galatea's orbits\n        \n        # Transform ring coordinates to align with Neptune's equatorial plane\n        # These angles were empirically determined to match the orbital plane of Despina and Galatea\n        # First rotation: 32 deg around x-axis provides the primary tilt \n        tilt_angle = np.radians(32)\n        x_rot1, y_rot1, z_rot1 = rotate_points(x, y, z, tilt_angle, 'x')\n\n        # Second rotation: 34 deg around z-axis aligns with the final orientation\n        final_orientation = np.radians(34)\n        x_final, y_final, z_final = rotate_points(x_rot1, y_rot1, z_rot1, final_orientation, 'z')\n        \n        # Apply center position offset\n        x_final = x_final + center_x\n        y_final = y_final + center_y\n        z_final = z_final + center_z\n        \n        # Create hover text\n        text_array = [ring_info['description']] * len(x)\n        \n        # Add ring trace\n        traces.append(\n            go.Scatter3d(\n                x=x_final,\n                y=y_final,\n                z=z_final,\n                mode='markers',\n                marker=dict(\n                    size=1.5,  # Small markers for rings\n                    color=ring_info['color'],\n                    opacity=ring_info['opacity']\n                ),\n                name=f\"Neptune: {ring_info['name']}\",\n                text=text_array,\n                customdata=[f\"Neptune: {ring_info['name']}\"] * len(x),\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            )\n        )\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=73000 / KM_PER_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 1157,
    "end_line": 1642,
    "has_docstring": true,
    "docstring": "Creates a visualization of Neptune's ring system with proper alignment.\n\nParameters:\n    center_position (tuple): (x, y, z) position of Neptune's center\n    \nReturns:\n    list: A list of plotly traces representing Neptune's ring components\n    \nNotes:\n    Neptune's ring system requires specific transformations to correctly align\n    with its axial tilt (28.32 deg) and pole orientation. Unlike Uranus (which has\n    an extreme axial tilt of ~98 deg), Neptune's rings require a different approach.\n    \n    The transformation uses:\n    1. Standard orbital element rotations for each ring\n    2. Application of Neptune's pole direction (RA: 299.36 deg, Dec: 43.46 deg)\n    3. Proper offsetting relative to Neptune's center",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_neptune_ring_system",
    "component_id": "neptune_visualization_shells.create_neptune_ring_system"
  },
  "neptune_visualization_shells.create_neptune_hill_sphere_shell": {
    "id": "neptune_visualization_shells.create_neptune_hill_sphere_shell",
    "name": "create_neptune_hill_sphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\neptune_visualization_shells.py",
    "relative_path": "neptune_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_neptune_hill_sphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates neptune's Hill sphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 4685, \n        'color': 'rgb(0, 255, 0)',  # Green for Hill sphere\n        'opacity': 0.25,\n        'name': 'Hill Sphere',\n        'description': (\n            \"SET MANUAL SCALE OF AT LEAST 0.3 AU TO VISUALIZE.<br><br>\"\n            \"Neptune's Hill sphere is the region around the planet where its gravitational influence dominates over that of the Sun. <br>\" \n            \"Any moon or other object orbiting Neptune within this sphere is more likely to remain bound to it rather than being pulled <br>\" \n            \"away by the Sun's gravity. Neptune's Hill sphere extends to a staggering approximately 4685 times the radius of Neptune. <br>\" \n            \"This vast gravitational influence allows Neptune to retain its large system of moons, including the distant and unusual <br>\" \n            \"irregular satellites.\"          )\n    }\n        \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * NEPTUNE_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Neptune: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Neptune: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    # Add sun direction indicator scaled to this shell's radius\n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=layer_radius\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 1655,
    "end_line": 1709,
    "has_docstring": true,
    "docstring": "Creates neptune's Hill sphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_neptune_hill_sphere_shell",
    "component_id": "neptune_visualization_shells.create_neptune_hill_sphere_shell"
  },
  "object_type_analyzer.expand_object_type": {
    "id": "object_type_analyzer.expand_object_type",
    "name": "expand_object_type",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\object_type_analyzer.py",
    "relative_path": "object_type_analyzer.py",
    "depends_on": [],
    "source_code": "def expand_object_type(ot):\n    \"\"\"\n    Expand object type codes to full descriptions.\n    This is a utility function used by visualization modules.\n    \"\"\"\n    import re\n    import pandas as pd\n    \n    if ot is None or pd.isna(ot):\n        return 'Unknown'\n    \n    ot_codes = re.split(r'[;, ]+', str(ot))\n    descriptions = []\n    \n    # Use the mapping from constants_new that's already imported\n    from constants_new import object_type_mapping\n    \n    for code in ot_codes:\n        code = code.strip()\n        if code in object_type_mapping:\n            desc = object_type_mapping[code]\n        else:\n            matched = False\n            for key in object_type_mapping:\n                if key in code:\n                    desc = object_type_mapping[key]\n                    matched = True\n                    break\n            if not matched:\n                desc = code\n        descriptions.append(desc)\n    \n    return ', '.join(descriptions)",
    "start_line": 13,
    "end_line": 45,
    "has_docstring": true,
    "docstring": "Expand object type codes to full descriptions.\nThis is a utility function used by visualization modules.",
    "parameters": [
      "ot"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function expand_object_type",
    "component_id": "object_type_analyzer.expand_object_type"
  },
  "object_type_analyzer.ObjectTypeAnalyzer": {
    "id": "object_type_analyzer.ObjectTypeAnalyzer",
    "name": "ObjectTypeAnalyzer",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\object_type_analyzer.py",
    "relative_path": "object_type_analyzer.py",
    "depends_on": [],
    "source_code": "class ObjectTypeAnalyzer:\n    \"\"\"\n    Analyzer for categorizing and analyzing astronomical object types.\n    Provides research-grade statistical analysis of stellar populations.\n    \"\"\"\n        \n    def __init__(self):\n        # Define the 5 main categories with descriptions\n        self.categories = {\n            'Variable Stars': 'Stars showing brightness variations',\n            'Binary/Multiple Systems': 'Gravitationally bound star systems',\n            'Evolved Stars': 'Stars in late evolutionary stages',\n            'Young Stellar Objects': 'Stars in formation or early evolution',\n            'Peculiar/Special Objects': 'Unusual stellar phenomena'\n        }\n        \n        # Create the comprehensive mapping from object_type_mapping codes\n        # This mapping is based on SIMBAD object type codes\n        self.type_to_category = {\n            # Variable Stars\n            'V*': 'Variable Stars',\n            'Cepheid': 'Variable Stars',\n            'Cepheid*': 'Variable Stars',\n            'ClassicalCep': 'Variable Stars',\n            'Type2Cep': 'Variable Stars',\n            'Type2Cep*': 'Variable Stars',\n            'AnomalCep': 'Variable Stars',\n            'RRLyr': 'Variable Stars',\n            'RR*': 'Variable Stars',\n            'RRLyrae_Candidate': 'Variable Stars',\n            'RRLyrae_Candidate*': 'Variable Stars',\n            'Mira': 'Variable Stars',\n            'Mira*': 'Variable Stars',\n            'deltaSct*': 'Variable Stars',\n            'Variable*': 'Variable Stars',\n            'PulsV*': 'Variable Stars',\n            'LongPeriodV*': 'Variable Stars',\n            'SemiRegV*': 'Variable Stars',\n            'IrregularV*': 'Variable Stars',\n            'EclipsingBinary': 'Variable Stars',\n            'EB*': 'Variable Stars',\n            'RVTauriV*': 'Variable Stars',\n            'AlgolEclBin*': 'Variable Stars',\n            'BetLyrEclBin*': 'Variable Stars',\n            'EllipsoidV*': 'Variable Stars',\n            \n            # Binary/Multiple Systems\n            'SB*': 'Binary/Multiple Systems',\n            '**': 'Binary/Multiple Systems',\n            'DoubleMultStar': 'Binary/Multiple Systems',\n            'ContactBin': 'Binary/Multiple Systems',\n            'ContactBin*': 'Binary/Multiple Systems',\n            'DetachedBin': 'Binary/Multiple Systems',\n            'XrayBin': 'Binary/Multiple Systems',\n            'Spectroscopic_Binary': 'Binary/Multiple Systems',\n            'CataclyV*': 'Binary/Multiple Systems',\n            'Symbiotic*': 'Binary/Multiple Systems',\n            'S*': 'Binary/Multiple Systems',  # Symbiotic\n            'Nova': 'Binary/Multiple Systems',\n            'Nova*': 'Binary/Multiple Systems',\n            'DwarfNova': 'Binary/Multiple Systems',\n            \n            # Evolved Stars\n            'RedGiant': 'Evolved Stars',\n            'RedGiant*': 'Evolved Stars',\n            'RGB*': 'Evolved Stars',\n            'RedSuperGiant': 'Evolved Stars',\n            'RedSG*': 'Evolved Stars',\n            'BlueSupergiant': 'Evolved Stars',\n            'BlueSG*': 'Evolved Stars',\n            'YellowSG': 'Evolved Stars',\n            'Supergiant': 'Evolved Stars',\n            'Supergiant*': 'Evolved Stars',\n            's*r': 'Evolved Stars',\n            'Giant': 'Evolved Stars',\n            'Giant*': 'Evolved Stars',\n            'WD*': 'Evolved Stars',\n            'WhiteDwarf': 'Evolved Stars',\n            'WhiteDwarf*': 'Evolved Stars',\n            'PlanetaryNeb': 'Evolved Stars',\n            'PN': 'Evolved Stars',\n            'AGB*': 'Evolved Stars',\n            'post-AGB*': 'Evolved Stars',\n            'HorizontalBranch*': 'Evolved Stars',\n            'HB*': 'Evolved Stars',\n            'C*': 'Evolved Stars',  # Carbon stars\n            'CarbonStar': 'Evolved Stars',\n            \n            # Young Stellar Objects\n            'YSO': 'Young Stellar Objects',\n            'Y*O': 'Young Stellar Objects',\n            'TTauri*': 'Young Stellar Objects',\n            'HerbigAe/Be*': 'Young Stellar Objects',\n            'Herbig*': 'Young Stellar Objects',\n            'PreMainSeq*': 'Young Stellar Objects',\n            'ProtoStar': 'Young Stellar Objects',\n            'YSO_Candidate': 'Young Stellar Objects',\n            'HerbigHaro': 'Young Stellar Objects',\n            'HH': 'Young Stellar Objects',\n            'OrionV*': 'Young Stellar Objects',\n            \n            # Peculiar/Special Objects\n            'WolfRayet*': 'Peculiar/Special Objects',\n            'WR*': 'Peculiar/Special Objects',\n            'Be*': 'Peculiar/Special Objects',\n            'Ae*': 'Peculiar/Special Objects',\n            'BlueStraggler': 'Peculiar/Special Objects',\n            'ChemPec*': 'Peculiar/Special Objects',\n            'Em*': 'Peculiar/Special Objects',\n            'EmissionLineStar': 'Peculiar/Special Objects',\n            'BaStar': 'Peculiar/Special Objects',\n            'Ba*': 'Peculiar/Special Objects',\n            'HgMnStar': 'Peculiar/Special Objects',\n            'PecStar': 'Peculiar/Special Objects',\n            'SN*': 'Peculiar/Special Objects',\n            'Pulsar': 'Peculiar/Special Objects',\n            'Magnetar': 'Peculiar/Special Objects',\n            'BYDra*': 'Peculiar/Special Objects',\n            'RSCVn*': 'Peculiar/Special Objects',\n            'FlareStar': 'Peculiar/Special Objects',\n            'Flare*': 'Peculiar/Special Objects',\n            \n            # Default/Normal stars\n            'Star': 'Normal Stars',\n            'MainSeq*': 'Normal Stars',\n            '*': 'Normal Stars',\n            'PM*': 'Normal Stars',  # High proper motion star\n            'HighPM*': 'Normal Stars',\n        }\n        \n        # Analysis priorities (lower number = higher priority for reporting)\n        self.category_priority = {\n            'Peculiar/Special Objects': 1,\n            'Young Stellar Objects': 2,\n            'Binary/Multiple Systems': 3,\n            'Variable Stars': 4,\n            'Evolved Stars': 5,\n            'Normal Stars': 6,\n            'Unknown': 7\n        }\n        \n        # Define rare/notable types worth highlighting\n        self.notable_types = {\n            'WolfRayet*', 'WR*', 'SN*', 'Nova', 'Nova*', 'Pulsar', 'Magnetar',\n            'PlanetaryNeb', 'PN', 'BlueStraggler', 'Symbiotic*', 'S*',\n            'XrayBin', 'HerbigHaro', 'HH', 'ChemPec*', 'CataclyV*',\n            'Be*', 'Ae*', 'BaStar', 'Ba*', 'HgMnStar', 'post-AGB*'\n        }\n        \n        # Research interest scores (for future expansion)\n        self.research_interest = {\n            'WolfRayet*': 10,  # Very rare, end-state massive stars\n            'SN*': 10,         # Supernovae\n            'Pulsar': 10,      # Neutron stars\n            'BlueStraggler': 9,  # Stellar collision/mass transfer products\n            'Symbiotic*': 8,   # Interacting binaries\n            'XrayBin': 8,      # X-ray binaries\n            'Be*': 7,          # Emission line B stars\n            'CataclyV*': 7,    # Cataclysmic variables\n            'YSO': 6,          # Star formation\n            'Cepheid': 6,      # Distance indicators\n            'RRLyr': 6,        # Distance/age indicators\n        }\n    \n    def categorize_object_type(self, obj_type: str) -> str:\n        \"\"\"\n        Categorize a single object type into one of the main categories.\n        \n        Args:\n            obj_type: Object type code or description\n            \n        Returns:\n            Category name\n        \"\"\"\n        if pd.isna(obj_type) or obj_type in ['Unknown', 'nan', 'None', '']:\n            return 'Unknown'\n        \n        obj_type_str = str(obj_type).strip()\n        \n        # Direct lookup first (most efficient)\n        if obj_type_str in self.type_to_category:\n            return self.type_to_category[obj_type_str]\n        \n        # Check if it's a description containing known codes\n        # This handles cases like \"Variable Star of Mira Type\"\n        for code, category in self.type_to_category.items():\n            if code in obj_type_str or code.replace('*', '') in obj_type_str:\n                return category\n        \n        # Check for keywords in descriptions\n        obj_lower = obj_type_str.lower()\n        if 'variable' in obj_lower:\n            return 'Variable Stars'\n        elif 'binary' in obj_lower or 'double' in obj_lower or 'multiple' in obj_lower:\n            return 'Binary/Multiple Systems'\n        elif 'giant' in obj_lower or 'dwarf' in obj_lower or 'evolved' in obj_lower:\n            return 'Evolved Stars'\n        elif 'young' in obj_lower or 'pre-main' in obj_lower or 'tauri' in obj_lower:\n            return 'Young Stellar Objects'\n        elif 'peculiar' in obj_lower or 'emission' in obj_lower or 'wolf' in obj_lower:\n            return 'Peculiar/Special Objects'\n        \n        # Default to Normal Stars if no match\n        return 'Normal Stars'\n    \n    def analyze_distribution(self, object_types: pd.Series) -> Dict:\n        \"\"\"\n        Analyze a distribution of object types for research-grade statistics.\n        \n        Args:\n            object_types: Series of object type codes or descriptions\n            \n        Returns:\n            Dictionary with comprehensive analysis results\n        \"\"\"\n        results = {\n            'total_count': 0,\n            'typed_count': 0,\n            'category_counts': {},\n            'category_percentages': {},\n            'type_counts': {},\n            'notable_objects': [],\n            'diversity_score': 0,\n            'shannon_entropy': 0,\n            'simpson_index': 0,\n            'research_targets': [],\n            'summary': '',\n            'timestamp': datetime.now().isoformat()\n        }\n        \n        # Clean the data\n        clean_types = object_types.dropna()\n        clean_types = clean_types[~clean_types.isin(['Unknown', 'nan', 'None', ''])]\n        \n        results['total_count'] = len(object_types)\n        results['typed_count'] = len(clean_types)\n        \n        if len(clean_types) == 0:\n            results['summary'] = 'No object type information available'\n            return results\n        \n        # Count individual types\n        type_counts = clean_types.value_counts()\n        results['type_counts'] = type_counts.head(20).to_dict()  # Top 20 for report\n        \n        # Categorize all objects\n        categories = clean_types.apply(self.categorize_object_type)\n        category_counts = categories.value_counts()\n        \n        # Initialize all categories to 0\n        for category in list(self.categories.keys()) + ['Normal Stars', 'Unknown']:\n            results['category_counts'][category] = 0\n            results['category_percentages'][category] = 0\n        \n        # Store actual counts and percentages\n        for category, count in category_counts.items():\n            results['category_counts'][category] = int(count)\n            results['category_percentages'][category] = round(count / len(clean_types) * 100, 2)\n        \n        # Find notable objects\n        for obj_type, count in type_counts.items():\n            obj_type_str = str(obj_type)\n            # Check if it's notable\n            if any(notable in obj_type_str for notable in self.notable_types):\n                results['notable_objects'].append((obj_type_str, int(count)))\n            # Check research interest\n            for research_type, score in self.research_interest.items():\n                if research_type.replace('*', '') in obj_type_str:\n                    results['research_targets'].append({\n                        'type': obj_type_str,\n                        'count': int(count),\n                        'interest_score': score\n                    })\n        \n        # Sort research targets by interest score\n        results['research_targets'] = sorted(\n            results['research_targets'], \n            key=lambda x: x['interest_score'], \n            reverse=True\n        )[:10]  # Top 10\n        \n        # Calculate diversity metrics\n        results['diversity_score'] = self._calculate_diversity_score(type_counts)\n        results['shannon_entropy'] = self._calculate_shannon_entropy(type_counts)\n        results['simpson_index'] = self._calculate_simpson_index(type_counts)\n        \n        # Generate summary\n        dominant_category = category_counts.idxmax() if len(category_counts) > 0 else 'Unknown'\n        results['summary'] = self._generate_summary(results, dominant_category)\n        \n        return results\n    \n    def _calculate_diversity_score(self, type_counts: pd.Series) -> int:\n        \"\"\"\n        Calculate a diversity score (0-100) based on variety and evenness.\n        \"\"\"\n        n_types = len(type_counts)\n        if n_types == 0:\n            return 0\n        \n        # Component 1: Number of unique types (max 50 points)\n        variety_score = min(50, n_types * 2)\n        \n        # Component 2: Evenness (max 50 points)\n        total = type_counts.sum()\n        expected = total / n_types\n        evenness = 1 - (type_counts.std() / expected if expected > 0 else 1)\n        evenness_score = max(0, evenness * 50)\n        \n        return int(variety_score + evenness_score)\n    \n    def _calculate_shannon_entropy(self, type_counts: pd.Series) -> float:\n        \"\"\"\n        Calculate Shannon entropy for diversity measurement.\n        Higher values indicate more diversity.\n        \"\"\"\n        if len(type_counts) == 0:\n            return 0.0\n        \n        proportions = type_counts / type_counts.sum()\n        entropy = -sum(p * np.log2(p) if p > 0 else 0 for p in proportions)\n        return round(entropy, 3)\n    \n    def _calculate_simpson_index(self, type_counts: pd.Series) -> float:\n        \"\"\"\n        Calculate Simpson's diversity index.\n        Values closer to 1 indicate higher diversity.\n        \"\"\"\n        if len(type_counts) == 0:\n            return 0.0\n        \n        total = type_counts.sum()\n        if total <= 1:\n            return 0.0\n        \n        simpson = sum(count * (count - 1) for count in type_counts) / (total * (total - 1))\n        return round(1 - simpson, 3)\n    \n    def _generate_summary(self, results: Dict, dominant_category: str) -> str:\n        \"\"\"Generate a research-oriented text summary.\"\"\"\n        summary_parts = []\n        \n        # Data completeness\n        completeness = (results['typed_count'] / results['total_count'] * 100) if results['total_count'] > 0 else 0\n        summary_parts.append(f\"{completeness:.1f}% objects typed\")\n        \n        # Dominant population\n        if dominant_category != 'Normal Stars' and dominant_category != 'Unknown':\n            percentage = results['category_percentages'].get(dominant_category, 0)\n            summary_parts.append(f\"dominated by {dominant_category} ({percentage:.1f}%)\")\n        \n        # Diversity assessment\n        if results['shannon_entropy'] > 3.5:\n            summary_parts.append(\"very high diversity (H'={:.2f})\".format(results['shannon_entropy']))\n        elif results['shannon_entropy'] > 2.5:\n            summary_parts.append(\"high diversity (H'={:.2f})\".format(results['shannon_entropy']))\n        elif results['shannon_entropy'] > 1.5:\n            summary_parts.append(\"moderate diversity (H'={:.2f})\".format(results['shannon_entropy']))\n        else:\n            summary_parts.append(\"low diversity (H'={:.2f})\".format(results['shannon_entropy']))\n        \n        # Research highlights\n        if results['research_targets']:\n            n_targets = len(results['research_targets'])\n            summary_parts.append(f\"{n_targets} high-interest research targets\")\n        \n        return \". \".join(summary_parts).capitalize() if summary_parts else \"Standard stellar population\"\n    \n    def format_report_section(self, analysis_results: Dict) -> List[str]:\n        \"\"\"\n        Format analysis results for the plot report.\n        \n        Returns:\n            List of formatted report lines\n        \"\"\"\n        lines = []\n        \n        if analysis_results['typed_count'] == 0:\n            lines.append(\"  No object type information available\")\n            return lines\n        \n        # Overall statistics\n        lines.append(f\"\\nAnalysis Summary: {analysis_results['summary']}\")\n        lines.append(f\"\\nTotal objects: {analysis_results['total_count']:,d}\")\n        lines.append(f\"Objects with type data: {analysis_results['typed_count']:,d} ({analysis_results['typed_count']/analysis_results['total_count']*100:.1f}%)\")\n        lines.append(f\"Unique object types: {len(analysis_results['type_counts'])}\")\n        \n        # Diversity metrics\n        lines.append(\"\\nDiversity Metrics:\")\n        lines.append(f\"  - Diversity Score: {analysis_results['diversity_score']}/100\")\n        lines.append(f\"  - Shannon Entropy: {analysis_results['shannon_entropy']:.3f}\")\n        lines.append(f\"  - Simpson Index: {analysis_results['simpson_index']:.3f}\")\n        \n        # Category breakdown\n        lines.append(\"\\nObject Categories:\")\n        sorted_categories = sorted(\n            [(cat, count) for cat, count in analysis_results['category_counts'].items() if count > 0],\n            key=lambda x: (self.category_priority.get(x[0], 999), -x[1])\n        )\n        \n        for category, count in sorted_categories:\n            percentage = analysis_results['category_percentages'][category]\n            lines.append(f\"  - {category}: {count:,d} ({percentage:.1f}%)\")\n        \n        # Top 5 specific types\n        if analysis_results['type_counts']:\n            lines.append(\"\\nMost Common Types:\")\n            for i, (obj_type, count) in enumerate(list(analysis_results['type_counts'].items())[:5], 1):\n                display_type = obj_type if len(str(obj_type)) <= 35 else str(obj_type)[:32] + \"...\"\n                percentage = (count / analysis_results['typed_count']) * 100\n                lines.append(f\"  {i}. {display_type}: {count:,d} ({percentage:.1f}%)\")\n        \n        # Research targets (high scientific interest)\n        if analysis_results['research_targets']:\n            lines.append(\"\\nHigh-Interest Research Targets:\")\n            for target in analysis_results['research_targets'][:5]:\n                display_type = target['type'] if len(target['type']) <= 30 else target['type'][:27] + \"...\"\n                lines.append(f\"  - {display_type}: {target['count']} (interest: {target['interest_score']}/10)\")\n        \n        # Notable/rare objects\n        if analysis_results['notable_objects']:\n            lines.append(\"\\nRare/Notable Objects:\")\n            for obj_type, count in analysis_results['notable_objects'][:5]:\n                display_type = obj_type if len(str(obj_type)) <= 35 else str(obj_type)[:32] + \"...\"\n                lines.append(f\"  - {display_type}: {count}\")\n        \n        return lines\n    \n    def export_analysis(self, analysis_results: Dict, filename: Optional[str] = None) -> str:\n        \"\"\"\n        Export detailed analysis results to a file for research use.\n        \n        Args:\n            analysis_results: Results from analyze_distribution\n            filename: Optional output filename\n            \n        Returns:\n            Path to exported file\n        \"\"\"\n        if filename is None:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"object_type_analysis_{timestamp}.txt\"\n        \n        with open(filename, 'w') as f:\n            f.write(\"ASTRONOMICAL OBJECT TYPE ANALYSIS REPORT\\n\")\n            f.write(\"=\" * 60 + \"\\n\")\n            f.write(f\"Generated: {analysis_results['timestamp']}\\n\")\n            f.write(\"=\" * 60 + \"\\n\\n\")\n            \n            # Write formatted report\n            lines = self.format_report_section(analysis_results)\n            for line in lines:\n                f.write(line + \"\\n\")\n            \n            # Add complete type distribution for research\n            f.write(\"\\n\" + \"=\" * 60 + \"\\n\")\n            f.write(\"COMPLETE TYPE DISTRIBUTION\\n\")\n            f.write(\"=\" * 60 + \"\\n\")\n            for obj_type, count in analysis_results['type_counts'].items():\n                f.write(f\"{obj_type}: {count}\\n\")\n        \n        return filename\n\n    \n    def generate_complete_report(self, \n                                combined_df: pd.DataFrame,\n                                counts_dict: Dict = None,\n                                processing_times: Dict = None,\n                                mode: str = 'magnitude',\n                                limit_value: float = None) -> Dict[str, Any]:\n        \"\"\"\n        Generate a complete report data structure for the plot.\n        \n        Args:\n            combined_df: DataFrame with all star data\n            counts_dict: Dictionary with catalog counts\n            processing_times: Processing time information\n            mode: 'magnitude' or 'distance'\n            limit_value: Magnitude or distance limit\n            \n        Returns:\n            Dictionary containing all report sections\n        \"\"\"\n        report = {\n            'metadata': {\n                'mode': mode,\n                'limit_value': limit_value,\n                'total_stars': len(combined_df),\n                'generation_time': datetime.now().isoformat(),\n                'generated_by': 'visualization_script'\n            },\n            'sections': {}\n        }\n        \n        # Section 1: Basic Statistics\n        report['sections']['basic_stats'] = self._generate_basic_stats(\n            combined_df, counts_dict, mode, limit_value\n        )\n        \n        # Section 2: Data Completeness\n        report['sections']['completeness'] = self._generate_completeness_metrics(\n            combined_df\n        )\n        \n        # Section 3: Data Quality\n        report['sections']['quality'] = self._generate_quality_indicators(\n            combined_df\n        )\n        \n        # Section 4: Catalog Coverage\n        report['sections']['catalog_coverage'] = self._generate_catalog_coverage(\n            combined_df\n        )\n        \n        # Section 5: Processing Diagnostics\n        report['sections']['processing'] = processing_times or {'total': 0}\n        \n        # Section 6: Object Type Analysis\n        report['sections']['object_analysis'] = self._generate_object_type_analysis(\n            combined_df\n        )\n        \n        # Section 7: Warnings and Recommendations\n        report['sections']['warnings'] = self._generate_warnings_and_recommendations(\n            combined_df\n        )\n        \n        return report\n    \n    def _generate_basic_stats(self, df: pd.DataFrame, counts_dict: Dict, \n                              mode: str, limit_value: float) -> Dict:\n        \"\"\"Generate basic statistics section.\"\"\"\n        stats = {\n            'total_stars': len(df),\n            'mode': mode,\n            'limit_value': limit_value,\n            'catalog_distribution': {}\n        }\n        \n        if counts_dict:\n            stats['catalog_distribution'] = counts_dict\n        else:\n            # Calculate from dataframe if not provided\n            if 'Source_Catalog' in df.columns:\n                stats['catalog_distribution'] = df['Source_Catalog'].value_counts().to_dict()\n        \n        return stats\n    \n    def _generate_completeness_metrics(self, df: pd.DataFrame) -> Dict:\n        \"\"\"Generate data completeness metrics.\"\"\"\n        metrics = {}\n        \n        # Temperature completeness\n        if 'Temperature' in df.columns:\n            temp_valid = df['Temperature'].notna().sum()\n            temp_missing = df['Temperature'].isna().sum()\n            metrics['temperature'] = {\n                'valid': int(temp_valid),\n                'missing': int(temp_missing),\n                'percentage': round(temp_valid / len(df) * 100, 1) if len(df) > 0 else 0\n            }\n        \n        # Luminosity completeness\n        if 'Luminosity' in df.columns:\n            lum_valid = df['Luminosity'].notna().sum()\n            lum_missing = df['Luminosity'].isna().sum()\n            metrics['luminosity'] = {\n                'valid': int(lum_valid),\n                'missing': int(lum_missing),\n                'percentage': round(lum_valid / len(df) * 100, 1) if len(df) > 0 else 0\n            }\n        \n        # Temperature source breakdown\n        if 'Temperature_Method' in df.columns:\n            methods = df['Temperature_Method'].value_counts().to_dict()\n            metrics['temperature_sources'] = {k: int(v) for k, v in methods.items()}\n        \n        # Plottable stars\n        if 'Temperature' in df.columns and 'Luminosity' in df.columns:\n            plottable = df['Temperature'].notna() & df['Luminosity'].notna()\n            metrics['plottable'] = {\n                'count': int(plottable.sum()),\n                'percentage': round(plottable.sum() / len(df) * 100, 1) if len(df) > 0 else 0\n            }\n        \n        return metrics\n    \n    def _generate_quality_indicators(self, df: pd.DataFrame) -> Dict:\n        \"\"\"Generate data quality indicators.\"\"\"\n        indicators = {\n            'anomalies': [],\n            'statistics': {}\n        }\n        \n        # Check for temperature anomalies\n        if 'Temperature' in df.columns:\n            temp = df['Temperature'].dropna()\n            if len(temp) > 0:\n                # Extreme temperatures\n                very_hot = (temp > 40000).sum()\n                very_cool = (temp < 2000).sum()\n                \n                if very_hot > 0:\n                    indicators['anomalies'].append({\n                        'type': 'extreme_temperature',\n                        'description': f'{very_hot} stars with T > 40,000 K',\n                        'severity': 'info'\n                    })\n                \n                if very_cool > 0:\n                    indicators['anomalies'].append({\n                        'type': 'extreme_temperature',\n                        'description': f'{very_cool} stars with T < 2,000 K',\n                        'severity': 'info'\n                    })\n                \n                indicators['statistics']['temperature'] = {\n                    'min': float(temp.min()),\n                    'max': float(temp.max()),\n                    'mean': float(temp.mean()),\n                    'median': float(temp.median())\n                }\n        \n        # Check parallax quality if available\n        if 'e_Plx' in df.columns and 'Plx' in df.columns:\n            parallax_quality = df['e_Plx'] / df['Plx'].abs()\n            high_error = (parallax_quality > 0.2).sum()\n            if high_error > 0:\n                indicators['anomalies'].append({\n                    'type': 'parallax_uncertainty',\n                    'description': f'{high_error} stars with parallax error > 20%',\n                    'severity': 'warning'\n                })\n        \n        return indicators\n    \n    def _generate_catalog_coverage(self, df: pd.DataFrame) -> Dict:\n        \"\"\"Generate catalog coverage analysis.\"\"\"\n        coverage = {}\n        \n        if 'Source_Catalog' in df.columns:\n            catalog_counts = df['Source_Catalog'].value_counts()\n            total = len(df)\n            \n            coverage['sources'] = {}\n            for catalog, count in catalog_counts.items():\n                coverage['sources'][catalog] = {\n                    'count': int(count),\n                    'percentage': round(count / total * 100, 1) if total > 0 else 0\n                }\n        \n        # Add magnitude distribution if available\n        if 'Apparent_Magnitude' in df.columns:\n            mag = df['Apparent_Magnitude'].dropna()\n            if len(mag) > 0:\n                coverage['magnitude_stats'] = {\n                    'min': float(mag.min()),\n                    'max': float(mag.max()),\n                    'mean': float(mag.mean())\n                }\n        \n        return coverage\n    \n    def _generate_object_type_analysis(self, df: pd.DataFrame) -> Dict:\n        \"\"\"Generate object type analysis section.\"\"\"\n        # Look for object type column\n        type_column = None\n        if 'Object_Type_Desc' in df.columns:\n            type_column = 'Object_Type_Desc'\n        elif 'Object_Type' in df.columns:\n            type_column = 'Object_Type'\n        \n        if type_column and df[type_column].notna().any():\n            # Use existing analyze_distribution method\n            return self.analyze_distribution(df[type_column])\n        \n        return {\n            'summary': 'No object type information available',\n            'total_count': 0,\n            'typed_count': 0,\n            'category_counts': {},\n            'category_percentages': {},\n            'type_counts': {},\n            'notable_objects': [],\n            'diversity_score': 0\n        }\n    \n    def _generate_warnings_and_recommendations(self, df: pd.DataFrame) -> List[Dict]:\n        \"\"\"Generate warnings and recommendations.\"\"\"\n        warnings = []\n        \n        # Check data size\n        if len(df) < 2:\n            warnings.append({\n                'level': 'critical',\n                'message': f'Only {len(df)} star(s) in dataset - insufficient for meaningful visualization',\n                'recommendation': 'Increase magnitude limit or distance range'\n            })\n        elif len(df) < 10:\n            warnings.append({\n                'level': 'warning',\n                'message': f'Limited dataset with only {len(df)} stars',\n                'recommendation': 'Consider expanding search criteria for richer visualization'\n            })\n        \n        # Check completeness\n        if 'Temperature' in df.columns:\n            temp_complete = df['Temperature'].notna().sum() / len(df) * 100\n            if temp_complete < 50:\n                warnings.append({\n                    'level': 'warning',\n                    'message': f'Low temperature completeness ({temp_complete:.1f}%)',\n                    'recommendation': 'Many stars lack temperature data'\n                })\n        \n        # Check for catalog bias\n        if 'Source_Catalog' in df.columns:\n            catalog_counts = df['Source_Catalog'].value_counts()\n            if len(catalog_counts) == 1:\n                warnings.append({\n                    'level': 'info',\n                    'message': f'Data from single catalog only ({catalog_counts.index[0]})',\n                    'recommendation': 'Results may be biased to catalog selection criteria'\n                })\n        \n        return warnings if warnings else [{'level': 'ok', 'message': 'No warnings - data quality appears good'}]\n    \n    def format_complete_report(self, report_data: Dict) -> List[str]:\n        \"\"\"\n        Format a complete report from report data structure.\n        \n        Args:\n            report_data: Dictionary from generate_complete_report\n            \n        Returns:\n            List of formatted report lines\n        \"\"\"\n        lines = []\n        \n        # Header\n        lines.append(\"=\" * 46)\n        lines.append(\"PLOT DATA REPORT\")\n        lines.append(\"=\" * 46)\n        \n        metadata = report_data.get('metadata', {})\n        lines.append(f\"Generated: {metadata.get('generation_time', 'Unknown')}\")\n        lines.append(f\"Plot Mode: {metadata.get('mode', 'Unknown')}\")\n        \n        if metadata.get('mode') == 'magnitude':\n            lines.append(f\"Limiting Magnitude: {metadata.get('limit_value', 'Unknown')}\")\n        else:\n            lines.append(f\"Distance Limit: {metadata.get('limit_value', 'Unknown')} ly\")\n        \n        sections = report_data.get('sections', {})\n        \n        # Section 1: Basic Statistics\n        if 'basic_stats' in sections:\n            lines.append(\"\\n\" + \"-\" * 52)\n            lines.append(\"1. BASIC PLOT STATISTICS\")\n            lines.append(\"-\" * 52)\n            stats = sections['basic_stats']\n            lines.append(f\"Total Stars in Dataset: {stats.get('total_stars', 0)}\")\n            \n            if 'catalog_distribution' in stats:\n                lines.append(\"\\nCatalog Distribution:\")\n                for catalog, count in stats['catalog_distribution'].items():\n                    percentage = (count / stats['total_stars'] * 100) if stats['total_stars'] > 0 else 0\n                    lines.append(f\"  {catalog}: {count} ({percentage:.1f}%)\")\n        \n        # Section 2: Data Completeness\n        if 'completeness' in sections:\n            lines.append(\"\\n\" + \"-\" * 52)\n            lines.append(\"2. DATA COMPLETENESS METRICS\")\n            lines.append(\"-\" * 52)\n            comp = sections['completeness']\n            \n            if 'temperature' in comp:\n                t = comp['temperature']\n                lines.append(f\"\\nTemperature Data:\")\n                lines.append(f\"  Valid: {t['valid']} ({t['percentage']:.1f}%)\")\n                lines.append(f\"  Missing: {t['missing']}\")\n            \n            if 'luminosity' in comp:\n                l = comp['luminosity']\n                lines.append(f\"\\nLuminosity Data:\")\n                lines.append(f\"  Valid: {l['valid']} ({l['percentage']:.1f}%)\")\n                lines.append(f\"  Missing: {l['missing']}\")\n        \n        # Section 6: Object Type Analysis\n        if 'object_analysis' in sections:\n            lines.append(\"\\n\" + \"-\" * 52)\n            lines.append(\"6. OBJECT TYPE ANALYSIS\")\n            lines.append(\"-\" * 52)\n            analysis = sections['object_analysis']\n            lines.extend(self.format_report_section(analysis))\n        \n        # Section 7: Warnings\n        if 'warnings' in sections:\n            lines.append(\"\\n\" + \"-\" * 52)\n            lines.append(\"7. WARNINGS AND RECOMMENDATIONS\")\n            lines.append(\"-\" * 52)\n            for warning in sections['warnings']:\n                if warning['level'] == 'ok':\n                    lines.append(f\"\\nOK: {warning['message']}\")\n                else:\n                    level = warning['level'].upper()\n                    lines.append(f\"\\n{level}: {warning['message']}\")\n                    if 'recommendation' in warning:\n                        lines.append(f\"  -> {warning['recommendation']}\")\n        \n        # Footer\n        lines.append(\"\\n\" + \"=\" * 46)\n        lines.append(\"END OF REPORT\")\n        lines.append(\"=\" * 46)\n        \n        return lines",
    "start_line": 47,
    "end_line": 862,
    "has_docstring": true,
    "docstring": "Analyzer for categorizing and analyzing astronomical object types.\nProvides research-grade statistical analysis of stellar populations.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class ObjectTypeAnalyzer",
    "component_id": "object_type_analyzer.ObjectTypeAnalyzer"
  },
  "object_type_analyzer.analyze_sample_data": {
    "id": "object_type_analyzer.analyze_sample_data",
    "name": "analyze_sample_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\object_type_analyzer.py",
    "relative_path": "object_type_analyzer.py",
    "depends_on": [
      "object_type_analyzer.ObjectTypeAnalyzer"
    ],
    "source_code": "def analyze_sample_data():\n    \"\"\"Test function to demonstrate the analyzer.\"\"\"\n    # Create sample data\n    sample_types = pd.Series([\n        'V*', 'V*', 'RRLyr', 'Cepheid', 'Mira',  # Variables\n        'SB*', '**', 'ContactBin',  # Binaries\n        'RedGiant', 'WhiteDwarf', 'AGB*',  # Evolved\n        'YSO', 'TTauri*',  # Young\n        'WolfRayet*', 'Be*',  # Peculiar\n        'Star', 'Star', 'Star', 'Star', 'Star',  # Normal\n        'Unknown', None, 'nan'  # Invalid\n    ] * 10)  # Multiply for larger sample\n    \n    analyzer = ObjectTypeAnalyzer()\n    results = analyzer.analyze_distribution(sample_types)\n    \n    print(\"OBJECT TYPE ANALYSIS TEST\")\n    print(\"=\" * 50)\n    for line in analyzer.format_report_section(results):\n        print(line)\n    \n    return results",
    "start_line": 865,
    "end_line": 886,
    "has_docstring": true,
    "docstring": "Test function to demonstrate the analyzer.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function analyze_sample_data",
    "component_id": "object_type_analyzer.analyze_sample_data"
  },
  "orbit_data_manager.repair_cache_on_load": {
    "id": "orbit_data_manager.repair_cache_on_load",
    "name": "repair_cache_on_load",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [],
    "source_code": "def repair_cache_on_load():\n    \"\"\"Load cache and remove only corrupted entries\"\"\"\n#    if not os.path.exists('orbit_paths.json'):\n    if not os.path.exists('data/orbit_paths.json'):    \n        return {}\n    \n    try:\n#        with open('orbit_paths.json', 'r') as f:\n        with open('data/orbit_paths.json', 'r') as f:\n            cache_data = json.load(f)\n        \n        # Track what we remove\n        removed_entries = []\n        cleaned_cache = {}\n        \n        for orbit_key, orbit_data in cache_data.items():\n            try:\n                # Validate this entry\n                if isinstance(orbit_data, dict) and (\n                    'data_points' in orbit_data or  # New format\n                    ('x' in orbit_data and 'y' in orbit_data and 'z' in orbit_data)  # Old format\n                ):\n                    # Entry looks good, keep it\n                    cleaned_cache[orbit_key] = orbit_data\n                else:\n                    removed_entries.append(orbit_key)\n            except Exception:\n                # Any error processing this entry = corrupted\n                removed_entries.append(orbit_key)\n        \n        if removed_entries:\n            print(f\"[CACHE REPAIR] Removed {len(removed_entries)} corrupted entries: {removed_entries}\", flush=True)\n            print(f\"[CACHE REPAIR] Kept {len(cleaned_cache)} valid entries\", flush=True)\n            \n            # Save the cleaned cache back\n    #        with open('orbit_paths.json', 'w') as f:\n            with open('data/orbit_paths.json', 'w') as f:\n                json.dump(cleaned_cache, f)\n        \n        return cleaned_cache\n        \n    except json.JSONDecodeError:\n        # Entire file is corrupted\n        print(\"[CACHE ERROR] Entire cache file corrupted, starting fresh\", flush=True)\n        return {}",
    "start_line": 41,
    "end_line": 85,
    "has_docstring": true,
    "docstring": "Load cache and remove only corrupted entries",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function repair_cache_on_load",
    "component_id": "orbit_data_manager.repair_cache_on_load"
  },
  "orbit_data_manager.initialize": {
    "id": "orbit_data_manager.initialize",
    "name": "initialize",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [
      "orbit_data_manager.load_orbit_paths"
    ],
    "source_code": "def initialize(status_widget=None, root_widget=None, center_var=None, data_file=ORBIT_PATHS_FILE):\n    \"\"\"\n    Initialize the orbit data manager by loading cached data.\n    \n    Parameters:\n        status_widget: UI widget for displaying status messages\n        root_widget: Root Tkinter widget for UI updates\n        center_var: Tkinter variable controlling center object selection\n        data_file: Path to the orbit data cache file\n    \n    Returns:\n        dict: The loaded orbit paths data\n    \"\"\"\n    global orbit_paths_over_time, status_display, root, center_object_var\n    \n    status_display = status_widget\n    root = root_widget\n    center_object_var = center_var\n    orbit_paths_over_time = load_orbit_paths(data_file)\n    return orbit_paths_over_time",
    "start_line": 87,
    "end_line": 106,
    "has_docstring": true,
    "docstring": "Initialize the orbit data manager by loading cached data.\n\nParameters:\n    status_widget: UI widget for displaying status messages\n    root_widget: Root Tkinter widget for UI updates\n    center_var: Tkinter variable controlling center object selection\n    data_file: Path to the orbit data cache file\n\nReturns:\n    dict: The loaded orbit paths data",
    "parameters": [
      "status_widget",
      "root_widget",
      "center_var",
      "data_file"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function initialize",
    "component_id": "orbit_data_manager.initialize"
  },
  "orbit_data_manager.load_orbit_paths": {
    "id": "orbit_data_manager.load_orbit_paths",
    "name": "load_orbit_paths",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [
      "orbit_data_manager.update_status",
      "orbit_data_manager.convert_single_orbit_to_new_format"
    ],
    "source_code": "def load_orbit_paths(file_path=ORBIT_PATHS_FILE):\n    \"\"\"\n    Load orbit paths from file with automatic repair of corrupted entries.\n    \n    Parameters:\n        file_path: Path to the orbit paths data file\n        \n    Returns:\n        dict: The loaded orbit paths data, with corrupted entries removed\n    \"\"\"\n    print(f\"\\n{'='*60}\", flush=True)\n    print(f\"LOADING ORBIT CACHE FROM: {file_path}\", flush=True)\n    print(f\"{'='*60}\\n\", flush=True)\n\n    global status_display\n    \n    try:\n        with open(file_path, \"r\") as f:\n            data = json.load(f)\n            \n        if not isinstance(data, dict):\n            error_msg = \"[CACHE ERROR] Cache file has invalid structure, starting fresh\"\n            print(error_msg, flush=True)\n            update_status(error_msg)\n            return {}\n            \n        # Validate and clean the data\n        cleaned_data = {}\n        removed_entries = []\n        total_entries = len(data)\n        \n        for orbit_key, orbit_data in data.items():\n            try:\n                # Basic validation\n                if not isinstance(orbit_data, dict):\n                    removed_entries.append((orbit_key, \"Not a dictionary\"))\n                    continue\n                \n                # Check for new format (time-indexed with data_points)\n                if \"data_points\" in orbit_data:\n                    if not isinstance(orbit_data[\"data_points\"], dict):\n                        removed_entries.append((orbit_key, \"Invalid data_points structure\"))\n                        continue\n                    \n                    # Validate at least one data point\n                    if orbit_data[\"data_points\"]:\n                        sample_key = next(iter(orbit_data[\"data_points\"]))\n                        sample_point = orbit_data[\"data_points\"][sample_key]\n                        \n                        if not isinstance(sample_point, dict) or \\\n                           not all(k in sample_point for k in ['x', 'y', 'z']):\n                            removed_entries.append((orbit_key, \"Invalid data point structure\"))\n                            continue\n                    \n                    # Valid new format\n                    cleaned_data[orbit_key] = orbit_data\n                    \n                # Check for old format (arrays)\n                elif all(k in orbit_data for k in ['x', 'y', 'z']):\n                    # Validate arrays\n                    if not all(isinstance(orbit_data[k], list) for k in ['x', 'y', 'z']):\n                        removed_entries.append((orbit_key, \"Invalid coordinate arrays\"))\n                        continue\n                        \n                    # Check lengths match\n                    x_len = len(orbit_data['x'])\n                    y_len = len(orbit_data['y'])\n                    z_len = len(orbit_data['z'])\n                    \n                    if x_len != y_len or y_len != z_len:\n                        removed_entries.append((orbit_key, f\"Mismatched array lengths: x={x_len}, y={y_len}, z={z_len}\"))\n                        continue\n                        \n                    if x_len == 0:\n                        removed_entries.append((orbit_key, \"Empty coordinate arrays\"))\n                        continue\n                    \n                    if orbit_key not in _conversion_messages_shown and _startup_complete:\n                        print(f\"Converting old format data for {orbit_key}\", flush=True)\n                        _conversion_messages_shown.add(orbit_key)\n\n                    converted = convert_single_orbit_to_new_format(orbit_key, orbit_data)\n                    if converted:\n                        cleaned_data[orbit_key] = converted\n                    else:\n                        removed_entries.append((orbit_key, \"Failed to convert old format\"))\n                        \n                else:\n                    removed_entries.append((orbit_key, \"Missing required data fields\"))\n                    \n            except Exception as e:\n                removed_entries.append((orbit_key, f\"Validation error: {str(e)}\"))\n        \n        # Report what was cleaned\n        if removed_entries:\n            # Console output\n            print(f\"\\n[CACHE REPAIR] Removed {len(removed_entries)} corrupted entries out of {total_entries}:\", flush=True)\n            for entry, reason in removed_entries[:5]:\n                print(f\"  - {entry}: {reason}\", flush=True)\n            if len(removed_entries) > 5:\n                print(f\"  ... and {len(removed_entries) - 5} more\", flush=True)\n            print(f\"[CACHE REPAIR] Keeping {len(cleaned_data)} valid entries\", flush=True)\n            \n            # Status display output\n            status_msg = f\"Cache repaired: removed {len(removed_entries)} corrupted entries, kept {len(cleaned_data)} valid\"\n            update_status(status_msg)\n            \n            # Save cleaned data back to file\n        #    save_orbit_paths(cleaned_data, file_path)  # removed for avoid cache overwrites\n            print(f\"\\n[SAFETY] Auto-save DISABLED. Original file preserved.\", flush=True)\n            print(f\"[SAFETY] If entries are truly corrupted, use verify_orbit_cache.py to repair safely.\", flush=True)        \n        else:\n            # Report success\n            if total_entries > 0:\n                status_msg = f\"Cache loaded successfully: {total_entries} valid entries\"\n                update_status(status_msg)\n        \n        return cleaned_data\n            \n    except FileNotFoundError:\n        # Try backup files before giving up\n        backup_file = file_path + '.backup'\n        backup_old_file = file_path + '.backup_old'\n        \n        # Try backup first\n        if os.path.exists(backup_file):\n            try:\n                with open(backup_file, 'r') as f:\n                    data = json.load(f)\n                print(f\"[OK] Recovered from {os.path.basename(backup_file)}\", flush=True)\n                update_status(f\"Recovered from backup file\")\n                \n                # Restore to main file\n                shutil.copy2(backup_file, file_path)\n                return data\n            except Exception as e:\n                print(f\"[WARN] Backup also unavailable: {e}\", flush=True)\n        \n        # Try old backup\n        if os.path.exists(backup_old_file):\n            try:\n                with open(backup_old_file, 'r') as f:\n                    data = json.load(f)\n                print(f\"[OK] Recovered from {os.path.basename(backup_old_file)}\", flush=True)\n                update_status(f\"Recovered from old backup file\")\n                \n                # Restore to main file\n                shutil.copy2(backup_old_file, file_path)\n                return data\n            except Exception as e:\n                print(f\"[WARN] Old backup also unavailable: {e}\", flush=True)\n        \n        # All failed - truly no existing file\n        msg = f\"No existing orbit paths file found at {file_path}, creating new cache.\"\n        print(msg, flush=True)\n        update_status(\"Starting with fresh cache (no existing file found)\")\n        return {}\n        \n    except json.JSONDecodeError as e:\n        error_msg = f\"[CACHE ERROR] Cache file is corrupted: {e}\"\n        print(error_msg, flush=True)\n        \n        # Before giving up, try the backup hierarchy\n        backup_file = file_path + '.backup'\n        backup_old_file = file_path + '.backup_old'\n        \n        # Try backup first\n        if os.path.exists(backup_file):\n            try:\n                with open(backup_file, 'r') as f:\n                    data = json.load(f)\n                print(f\"[OK] Recovered from {os.path.basename(backup_file)}\", flush=True)\n                update_status(\"Recovered from backup after corruption\")\n                \n                # Save the corrupted main file\n                corrupted_name = file_path + '.corrupted.' + datetime.now().strftime('%Y%m%d_%H%M%S')\n                shutil.move(file_path, corrupted_name)\n                print(f\"Corrupted file saved as: {corrupted_name}\", flush=True)\n                \n                # Restore backup to main\n                shutil.copy2(backup_file, file_path)\n                return data\n            except Exception as backup_e:\n                print(f\"[WARN] Backup also corrupted: {backup_e}\", flush=True)\n        \n        # Try old backup\n        if os.path.exists(backup_old_file):\n            try:\n                with open(backup_old_file, 'r') as f:\n                    data = json.load(f)\n                print(f\"[OK] Recovered from {os.path.basename(backup_old_file)}\", flush=True)\n                update_status(\"Recovered from old backup after double corruption\")\n                \n                # Save the corrupted main file\n                corrupted_name = file_path + '.corrupted.' + datetime.now().strftime('%Y%m%d_%H%M%S')\n                shutil.move(file_path, corrupted_name)\n                print(f\"Corrupted file saved as: {corrupted_name}\", flush=True)\n                \n                # Restore old backup to main\n                shutil.copy2(backup_old_file, file_path)\n                return data\n            except Exception as old_backup_e:\n                print(f\"[FAIL] All backups corrupted: {old_backup_e}\", flush=True)\n        \n        # All failed - save corrupted file and start fresh\n        update_status(\"All cache files corrupted - starting fresh\")\n        backup_name = file_path + '.corrupted.' + datetime.now().strftime('%Y%m%d_%H%M%S')\n        try:\n            shutil.move(file_path, backup_name)\n            print(f\"[CACHE BACKUP] Corrupted file saved as: {backup_name}\", flush=True)\n        except Exception as backup_error:\n            print(f\"[CACHE BACKUP] Could not backup corrupted file: {backup_error}\")\n        \n        return {}\n        \n    except Exception as e:\n        error_msg = f\"Error loading orbit paths: {e}\"\n        print(error_msg, flush=True)\n        update_status(\"Error loading cache - check console for details\")\n        traceback.print_exc()\n        return {}",
    "start_line": 108,
    "end_line": 328,
    "has_docstring": true,
    "docstring": "Load orbit paths from file with automatic repair of corrupted entries.\n\nParameters:\n    file_path: Path to the orbit paths data file\n    \nReturns:\n    dict: The loaded orbit paths data, with corrupted entries removed",
    "parameters": [
      "file_path"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_orbit_paths",
    "component_id": "orbit_data_manager.load_orbit_paths"
  },
  "orbit_data_manager.convert_single_orbit_to_new_format": {
    "id": "orbit_data_manager.convert_single_orbit_to_new_format",
    "name": "convert_single_orbit_to_new_format",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [],
    "source_code": "def convert_single_orbit_to_new_format(orbit_key, orbit_data):\n    \"\"\"\n    Convert a single orbit from old format to new format.\n    \n    Parameters:\n        orbit_key: The key for this orbit (e.g., \"Mars_Sun\")\n        orbit_data: The old format data with x, y, z arrays\n        \n    Returns:\n        dict: Converted data in new format or None if conversion fails\n    \"\"\"\n\n    global _conversion_messages_shown\n    \n    if orbit_key not in _conversion_messages_shown:\n        print(f\"Converting old format data for {orbit_key}\", flush=True)\n        _conversion_messages_shown.add(orbit_key)\n    \n    try:\n        # Extract object and center names\n        if \"_\" in orbit_key:\n            obj_name, center_name = orbit_key.split(\"_\", 1)\n        else:\n            obj_name, center_name = orbit_key, \"Sun\"\n        \n        # Get coordinate arrays\n        x_coords = orbit_data['x']\n        y_coords = orbit_data['y']\n        z_coords = orbit_data['z']\n        \n        num_points = len(x_coords)\n        if num_points == 0:\n            return None\n            \n        # Generate synthetic dates\n        today = datetime.today()\n        days_span = DEFAULT_DAYS_AHEAD\n        days_between = days_span / (num_points - 1) if num_points > 1 else 1\n        \n        data_points = {}\n        for i in range(num_points):\n            point_date = today - timedelta(days=days_span/2) + timedelta(days=i * days_between)\n            date_str = point_date.strftime(\"%Y-%m-%d\")\n            \n            data_points[date_str] = {\n                \"x\": x_coords[i],\n                \"y\": y_coords[i],\n                \"z\": z_coords[i]\n            }\n        \n        return {\n            \"data_points\": data_points,\n            \"metadata\": {\n                \"start_date\": (today - timedelta(days=days_span/2)).strftime(\"%Y-%m-%d\"),\n                \"end_date\": (today + timedelta(days=days_span/2)).strftime(\"%Y-%m-%d\"),\n                \"center_body\": center_name,\n                \"last_updated\": today.strftime(\"%Y-%m-%d\"),\n                \"converted_from_old_format\": True\n            }\n        }\n        \n    except Exception as e:\n        print(f\"Error converting orbit {orbit_key}: {e}\", flush=True)\n        return None",
    "start_line": 330,
    "end_line": 393,
    "has_docstring": true,
    "docstring": "Convert a single orbit from old format to new format.\n\nParameters:\n    orbit_key: The key for this orbit (e.g., \"Mars_Sun\")\n    orbit_data: The old format data with x, y, z arrays\n    \nReturns:\n    dict: Converted data in new format or None if conversion fails",
    "parameters": [
      "orbit_key",
      "orbit_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function convert_single_orbit_to_new_format",
    "component_id": "orbit_data_manager.convert_single_orbit_to_new_format"
  },
  "orbit_data_manager.save_orbit_paths": {
    "id": "orbit_data_manager.save_orbit_paths",
    "name": "save_orbit_paths",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [
      "orbit_data_manager.update_status"
    ],
    "source_code": "def save_orbit_paths(data=None, file_path=ORBIT_PATHS_FILE):\n    \"\"\"\n    Save orbit paths data to file with safety checks.\n    \n    Parameters:\n        data: Orbit paths data to save (defaults to global orbit_paths_over_time)\n        file_path: Path to save the data to\n    \"\"\"\n    global orbit_paths_over_time\n    \n    if data is None:\n        data = orbit_paths_over_time\n    \n    # ENHANCED SAFETY CHECK: Cache should never shrink significantly (we don't prune)\n    if os.path.exists(file_path):\n        try:\n            existing_size = os.path.getsize(file_path)\n            existing_size_mb = existing_size / (1024 * 1024)\n            \n            # Serialize data to check its size\n            data_str = json.dumps(data)\n            new_size = len(data_str.encode('utf-8'))\n            new_size_mb = new_size / (1024 * 1024)\n            \n            # Count entries for better diagnostics\n            try:\n                with open(file_path, 'r') as f:\n                    existing_data = json.load(f)\n                    existing_entry_count = len(existing_data)\n            except:\n                existing_entry_count = \"unknown\"\n            \n            new_entry_count = len(data)\n            \n            # Calculate reduction percentage\n            size_reduction_percent = ((existing_size - new_size) / existing_size * 100) if existing_size > 0 else 0\n            \n            # CRITICAL: Any reduction > 5% is suspicious (cache should only grow)\n            if existing_size_mb > 1 and size_reduction_percent > 5:\n                error_msg = (\n                    f\"\\n{'='*70}\\n\"\n                    f\"CRITICAL: BLOCKED CACHE OVERWRITE - SIZE REDUCTION DETECTED\\n\"\n                    f\"{'='*70}\\n\"\n                    f\"Existing: {existing_size_mb:.1f} MB ({existing_entry_count} entries)\\n\"\n                    f\"New data: {new_size_mb:.1f} MB ({new_entry_count} entries)\\n\"\n                    f\"Reduction: {size_reduction_percent:.1f}%\\n\"\n                    f\"\\n\"\n                    f\"This cache never prunes old data - it should only grow.\\n\"\n                    f\"Size reduction indicates:\\n\"\n                    f\"  - Validation incorrectly rejected entries during load\\n\"\n                    f\"  - orbit_paths_over_time global wasn't fully loaded\\n\"\n                    f\"  - Cache corruption or processing bug\\n\"\n                    f\"\\n\"\n                    f\"SAVE BLOCKED - Original cache preserved at {file_path}\\n\"\n                    f\"{'='*70}\\n\"\n                )\n                print(error_msg, flush=True)\n                \n                # Create emergency backup\n                emergency_backup = file_path + '.emergency_' + datetime.now().strftime('%Y%m%d_%H%M%S')\n                shutil.copy2(file_path, emergency_backup)\n                print(f\"[EMERGENCY BACKUP] Created: {emergency_backup}\", flush=True)\n                \n                # Update status if available\n                update_status(f\"SAVE BLOCKED: Cache shrunk by {size_reduction_percent:.1f}%\")\n                \n                # Stop the save operation\n                raise ValueError(f\"Safety check failed: Cache reduced by {size_reduction_percent:.1f}%\")\n                \n        except ValueError:\n            raise  # Re-raise our safety exception\n        except (OSError, IOError) as e:\n            print(f\"[WARNING] Could not perform safety check: {e}\", flush=True)\n    \n    # Create a temporary file first\n    temp_file = file_path + '.tmp'\n    backup_file = file_path + '.backup'\n    backup_old_file = file_path + '.backup_old'  # NEW - second generation\n    \n    try:\n        # Step 1: Write to temporary file\n        with open(temp_file, 'w') as f:\n            json.dump(data, f)\n        \n        # Step 2: Verify the temp file was written correctly\n        with open(temp_file, 'r') as f:\n            json.load(f)  # This will raise an exception if JSON is invalid\n        \n        # Step 3: Rotate backups: backup [OK] backup_old\n        if os.path.exists(backup_file):\n            if os.path.exists(backup_old_file):\n                os.remove(backup_old_file)  # Remove oldest backup\n            shutil.copy2(backup_file, backup_old_file)  # Preserve backup as backup_old\n            print(f\"  Rotated: {os.path.basename(backup_file)} [OK] {os.path.basename(backup_old_file)}\", flush=True)\n        \n        # Step 4: Current [OK] backup\n        if os.path.exists(file_path):\n            shutil.copy2(file_path, backup_file)  # Copy (not move) current to backup\n            print(f\"  Backed up: {os.path.basename(file_path)} [OK] {os.path.basename(backup_file)}\", flush=True)\n        \n        # Step 5: Temp [OK] current (atomic on most systems)\n        shutil.move(temp_file, file_path)\n        \n        print(f\"[OK] Saved: {os.path.basename(file_path)} (2-gen protected)\", flush=True)\n        \n        # NOTE: We do NOT delete backups - they persist as safety nets!    \n            \n    except Exception as e:\n        print(f\"Error saving orbit paths: {e}\", flush=True)\n        \n        # Try to restore from backup\n        if os.path.exists(backup_file):\n            try:\n                shutil.copy2(backup_file, file_path)\n                print(f\"[RECOVERY] Restored from backup after save failure\", flush=True)\n            except Exception as restore_error:\n                print(f\"[CRITICAL] Could not restore backup: {restore_error}\", flush=True)\n        \n        # Clean up temp file if it exists\n        if os.path.exists(temp_file):\n            try:\n                os.remove(temp_file)\n            except:\n                pass\n                \n        traceback.print_exc()\n        raise  # Re-raise the exception",
    "start_line": 397,
    "end_line": 523,
    "has_docstring": true,
    "docstring": "Save orbit paths data to file with safety checks.\n\nParameters:\n    data: Orbit paths data to save (defaults to global orbit_paths_over_time)\n    file_path: Path to save the data to",
    "parameters": [
      "data",
      "file_path"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function save_orbit_paths",
    "component_id": "orbit_data_manager.save_orbit_paths"
  },
  "orbit_data_manager.convert_to_new_format": {
    "id": "orbit_data_manager.convert_to_new_format",
    "name": "convert_to_new_format",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [],
    "source_code": "def convert_to_new_format(old_data):\n    \"\"\"\n    Convert old format orbit data to new time-indexed format.\n    \n    Parameters:\n        old_data: Dictionary containing orbit data in old format\n        \n    Returns:\n        dict: Converted data in new time-indexed format\n    \"\"\"\n    new_data = {}\n    today = datetime.today()\n    today_str = today.strftime(\"%Y-%m-%d\")\n    \n    print(\"Converting orbit data to new time-indexed format...\", flush=True)\n    \n    for key, coords in old_data.items():\n        # Skip entries that don't have coordinate data\n        if not isinstance(coords, dict) or \"x\" not in coords:\n            continue\n            \n        # Extract object and center names from key\n        if \"_\" in key:\n            obj_name, center_name = key.split(\"_\", 1)\n        else:\n            obj_name, center_name = key, \"Sun\"  # Default for backward compatibility\n            \n        # Create synthetic dates for the points (estimate)\n        num_points = len(coords.get(\"x\", []))\n        if num_points > 0:\n            # Assume points cover a 2-year period\n            days_between = DEFAULT_DAYS_AHEAD / (num_points - 1) if num_points > 1 else 1\n            \n            data_points = {}\n            for i in range(num_points):\n                point_date = today - timedelta(days=1) + timedelta(days=i * days_between)\n                date_str = point_date.strftime(\"%Y-%m-%d\")\n                \n                # Only add the point if all coordinates are available\n                if (i < len(coords.get(\"x\", [])) and \n                    i < len(coords.get(\"y\", [])) and \n                    i < len(coords.get(\"z\", []))):\n                    \n                    data_points[date_str] = {\n                        \"x\": coords[\"x\"][i],\n                        \"y\": coords[\"y\"][i],\n                        \"z\": coords[\"z\"][i]\n                    }\n            \n            new_data[key] = {\n                \"data_points\": data_points,\n                \"metadata\": {\n                    \"earliest_date\": today.strftime(\"%Y-%m-%d\"),\n                    \"latest_date\": (today + timedelta(days=DEFAULT_DAYS_AHEAD)).strftime(\"%Y-%m-%d\"),\n                    \"center_body\": center_name,\n                    \"last_updated\": today_str,\n                    \"converted_from_legacy\": True\n                }\n            }\n    \n    print(f\"Converted {len(new_data)} orbit paths to new format.\", flush=True)\n    return new_data",
    "start_line": 525,
    "end_line": 586,
    "has_docstring": true,
    "docstring": "Convert old format orbit data to new time-indexed format.\n\nParameters:\n    old_data: Dictionary containing orbit data in old format\n    \nReturns:\n    dict: Converted data in new time-indexed format",
    "parameters": [
      "old_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function convert_to_new_format",
    "component_id": "orbit_data_manager.convert_to_new_format"
  },
  "orbit_data_manager.determine_interval_for_object": {
    "id": "orbit_data_manager.determine_interval_for_object",
    "name": "determine_interval_for_object",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [],
    "source_code": "def determine_interval_for_object(obj, orbital_params=None, parent_planets=None, center_object_name=None):    # fixes pluto as satellite issue for fetching intervals\n    \"\"\"\n    Determine appropriate time interval for fetching orbit data.\n    \n    Parameters:\n        obj: Object info dictionary\n        orbital_params: Dictionary of orbital parameters for known objects\n        parent_planets: Dictionary mapping planets to their satellites\n        \n    Returns:\n        str: Time interval string (e.g., \"1d\", \"12h\", \"6h\", \"1h\")\n    \"\"\"\n    # Handle special case for Planet 9\n    if obj.get('id') == 'planet9_placeholder':\n        return \"1d\"  # Default interval for Planet 9 (though not actually used)\n    \n    # Default interval\n    interval = \"1d\"\n    \n    # Check if this is a comet\n    if obj.get('is_comet', False):\n        interval = \"6h\"\n    \n    # Check if this is a mission\n    elif obj.get('is_mission', False):\n        interval = \"6h\"\n    \n    # Check if this is a satellite of the center object\n#    elif parent_planets and any(obj['name'] in moons for planet, moons in parent_planets.items()):\n#        interval = \"1h\"\n    \n    elif parent_planets and center_object_name and center_object_name in parent_planets:    # fixes pluto as satellite issue for fetching intervals\n        if obj['name'] in parent_planets[center_object_name]:\n            interval = \"1h\"\n\n    # Check for high eccentricity objects\n    elif orbital_params and obj['name'] in orbital_params:\n        e = orbital_params[obj['name']].get('e', 0)\n        if e > 0.5:  # High eccentricity\n            interval = \"12h\"\n    \n    return interval",
    "start_line": 590,
    "end_line": 631,
    "has_docstring": true,
    "docstring": "Determine appropriate time interval for fetching orbit data.\n\nParameters:\n    obj: Object info dictionary\n    orbital_params: Dictionary of orbital parameters for known objects\n    parent_planets: Dictionary mapping planets to their satellites\n    \nReturns:\n    str: Time interval string (e.g., \"1d\", \"12h\", \"6h\", \"1h\")",
    "parameters": [
      "obj",
      "orbital_params",
      "parent_planets",
      "center_object_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function determine_interval_for_object",
    "component_id": "orbit_data_manager.determine_interval_for_object"
  },
  "orbit_data_manager.fetch_orbit_path": {
    "id": "orbit_data_manager.fetch_orbit_path",
    "name": "fetch_orbit_path",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [
      "orbit_data_manager.calculate_planet9_orbit"
    ],
    "source_code": "def fetch_orbit_path(obj_info, start_date, end_date, interval, center_id='@0', id_type=None):\n    \"\"\"\n    Fetch orbit path data from JPL Horizons.\n    \n    Parameters:\n        obj_info: Object information dictionary\n        start_date: Start date for the orbit path\n        end_date: End date for the orbit path\n        interval: Time interval (e.g., \"1d\", \"12h\")\n        center_id: ID of the central body (default: '@0' for solar system barycenter)\n        id_type: Type of ID for the object\n        \n    Returns:\n        dict: Dictionary with keys 'x', 'y', and 'z' or None on failure\n    \"\"\"\n    # Handle special case for Planet 9 (calculated instead of fetched)\n    if obj_info.get('id') == 'planet9_placeholder':\n        return calculate_planet9_orbit(start_date, end_date, interval)\n    \n    # Skip JPL Horizons for exoplanets and binary stars - they use Keplerian orbit calculations\n    if obj_info.get('object_type') in ['exoplanet', 'exo_host_star']:\n        return None\n    if id_type in ['exoplanet', 'binary_star_a', 'binary_star_b', 'barycenter']:\n        return None    \n    \n    try:\n        # Use the object's id and id_type\n        object_id = obj_info['id']\n        \n        # Format the center_id appropriately\n        location = center_id\n        if not location.startswith('@'):\n            location = '@' + location\n        \n        # Format dates as required by Horizons\n        epochs = {\n            'start': start_date.strftime('%Y-%m-%d'),\n            'stop': end_date.strftime('%Y-%m-%d'),\n            'step': interval  # e.g. \"1d\" for one day, \"12h\" for 12 hours\n        }\n\n        # Create Horizons object and fetch vectors        \n        obj = Horizons(id=object_id, id_type=id_type, location=location, epochs=epochs)\n        eph = obj.vectors()\n        \n        # Process the ephemerides table to extract x, y, z coordinates\n        x_coords = list(eph['x'])\n        y_coords = list(eph['y'])\n        z_coords = list(eph['z'])\n        \n        return {'x': x_coords, 'y': y_coords, 'z': z_coords}\n    except Exception as e:\n        print(f\"Error fetching orbit path for {obj_info['name']}: {e}\", flush=True)\n        traceback.print_exc()\n        return None",
    "start_line": 634,
    "end_line": 688,
    "has_docstring": true,
    "docstring": "Fetch orbit path data from JPL Horizons.\n\nParameters:\n    obj_info: Object information dictionary\n    start_date: Start date for the orbit path\n    end_date: End date for the orbit path\n    interval: Time interval (e.g., \"1d\", \"12h\")\n    center_id: ID of the central body (default: '@0' for solar system barycenter)\n    id_type: Type of ID for the object\n    \nReturns:\n    dict: Dictionary with keys 'x', 'y', and 'z' or None on failure",
    "parameters": [
      "obj_info",
      "start_date",
      "end_date",
      "interval",
      "center_id",
      "id_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_orbit_path",
    "component_id": "orbit_data_manager.fetch_orbit_path"
  },
  "orbit_data_manager.calculate_planet9_orbit": {
    "id": "orbit_data_manager.calculate_planet9_orbit",
    "name": "calculate_planet9_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [],
    "source_code": "def calculate_planet9_orbit(start_date, end_date, interval):\n    \"\"\"\n    Calculate synthetic orbit for hypothetical Planet 9.\n    \n    Parameters:\n        start_date: Start date for the orbit\n        end_date: End date for the orbit\n        interval: Time interval\n        \n    Returns:\n        dict: Synthetic orbit data\n    \"\"\"\n    # Calculate days between start and end\n    days_total = (end_date - start_date).days\n    \n    # Determine number of points based on interval\n    if interval == \"1d\":\n        num_points = days_total + 1\n    elif interval == \"12h\":\n        num_points = days_total * 2 + 1\n    elif interval == \"6h\":\n        num_points = days_total * 4 + 1\n    elif interval == \"1h\":\n        num_points = days_total * 24 + 1\n    else:\n        # Default to daily\n        num_points = days_total + 1\n    \n    # Planet 9 orbital parameters (hypothetical)\n    a = 600  # Semi-major axis (AU)\n    e = 0.30  # Eccentricity\n    i = 6     # Inclination (degrees)\n    Omega = 90  # Longitude of ascending node (degrees)\n    omega = 150  # Argument of perihelion (degrees)\n    \n    # Period in years (Kepler's third law)\n    P = np.sqrt(a**3)  # Period in years\n    P_days = P * 365.25  # Period in days\n    \n    # Create time points\n    t = np.linspace(0, days_total, num_points)\n    \n    # Calculate mean anomaly at each time\n    M = 360 * t / P_days\n    \n    # Solve Kepler's equation to get eccentric anomaly (simplified)\n    # For a proper implementation, this would be an iterative solution\n    E = M + e * np.sin(np.radians(M))\n    \n    # Calculate true anomaly\n    theta = 2 * np.arctan2(np.sqrt(1 + e) * np.sin(np.radians(E/2)), \n                           np.sqrt(1 - e) * np.cos(np.radians(E/2)))\n    theta = np.degrees(theta)\n    \n    # Calculate distance from Sun\n    r = a * (1 - e**2) / (1 + e * np.cos(np.radians(theta)))\n    \n    # Calculate position in orbital plane\n    xp = r * np.cos(np.radians(theta))\n    yp = r * np.sin(np.radians(theta))\n    zp = np.zeros_like(xp)\n    \n    # Rotate to account for orbital orientation\n    # Convert angles to radians\n    i_rad = np.radians(i)\n    omega_rad = np.radians(omega)\n    Omega_rad = np.radians(Omega)\n    \n    # Initialize result arrays\n    x = np.zeros_like(xp)\n    y = np.zeros_like(yp)\n    z = np.zeros_like(zp)\n    \n    # Perform rotations for each point\n    for j in range(len(xp)):\n        # Rotate by argument of perihelion\n        x1 = xp[j] * np.cos(omega_rad) - yp[j] * np.sin(omega_rad)\n        y1 = xp[j] * np.sin(omega_rad) + yp[j] * np.cos(omega_rad)\n        \n        # Rotate by inclination\n        x2 = x1\n        y2 = y1 * np.cos(i_rad)\n        z2 = y1 * np.sin(i_rad)\n        \n        # Rotate by longitude of ascending node\n        x[j] = x2 * np.cos(Omega_rad) - y2 * np.sin(Omega_rad)\n        y[j] = x2 * np.sin(Omega_rad) + y2 * np.cos(Omega_rad)\n        z[j] = z2\n    \n    return {'x': x.tolist(), 'y': y.tolist(), 'z': z.tolist()}",
    "start_line": 691,
    "end_line": 780,
    "has_docstring": true,
    "docstring": "Calculate synthetic orbit for hypothetical Planet 9.\n\nParameters:\n    start_date: Start date for the orbit\n    end_date: End date for the orbit\n    interval: Time interval\n    \nReturns:\n    dict: Synthetic orbit data",
    "parameters": [
      "start_date",
      "end_date",
      "interval"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_planet9_orbit",
    "component_id": "orbit_data_manager.calculate_planet9_orbit"
  },
  "orbit_data_manager.calculate_planet9_position": {
    "id": "orbit_data_manager.calculate_planet9_position",
    "name": "calculate_planet9_position",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [],
    "source_code": "def calculate_planet9_position(theta_offset=75):\n    \"\"\"\n    Calculate a fixed position for Planet 9 based on our best estimate.\n    This function returns a single position rather than a full orbit.\n    \n    Parameters:\n        theta_offset: Angle offset in degrees to position Planet 9 along its orbit\n        \n    Returns:\n        tuple: (x, y, z, range_value) position and distance\n    \"\"\"\n    # Planet 9 orbital parameters\n    a = 600  # Semi-major axis (AU)\n    e = 0.30  # Eccentricity\n    i = 6     # Inclination (degrees)\n    Omega = 90  # Longitude of ascending node (degrees)\n    omega = 150  # Argument of perihelion (degrees)\n    theta = theta_offset  # True anomaly - where along the orbit the planet is positioned\n    \n    # Convert angles to radians\n    i_rad = np.radians(i)\n    omega_rad = np.radians(omega)\n    Omega_rad = np.radians(Omega)\n    theta_rad = np.radians(theta)\n    \n    # Calculate distance from Sun at this point in the orbit\n    r = a * (1 - e**2) / (1 + e * np.cos(theta_rad))\n    \n    # Calculate position in orbital plane\n    x_orbit = r * np.cos(theta_rad)\n    y_orbit = r * np.sin(theta_rad)\n    \n    # Rotate to account for orientation of orbit in 3D space\n    # First, rotate by argument of perihelion\n    x_perihelion = x_orbit * np.cos(omega_rad) - y_orbit * np.sin(omega_rad)\n    y_perihelion = x_orbit * np.sin(omega_rad) + y_orbit * np.cos(omega_rad)\n    \n    # Then, rotate to account for inclination\n    x_inclined = x_perihelion\n    y_inclined = y_perihelion * np.cos(i_rad)\n    z_inclined = y_perihelion * np.sin(i_rad)\n    \n    # Finally, rotate by longitude of ascending node\n    x = x_inclined * np.cos(Omega_rad) - y_inclined * np.sin(Omega_rad)\n    y = x_inclined * np.sin(Omega_rad) + y_inclined * np.cos(Omega_rad)\n    z = z_inclined\n    \n    # Calculate range (distance from Sun)\n    range_val = np.sqrt(x**2 + y**2 + z**2)\n    \n    return x, y, z, range_val",
    "start_line": 783,
    "end_line": 833,
    "has_docstring": true,
    "docstring": "Calculate a fixed position for Planet 9 based on our best estimate.\nThis function returns a single position rather than a full orbit.\n\nParameters:\n    theta_offset: Angle offset in degrees to position Planet 9 along its orbit\n    \nReturns:\n    tuple: (x, y, z, range_value) position and distance",
    "parameters": [
      "theta_offset"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_planet9_position",
    "component_id": "orbit_data_manager.calculate_planet9_position"
  },
  "orbit_data_manager.update_status": {
    "id": "orbit_data_manager.update_status",
    "name": "update_status",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [],
    "source_code": "def update_status(message):\n    \"\"\"\n    Update status display if available and print to console.\n    \n    Parameters:\n        message: Status message to display\n    \"\"\"\n    # Always print to console for logging\n    print(message, flush=True)\n    \n    # Update status display if available\n    global status_display, root\n    if status_display:\n        try:\n            # Check if widget still exists before updating\n            if root and root.winfo_exists() and status_display.winfo_exists():\n                status_display.config(text=message)\n                root.update_idletasks()  # Use update_idletasks instead of update\n        except Exception as e:\n            # Just print the error, don't try to update the display again\n            print(f\"Error updating status display: {e}\", flush=True)",
    "start_line": 835,
    "end_line": 855,
    "has_docstring": true,
    "docstring": "Update status display if available and print to console.\n\nParameters:\n    message: Status message to display",
    "parameters": [
      "message"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function update_status",
    "component_id": "orbit_data_manager.update_status"
  },
  "orbit_data_manager.fetch_orbit_path_by_dates": {
    "id": "orbit_data_manager.fetch_orbit_path_by_dates",
    "name": "fetch_orbit_path_by_dates",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [
      "orbit_data_manager.fetch_orbit_path",
      "orbit_data_manager.calculate_planet9_orbit",
      "orbit_data_manager.update_status"
    ],
    "source_code": "def fetch_orbit_path_by_dates(obj_info, start_date, end_date, interval, center_id='@0', id_type=None):\n    \"\"\"\n    Fetch orbit path data for specific date range and convert to time-indexed format.\n    \n    Parameters:\n        obj_info: Object information dictionary\n        start_date: Start date for the orbit path\n        end_date: End date for the orbit path\n        interval: Time interval (e.g., \"1d\", \"12h\")\n        center_id: ID of the central body\n        id_type: Type of ID for the object\n        \n    Returns:\n        dict: Orbit data in time-indexed format\n    \"\"\"\n    # ADD THIS VALIDATION AT THE START\n    if start_date >= end_date:\n        print(f\"WARNING: Invalid date range for {obj_info['name']}: start {start_date} >= end {end_date}\", flush=True)\n        return None  # Return None for invalid date ranges\n\n    # Special case for Planet 9 - don't fetch from Horizons\n    if obj_info.get('id') == 'planet9_placeholder':\n        # For Planet 9, we'll create a synthetic orbit\n        raw_data = calculate_planet9_orbit(start_date, end_date, interval)\n    else:\n        update_status(f\"Fetching orbit data for {obj_info['name']} from {start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}\")\n        raw_data = fetch_orbit_path(obj_info, start_date, end_date, interval, center_id, id_type)\n    \n    if not raw_data or 'x' not in raw_data or not raw_data['x']:\n        return None\n        \n    # Convert array format to time-indexed format\n    data_points = {}\n    \n    # Calculate number of days between start and end\n    total_days = (end_date - start_date).days\n    \n    # Assuming points are evenly distributed between start and end dates\n    num_points = len(raw_data['x'])\n    \n    if num_points <= 1:\n        return None\n        \n    days_between = total_days / (num_points - 1)\n    \n    for i in range(num_points):\n        point_date = start_date + timedelta(days=i * days_between)\n        date_str = point_date.strftime(\"%Y-%m-%d\")\n        \n        data_points[date_str] = {\n            \"x\": raw_data['x'][i],\n            \"y\": raw_data['y'][i],\n            \"z\": raw_data['z'][i]\n        }\n    \n    center_name = center_id\n    if isinstance(center_id, str):\n        center_name = center_id.replace('@', '') if center_id.startswith('@') else center_id\n    \n    return {\n        \"data_points\": data_points,\n        \"metadata\": {\n            \"earliest_date\": start_date.strftime(\"%Y-%m-%d\"),\n            \"latest_date\": end_date.strftime(\"%Y-%m-%d\"),\n            \"center_body\": center_name,\n            \"last_updated\": datetime.today().strftime(\"%Y-%m-%d\")\n        }\n    }",
    "start_line": 857,
    "end_line": 924,
    "has_docstring": true,
    "docstring": "Fetch orbit path data for specific date range and convert to time-indexed format.\n\nParameters:\n    obj_info: Object information dictionary\n    start_date: Start date for the orbit path\n    end_date: End date for the orbit path\n    interval: Time interval (e.g., \"1d\", \"12h\")\n    center_id: ID of the central body\n    id_type: Type of ID for the object\n    \nReturns:\n    dict: Orbit data in time-indexed format",
    "parameters": [
      "obj_info",
      "start_date",
      "end_date",
      "interval",
      "center_id",
      "id_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_orbit_path_by_dates",
    "component_id": "orbit_data_manager.fetch_orbit_path_by_dates"
  },
  "orbit_data_manager.merge_orbit_data": {
    "id": "orbit_data_manager.merge_orbit_data",
    "name": "merge_orbit_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [
      "orrery_integration.update"
    ],
    "source_code": "def merge_orbit_data(existing_data, new_data, new_start_date, new_end_date):\n    \"\"\"\n    Merge new orbit data with existing data.\n    \"\"\"\n    if not new_data or \"data_points\" not in new_data:\n        return existing_data\n        \n    # Create a copy of existing data\n    merged_data = {\n        \"data_points\": existing_data.get(\"data_points\", {}).copy(),\n        \"metadata\": existing_data.get(\"metadata\", {}).copy()\n    }\n    \n    # Add new data points\n    merged_data[\"data_points\"].update(new_data.get(\"data_points\", {}))\n    \n    # Update metadata to reflect the actual data range\n    all_dates = sorted(merged_data[\"data_points\"].keys())\n    if all_dates:\n        merged_data[\"metadata\"][\"start_date\"] = all_dates[0]\n        merged_data[\"metadata\"][\"end_date\"] = all_dates[-1]\n        \n    merged_data[\"metadata\"][\"last_updated\"] = datetime.today().strftime(\"%Y-%m-%d\")\n    \n    return merged_data",
    "start_line": 926,
    "end_line": 950,
    "has_docstring": true,
    "docstring": "Merge new orbit data with existing data.",
    "parameters": [
      "existing_data",
      "new_data",
      "new_start_date",
      "new_end_date"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function merge_orbit_data",
    "component_id": "orbit_data_manager.merge_orbit_data"
  },
  "orbit_data_manager.fetch_complete_orbit_path": {
    "id": "orbit_data_manager.fetch_complete_orbit_path",
    "name": "fetch_complete_orbit_path",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [
      "orbit_data_manager.fetch_orbit_path",
      "orbit_data_manager.calculate_planet9_orbit",
      "orbit_data_manager.update_status"
    ],
    "source_code": "def fetch_complete_orbit_path(obj, orbit_key, today, end_window, interval, center_id, center_id_type):\n    \"\"\"\n    Fetch and store a complete orbit path for an object.\n    \n    Parameters:\n        obj: Object information dictionary\n        orbit_key: Key for storing the orbit data\n        today: Start date\n        end_window: End date\n        interval: Time interval\n        center_id: ID of the central body\n        center_id_type: Type of ID for the central body\n        \n    Returns:\n        bool: Success status\n    \"\"\"\n    global orbit_paths_over_time\n    \n    # Special case for Planet 9 - don't fetch from Horizons\n    if obj.get('id') == 'planet9_placeholder':\n        # For Planet 9, we'll create a synthetic orbit and store it\n        update_status(f\"Calculating synthetic orbit for {obj['name']}\")\n        path_data = calculate_planet9_orbit(today, end_window, interval)\n    else:\n        update_status(f\"Fetching complete orbit path for {obj['name']} relative to {center_id}\")\n        path_data = fetch_orbit_path(\n            obj, today, end_window, interval,\n            center_id=center_id, id_type=obj.get('id_type')\n        )\n    \n    if not path_data:\n        return False\n        \n    # Convert to new format\n    orbit_paths_over_time[orbit_key] = {\n        \"data_points\": {},\n        \"metadata\": {\n            \"earliest_date\": today.strftime(\"%Y-%m-%d\"),\n            \"latest_date\": end_window.strftime(\"%Y-%m-%d\"),\n            \"center_body\": center_id_type or center_id,\n            \"last_updated\": today.strftime(\"%Y-%m-%d\")\n        }\n    }\n    \n    # Convert array data to time-indexed format\n    num_points = len(path_data['x'])\n    if num_points > 0:\n        days_span = (end_window - today).days\n        days_between = days_span / (num_points - 1) if num_points > 1 else 1\n        \n        for i in range(num_points):\n            point_date = today + timedelta(days=i * days_between)\n            date_str = point_date.strftime(\"%Y-%m-%d\")\n            \n            orbit_paths_over_time[orbit_key][\"data_points\"][date_str] = {\n                \"x\": path_data['x'][i],\n                \"y\": path_data['y'][i],\n                \"z\": path_data['z'][i]\n            }\n    \n    return True",
    "start_line": 952,
    "end_line": 1012,
    "has_docstring": true,
    "docstring": "Fetch and store a complete orbit path for an object.\n\nParameters:\n    obj: Object information dictionary\n    orbit_key: Key for storing the orbit data\n    today: Start date\n    end_window: End date\n    interval: Time interval\n    center_id: ID of the central body\n    center_id_type: Type of ID for the central body\n    \nReturns:\n    bool: Success status",
    "parameters": [
      "obj",
      "orbit_key",
      "today",
      "end_window",
      "interval",
      "center_id",
      "center_id_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_complete_orbit_path",
    "component_id": "orbit_data_manager.fetch_complete_orbit_path"
  },
  "orbit_data_manager.get_planet9_data": {
    "id": "orbit_data_manager.get_planet9_data",
    "name": "get_planet9_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [
      "orbit_data_manager.calculate_planet9_position"
    ],
    "source_code": "def get_planet9_data(center_object_name='Sun'):\n    \"\"\"\n    Get Planet 9 data for different center objects.\n    \n    Parameters:\n        center_object_name: Name of the central body\n        \n    Returns:\n        dict: Planet 9 data in the requested reference frame\n    \"\"\"\n    # If the center is Sun, return the standard Planet 9 position\n    if center_object_name == 'Sun':\n        x, y, z, r = calculate_planet9_position()\n        return {\n            'x': x,\n            'y': y, \n            'z': z,\n            'range': r\n        }\n    \n    # For other centers, we need to offset Planet 9 by the position of the center object\n    # This is a placeholder for proper implementation that would account for the position\n    # of the center body relative to the Sun\n    return {\n        'x': 0,\n        'y': 0,\n        'z': 0,\n        'range': 0\n    }",
    "start_line": 1015,
    "end_line": 1043,
    "has_docstring": true,
    "docstring": "Get Planet 9 data for different center objects.\n\nParameters:\n    center_object_name: Name of the central body\n    \nReturns:\n    dict: Planet 9 data in the requested reference frame",
    "parameters": [
      "center_object_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_planet9_data",
    "component_id": "orbit_data_manager.get_planet9_data"
  },
  "orbit_data_manager.update_orbit_paths_incrementally": {
    "id": "orbit_data_manager.update_orbit_paths_incrementally",
    "name": "update_orbit_paths_incrementally",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [
      "orbit_data_manager.calculate_planet9_orbit",
      "orbit_data_manager.merge_orbit_data",
      "orbit_data_manager.save_orbit_paths",
      "orbit_data_manager.determine_interval_for_object",
      "orbit_data_manager.fetch_orbit_path_by_dates",
      "orbit_data_manager.update_status",
      "orrery_integration.update",
      "orbit_data_manager.fetch_complete_orbit_path"
    ],
    "source_code": "def update_orbit_paths_incrementally(object_list=None, center_object_name=\"Sun\", \n                                     days_ahead=365, fetch_requests=None,\n                                     planetary_params=None, \n                                     parent_planets=None, root_widget=None):\n    \"\"\"\n    Update orbit paths incrementally, fetching only missing data.\n    \n    Parameters:\n        object_list: List of objects to update\n        center_object_name: Name of central body\n        days_ahead: Default days to look ahead (used if fetch_requests is None)\n        fetch_requests: List of specific fetch requests with date ranges\n        planetary_params: Dictionary of orbital parameters\n        parent_planets: Dictionary mapping planets to their satellites\n        root_widget: Root Tkinter widget for UI updates\n    \"\"\"\n    global orbit_paths_over_time, root\n    \n    # Update root reference if provided\n    if root_widget:\n        root = root_widget\n    \n    today = datetime.today()\n    end_window = today + timedelta(days=days_ahead)\n    end_window_str = end_window.strftime(\"%Y-%m-%d\")\n    \n    update_status(f\"Checking orbit data for updates to {end_window_str}...\")\n    \n    # Get center object info from the provided object_list\n    center_object_info = None\n    if object_list:\n        center_object_info = next((obj for obj in object_list if obj['name'] == center_object_name), None)\n    \n    if center_object_info:\n        center_id = center_object_info['id']\n        center_id_type = center_object_info.get('id_type')\n    else:\n        center_id = 'Sun'\n        center_id_type = None\n    \n    # If we have specific fetch requests, use those instead of the default behavior\n    if fetch_requests:\n        updated_count = 0\n        time_saved_hours = 0\n        \n        for request in fetch_requests:\n            obj = request['object']\n            fetch_start = request['fetch_start']\n            fetch_end = request['fetch_end']\n            reason = request.get('reason', 'requested')\n\n            # ADD THIS VALIDATION\n            if fetch_start >= fetch_end:\n                print(f\"Skipping invalid fetch request for {obj['name']}: {fetch_start} to {fetch_end}\", flush=True)\n                continue            \n            \n            orbit_key = f\"{obj['name']}_{center_object_name}\"\n            \n            # Determine appropriate interval\n            interval = determine_interval_for_object(obj, planetary_params, parent_planets)\n            \n            # Update status\n            days_to_fetch = (fetch_end - fetch_start).days + 1\n            update_status(f\"Fetching {days_to_fetch} days for {obj['name']} ({reason})\")\n            if root:\n                root.update()\n            \n            # Special handling for Planet 9\n            if obj.get('id') == 'planet9_placeholder':\n                # Calculate synthetic orbit\n                path_data = calculate_planet9_orbit(fetch_start, fetch_end, interval)\n                \n                # Convert to time-indexed format\n                new_data = {\n                    \"data_points\": {},\n                    \"metadata\": {\n                        \"start_date\": fetch_start.strftime(\"%Y-%m-%d\"),\n                        \"end_date\": fetch_end.strftime(\"%Y-%m-%d\"),\n                        \"center_body\": center_object_name,\n                        \"last_updated\": today.strftime(\"%Y-%m-%d\")\n                    }\n                }\n                \n                # Convert array data to time-indexed format\n                num_points = len(path_data['x'])\n                if num_points > 0:\n                    days_span = (fetch_end - fetch_start).days\n                    days_between = days_span / (num_points - 1) if num_points > 1 else 1\n                    \n                    for i in range(num_points):\n                        point_date = fetch_start + timedelta(days=i * days_between)\n                        date_str = point_date.strftime(\"%Y-%m-%d\")\n                        \n                        new_data[\"data_points\"][date_str] = {\n                            \"x\": path_data['x'][i],\n                            \"y\": path_data['y'][i],\n                            \"z\": path_data['z'][i]\n                        }\n            else:\n                # Fetch the specific date range from JPL Horizons\n                new_data = fetch_orbit_path_by_dates(\n                    obj, fetch_start, fetch_end, interval,\n                    center_id=center_id, id_type=obj.get('id_type')\n                )\n            \n            if new_data:\n                # Check if we have existing data to merge with\n                if orbit_key in orbit_paths_over_time:\n                    # Calculate time saved by not re-fetching existing data\n                    existing_data = orbit_paths_over_time[orbit_key]\n                    existing_points = len(existing_data.get(\"data_points\", {}))\n                    if existing_points > 0:\n                        # Estimate based on interval\n                        calls_saved = existing_points\n                        if interval == \"12h\":\n                            calls_saved /= 2\n                        elif interval == \"6h\":\n                            calls_saved /= 4\n                        elif interval == \"1h\":\n                            calls_saved /= 24\n                        \n                        # Each API call might take ~1-2 seconds\n                        time_saved_seconds = calls_saved * 1.5\n                        time_saved_hours += time_saved_seconds / 3600\n                    \n                    # Merge with existing data\n                    orbit_paths_over_time[orbit_key] = merge_orbit_data(\n                        orbit_paths_over_time[orbit_key], new_data,\n                        fetch_start, fetch_end\n                    )\n                else:\n                    # New entry\n                    orbit_paths_over_time[orbit_key] = new_data\n                \n                updated_count += 1\n        \n        # Save the updated data\n        save_orbit_paths(orbit_paths_over_time)\n        \n        update_status(f\"Smart fetch complete: Updated {updated_count} orbits with minimal data fetching. \"\n                     f\"Saved approximately {time_saved_hours:.1f} hours of fetch time.\")\n        \n        return updated_count, 0, len(fetch_requests), time_saved_hours\n    \n    # Otherwise, continue with the existing logic...\n    # Default to all objects if none specified\n    if not object_list:\n        update_status(\"No object list provided, cannot update orbit paths incrementally.\")\n        return 0, 0, 0, 0\n    \n    # Filter object list to exclude center object\n    object_list = [obj for obj in object_list if 'id' in obj and obj['name'] != center_object_name]\n    \n    updated_count = 0\n    already_current = 0\n    time_saved_hours = 0\n    \n    for obj in object_list:\n        # Special case for Planet 9\n        if obj.get('id') == 'planet9_placeholder':\n            # Planet 9 is synthetic, doesn't need updating from Horizons\n            orbit_key = f\"{obj['name']}_{center_object_name}\"\n            \n            # Only create/update Planet 9 data if it doesn't exist yet\n            if orbit_key not in orbit_paths_over_time:\n                update_status(f\"Generating synthetic orbit for {obj['name']}\")\n                # Use a default interval\n                interval = \"1d\"\n                fetch_complete_orbit_path(obj, orbit_key, today, end_window, interval, center_id, center_id_type)\n                updated_count += 1\n            else:\n                already_current += 1\n                \n            continue\n        \n        orbit_key = f\"{obj['name']}_{center_object_name}\"\n        \n        # Determine appropriate interval based on object type\n        interval = determine_interval_for_object(obj, planetary_params, parent_planets)\n        \n        # Check if we have existing data\n        if orbit_key in orbit_paths_over_time:\n            metadata = orbit_paths_over_time[orbit_key].get(\"metadata\", {})\n            latest_date_str = metadata.get(\"latest_date\")\n            \n            if latest_date_str:\n                latest_date = datetime.strptime(latest_date_str, \"%Y-%m-%d\")\n                \n                # Only update if our data doesn't extend to the desired end window\n                if latest_date < end_window:\n                    # Start fetching from the day after the latest date we have\n                    new_start_date = latest_date + timedelta(days=1)\n                    new_start_date_str = new_start_date.strftime(\"%Y-%m-%d\")\n                    \n                    # Estimate time saved by incremental update (vs full refetch)\n                    days_already_have = (latest_date - today).days\n                    if days_already_have > 0:\n                        # Rough estimate based on time interval\n                        calls_saved = days_already_have\n                        if interval == \"12h\":\n                            calls_saved *= 2\n                        elif interval == \"6h\":\n                            calls_saved *= 4\n                        elif interval == \"1h\":\n                            calls_saved *= 24\n                        \n                        # Each API call might take ~1-2 seconds\n                        time_saved_seconds = calls_saved * 1.5\n                        time_saved_hours += time_saved_seconds / 3600\n                    \n                    update_status(f\"Incrementally updating {obj['name']} from {new_start_date_str} to {end_window_str}\")\n                    if root:\n                        root.update()\n                    \n                    # Fetch only the missing date range\n                    new_data = fetch_orbit_path_by_dates(\n                        obj, new_start_date, end_window, interval, \n                        center_id=center_id, id_type=obj.get('id_type')\n                    )\n                    \n                    if new_data:\n                        # Merge the new data with existing data\n                        orbit_paths_over_time[orbit_key] = merge_orbit_data(\n                            orbit_paths_over_time[orbit_key], new_data, \n                            new_start_date, end_window\n                        )\n                        \n                        # Update metadata\n                        orbit_paths_over_time[orbit_key][\"metadata\"][\"latest_date\"] = end_window_str\n                        orbit_paths_over_time[orbit_key][\"metadata\"][\"last_updated\"] = today.strftime(\"%Y-%m-%d\")\n                        \n                        updated_count += 1\n                else:\n                    already_current += 1\n            else:\n                # Missing metadata, treat as new entry\n                fetch_complete_orbit_path(obj, orbit_key, today, end_window, interval, center_id, center_id_type)\n                updated_count += 1\n        else:\n            # No existing data, fetch complete path\n            fetch_complete_orbit_path(obj, orbit_key, today, end_window, interval, center_id, center_id_type)\n            updated_count += 1\n    \n    # Save the updated data\n    save_orbit_paths(orbit_paths_over_time)\n    \n    update_status(\n        f\"Updated {updated_count} orbit paths, {already_current} already current. \"\n        f\"Data now extends to {end_window_str}. Saved approximately {time_saved_hours:.1f} hours of fetch time.\"\n    )\n    \n    return updated_count, already_current, len(object_list), time_saved_hours",
    "start_line": 1045,
    "end_line": 1296,
    "has_docstring": true,
    "docstring": "Update orbit paths incrementally, fetching only missing data.\n\nParameters:\n    object_list: List of objects to update\n    center_object_name: Name of central body\n    days_ahead: Default days to look ahead (used if fetch_requests is None)\n    fetch_requests: List of specific fetch requests with date ranges\n    planetary_params: Dictionary of orbital parameters\n    parent_planets: Dictionary mapping planets to their satellites\n    root_widget: Root Tkinter widget for UI updates",
    "parameters": [
      "object_list",
      "center_object_name",
      "days_ahead",
      "fetch_requests",
      "planetary_params",
      "parent_planets",
      "root_widget"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function update_orbit_paths_incrementally",
    "component_id": "orbit_data_manager.update_orbit_paths_incrementally"
  },
  "orbit_data_manager.get_orbit_data_for_plotting": {
    "id": "orbit_data_manager.get_orbit_data_for_plotting",
    "name": "get_orbit_data_for_plotting",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [],
    "source_code": "def get_orbit_data_for_plotting(objects_to_plot, center_object_name='Sun'):\n    \"\"\"\n    Get orbit path data for plotting.\n    \n    Parameters:\n        objects_to_plot: List of objects to get data for\n        center_object_name: Name of central body\n        \n    Returns:\n        dict: Dictionary mapping object names to their orbit path data in plotting format\n    \"\"\"\n    plot_data = {}\n    \n    # Extract just the names from the objects_to_plot list\n    selected_names = [obj['name'] for obj in objects_to_plot]\n    \n    for name in selected_names:\n        if name == center_object_name:\n            continue\n            \n        orbit_key = f\"{name}_{center_object_name}\"\n        \n        if orbit_key in orbit_paths_over_time:\n            orbit_data = orbit_paths_over_time[orbit_key]\n            \n            # Extract coordinates from time-indexed data\n            data_points = orbit_data.get(\"data_points\", {})\n            dates = sorted(data_points.keys())\n            \n            if not dates:\n                continue\n                \n            # Reconstruct coordinate arrays\n            x_coords = []\n            y_coords = []\n            z_coords = []\n            \n            for date in dates:\n                point = data_points[date]\n                x_coords.append(point[\"x\"])\n                y_coords.append(point[\"y\"])\n                z_coords.append(point[\"z\"])\n            \n            plot_data[name] = {\n                'x': x_coords,\n                'y': y_coords,\n                'z': z_coords,\n                'dates': dates\n            }\n        \n        # Fallback to old key format if the new format isn't found\n        elif name in orbit_paths_over_time:\n            # Handle legacy format data that might still be in the cache\n            path = orbit_paths_over_time[name]\n            if 'x' in path and 'y' in path and 'z' in path:\n                plot_data[name] = {\n                    'x': path['x'],\n                    'y': path['y'],\n                    'z': path['z'],\n                    'dates': []  # No dates in legacy format\n                }\n    \n    return plot_data",
    "start_line": 1299,
    "end_line": 1361,
    "has_docstring": true,
    "docstring": "Get orbit path data for plotting.\n\nParameters:\n    objects_to_plot: List of objects to get data for\n    center_object_name: Name of central body\n    \nReturns:\n    dict: Dictionary mapping object names to their orbit path data in plotting format",
    "parameters": [
      "objects_to_plot",
      "center_object_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_orbit_data_for_plotting",
    "component_id": "orbit_data_manager.get_orbit_data_for_plotting"
  },
  "orbit_data_manager.get_data_stats": {
    "id": "orbit_data_manager.get_data_stats",
    "name": "get_data_stats",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [],
    "source_code": "def get_data_stats():\n    \"\"\"\n    Get statistics about the stored orbit data.\n    \n    Returns:\n        dict: Statistics about the orbit data\n    \"\"\"\n    stats = {\n        \"total_objects\": len(orbit_paths_over_time),\n        \"total_points\": 0,\n        \"earliest_date\": None,\n        \"latest_date\": None,\n        \"file_size_mb\": 0,\n        \"center_bodies\": set(),\n        \"objects_per_center\": {}\n    }\n    \n    try:\n        file_size = os.path.getsize(ORBIT_PATHS_FILE) / (1024 * 1024)\n        stats[\"file_size_mb\"] = round(file_size, 2)\n    except (FileNotFoundError, OSError):\n        pass\n    \n    earliest_dates = []\n    latest_dates = []\n    \n    for key, data in orbit_paths_over_time.items():\n        # Count data points\n        if \"data_points\" in data:\n            stats[\"total_points\"] += len(data[\"data_points\"])\n            \n            # Extract center body\n            if \"_\" in key:\n                _, center = key.split(\"_\", 1)\n                stats[\"center_bodies\"].add(center)\n                \n                # Count objects per center\n                if center not in stats[\"objects_per_center\"]:\n                    stats[\"objects_per_center\"][center] = 0\n                stats[\"objects_per_center\"][center] += 1\n            \n            # Track date ranges\n            metadata = data.get(\"metadata\", {})\n            if \"earliest_date\" in metadata:\n                try:\n                    earliest_dates.append(datetime.strptime(metadata[\"earliest_date\"], \"%Y-%m-%d\"))\n                except ValueError:\n                    pass\n                \n            if \"latest_date\" in metadata:\n                try:\n                    latest_dates.append(datetime.strptime(metadata[\"latest_date\"], \"%Y-%m-%d\"))\n                except ValueError:\n                    pass\n    \n    # Find overall date range\n    if earliest_dates:\n        stats[\"earliest_date\"] = min(earliest_dates).strftime(\"%Y-%m-%d\")\n    \n    if latest_dates:\n        stats[\"latest_date\"] = max(latest_dates).strftime(\"%Y-%m-%d\")\n    \n    return stats",
    "start_line": 1364,
    "end_line": 1426,
    "has_docstring": true,
    "docstring": "Get statistics about the stored orbit data.\n\nReturns:\n    dict: Statistics about the orbit data",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_data_stats",
    "component_id": "orbit_data_manager.get_data_stats"
  },
  "orbit_data_manager.on_center_change": {
    "id": "orbit_data_manager.on_center_change",
    "name": "on_center_change",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [
      "orrery_integration.update",
      "orbit_data_manager.update_orbit_paths_incrementally",
      "orbit_data_manager.update_status"
    ],
    "source_code": "def on_center_change(*args, objects=None, planetary_params=None, parent_planets=None):\n    \"\"\"\n    Update orbit paths when the center object is changed.\n    \n    Parameters:\n        *args: Variable arguments for Tkinter trace_add\n        objects: List of all celestial objects\n        planetary_params: Dictionary of orbital parameters\n        parent_planets: Dictionary mapping planets to their satellites\n        \n    Returns:\n        None\n    \"\"\"\n#    global center_object_var, root, status_display\n    global center_object_var, root, status_display, last_center_updated, last_update_time\n    \n    # If any required parameters are missing, return early\n    if not center_object_var or not objects:\n        return\n    \n    center_object = center_object_var.get()\n\n    # Check if this is the same center we just updated\n    now = datetime.now()\n    if (center_object == last_center_updated and \n        last_update_time and \n        (now - last_update_time).total_seconds() < 600):  # 10 minutes cache\n        update_status(f\"Using cached data for center: {center_object}\")\n        return\n\n    if center_object != 'Sun':\n\n        # Only fetch non-Sun centered paths when needed to avoid excessive startup time\n#        if status_display:\n#            status_display.config(text=f\"Updating orbit paths for center: {center_object}...\")\n#        if root:\n#            root.update()  # Force GUI to refresh\n\n        # Only fetch non-Sun centered paths when needed to avoid excessive startup time\n        update_status(f\"Updating orbit paths for center: {center_object}...\")\n        if root:\n            root.update()  # Force GUI to refresh            \n        \n        # Call the incremental update with the new center\n        updated, current, total, time_saved = update_orbit_paths_incrementally(\n            object_list=objects,\n            center_object_name=center_object,\n            days_ahead=730,\n            planetary_params=planetary_params,\n            parent_planets=parent_planets,\n            root_widget=root\n        )\n        \n#        if status_display:\n#            status_display.config(\n#                text=f\"Updated {updated} orbit paths, {current} already current for center: {center_object}\"\n#            )\n\n        # Update our cache information\n        last_center_updated = center_object\n        last_update_time = now\n        \n        update_status(\n            f\"Updated {updated} orbit paths, {current} already current for center: {center_object}\"\n        )",
    "start_line": 1429,
    "end_line": 1493,
    "has_docstring": true,
    "docstring": "Update orbit paths when the center object is changed.\n\nParameters:\n    *args: Variable arguments for Tkinter trace_add\n    objects: List of all celestial objects\n    planetary_params: Dictionary of orbital parameters\n    parent_planets: Dictionary mapping planets to their satellites\n    \nReturns:\n    None",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function on_center_change",
    "component_id": "orbit_data_manager.on_center_change"
  },
  "orbit_data_manager.plot_orbit_paths": {
    "id": "orbit_data_manager.plot_orbit_paths",
    "name": "plot_orbit_paths",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [
      "constants_new.color_map"
    ],
    "source_code": "def plot_orbit_paths(fig, objects_to_plot, center_object_name='Sun', color_map=None, parent_planets=None):\n    \"\"\"\n    Plot orbit paths using time-indexed data.\n    \n    Parameters:\n        fig: Plotly figure object\n        objects_to_plot: List of objects to plot orbits for\n        center_object_name: Name of the central body (default: 'Sun')\n        color_map: Function to get color for an object\n        parent_planets: Dictionary mapping planets to their satellites\n        \n    Returns:\n        plotly.graph_objects.Figure: The modified figure with orbits added\n    \"\"\"\n    # Debug output to verify we're getting the right list of selected objects\n    selected_names = [obj['name'] for obj in objects_to_plot]\n    print(\"\\nSelected objects for orbit paths:\", flush=True)\n    for name in selected_names:\n        print(f\"  - {name}\", flush=True)\n\n    for name in selected_names:\n        # Skip objects that are the center\n        if name == center_object_name:\n            continue\n            \n        # Check if this is a satellite of the center object\n        is_satellite_of_center = False\n        if parent_planets and center_object_name in parent_planets:\n            is_satellite_of_center = name in parent_planets.get(center_object_name, [])\n        \n        # Generate a unique key for this object-center pair\n        orbit_key = f\"{name}_{center_object_name}\"\n        \n        # Check if we have the orbit path for this object-center combination\n        if orbit_key in orbit_paths_over_time:\n            orbit_data = orbit_paths_over_time[orbit_key]\n            \n            # Extract coordinates from time-indexed data\n            data_points = orbit_data.get(\"data_points\", {})\n            dates = sorted(data_points.keys())\n            \n            if not dates:\n                print(f\"No data points found for {name} relative to {center_object_name}\", flush=True)\n                continue\n                \n            # Reconstruct coordinate arrays\n            x_coords = []\n            y_coords = []\n            z_coords = []\n            \n            for date in dates:\n                point = data_points[date]\n                x_coords.append(point[\"x\"])\n                y_coords.append(point[\"y\"])\n                z_coords.append(point[\"z\"])\n            \n            # Create the hover text\n            if is_satellite_of_center:\n                hover_text = [f\"{name} Orbit around {center_object_name}\"] * len(x_coords)\n                orbit_name = f\"{name} Orbit around {center_object_name}\"\n            else:\n                hover_text = [f\"{name} Orbit\"] * len(x_coords)\n                orbit_name = f\"{name} Orbit\"\n\n            print(f\"Plotting orbit for {name} relative to {center_object_name} ({len(x_coords)} points)\", flush=True)\n            \n            # Get color if color_map is provided\n            color = 'white'  # Default color\n            if color_map:\n                color = color_map(name)\n                \n            # Add orbit trace to figure\n            fig.add_trace(\n                go.Scatter3d(\n                    x=x_coords,\n                    y=y_coords,\n                    z=z_coords,\n                    mode='lines',\n                    line=dict(width=1, color=color),  # uses the color from color_map\n                    name=orbit_name,\n                    text=hover_text,\n                    customdata=hover_text,\n                    hovertemplate='%{text}<extra></extra>',\n                    showlegend=True\n                )\n            )\n            \n        # Fallback to old key format if the new format isn't found\n        elif name in orbit_paths_over_time:\n            path = orbit_paths_over_time[name]\n            \n            # Skip entries that don't have proper coordinates\n            if not isinstance(path, dict) or 'x' not in path:\n                continue\n                \n            # Create the hover text arrays\n            hover_text = [f\"{name} Orbit\"] * len(path['x'])\n            \n            # Get color if color_map is provided\n            color = 'white'  # Default color\n            if color_map:\n                color = color_map(name)\n\n            fig.add_trace(\n                go.Scatter3d(\n                    x=path['x'],\n                    y=path['y'],\n                    z=path['z'],\n                    mode='lines',\n                    line=dict(width=1, color=color),\n                    name=f\"{name} Orbit\",\n                    text=hover_text,\n                    customdata=hover_text,\n                    hovertemplate='%{text}<extra></extra>',\n                    showlegend=True\n                )\n            )\n        else:\n            print(f\"No orbit path found for {name} relative to {center_object_name}\", flush=True)\n            \n    return fig",
    "start_line": 1496,
    "end_line": 1616,
    "has_docstring": true,
    "docstring": "Plot orbit paths using time-indexed data.\n\nParameters:\n    fig: Plotly figure object\n    objects_to_plot: List of objects to plot orbits for\n    center_object_name: Name of the central body (default: 'Sun')\n    color_map: Function to get color for an object\n    parent_planets: Dictionary mapping planets to their satellites\n    \nReturns:\n    plotly.graph_objects.Figure: The modified figure with orbits added",
    "parameters": [
      "fig",
      "objects_to_plot",
      "center_object_name",
      "color_map",
      "parent_planets"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_orbit_paths",
    "component_id": "orbit_data_manager.plot_orbit_paths"
  },
  "orbit_data_manager.query_horizons_elements": {
    "id": "orbit_data_manager.query_horizons_elements",
    "name": "query_horizons_elements",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [],
    "source_code": "def query_horizons_elements(horizons_id, id_type='smallbody', date_str=None, center_body=None):\n    \"\"\"\n    Query JPL Horizons for osculating orbital elements (Keplerian).\n    Called by osculating_cache_manager.py.\n    \n    Parameters:\n        horizons_id (str): Horizons ID to query (e.g., 'C/2025 N1', '199', '-23')\n        id_type (str): Horizons ID type ('smallbody', 'majorbody', 'id', etc.)\n        date_str (str, optional): Date string in 'YYYY-MM-DD' format (defaults to today)\n        center_body (str, optional): Override center body for elements (e.g., '@9' for Pluto barycenter)\n                                     If None, auto-detects based on object ID.\n    \n    Returns:\n        dict: Orbital elements with metadata including 'center_body' used\n    \n    Fixes applied:\n    1. Uses astropy.time for Julian Date conversion (fixes TLIST error)\n    2. Handles flexible column names (e.g., 'a' vs 'A', 'incl' vs 'IN')\n    3. Auto-detects and converts KM to AU for Major Bodies\n    4. Uses proper Horizons ID and ID type for unambiguous queries\n    5. Supports explicit center_body override for barycentric elements\n    \"\"\"\n    from astroquery.jplhorizons import Horizons\n    from datetime import datetime\n    from astropy.time import Time\n    \n    # Default to today if no date provided\n    if date_str is None:\n        date_str = datetime.now().strftime('%Y-%m-%d')\n    \n    \"\"\"\n    # ===== ADD THIS ENTIRE BLOCK =====\n    # Determine the correct location/center based on object ID\n    location = '@sun'  # Default for planets, asteroids, comets, spacecraft\n    \n    # Satellites: Extract parent planet from 3-digit ID (e.g., 301 [OK] Earth)\n#    if horizons_id.isdigit() and len(horizons_id) == 3:\n    if horizons_id.isdigit() and len(horizons_id) == 3 and not horizons_id.endswith('99'):\n        parent_id_map = {\n            '3': '399',   # Earth\n            '4': '499',   # Mars\n            '5': '599',   # Jupiter\n            '6': '699',   # Saturn\n            '7': '799',   # Uranus\n            '8': '899',   # Neptune\n            '9': '999',   # Pluto\n        }\n        first_digit = horizons_id[0]\n        if first_digit in parent_id_map:\n            location = '@' + parent_id_map[first_digit]\n    \n    # Handle Eris/Dysnomia (special case - Dysnomia orbits Eris)\n    elif horizons_id in ['136199', '20136199']:\n        location = '@136199'  # Relative to Eris\n    # ===== END OF NEW BLOCK =====\n    \"\"\"\n\n# ===== LOCATION/CENTER DETERMINATION =====\n    # Determine the correct location/center based on object ID\n    location = '@sun'  # Default for planets, asteroids, comets, spacecraft\n    \n    # Satellites: Extract parent planet from 3-digit ID (e.g., 301 [OK] Earth)\n    # EXCLUDE planets themselves (x99 pattern: 199, 299, 399, etc.)\n    if horizons_id.isdigit() and len(horizons_id) == 3 and not horizons_id.endswith('99'):\n        parent_id_map = {\n            '3': '399',   # Earth\n            '4': '499',   # Mars\n            '5': '599',   # Jupiter\n            '6': '699',   # Saturn\n            '7': '799',   # Uranus\n            '8': '899',   # Neptune\n            '9': '999',   # Pluto\n        }\n        first_digit = horizons_id[0]\n        if first_digit in parent_id_map:\n            location = '@' + parent_id_map[first_digit]\n    \n    # Handle Dysnomia (Eris's moon) - orbits Eris barycenter\n    elif horizons_id == '120136199':\n        location = '@20136199'  # Relative to Eris system barycenter\n    \n    # Handle Hi'iaka (Haumea's outer moon)\n    elif horizons_id == '120136108':\n        location = '@20136108'  # Relative to Haumea system barycenter\n    \n    # Handle Namaka (Haumea's inner moon)\n    elif horizons_id == '220136108':\n        location = '@20136108'  # Relative to Haumea system barycenter\n    \n    # Handle MK2 (Makemake's moon)\n    elif horizons_id == '120136472':\n        location = '@20136472'  # Relative to Makemake system barycenter\n\n    # Handle Weywot (Quaoar's moon)\n    elif horizons_id == '120050000':\n        location = '@920050000'  # Relative to Quaoar primary body\n\n    # Handle Vanth (Orcus's moon)\n    elif horizons_id == '120090482':\n        location = '@20090482'  # Relative to Orcus system barycenter\n\n    # Handle Xiangliu (Gonggong's moon)\n    elif horizons_id == '120225088':\n        location = '@20225088'  # Relative to Gonggong system barycenter\n\n    # ===== END OF LOCATION BLOCK =====\n#    print(f\"  [Horizons Query] ID: {horizons_id} | Type: {id_type} | Location: {location} | Date: {date_str}\", flush=True)\n    \n    # Override location if center_body explicitly provided\n    if center_body is not None:\n        if center_body.startswith('@'):\n            location = center_body\n        else:\n            location = '@' + center_body\n        print(f\"  [Horizons Query] Using explicit center_body override: {location}\", flush=True)\n\n    print(f\"  [Horizons Query] ID: {horizons_id} | Type: {id_type} | Location: {location} | Date: {date_str}\", flush=True)\n\n    try:\n        # Convert string date to Julian Date to prevent formatting errors\n        dt = Time(date_str)\n        epoch_jd = dt.jd\n        \n        # Define the query with proper ID and ID type\n    #    obj = Horizons(id=horizons_id, id_type=id_type, location='@sun', epochs=epoch_jd)\n        obj = Horizons(id=horizons_id, id_type=id_type, location=location, epochs=epoch_jd)\n        \n        # Fetch ELEMENTS\n        el = obj.elements()\n        \n        if len(el) == 0:\n            raise ValueError(f\"No elements returned for {horizons_id}\")\n            \n        # Get the first row\n        row = el[0]\n        \n        # --- Helper to safely get column values ---\n        def get_col(candidates):\n            for name in candidates:\n                if name in row.colnames:\n                    return float(row[name])\n            # Debug: Print available columns if key not found\n            print(f\"    [DEBUG] Available columns: {row.colnames}\", flush=True)\n            raise KeyError(f\"Could not find any of {candidates} in Horizons response\")\n\n        # --- Extract Values (Handling Name Variations) ---\n        a_val = get_col(['a', 'A'])           # Semi-major axis\n        e_val = get_col(['e', 'EC'])          # Eccentricity\n        i_val = get_col(['incl', 'IN', 'i'])  # Inclination\n        w_val = get_col(['w', 'W', 'omega'])  # Arg of Perihelion\n        om_val = get_col(['Omega', 'OM'])     # Longitude of Ascending Node\n        tp_val = get_col(['Tp_jd', 'Tp', 'TP']) # Time of Perihelion (JD)\n\n        # Mean and True Anomaly (for phase verification)\n        # These tell us WHERE on the ellipse the object is at epoch\n        try:\n            ma_val = get_col(['MA', 'M', 'meanAnomaly'])\n        except KeyError:\n            ma_val = None\n        \n        try:\n            ta_val = get_col(['TA', 'nu', 'trueAnomaly'])\n        except KeyError:\n            ta_val = None\n\n        # --- Unit Conversion (KM -> AU) ---\n        # Major bodies (like Mercury) often return 'a' in km (e.g., 5.7e7 km).\n        # We need AU (e.g., 0.387 AU). 1 AU approx 1.496e8 km.\n        # Threshold: If a > 10000, it's definitely meters or km, not AU.\n        \n        KM_TO_AU = 1.0 / 149597870.7\n        \n        if abs(a_val) > 10000: \n            print(f\"    [Unit Conv] converting 'a' from {a_val} (likely km) to AU\", flush=True)\n            a_val = a_val * KM_TO_AU\n        \n        result = {\n            'a': a_val,\n            'e': e_val,\n            'i': i_val,\n            'omega': w_val,\n            'Omega': om_val,\n            'TP': tp_val,\n            'MA': ma_val,      # Mean anomaly at epoch (degrees) - for time propagation\n            'TA': ta_val,      # True anomaly at epoch (degrees) - for position verification\n            'epoch': f\"{date_str} osc.\",\n            'solution_date': datetime.now().strftime('%Y-%m-%d'),\n            'horizons_id': str(horizons_id),  # Store the actual ID we queried\n            'center_body': location           # Store which center was used\n        }\n\n        # Attempt to add optional data (Perihelion Distance q)\n        try:\n             q_val = get_col(['q', 'QR'])\n             # Apply same unit conversion check for q\n             if abs(q_val) > 10000:\n                 q_val = q_val * KM_TO_AU\n             result['q'] = q_val\n        except KeyError:\n             pass\n        \n        return result\n        \n    except Exception as e:\n        print(f\"  [Horizons Error] Could not fetch elements: {e}\", flush=True)\n        raise e",
    "start_line": 1624,
    "end_line": 1829,
    "has_docstring": true,
    "docstring": "Query JPL Horizons for osculating orbital elements (Keplerian).\nCalled by osculating_cache_manager.py.\n\nParameters:\n    horizons_id (str): Horizons ID to query (e.g., 'C/2025 N1', '199', '-23')\n    id_type (str): Horizons ID type ('smallbody', 'majorbody', 'id', etc.)\n    date_str (str, optional): Date string in 'YYYY-MM-DD' format (defaults to today)\n    center_body (str, optional): Override center body for elements (e.g., '@9' for Pluto barycenter)\n                                 If None, auto-detects based on object ID.\n\nReturns:\n    dict: Orbital elements with metadata including 'center_body' used\n\nFixes applied:\n1. Uses astropy.time for Julian Date conversion (fixes TLIST error)\n2. Handles flexible column names (e.g., 'a' vs 'A', 'incl' vs 'IN')\n3. Auto-detects and converts KM to AU for Major Bodies\n4. Uses proper Horizons ID and ID type for unambiguous queries\n5. Supports explicit center_body override for barycentric elements",
    "parameters": [
      "horizons_id",
      "id_type",
      "date_str",
      "center_body"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function query_horizons_elements",
    "component_id": "orbit_data_manager.query_horizons_elements"
  },
  "orbit_data_manager.get_col": {
    "id": "orbit_data_manager.get_col",
    "name": "get_col",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbit_data_manager.py",
    "relative_path": "orbit_data_manager.py",
    "depends_on": [],
    "source_code": "        def get_col(candidates):\n            for name in candidates:\n                if name in row.colnames:\n                    return float(row[name])\n            # Debug: Print available columns if key not found\n            print(f\"    [DEBUG] Available columns: {row.colnames}\", flush=True)\n            raise KeyError(f\"Could not find any of {candidates} in Horizons response\")",
    "start_line": 1761,
    "end_line": 1767,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "candidates"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_col",
    "component_id": "orbit_data_manager.get_col"
  },
  "orbital_param_viz.CreateToolTip": {
    "id": "orbital_param_viz.CreateToolTip",
    "name": "CreateToolTip",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbital_param_viz.py",
    "relative_path": "orbital_param_viz.py",
    "depends_on": [],
    "source_code": "class CreateToolTip(object):\n    \"\"\"\n    Create a tooltip for a given widget with intelligent positioning to prevent clipping.\n    \"\"\"\n    def __init__(self, widget, text='widget info'):\n        self.waittime = 500     # milliseconds\n        self.wraplength = 1000   # Reduced wraplength\n        self.widget = widget\n        self.text = text\n        self.widget.bind(\"<Enter>\", self.enter)\n        self.widget.bind(\"<Leave>\", self.leave)\n        self.id = None\n        self.tw = None\n\n    def enter(self, event=None):\n        self.schedule()\n\n    def leave(self, event=None):\n        self.unschedule()\n        self.hidetip()\n\n    def schedule(self):\n        self.unschedule()\n        self.id = self.widget.after(self.waittime, self.showtip)\n\n    def unschedule(self):\n        id_ = self.id\n        self.id = None\n        if id_:\n            self.widget.after_cancel(id_)\n\n    def showtip(self, event=None):\n        try:\n            # Get screen dimensions and taskbar height (estimated)\n            screen_width = self.widget.winfo_screenwidth()\n            screen_height = self.widget.winfo_screenheight()\n            taskbar_height = 40  # Estimated Windows taskbar height\n\n            # Create the tooltip window\n            self.tw = tk.Toplevel(self.widget)\n            self.tw.wm_overrideredirect(True)\n            \n            # Calculate usable screen height\n            usable_height = screen_height - taskbar_height\n\n            # Create the tooltip label\n            label = tk.Label(\n                self.tw,\n                text=self.text,\n                justify='left',\n                background='yellow',\n                relief='solid',\n                borderwidth=1,\n                wraplength=min(self.wraplength, screen_width - 100),\n                font=(\"Arial\", 10, \"normal\")\n            )\n            label.pack(ipadx=1, ipady=1)\n\n            # Update the window to calculate its size\n            self.tw.update_idletasks()\n            tooltip_width = self.tw.winfo_width()\n            tooltip_height = self.tw.winfo_height()\n\n            # Initial x position - try positioning to the right of the widget first\n            x = self.widget.winfo_rootx() + self.widget.winfo_width() + 5\n\n            # If tooltip would extend beyond right edge, try positioning to the left of the widget\n            if x + tooltip_width > screen_width:\n                x = self.widget.winfo_rootx() - tooltip_width - 5\n\n            # If that would push it off the left edge, position at left screen edge with padding\n            if x < 0:\n                x = 5\n\n            # Calculate vertical position\n            y = self.widget.winfo_rooty()\n\n            # If tooltip is taller than available space, position at top of screen\n            if tooltip_height > usable_height:\n                y = 5  # Small padding from top\n            else:\n                # Center vertically relative to widget if space allows\n                widget_center = y + (self.widget.winfo_height() / 2)\n                y = widget_center - (tooltip_height / 2)\n                \n                # Ensure tooltip doesn't go below usable screen area\n                if y + tooltip_height > usable_height:\n                    y = usable_height - tooltip_height - 5\n\n                # Ensure tooltip doesn't go above top of screen\n                if y < 5:\n                    y = 5\n\n            # Position the tooltip\n            self.tw.wm_geometry(f\"+{int(x)}+{int(y)}\")\n\n        except Exception as e:\n            print(f\"Error showing tooltip: {e}\")\n            import traceback\n            traceback.print_exc()\n\n    def hidetip(self):\n        if self.tw:\n            self.tw.destroy()\n        self.tw = None",
    "start_line": 16,
    "end_line": 120,
    "has_docstring": true,
    "docstring": "Create a tooltip for a given widget with intelligent positioning to prevent clipping.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "object"
    ],
    "class_name": null,
    "display_name": "class CreateToolTip",
    "component_id": "orbital_param_viz.CreateToolTip"
  },
  "orbital_param_viz.rotation_matrix_x": {
    "id": "orbital_param_viz.rotation_matrix_x",
    "name": "rotation_matrix_x",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbital_param_viz.py",
    "relative_path": "orbital_param_viz.py",
    "depends_on": [],
    "source_code": "def rotation_matrix_x(angle):\n    \"\"\"Create rotation matrix around X axis\"\"\"\n    c, s = np.cos(angle), np.sin(angle)\n    return np.array([[1, 0, 0],\n                     [0, c, -s],\n                     [0, s, c]])",
    "start_line": 122,
    "end_line": 127,
    "has_docstring": true,
    "docstring": "Create rotation matrix around X axis",
    "parameters": [
      "angle"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function rotation_matrix_x",
    "component_id": "orbital_param_viz.rotation_matrix_x"
  },
  "orbital_param_viz.rotation_matrix_z": {
    "id": "orbital_param_viz.rotation_matrix_z",
    "name": "rotation_matrix_z",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbital_param_viz.py",
    "relative_path": "orbital_param_viz.py",
    "depends_on": [],
    "source_code": "def rotation_matrix_z(angle):\n    \"\"\"Create rotation matrix around Z axis\"\"\"\n    c, s = np.cos(angle), np.sin(angle)\n    return np.array([[c, -s, 0],\n                     [s, c, 0],\n                     [0, 0, 1]])",
    "start_line": 129,
    "end_line": 134,
    "has_docstring": true,
    "docstring": "Create rotation matrix around Z axis",
    "parameters": [
      "angle"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function rotation_matrix_z",
    "component_id": "orbital_param_viz.rotation_matrix_z"
  },
  "orbital_param_viz.add_coordinate_frame": {
    "id": "orbital_param_viz.add_coordinate_frame",
    "name": "add_coordinate_frame",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbital_param_viz.py",
    "relative_path": "orbital_param_viz.py",
    "depends_on": [],
    "source_code": "def add_coordinate_frame(fig, name, color, R_transform, axis_length, \n                        show_labels=True, opacity=0.8, line_width=4,\n                        show_in_legend=True, visible=True):\n    \"\"\"\n    Add a 3D coordinate frame with the given transformation.\n    \n    Parameters:\n        fig: Plotly figure\n        name: Name of the frame (e.g., 'Perifocal', 'After omega')\n        color: Color for the axes\n        R_transform: 3x3 rotation matrix\n        axis_length: Length of the axes\n        show_labels: Whether to show axis labels\n        opacity: Opacity of the axes\n        line_width: Width of axis lines\n        show_in_legend: Whether to show in legend\n        visible: Whether frame is initially visible\n    \"\"\"\n    # Base axes vectors\n    axes = {\n        'X': np.array([axis_length, 0, 0]),\n        'Y': np.array([0, axis_length, 0]),\n        'Z': np.array([0, 0, axis_length])\n    }\n    \n    # For legend grouping\n    legendgroup = f'frame_{name.replace(\" \", \"_\")}'\n    \n    for i, (axis_name, axis_vec) in enumerate(axes.items()):\n        # Transform the axis\n        transformed = R_transform @ axis_vec\n        \n        # Add axis line\n        fig.add_trace(go.Scatter3d(\n            x=[0, transformed[0]],\n            y=[0, transformed[1]], \n            z=[0, transformed[2]],\n            mode='lines+text',\n            line=dict(color=color, width=line_width),\n            text=['', f'{axis_name}' if show_labels else ''],\n            textposition='top center',\n            textfont=dict(size=14, color=color),\n            opacity=opacity,\n    #        name=f'{name} axes' if i == 0 else '',  # Only show once in legend\n            name=name if i == 0 else '',  # use the name directly            \n            legendgroup=legendgroup,\n            showlegend=(i == 0 and show_in_legend),\n            visible=visible,\n            hovertemplate=f'<b>{name} Frame</b><br>{axis_name}-axis'\n        ))\n        \n        # Add arrow head using a small marker\n        fig.add_trace(go.Scatter3d(\n            x=[transformed[0] * 1.05],  # Slightly beyond the line end\n            y=[transformed[1] * 1.05],\n            z=[transformed[2] * 1.05],\n            mode='markers',\n            marker=dict(\n                symbol='diamond',\n                size=4,\n                color=color\n            ),\n            opacity=opacity,\n            showlegend=False,\n            legendgroup=legendgroup,\n            visible=visible,\n            hoverinfo='skip'\n        ))",
    "start_line": 136,
    "end_line": 203,
    "has_docstring": true,
    "docstring": "Add a 3D coordinate frame with the given transformation.\n\nParameters:\n    fig: Plotly figure\n    name: Name of the frame (e.g., 'Perifocal', 'After omega')\n    color: Color for the axes\n    R_transform: 3x3 rotation matrix\n    axis_length: Length of the axes\n    show_labels: Whether to show axis labels\n    opacity: Opacity of the axes\n    line_width: Width of axis lines\n    show_in_legend: Whether to show in legend\n    visible: Whether frame is initially visible",
    "parameters": [
      "fig",
      "name",
      "color",
      "R_transform",
      "axis_length",
      "show_labels",
      "opacity",
      "line_width",
      "show_in_legend",
      "visible"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_coordinate_frame",
    "component_id": "orbital_param_viz.add_coordinate_frame"
  },
  "orbital_param_viz.add_angle_arc": {
    "id": "orbital_param_viz.add_angle_arc",
    "name": "add_angle_arc",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbital_param_viz.py",
    "relative_path": "orbital_param_viz.py",
    "depends_on": [],
    "source_code": "def add_angle_arc(fig, angle_rad, radius, axis, color, label, start_angle=0,\n                  show_in_legend=True, legendgroup=None):\n    \"\"\"Add an arc showing a rotation angle\"\"\"\n    angle_points = 30\n    angles = np.linspace(start_angle, start_angle + angle_rad, angle_points)\n    \n    if axis == 'z':\n        x = radius * np.cos(angles)\n        y = radius * np.sin(angles)\n        z = np.zeros_like(angles)\n    elif axis == 'x':\n        x = np.zeros_like(angles)\n        y = radius * np.cos(angles)\n        z = radius * np.sin(angles)\n    \n    # Add the arc\n    fig.add_trace(go.Scatter3d(\n        x=x, y=y, z=z,\n        mode='lines+text',\n        line=dict(color=color, width=3),\n        text=[''] * (angle_points-1) + [label],\n        textposition='top center',\n        name=label,\n        legendgroup=legendgroup,\n        showlegend=show_in_legend,\n        visible=True,\n        hovertemplate=f'<b>{label}</b>'\n    ))",
    "start_line": 205,
    "end_line": 232,
    "has_docstring": true,
    "docstring": "Add an arc showing a rotation angle",
    "parameters": [
      "fig",
      "angle_rad",
      "radius",
      "axis",
      "color",
      "label",
      "start_angle",
      "show_in_legend",
      "legendgroup"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_angle_arc",
    "component_id": "orbital_param_viz.add_angle_arc"
  },
  "orbital_param_viz.create_orbital_transformation_viz": {
    "id": "orbital_param_viz.create_orbital_transformation_viz",
    "name": "create_orbital_transformation_viz",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbital_param_viz.py",
    "relative_path": "orbital_param_viz.py",
    "depends_on": [
      "orbital_param_viz.rotation_matrix_z",
      "orbital_param_viz.add_coordinate_frame",
      "orbital_param_viz.rotation_matrix_x",
      "apsidal_markers.calculate_apsidal_dates"
    ],
    "source_code": "def create_orbital_transformation_viz(fig, obj_name, planetary_params, \n                                    show_steps=True, show_axes=True, \n                                    plot_date=None,\n                                    center_object='Sun', parent_planets=None,\n                                    show_apsidal_markers=True,\n                                    current_position=None):                                    \n                            \n    \"\"\"\n    Create a visualization showing how orbital parameters transform to 3D orbit.\n    This version clearly shows the coordinate system transformations.\n    \n    Parameters:\n        fig: Plotly figure object (for compatibility, though we create a new one)\n        obj_name: Name of the object\n        planetary_params: Dictionary of orbital parameters\n        show_steps: Whether to show intermediate transformation steps\n        show_axes: Whether to show coordinate axes\n        plot_date: Date for the visualization (defaults to current date)\n        center_object: Name of the central body (defaults to 'Sun')\n        parent_planets: Dictionary mapping planets to their satellites\n    \"\"\"\n    \n    if obj_name not in planetary_params:\n        print(f\"No orbital parameters found for {obj_name}\")\n        return fig\n    \n    params = planetary_params[obj_name]\n    \n    # Add period if missing but object is known in KNOWN_ORBITAL_PERIODS\n    if 'period' not in params and obj_name in KNOWN_ORBITAL_PERIODS:\n        period_value = KNOWN_ORBITAL_PERIODS[obj_name]\n        if period_value is not None:  # Some objects might have None (hyperbolic)\n            params['period'] = period_value\n            print(f\"Added known period for {obj_name}: {params['period']:.1f} days\")\n\n    \n    # Extract orbital elements\n    a = params.get('a', 1.0)  # Semi-major axis\n    e = params.get('e', 0.0)  # Eccentricity\n    i = params.get('i', 0.0)  # Inclination (degrees)\n    omega = params.get('omega', 0.0)  # Argument of periapsis (degrees)\n    Omega = params.get('Omega', 0.0)  # Longitude of ascending node (degrees)\n    \n    # Convert to radians\n    i_rad = np.radians(i)\n    omega_rad = np.radians(omega)\n    Omega_rad = np.radians(Omega)\n\n    # Determine the central body\n    center_object = 'Sun'  # Default\n    if parent_planets:\n        for planet, moons in parent_planets.items():\n            if obj_name in moons:\n                center_object = planet\n                break    \n    \n    # Calculate periapsis and apoapsis distances\n    r_peri = a * (1 - e)\n    r_apo = a * (1 + e) if e < 1 else None\n    \n    # Set up the plot date\n    if plot_date is None:\n        plot_date = dt.datetime.now()\n    \n    # Clear the figure and start fresh\n    fig.data = []\n    fig.layout = {}\n        \n    # Add central body\n    center_color = 'yellow' if center_object == 'Sun' else 'deepskyblue'\n    fig.add_trace(go.Scatter3d(\n        x=[0], y=[0], z=[0],\n        mode='markers+text',\n        marker=dict(size=20, color=center_color,\n                    line=dict(color='orange', width=2)),\n        text=[center_object],\n        textposition='bottom center',\n        name=center_object,\n        showlegend=True,\n        hovertemplate=f'<b>{center_object}</b><br>Central body'\n    ))\n    \n    # Generate orbital points in perifocal frame\n    if e < 1.0:\n        # Elliptical orbit: Full 360 degrees\n        true_anomaly = np.linspace(0, 2 * np.pi, 200)\n    else:\n        # Hyperbolic orbit: Limit the true anomaly to the valid range\n        # Calculate the angle of the asymptotes where the orbit goes to infinity\n        nu_max = np.arccos(-1 / e)\n        # Generate points within this range, leaving a small buffer to avoid infinity\n        true_anomaly = np.linspace(-nu_max * 0.95, nu_max * 0.95, 200)\n\n    r = a * (1 - e**2) / (1 + e * np.cos(true_anomaly))\n    \n    # Perifocal coordinates\n    x0 = r * np.cos(true_anomaly)\n    y0 = r * np.sin(true_anomaly)\n    z0 = np.zeros_like(true_anomaly)\n    \n    # Build transformation matrices (CORRECTED TO STANDARD CONVENTION)\n    R1 = rotation_matrix_z(Omega_rad)  # First: Longitude of ascending node\n    R2 = rotation_matrix_x(i_rad)      # Second: Inclination\n    R3 = rotation_matrix_z(omega_rad)  # Third: Argument of periapsis\n    \n    # Cumulative transformations (STANDARD ASTRONOMICAL SEQUENCE)\n    R_after_Omega = R1                    # After Omega rotation\n    R_after_inclination = R1 @ R2         # After Omega and i rotations\n    R_final = R1 @ R2 @ R3                # Final: all three rotations\n    \n    # Calculate appropriate scale_basis for the visualization\n    if e >= 0.99:  # Near-parabolic or hyperbolic orbit\n        # For these orbits, use perihelion distance as reference\n        if a < 0:  # Hyperbolic with negative semi-major axis\n            q = abs(a) * (e - 1)  # Perihelion for hyperbolic\n        else:\n            q = a * (1 - e)  # Perihelion for near-parabolic\n        \n        # Special case for known comets\n        if obj_name == 'C/2025_K1':\n            q = 0.33  # Known perihelion\n        \n        # Use a reasonable multiple of perihelion for visualization scale\n        scale_basis = max(3 * q, 1.0)  # At least 1 AU\n        \n        # Cap the scale for better visualization\n        scale_basis = min(scale_basis, 5.0)  # Maximum 5 AU for near-parabolic\n        \n    else:  # Elliptical orbit\n        # For elliptical orbits, use the semi-major axis\n        scale_basis = abs(a)\n        \n        # Adjust for very small orbits (like satellites)\n        if scale_basis < 0.1:\n            scale_basis = 0.1\n\n    # Calculate axis length for coordinate frames\n    # Should be proportional to the orbit size but not too large\n    axis_length = min(0.8 * scale_basis, 2.0)  # Cap at 2 AU for frames\n    \n    if show_axes:\n        # 1. Ecliptic reference frame (gray, always visible)\n        add_coordinate_frame(fig, \"Ecliptic Ref. (+X: Vernal Equinox)\", \"gray\", np.eye(3), \n                           axis_length * 1.2, opacity=0.4, line_width=2, visible=True)\n        \n        # 2. Perifocal frame (blue)\n        add_coordinate_frame(fig, \"1. Perifocal\", \"cyan\", np.eye(3), \n                           axis_length, opacity=0.8, visible=True)\n        \n        # 3. After Omega rotation (purple) - positions the line of nodes\n        if show_steps and Omega != 0:\n            add_coordinate_frame(fig, \"2. After Omega rotation\", \"purple\", R_after_Omega, \n                               axis_length, opacity=0.7, visible=True)\n        \n        # 4. After Omega and i rotation (orange) - tilts the orbital plane\n        if show_steps and i != 0:\n            add_coordinate_frame(fig, \"3. After Omega and i rotation\", \"orange\", \n                               R_after_inclination, axis_length, \n                               opacity=0.7, visible=True)\n        \n        # 5. Final = After all rotations (red)\n        add_coordinate_frame(fig, \"4. After omega rotation (Final)\", \"red\", R_final, \n                           axis_length, opacity=0.8, visible=True)\n\n    # Add orbits at each transformation stage\n    # 1. Perifocal orbit\n    # Create the equation string based on orbit type\n    if e < 1.0:  # Elliptical orbit\n        orbit_type = \"Ellipse\"\n        equation = \"r = a(1 - e^2) / (1 + e*cos(nu))\"\n    elif e == 1.0:  # Parabolic orbit\n        orbit_type = \"Parabola\"\n        equation = \"r = 2p / (1 + cos(nu))\"\n        p_value = a * (1 - e**2)  # semi-latus rectum\n    else:  # Hyperbolic orbit\n        orbit_type = \"Hyperbola\"\n        equation = \"r = a(1 - e^2) / (1 + e*cos(nu))\"\n    \n    fig.add_trace(go.Scatter3d(\n        x=x0, y=y0, z=z0,\n        mode='lines',\n        line=dict(color='cyan', width=4),\n        name='1. Perifocal Frame',\n        showlegend=True,\n        visible=True,\n        hovertemplate=(\n            f'<b>Perifocal Orbit ({orbit_type})</b><br>' +\n            'The orbit in its natural, un-rotated frame.<br><br>' +\n            '<b>Orbit Equation (Polar form):</b><br>' +\n            f'{equation}<br><br>' +\n            '<b>Where:</b><br>' +\n            f'* r = radius from focus ({center_object})<br>' +\n            f'* nu = true anomaly (angle from periapsis)<br>' +\n            f'* a = {a:.3f} AU (semi-major axis)<br>' +\n            f'* e = {e:.6f} (eccentricity)<br>' +\n            (f'* p = {p_value:.3f} AU (semi-latus rectum)<br>' if e == 1.0 else '') +\n            '<br><b>True anomaly (nu):</b><br>' +\n            'The angle measured from periapsis to the<br>' +\n            'current position along the orbit, in the<br>' +\n            'direction of motion.<br>' +\n            '<br><b>Eccentricity (e):</b><br>' +\n            'A measure of how elongated the orbit is:<br>' +\n            '* e = 0: perfect circle<br>' +\n            '* 0 < e < 1: ellipse<br>' +\n            '* e = 1: parabola<br>' +\n            '* e > 1: hyperbola<br>' +\n            '<br><b>Eccentricity from apsides:</b><br>' +\n            (f'e = (r_apo - r_peri) / (r_apo + r_peri)<br>' +\n             f'e = ({r_apo:.3f} - {r_peri:.3f}) / ({r_apo:.3f} + {r_peri:.3f})<br>' +\n             f'e = {e:.6f}' if e < 1.0 else \n             'e = (r_apo - r_peri) / (r_apo + r_peri)<br>' +\n             '(Not applicable for parabolic/hyperbolic orbits)') +\n            '<extra></extra>'\n        )\n    ))  \n    \n    # Add periapsis/apoapsis markers in perifocal\n    fig.add_trace(go.Scatter3d(\n        x=[r_peri], y=[0], z=[0],\n        mode='markers+text',\n        marker=dict(size=6, color='cyan', symbol='square-open'),\n        text=['Periapsis'],\n        textposition='bottom center',\n        name='Periapsis (perifocal)',\n#        legendgroup='apsides',\n#        legendgrouptitle_text='Orbital Points',\n        showlegend=True,\n        visible=True,\n        hovertemplate=f'<b>Periapsis</b><br>Distance: {r_peri:.3f} AU<br>Closest point to {center_object}'\n    ))\n    \n    if e < 1.0:\n        fig.add_trace(go.Scatter3d(\n            x=[-r_apo], y=[0], z=[0],\n            mode='markers+text',\n            marker=dict(size=6, color='cyan', symbol='square-open'),\n            text=['Apoapsis'],\n            textposition='top center',\n            name='Apoapsis (perifocal)',\n#            legendgroup='apsides',\n            showlegend=True,\n            visible=True,\n            hovertemplate=f'<b>Apoapsis</b><br>Distance: {r_apo:.3f} AU<br>Farthest point from {center_object} (a, semi-major axis)'\n        ))\n\n    # ========== INSERT THE NEW CODE HERE ==========\n    # Add semi-major axis trace in perifocal frame\n    if e < 1.0:  # Only for elliptical orbits\n        # The semi-major axis is the distance from the center of the ellipse to either end\n        # In the perifocal frame with focus at origin:\n        # - Center of ellipse is at (-a*e, 0, 0)\n        # - The semi-major axis extends from the center +/-a along the major axis\n        \n        # Method 1: Show semi-major axis from focus to a reference point\n        # This shows the actual semi-major axis length 'a'\n        # We'll draw from the geometric center to one vertex to show 'a'\n        ellipse_center_x = -a * e  # Center of ellipse in perifocal frame\n        \n        # Draw from focus (Sun) toward apoapsis direction, length = a\n        fig.add_trace(go.Scatter3d(\n            x=[0, -a],  # From Sun/focus toward apoapsis (negative x direction)\n            y=[0, 0],\n            z=[0, 0],\n            mode='lines+markers+text',\n            line=dict(color='cyan', width=3, dash='dashdot'),\n            marker=dict(size=[4, 8], color='cyan', symbol=['circle-open', 'diamond-open']),  # Open markers\n            text=['', f'a = {a:.3f} AU'],  # Label only at the end\n            textposition=['bottom center', 'top center'],\n            name='Semi-major axis (a)',\n            showlegend=True,\n            visible=True,\n            hovertemplate=f'<b>Semi-major axis</b><br>a = {a:.3f} AU<br>' +\n                          f'Mean distance of orbit from {center_object}<br>' +\n                          f'Periapsis: {r_peri:.3f} AU<br>' +\n                          f'Apoapsis: {r_apo:.3f} AU<br>' +\n                          f'a = (r_peri + r_apo) / 2'\n        ))\n        \n        # Optional: Add a subtle line showing the full major axis\n        fig.add_trace(go.Scatter3d(\n            x=[r_peri, -r_apo],  # Full major axis from periapsis to apoapsis\n            y=[0, 0],\n            z=[0, 0],\n            mode='lines',\n            line=dict(color='cyan', width=1, dash='dot'),\n            name='Major axis',\n            showlegend=False,  # Don't clutter the legend\n            visible=True,\n            hovertemplate='<b>Major axis</b><br>Full length = 2a'\n        ))\n    # ========== END OF NEW CODE ==========\n    \n    # 2. After Omega rotation\n    if show_steps:\n        coords1 = R_after_Omega @ np.vstack([x0, y0, z0])\n        fig.add_trace(go.Scatter3d(\n            x=coords1[0], y=coords1[1], z=coords1[2],\n            mode='lines',\n            line=dict(color='purple', width=3, dash='dash'),\n            name=f'2. After Omega rotation ({Omega:.1f} deg)',\n            showlegend=True,\n            visible=True,\n            hovertemplate=f'<b>Orbit after Omega rotation</b><br>'\n                          'Step 1: Positions the line of nodes at longitude Omega.'\n        ))\n\n        # Add angle arc for Omega (from vernal equinox to ascending node)\n        if Omega != 0:\n            Omega_arc_angle = np.linspace(0, Omega_rad, 30)\n            Omega_arc_r = 0.25 * scale_basis\n            fig.add_trace(go.Scatter3d(\n                x=Omega_arc_r * np.cos(Omega_arc_angle),\n                y=Omega_arc_r * np.sin(Omega_arc_angle),\n                z=np.zeros_like(Omega_arc_angle),\n                mode='lines+text',\n                line=dict(color='purple', width=3),\n                text=[''] * 29 + [f'Omega = {Omega:.1f} deg'],\n                textposition='top center',\n                name=f'Omega angle ({Omega:.1f} deg)',\n                showlegend=True,\n                visible=True,\n                hovertext=f'<b>Longitude of Ascending Node (Omega)</b><br>Angle: {Omega:.1f} deg<br>'\n                          'From vernal equinox to ascending node in ecliptic plane.'\n            ))\n    \n    # Fix for the line of nodes rendering issue in orbital_param_viz.py\n    # Replace the line of nodes section (around line where it says \"Add line of nodes if inclined\")\n\n    # Add line of nodes if inclined\n    if i != 0:\n        \n        # For near-parabolic and hyperbolic orbits, use a more reasonable scale\n        if e >= 0.99:  # Near-parabolic or hyperbolic\n            # For these orbits, use perihelion distance as reference\n            if a < 0:  # Hyperbolic with negative semi-major axis\n                q = abs(a) * (e - 1)  # Perihelion for hyperbolic\n            else:\n                q = a * (1 - e)  # Perihelion for near-parabolic\n            \n            # Special case for known comets\n            if obj_name == 'C/2025_K1':\n                q = 0.33  # Known perihelion\n            \n            # Use a reasonable multiple of perihelion for line length\n            nodes_length = max(3 * q, 1.0)  # At least 1 AU, at most 3x perihelion\n        else:\n            # For elliptical orbits, use the normal calculation\n            nodes_length = 1.2 * abs(a)\n        \n        # Ensure nodes_length is reasonable (cap at 10 AU for visualization)\n        nodes_length = min(nodes_length, 10.0)\n        \n        # CORRECTED: Line of nodes should be along x-axis after Omega rotation only\n        nodes_start = R_after_Omega @ np.array([-nodes_length, 0, 0])\n        nodes_end = R_after_Omega @ np.array([nodes_length, 0, 0])\n        \n        fig.add_trace(go.Scatter3d(\n            x=[nodes_start[0], nodes_end[0]],\n            y=[nodes_start[1], nodes_end[1]],\n            z=[nodes_start[2], nodes_end[2]],\n            mode='lines',\n            line=dict(color='purple', width=2, dash='dashdot'),\n            name='Line of Nodes',\n            showlegend=True,\n            visible=True,\n            hovertemplate='<b>Line of Nodes</b><br>Intersection with ecliptic plane'\n        ))\n        \n        # Ascending node marker (at +x after Omega rotation)\n        asc_node = R_after_Omega @ np.array([nodes_length, 0, 0])\n\n        fig.add_trace(go.Scatter3d(\n            x=[asc_node[0]], y=[asc_node[1]], z=[asc_node[2]],\n            mode='markers+text',\n            marker=dict(size=6, color='purple', symbol='square'),\n            text=['Ascending Node'],\n            textposition='top center',\n            name='Ascending Node',\n            showlegend=True,\n            visible=True,\n            hovertemplate='<b>Ascending Node</b><br>Where orbit crosses ecliptic plane northward'\n        ))\n\n    # After Omega and i rotation\n    if show_steps:\n        coords2 = R_after_inclination @ np.vstack([x0, y0, z0])\n        fig.add_trace(go.Scatter3d(\n            x=coords2[0], y=coords2[1], z=coords2[2],\n            mode='lines',\n            line=dict(color='orange', width=3, dash='dot'),\n            name=f'3. After Omega and i rotation ({i:.1f} deg)',\n            showlegend=True,\n            visible=True,\n            hovertemplate=f'<b>Orbit after Omega and i rotation</b><br>' \n            'Step 2: Tilts the orbital plane by inclination i.'\n        ))\n    \n# Fix for the inclination arc visibility issue in orbital_param_viz.py\n# Replace the existing inclination arc section (around line 340-365) with this improved version:\n\n    # Add inclination angle arc\n    if i != 0:\n        # The inclination arc should show the rotation around the X-axis (line of nodes)\n        # after the omega rotation has been applied\n        \n        # Make the arc radius larger for better visibility\n        inc_arc_r = 0.5 * scale_basis  # Increased from 0.3 * a for better visibility\n        \n        # Generate the arc in the YZ plane (rotation around X-axis)\n        inc_arc_angle = np.linspace(0, i_rad, 30)\n        \n        # Create arc points - starts from Y-axis and rotates toward Z-axis\n        inc_x = np.zeros_like(inc_arc_angle)\n        inc_y = inc_arc_r * np.cos(inc_arc_angle)\n        inc_z = inc_arc_r * np.sin(inc_arc_angle)\n        \n        # Transform the arc by the omega rotation to align with the line of nodes\n        inc_arc_coords = R_after_Omega @ np.vstack([inc_x, inc_y, inc_z])\n        \n        # Add the inclination arc trace\n        fig.add_trace(go.Scatter3d(\n            x=inc_arc_coords[0],\n            y=inc_arc_coords[1],\n            z=inc_arc_coords[2],\n            mode='lines+markers+text',\n            line=dict(color='orange', width=4),  # Increased width from 3\n            marker=dict(\n                size=[0] * 29 + [6],  # Add a marker at the end\n                color='orange',\n                symbol='diamond'\n            ),\n            text=[''] * 29 + [f'i = {i:.1f} deg'],\n            textposition='top center',\n            textfont=dict(size=12, color='orange'),\n            name=f'Inclination ({i:.1f} deg)',\n            legendgroup='inclination',\n            showlegend=True,\n            visible=True,\n            hovertemplate=f'<b>Inclination (i)</b><br>Angle: {i:.1f} deg<br>' +\n                         'Tilts the orbit relative to the ecliptic plane.<br>' +\n                         'Rotation around the X-axis (line of nodes).'\n        ))\n        \n        # Optional: Add a visual guide line from origin to start of arc\n        # This helps show what plane the rotation is in\n        guide_start = R_after_Omega @ np.array([0, inc_arc_r, 0])\n        fig.add_trace(go.Scatter3d(\n            x=[0, guide_start[0]],\n            y=[0, guide_start[1]],\n            z=[0, guide_start[2]],\n            mode='lines',\n            line=dict(color='orange', width=2, dash='dot'),\n            legendgroup='inclination',  # Same legendgroup         \n            showlegend=False,\n            visible=True,\n            hovertemplate='Start of inclination rotation'\n        ))\n        \n        # Add another guide line to the end of the arc\n        guide_end = R_after_Omega @ np.array([0, inc_arc_r * np.cos(i_rad), inc_arc_r * np.sin(i_rad)])\n        fig.add_trace(go.Scatter3d(\n            x=[0, guide_end[0]],\n            y=[0, guide_end[1]],\n            z=[0, guide_end[2]],\n            mode='lines',\n            line=dict(color='orange', width=2, dash='dot'),\n            legendgroup='inclination',  # Same legendgroup\n            showlegend=False,  # Don't show in legend\n            visible=True,\n            hovertemplate='End of inclination rotation'\n        ))\n\n    # 4. Final orbit\n    coords_final = R_final @ np.vstack([x0, y0, z0])\n    fig.add_trace(go.Scatter3d(\n        x=coords_final[0], y=coords_final[1], z=coords_final[2],\n        mode='lines',\n        line=dict(color='red', width=4),\n        name='4. Final Orbit',\n    #    legendgroup='transformations',\n        showlegend=True,\n        visible=True,\n        hovertemplate='<b>Final Orbit</b><br>In ecliptic coordinates'\n    ))\n    \n    # The Omega angle is already shown in step 2, no need to repeat it here\n\n    # Add arc showing omega angle from ascending node to periapsis\n    # This arc needs to be in the FINAL ORBITAL PLANE.\n\n    if omega != 0:\n        # Define the periapsis vector in the perifocal frame\n        peri_perifocal = np.array([r_peri, 0, 0])\n        # Calculate peri_final\n        peri_final = R_final @ peri_perifocal \n\n    #    arc_radius = 0.35 * a # Use the same radius as other arcs\n        arc_radius = 0.35 * scale_basis # Use scale_basis for consistent scaling\n\n        # Get the actual Ascending Node point in the FINAL frame.\n        # This uses the definition of the line of nodes already drawn.\n        # We need a point on the orbit that is the ascending node.\n        # This happens at true anomaly nu = -omega_rad in the perifocal frame.\n        \n        # Let's generate the ascending node point using the orbit equation,\n        # then apply the full R_final transformation.\n        # True anomaly for Ascending Node is -omega_rad\n        r_at_AN = a * (1 - e**2) / (1 + e * np.cos(-omega_rad))\n        \n        # Perifocal coordinates of Ascending Node\n        asc_node_perifocal = np.array([r_at_AN * np.cos(-omega_rad), \n                                       r_at_AN * np.sin(-omega_rad), \n                                       0])\n        \n        # Transform this point to the final frame\n        asc_node_final_point = R_final @ asc_node_perifocal\n\n        # Now, create a vector from the origin to this ascending node point, scaled for the arc\n        start_vec_for_arc = (asc_node_final_point / np.linalg.norm(asc_node_final_point)) * arc_radius\n        \n        # Get the orbital plane's normal vector in the final frame.\n        orbital_plane_normal_final = R_final @ np.array([0, 0, 1])\n        orbital_plane_normal_final_norm = orbital_plane_normal_final / np.linalg.norm(orbital_plane_normal_final)\n\n        arc_x_coords = []\n        arc_y_coords = []\n        arc_z_coords = []\n\n        # Generate intermediate angles for the arc sweep\n        # Sweep by omega_rad from the ascending node.\n        num_points = 30\n        sweep_angles = np.linspace(0, omega_rad, num_points)\n\n        for angle in sweep_angles:\n            # Rodrigues' Rotation Formula: V_rot = V*cos(theta) + (K x V)*sin(theta) + K*(K . V)*(1-cos(theta))\n            V_rotated = start_vec_for_arc * np.cos(angle) + \\\n                        np.cross(orbital_plane_normal_final_norm, start_vec_for_arc) * np.sin(angle) + \\\n                        orbital_plane_normal_final_norm * np.dot(orbital_plane_normal_final_norm, start_vec_for_arc) * (1 - np.cos(angle))\n            \n            arc_x_coords.append(V_rotated[0])\n            arc_y_coords.append(V_rotated[1])\n            arc_z_coords.append(V_rotated[2])\n\n        fig.add_trace(\n            go.Scatter3d(\n                x=arc_x_coords,\n                y=arc_y_coords,\n                z=arc_z_coords,\n                mode='lines+text',\n                line=dict(color='red', width=2, dash='dot'), \n                text=[''] * (len(arc_x_coords) - 1) + [f'omega = {omega:.1f} deg'],\n                textposition='bottom center', \n                name=f'omega angle (orbital plane)',\n                showlegend=True,\n                visible=True,\n                hovertext=f'<b>Argument of Periapsis (omega)</b><br>'\n                        f'Angle from Ascending Node to Periapsis.<br>'\n                        f'Measured in the orbital plane.<br>Value: {omega:.1f} deg'\n            )\n        )\n\n    # Transform and add final periapsis/apoapsis markers\n    peri_perifocal = np.array([r_peri, 0, 0])\n    peri_final = R_final @ peri_perifocal\n\n    # Create a combined trace for both apsides\n    apsides_x = [peri_final[0]]\n    apsides_y = [peri_final[1]]\n    apsides_z = [peri_final[2]]\n    apsides_text = ['Periapsis (final)']\n\n# Calculate apsidal dates if we have position information\n    perihelion_date_str = \"\"\n    aphelion_date_str = \"\"\n    \n    if plot_date is None:\n        plot_date = dt.datetime.now()\n    \n    print(f\"DEBUG: Calculating apsidal dates for {obj_name}\")\n    print(f\"  plot_date: {plot_date}\")\n    print(f\"  current_position: {current_position}\")\n    \n    # Try to calculate accurate dates if we have current position\n    if current_position and 'x' in current_position:\n        try:\n            from apsidal_markers import calculate_apsidal_dates\n            perihelion_date, aphelion_date = calculate_apsidal_dates(\n                plot_date,\n                current_position['x'],\n                current_position['y'],\n                current_position['z'],\n                a,\n                e,\n                i,\n                omega,\n                Omega,\n                obj_name\n            )\n            print(f\"  Calculated dates - Perihelion: {perihelion_date}, Aphelion: {aphelion_date}\")\n            if perihelion_date:\n                perihelion_date_str = f\"<br>Date: {perihelion_date.strftime('%Y-%m-%d')}\"\n            if aphelion_date and e < 1:\n                aphelion_date_str = f\"<br>Date: {aphelion_date.strftime('%Y-%m-%d')}\"\n            print(f\"  Date strings - Perihelion: {perihelion_date_str}, Aphelion: {aphelion_date_str}\")\n        except Exception as ex:\n            print(f\"Could not calculate apsidal dates: {ex}\")\n            import traceback\n            traceback.print_exc()\n    else:\n        print(\"  No current position available for date calculation\")\n    \n# ONLY use estimates if we don't have calculated dates\n    if not perihelion_date_str or not aphelion_date_str:\n        # Simple estimation based on orbital period\n        if 'period' in params and params['period'] is not None:\n            try:\n                period_days = params['period']\n                # For demonstration, show estimated dates\n                # In reality, you'd need current mean anomaly to be accurate\n                if not perihelion_date_str:\n                    est_perihelion = plot_date + dt.timedelta(days=period_days/4)\n                    perihelion_date_str = f\"<br>Next perihelion: ~{est_perihelion.strftime('%Y-%m-%d')} (estimate)\"\n                if not aphelion_date_str:\n                    est_aphelion = plot_date + dt.timedelta(days=3*period_days/4)\n                    aphelion_date_str = f\"<br>Next aphelion: ~{est_aphelion.strftime('%Y-%m-%d')} (estimate)\"\n            except:\n                pass\n        \n        # Check if we have pre-calculated dates in params\n        if not perihelion_date_str and 'perihelion_dates' in params and params['perihelion_dates']:\n            # Find the next perihelion date after plot_date\n            for date_str in params['perihelion_dates']:\n                try:\n                    peri_date = dt.datetime.strptime(date_str, '%Y-%m-%d')\n                    if peri_date > plot_date:\n                        perihelion_date_str = f\"<br>Next perihelion: {date_str}\"\n                        break\n                except:\n                    pass\n        \n        if not aphelion_date_str and 'aphelion_dates' in params and params['aphelion_dates']:\n            # Find the next aphelion date after plot_date\n            for date_str in params['aphelion_dates']:\n                try:\n                    apo_date = dt.datetime.strptime(date_str, '%Y-%m-%d')\n                    if apo_date > plot_date:\n                        aphelion_date_str = f\"<br>Next aphelion: {date_str}\"\n                        break\n                except:\n                    pass\n\n    # CREATE apsides_hover OUTSIDE the if block\n    apsides_hover = [f'<b>Periapsis (final)</b><br>Distance: {r_peri:.3f} AU from {center_object}{perihelion_date_str}']\n\n    if e < 1.0:\n        apo_perifocal = np.array([-r_apo, 0, 0])\n        apo_final = R_final @ apo_perifocal\n        apsides_x.append(apo_final[0])\n        apsides_y.append(apo_final[1])\n        apsides_z.append(apo_final[2])\n        apsides_text.append('Apoapsis (final)')\n        \n        apsides_hover.append(f'<b>Apoapsis (final)</b><br>Distance: {r_apo:.3f} AU from {center_object}{aphelion_date_str}')\n\n    fig.add_trace(go.Scatter3d(\n        x=apsides_x,\n        y=apsides_y,\n        z=apsides_z,\n        mode='markers+text',\n        marker=dict(size=6, color='red', symbol='square-open'),\n        text=apsides_text,\n        textposition='top center',\n        name='Apsides (final)',\n        showlegend=True,\n        visible=True,\n        hovertemplate=apsides_hover\n    ))\n                    \n# Add current position marker using the fetched position\n    if current_position and 'x' in current_position:\n        fig.add_trace(\n            go.Scatter3d(\n                x=[current_position['x']],\n                y=[current_position['y']], \n                z=[current_position['z']],\n                mode='markers+text',\n                marker=dict(size=8, color='red', symbol='circle'),\n                text=[f'{obj_name}'],\n                textposition='top center',\n                name=f'{obj_name} (final)',\n                showlegend=True,\n                hovertext=f'<b>{obj_name} Position</b><br>'\n                         f'Date: {plot_date.strftime(\"%Y-%m-%d\")}<br>'\n                         f'X: {current_position[\"x\"]:.3f} AU<br>'\n                         f'Y: {current_position[\"y\"]:.3f} AU<br>'\n                         f'Z: {current_position[\"z\"]:.3f} AU<br>'\n                         f'Distance: {np.sqrt(current_position[\"x\"]**2 + current_position[\"y\"]**2 + current_position[\"z\"]**2):.3f} AU'\n            )\n        )\n    else:\n        print(f\"Warning: No position data available for {obj_name}\")\n\n    # Add direction of motion indicator\n    # Define the arrow in the perifocal frame at true anomaly nu = 90 degrees\n    nu_motion = np.pi / 2\n    r_motion = a * (1 - e**2) / (1 + e * np.cos(nu_motion))\n    \n    # Position vector (start of arrow) in perifocal frame\n    pos_motion_pf = np.array([0, r_motion, 0])\n\n    # Tangent vector (direction of arrow) in perifocal frame\n    tangent_vec_pf = np.array([-np.sin(nu_motion), e + np.cos(nu_motion), 0])\n    tangent_vec_pf /= np.linalg.norm(tangent_vec_pf)\n\n    arrow_len = 0.4 * a\n    arrow_end_pf = pos_motion_pf + arrow_len * tangent_vec_pf\n\n    # Transform the arrow's start and end points to the final ecliptic frame\n    pos_motion_final = R_final @ pos_motion_pf\n    arrow_end_final = R_final @ arrow_end_pf\n\n    fig.add_trace(go.Scatter3d(\n        x=[pos_motion_final[0], arrow_end_final[0]],\n        y=[pos_motion_final[1], arrow_end_final[1]],\n        z=[pos_motion_final[2], arrow_end_final[2]],\n        mode='lines+markers+text',\n        textposition='top center',\n        line=dict(color='red', width=2),\n        marker=dict(symbol='diamond', size=[0, 8], color='red'),\n        name='Direction of Motion',\n        showlegend=True,\n        visible=True,\n        hoverinfo='text',\n\n        # Corrected: Provide text as a list for the two points\n        text=['',  # No text for the start of the arrow\n            f'Direction of Motion<br>'  # Text for the arrowhead\n            f'Orbit is {\"Retrograde (i > 90 deg)\" if i > 90 else \"Prograde (i < 90 deg)\"}']\n    ))\n\n    # Update layout\n    # Set axis range to accommodate extended coordinate frames\n    axis_range = scale_basis * 2.5 # Use a larger buffer to ensure everything fits\n    \n    fig.update_layout(\n        scene=dict(\n            xaxis=dict(range=[-axis_range, axis_range], title='X (AU)'),\n            yaxis=dict(range=[-axis_range, axis_range], title='Y (AU)'),\n            zaxis=dict(range=[-axis_range, axis_range], title='Z (AU)'),\n            aspectmode='cube',\n            camera=dict(eye=dict(x=1.5, y=1.5, z=1.5))\n        ),\n        title=dict(\n            text=f\"Orbital Parameter Transformation: {obj_name}<br><sub>Date: {plot_date.strftime('%Y-%m-%d %H:%M UTC')}</sub>\",\n    #        text=f\"Orbital Parameter Transformation: {obj_name}<br><sub>Date: {plot_date.strftime('%Y-%m-%d UTC')}</sub>\",            \n            x=0.5,\n            xanchor='center'\n        ),\n        margin=dict(r=50, l=50, t=80, b=50),\n        showlegend=True,\n        legend=dict(\n            x=0.02,\n            y=0.98,\n            bgcolor='rgba(255,255,255,0.5)',\n            bordercolor='black',\n            borderwidth=1,\n            font=dict(size=12),\n            itemsizing='constant',\n            itemwidth=30,\n            tracegroupgap=5,\n            yanchor='top',\n            xanchor='left'\n        ),\n        width=1450,\n        height=680\n    )\n    \n    # Add comprehensive annotation\n    annotation_text = f\"\"\"<b>Orbital Transformation Visualization</b><br><br>\n    <b>Orbital Elements:</b><br>\n    * a = {a:.3f} AU (semi-major axis)<br>\n    * e = {e:.6f} (eccentricity)<br>\n    * i = {i:.1f} deg (inclination)<br>\n    * omega = {omega:.1f} deg (argument of periapsis)<br>\n    * Omega = {Omega:.1f} deg (longitude of ascending node)<br><br>\n\n    <b>Coordinate Frame Transformations:</b><br>\n    The final transformation is a product of three rotations:<br>\n    R = R_z(omega) * R_x(i) * R_z(Omega)<br><br>\n\n    1. <b>Perifocal Frame</b> (cyan) - The orbit's 2D blueprint.<br>\n    * Periapsis is aligned on the +X axis.<br><br>\n\n    2. <b>After Omega rotation</b> (purple) - Positions the line of nodes.<br>\n    * Rotates by Omega around the Z-axis (from vernal equinox to ascending node).<br>\n    <b>[OK] Sets where the orbit crosses the ecliptic plane.</b><br><br>\n\n    3. <b>After Omega and i rotation</b> (orange) - Tilts the orbit.<br>\n    * Tilts the frame by i around the line of nodes (X-axis after Omega rotation).<br>\n    <b>[OK] Gives the orbit its inclination relative to the ecliptic.</b><br><br>\n\n    4. <b>After omega rotation (Final)</b> (red) - Final orientation.<br>\n    * Rotates by omega within the tilted orbital plane.<br>\n    <b>[OK] Positions the periapsis at angle omega from the ascending node.</b><br><br>    \n\n    <b>Key Insight:</b> This visualization shows the sequence of<br> \n    rotations applied to the initial Perifocal Orbit (cyan) to place it<br> \n    into its final orientation in the Ecliptic Frame (red).<br><br>\n\n    <b>Interactive:</b> Click legend items to show/hide elements.\"\"\"\n    \n    fig.add_annotation(\n        text=annotation_text,\n        xref=\"paper\", yref=\"paper\",\n        x=1.03, y=0.98,                 # x=0.98 originally\n        xanchor=\"right\", yanchor=\"top\",\n        showarrow=False,\n        font=dict(size=11, family=\"Arial\"),\n        align=\"left\",\n        bordercolor=\"gray\",\n        borderwidth=1,\n        borderpad=10,\n        bgcolor=\"rgba(255,255,255,0.5)\"\n    )\n    \n    return fig",
    "start_line": 234,
    "end_line": 1059,
    "has_docstring": true,
    "docstring": "Create a visualization showing how orbital parameters transform to 3D orbit.\nThis version clearly shows the coordinate system transformations.\n\nParameters:\n    fig: Plotly figure object (for compatibility, though we create a new one)\n    obj_name: Name of the object\n    planetary_params: Dictionary of orbital parameters\n    show_steps: Whether to show intermediate transformation steps\n    show_axes: Whether to show coordinate axes\n    plot_date: Date for the visualization (defaults to current date)\n    center_object: Name of the central body (defaults to 'Sun')\n    parent_planets: Dictionary mapping planets to their satellites",
    "parameters": [
      "fig",
      "obj_name",
      "planetary_params",
      "show_steps",
      "show_axes",
      "plot_date",
      "center_object",
      "parent_planets",
      "show_apsidal_markers",
      "current_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_orbital_transformation_viz",
    "component_id": "orbital_param_viz.create_orbital_transformation_viz"
  },
  "orbital_param_viz.create_eccentricity_demo_window": {
    "id": "orbital_param_viz.create_eccentricity_demo_window",
    "name": "create_eccentricity_demo_window",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbital_param_viz.py",
    "relative_path": "orbital_param_viz.py",
    "depends_on": [],
    "source_code": "def create_eccentricity_demo_window(parent, objects=None, planetary_params_override=None):\n    \"\"\"\n    Create a window with an interactive eccentricity slider visualization.\n    Shows how eccentricity affects orbital shape from circle to hyperbola.\n    \n    Parameters:\n        parent: Parent window\n        objects: List of celestial objects from main app (optional)\n        planetary_params_override: Override the global planetary_params if needed (optional)\n    \"\"\"\n    # Use the global planetary_params by default, but allow override if passed\n    params_to_use = planetary_params_override if planetary_params_override else planetary_params\n    \n    # Create new window\n    demo_window = tk.Toplevel(parent)\n    demo_window.title(\"Eccentricity Effects on Orbital Shape\")\n    demo_window.geometry(\"900x700\")\n    \n    # Create main frame\n    main_frame = ttk.Frame(demo_window)\n    main_frame.pack(fill='both', expand=True, padx=10, pady=10)\n    \n    # Create control frame at top\n    control_frame = ttk.LabelFrame(main_frame, text=\"Eccentricity Visualization\")\n    control_frame.pack(fill='x', padx=5, pady=5)\n    \n    # Eccentricity value display and orbit type\n    e_value_var = tk.StringVar(value=\"0.0167\")  # Earth's eccentricity\n    orbit_type_var = tk.StringVar(value=\"Ellipse\")  # Earth has elliptical orbit\n    \n    # IMPORTANT: Define object_var HERE, before update_plot function\n    object_var = tk.StringVar(value=\"Earth\")  # Default to Earth\n    \n    # Labels and entry\n    ttk.Label(control_frame, text=\"Eccentricity (e):\").grid(row=0, column=0, padx=5, pady=5, sticky='w')\n    \n    # Entry field for numerical input\n    e_entry = ttk.Entry(control_frame, textvariable=e_value_var, width=10, font=('TkDefaultFont', 12))\n    e_entry.grid(row=0, column=1, padx=5, pady=5)\n    \n    # Validation function for entry\n    def validate_entry(*args):\n        try:\n            value = float(e_value_var.get())\n            if 0 <= value <= 10.0:\n                e_slider.set(value)\n                update_plot()\n            else:\n                # Clamp to valid range\n                if value < 0:\n                    e_value_var.set(\"0.0000\")\n                    e_slider.set(0)\n                elif value > 10.0:\n                    e_value_var.set(\"10.0000\")\n                    e_slider.set(10.0)\n                update_plot()\n        except ValueError:\n            pass\n    \n    # Bind entry to validation\n    e_entry.bind('<Return>', lambda e: validate_entry())\n    e_entry.bind('<FocusOut>', lambda e: validate_entry())\n    \n    ttk.Label(control_frame, text=\"Orbit Type:\").grid(row=0, column=2, padx=20, pady=5, sticky='w')\n    orbit_type_label = tk.Label(control_frame, textvariable=orbit_type_var, font=('TkDefaultFont', 12, 'bold'))\n    orbit_type_label.grid(row=0, column=3, padx=5, pady=5)\n    \n    # Slider\n    e_slider = ttk.Scale(control_frame, from_=0.0, to=10.0, orient='horizontal', length=400)\n    e_slider.grid(row=1, column=0, columnspan=4, padx=5, pady=5, sticky='ew')\n    e_slider.set(0.0167)  # earth\n    \n    # Add tick marks\n    tick_frame = ttk.Frame(control_frame)\n    tick_frame.grid(row=2, column=0, columnspan=4, sticky='ew', padx=5)\n    \n    # Major tick marks\n    ticks = [0, 1.0, 2.0, 4.0, 6.0, 8.0, 10.0]\n    tick_labels = ['0 (Circle)', '1 (Parabola)', '2', '4', '6', '8', '10']\n    for i, (tick, label) in enumerate(zip(ticks, tick_labels)):\n        ttk.Label(tick_frame, text=label, font=('TkDefaultFont', 9)).place(\n            relx=tick/10.0, rely=0, anchor='n')\n    \n    # Create matplotlib figure\n    fig, ax = plt.subplots(figsize=(8, 6))\n    fig.patch.set_facecolor('white')\n    \n    # Embed in tkinter\n    canvas_frame = ttk.Frame(main_frame)\n    canvas_frame.pack(fill='both', expand=True, pady=10)\n    \n    canvas = FigureCanvasTkAgg(fig, master=canvas_frame)\n    canvas.get_tk_widget().pack(fill='both', expand=True)\n    \n    # Information panel\n    info_frame = ttk.LabelFrame(main_frame, text=\"Orbital Parameters\")\n    info_frame.pack(fill='x', padx=5, pady=5)\n    \n    param_labels = {}\n    param_info = [\n        ('periapsis', 'Periapsis distance:', 'AU'),\n        ('apoapsis', 'Apoapsis distance:', 'AU'),\n        ('b', 'Semi-minor axis (b):', 'AU'),\n        ('focus', 'Focus distance (c):', 'AU'),\n    ]\n    \n    for i, (key, label, unit) in enumerate(param_info):\n        ttk.Label(info_frame, text=label).grid(row=i//2, column=(i%2)*3, padx=5, pady=2, sticky='w')\n        value_label = ttk.Label(info_frame, text=\"1.000\")\n        value_label.grid(row=i//2, column=(i%2)*3+1, padx=5, pady=2, sticky='e')\n        ttk.Label(info_frame, text=unit).grid(row=i//2, column=(i%2)*3+2, padx=5, pady=2, sticky='w')\n        param_labels[key] = value_label\n    \n    def update_plot(*args):\n        \"\"\"Update the plot based on slider value\"\"\"\n        e = e_slider.get()\n        print(f\"Update plot called with e={e}\")\n        \n        # Update value display\n        e_value_var.set(f\"{e:.6f}\")\n        \n        # Determine orbit type\n        if e < 0.01:\n            orbit_type = \"Circle\"\n            orbit_color = 'blue'\n        elif e < 1.0:\n            orbit_type = \"Ellipse\"\n            orbit_color = 'green'\n        elif e == 1.0:\n            orbit_type = \"Parabola (theoretical)\"\n            orbit_color = 'orange'\n        else:\n            orbit_type = \"Hyperbola\"\n            orbit_color = 'red'\n        \n        orbit_type_var.set(orbit_type)\n        \n        # Clear the plot\n        ax.clear()\n        \n        # Set up the plot with extra space for text box\n        ax.set_xlim(-3.5, 3.5)\n        ax.set_ylim(-2.5, 2.5)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        ax.axhline(y=0, color='k', linewidth=0.5)\n        ax.axvline(x=0, color='k', linewidth=0.5)\n        \n        # Get the selected object name - now properly accessible\n        selected_obj = object_var.get()\n        \n        # Get the actual semi-major axis for the selected object\n        if selected_obj in params_to_use:\n            params = params_to_use[selected_obj]\n            a = params.get('a', 1.0)  # Use object's actual semi-major axis\n            print(f\"Using {selected_obj}'s semi-major axis: {a} AU\")\n        else:\n            a = 1.0  # Default to 1 AU if no data\n            print(f\"No data for {selected_obj}, using default a=1.0 AU\")\n\n# DYNAMIC AXES SCALING based on the orbit size\n        # For hyperbolic orbits, 'a' is often negative in JPL data (standard convention)\n        # We always use absolute value for distance calculations\n        \n        if e < 1.0:  # Ellipse or circle\n            # For elliptical orbits, 'a' should be positive\n            # The maximum extent is the apoapsis\n            max_extent = abs(a) * (1 + e)\n        elif abs(e - 1.0) < 0.01:  # Parabola\n            # For parabolic orbits, show a reasonable portion\n            max_extent = abs(a) * 3\n        else:  # Hyperbola (e > 1)\n            # For hyperbolic orbits, we need to determine the convention used\n            # If a < 0, it's the JPL convention (common for comets)\n            # If a > 0, it's the standard mathematical convention\n            \n            # Always use positive value for calculations\n            a_for_calc = abs(a)\n            \n            # Calculate key distances\n            r_peri = a_for_calc * (e - 1)  # Periapsis distance (always positive)\n            center_dist = a_for_calc * e    # Distance to hyperbola center\n            \n            # The plot needs to show:\n            # 1. The periapsis point clearly\n            # 2. The hyperbola center (if reasonable)\n            # 3. Enough of the trajectory to see the curve\n            \n            # For very high eccentricity, the center is far away\n            # We should focus on the periapsis region\n            if e > 5:\n                # High eccentricity: focus on periapsis region\n                max_extent = r_peri * 2.5  # Show 2.5x the periapsis distance\n            else:\n                # Moderate eccentricity: show more of the hyperbola\n                max_extent = max(\n                    r_peri * 3,        # At least 3x periapsis distance\n                    center_dist * 1.2  # Include the center if not too far\n                )\n            \n            print(f\"DEBUG: Hyperbola scaling - a={a:.3f}, a_for_calc={a_for_calc:.3f}\")\n            print(f\"DEBUG: e={e:.6f}, r_peri={r_peri:.3f}, center_dist={center_dist:.3f}\")\n            print(f\"DEBUG: max_extent={max_extent:.3f}\")\n        \n        # Add padding (20% extra space)\n        plot_range = max_extent * 1.2\n        \n        # For extremely high eccentricity, ensure minimum visible range\n        if e > 10 and plot_range < 2.0:\n            plot_range = 2.0  # Minimum 2 AU range for visibility\n        \n        print(f\"DEBUG: Final plot_range = +/-{plot_range:.3f} AU\")\n        \n        # Set up the plot with dynamic scaling\n        ax.set_xlim(-plot_range, plot_range)\n        ax.set_ylim(-plot_range, plot_range)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        ax.axhline(y=0, color='k', linewidth=0.5)\n        ax.axvline(x=0, color='k', linewidth=0.5)\n\n        if e < 1.0:  # Circle or Ellipse\n            # Calculate orbital parameters\n            b = a * np.sqrt(1 - e**2)  # Semi-minor axis\n            c = a * e  # Focus distance from center\n            \n            # The center of the ellipse is at (-c, 0) from the primary focus\n            center_x = -c\n            center_y = 0\n\n            # Periapsis and apoapsis distances from focus\n            r_peri = a * (1 - e)\n            r_apo = a * (1 + e)\n            \n            # Update parameter display\n            param_labels['periapsis'].config(text=f\"{r_peri:.3f}\")\n            param_labels['apoapsis'].config(text=f\"{r_apo:.3f}\")\n            param_labels['b'].config(text=f\"{b:.3f}\")\n            param_labels['focus'].config(text=f\"{c:.3f}\")\n            \n            # Draw the orbit using polar coordinates from the focus\n            theta = np.linspace(0, 2*np.pi, 1000)\n            r = a * (1 - e**2) / (1 + e * np.cos(theta))\n            x = r * np.cos(theta)\n            y = r * np.sin(theta)\n            \n            ax.plot(x, y, color=orbit_color, linewidth=2, label=f'{orbit_type} (e={e:.6f})')\n            \n            # Mark the orbit center with a cross\n            ax.plot(center_x, center_y, 'k+', markersize=10, markeredgewidth=2, \n                    label='Orbit Center', zorder=4)\n\n            # Mark the foci\n            # Primary focus (Sun) at origin\n            ax.plot(0, 0, 'yo', markersize=10, label='Primary Focus (Sun)', zorder=5)\n            \n            # Empty focus at -2c from the Sun\n            ax.plot(-2*c, 0, 'ko', markersize=6, label='Empty Focus', zorder=5)\n            \n            # Mark periapsis and apoapsis\n            ax.plot(r_peri, 0, 'ro', markersize=8, label='Periapsis', zorder=5)\n            ax.plot(-r_apo, 0, 'go', markersize=8, label='Apoapsis', zorder=5)\n            \n            # Add verification lines to show sum of distances is constant\n            # Draw lines from periapsis to both foci\n            ax.plot([r_peri, 0], [0, 0], 'r--', alpha=0.3, linewidth=1)\n            ax.plot([r_peri, -2*c], [0, 0], 'r--', alpha=0.3, linewidth=1)\n            \n            # Draw lines from apoapsis to both foci\n            ax.plot([-r_apo, 0], [0, 0], 'g--', alpha=0.3, linewidth=1)\n            ax.plot([-r_apo, -2*c], [0, 0], 'g--', alpha=0.3, linewidth=1)\n            \n            # Add text box with definitions - positioned outside plot area\n            textstr = f'''$\\\\mathbf{{Definitions}}$:\n            - $\\\\mathbf{{{orbit_type}}}$: A conic section with eccentricity e = {e:.6f}\n            - $\\\\mathbf{{Semi-major\\\\ axis\\\\ (a)}}$: Half the longest diameter of the ellipse\n                a = {a:.3f} AU\n            - $\\\\mathbf{{Semi-minor\\\\ axis\\\\ (b)}}$: Half the shortest diameter of the ellipse\n                b = {b:.3f} AU\n            - $\\\\mathbf{{Orbit\\\\ Center}}$: Geometric center of the ellipse at ({center_x:.3f}, 0) \n            - $\\\\mathbf{{Foci}}$: Two fixed points; the sum of distances from any\n                point on the ellipse to both foci = {2*a:.3f} AU (constant)\n            - $\\\\mathbf{{Periapsis}}$: Closest point to the primary focus (Sun)\n                Distance = {r_peri:.3f} AU\n            - $\\\\mathbf{{Apoapsis}}$: Farthest point from the primary focus\n                Distance = {r_apo:.3f} AU\n            - $\\\\mathbf{{c,\\\\ distance\\\\ from\\\\ center\\\\ to\\\\ either\\\\ foci}}$: c = {c:.3f} AU\n            - $\\\\mathbf{{Focus\\\\ separation}}$: 2c = {2*c:.3f} AU\n            - $\\\\mathbf{{Eccentricity}}$: e = c / a = {c / a:.6f}'''\n            \n            props = dict(boxstyle='round', facecolor='wheat', alpha=0.8)\n            ax.text(1.02, 0.98, textstr, transform=ax.transAxes, fontsize=8,\n                    verticalalignment='top', bbox=props, \n                    horizontalalignment='left')\n                                \n        else:  # Hyperbola\n                    # For hyperbola, a is the distance from center to vertex\n                    if e > 1:\n                        # IMPORTANT: For hyperbolic orbits, 'a' might be negative in the data\n                        # We need the absolute value for calculations\n                        a_abs = abs(a)\n                        \n                        # Use the object's actual semi-major axis if available\n                        b = a_abs * np.sqrt(e**2 - 1)\n                        c = a_abs * e\n                        r_peri = a_abs * (e - 1)\n                        \n                        # For a hyperbola with focus at origin, center is at (-c, 0)\n                        center_x = -c\n                        center_y = 0\n\n                        # Update parameter display\n                        param_labels['periapsis'].config(text=f\"{r_peri:.3f}\")\n                        param_labels['apoapsis'].config(text=\"N/A\")\n                        param_labels['b'].config(text=f\"{b:.3f}\")\n                        param_labels['focus'].config(text=f\"{c:.3f}\")\n                        \n                        # Draw hyperbola branch from focus\n                        # Valid angle range for hyperbola\n                        theta_max = np.arccos(-1/e)\n                        \n                        print(f\"DEBUG: Hyperbola params - a={a}, a_abs={a_abs}, e={e}, theta_max={np.degrees(theta_max)} deg\")\n                        print(f\"DEBUG: b={b:.3f}, c={c:.3f}, r_peri={r_peri:.3f}, plot_range={plot_range:.3f}\")\n                        \n                        # Generate angles for the hyperbola\n                        # For high eccentricity, we need a focused approach\n                        if e > 5:\n                            # Very high eccentricity - focus on periapsis region\n                            # The trajectory is almost straight, so use a small angle range\n                            theta_range = min(theta_max - 0.01, np.pi/6)  # Max 30 degrees\n                            num_points = 2000\n                        elif e > 2:\n                            # High eccentricity - use moderate angle range\n                            theta_range = min(theta_max - 0.01, np.pi/3)  # Max 60 degrees\n                            num_points = 1000\n                        else:\n                            # Normal hyperbola\n                            theta_range = theta_max - 0.01\n                            num_points = 500\n                        \n                        # Create the angle array\n                        theta = np.linspace(-theta_range, theta_range, num_points)\n                        \n                        # Calculate radius for each angle using the conic section equation\n                        # For hyperbola: r = a(e^2 - 1) / (1 + e*cos(theta))\n                        denominator = 1 + e * np.cos(theta)\n                        \n                        # Avoid division by zero or negative radii\n                        valid_angles = denominator > 0.001  # Small positive threshold\n                        theta = theta[valid_angles]\n                        denominator = denominator[valid_angles]\n                        \n                        r = a_abs * (e**2 - 1) / denominator\n                        \n                        print(f\"DEBUG: Generated {len(theta)} angles, r range: {np.min(r) if len(r) > 0 else 0:.3f} to {np.max(r) if len(r) > 0 else 0:.3f}\")\n                        \n                        # Filter out points that are too far from the origin\n                        # For high eccentricity, be more restrictive\n                        if e > 5:\n                            max_r = min(plot_range, r_peri * 10)\n                        else:\n                            max_r = plot_range * 1.5\n                            \n                        valid_mask = (r > 0) & (r <= max_r)\n                        \n                        print(f\"DEBUG: {np.sum(valid_mask)} valid points out of {len(r)} (max_r={max_r:.3f})\")\n                        \n                        # Apply the mask\n                        if np.sum(valid_mask) > 2:\n                            theta = theta[valid_mask]\n                            r = r[valid_mask]\n                        else:\n                            # Fallback: just show a tiny arc at periapsis\n                            print(f\"WARNING: Too few valid points for e={e:.6f}, using minimal arc\")\n                            theta = np.linspace(-0.01, 0.01, 50)\n                            r = np.full_like(theta, r_peri)  # Just use periapsis distance\n                        \n                        # Convert to Cartesian coordinates\n                        x = r * np.cos(theta)\n                        y = r * np.sin(theta)\n                        \n                        print(f\"DEBUG: Final plot has {len(x)} points\")\n                        print(f\"DEBUG: x range: {np.min(x) if len(x) > 0 else 0:.3f} to {np.max(x) if len(x) > 0 else 0:.3f}\")\n                        print(f\"DEBUG: y range: {np.min(y) if len(y) > 0 else 0:.3f} to {np.max(y) if len(y) > 0 else 0:.3f}\")\n                        \n                        # Plot the hyperbola\n                        if len(x) > 0:\n                            ax.plot(x, y, color=orbit_color, linewidth=2, label=f'{orbit_type} (e={e:.6f})')\n                        \n                        # Mark the hyperbola center with a cross (only if it's within view)\n                        if abs(center_x) < plot_range and abs(center_y) < plot_range:\n                            ax.plot(center_x, center_y, 'k+', markersize=10, markeredgewidth=2, \n                                    label='Hyperbola Center', zorder=4)\n\n                        # Draw asymptotes (corrected formula)\n                        if abs(c) < plot_range * 2:  # Only if center is reasonably close\n                            x_asym = np.linspace(-plot_range, plot_range, 100)\n                            # Asymptotes pass through the center at (-c, 0)\n                            # Slope is +/-b/a\n                            y_asym_upper = (b/a_abs) * (x_asym + c)\n                            y_asym_lower = -(b/a_abs) * (x_asym + c)\n                            \n                            # Only plot points within the viewing area\n                            mask = (np.abs(y_asym_upper) <= plot_range) & (np.abs(x_asym) <= plot_range)\n                            if np.sum(mask) > 1:\n                                ax.plot(x_asym[mask], y_asym_upper[mask], 'k--', alpha=0.3, linewidth=1)\n                                ax.plot(x_asym[mask], y_asym_lower[mask], 'k--', alpha=0.3, linewidth=1)\n                        \n                        # Mark primary focus (Sun) at origin\n                        ax.plot(0, 0, 'yo', markersize=10, label='Primary Focus (Sun)', zorder=5)\n                        \n                        # Mark periapsis\n                        ax.plot(r_peri, 0, 'ro', markersize=8, label='Periapsis', zorder=5)\n                        \n                        # Add text box with definitions - positioned outside plot area\n                        # Calculate actual distances for clarity\n                        geometric_a = abs(center_x) + r_peri  # Sum of absolute distances\n                        \n                        textstr = f'''$\\\\mathbf{{Definitions}}$:\n                        - $\\\\mathbf{{Hyperbola}}$: A conic section with eccentricity > 1; e = {e:.6f} \n                            Represents a fly-by trajectory with excess velocity\n                            \n                        - $\\\\mathbf{{Semi-major\\\\ axis\\\\ 'a'}}$:\n\n                            1) Orbital mechanics, 'a' (in JPL Horizons ephemeris):\n                                Used in calculations; can be a negative sum relative to the Sun (0,0)\n                                Same definition: distance from geometric center to vertex (periapsis), but\n                                    uses the vector distances relative to the Sun, so\n                                a = distance from Sun to periapsis + (negative) distance from Sun to the center \n                                    = {r_peri:.3f} + {center_x:.3f} = {a:.3f} AU\n                            \n                            2) Geometric, 'a' (same as for ellipses):\n                                This is the geometric distance from center to vertex (periapsis), or\n                                Half the major axis distance,\n                                a = distance from Sun to periapsis + (geometric) distance from Sun to the center \n                                    = {r_peri:.3f} + |{center_x:.3f}|  = {geometric_a:.3f} AU\n                            \n                        - $\\\\mathbf{{Focus\\\\ distance\\\\ , c}}$:\n                            This is the distance from center to focus (Sun); uses absolute value of orbital mechanics, a\n                            c = |a| $\\\\cdot$ e = {a_abs:.3f} $\\\\cdot$ {e:.6f} = {c:.3f} AU [OK]\n                            \n                        - $\\\\mathbf{{Eccentricity\\\\ , e}}$:\n                            Eccentricity definition; uses absolute value of orbital mechanics, a\n                            e = c / |a| = {c:.3f} / {a_abs:.3f} = {e:.6f} [OK]'''\n                        \n                        props = dict(boxstyle='round', facecolor='wheat', alpha=0.8)\n                        ax.text(1.02, 0.98, textstr, transform=ax.transAxes, fontsize=8,\n                                verticalalignment='top', bbox=props,\n                                horizontalalignment='left')\n        \n        # Add reference circle (e=0) - scale with the object's semi-major axis\n        if e > 0.01:\n            circle = plt.Circle((0, 0), a, fill=False, color='gray', \n                              linestyle='--', alpha=0.3, label='Reference circle (e=0)')\n            ax.add_patch(circle)\n        \n        # Labels and legend\n        ax.set_xlabel('Distance (AU)')\n        ax.set_ylabel('Distance (AU)')\n        # Use selected_obj in title instead of \"Demo Object\"\n        ax.set_title(f'{selected_obj} - Orbital Shape vs Eccentricity\\n{orbit_type}: e = {e:.6f}')\n        \n        # Position legend to avoid text box\n    #    ax.legend(loc='upper left', fontsize=9)\n        # With this line to position the legend outside the plot area to the left:\n        ax.legend(bbox_to_anchor=(-0.15, 1), loc='upper right', fontsize=9)        \n        \n        # Add educational annotations at the bottom\n        # Calculate the correct sum of distances for the current semi-major axis\n        if e < 0.01:\n            bottom_text = 'Perfect circle: All points equidistant from center'\n        elif e < 0.99:\n            # For an ellipse, the sum of distances to both foci is 2a\n            sum_of_distances = 2 * a\n            bottom_text = f'Ellipse: Sum of distances to both foci = {sum_of_distances:.3f} AU (constant)'\n        elif abs(e - 1.0) < 0.01:\n            bottom_text = 'Parabola: Escape trajectory, never returns'\n        else:\n            bottom_text = 'Hyperbola: Excess velocity, escapes on hyperbolic path'\n        \n    #    ax.text(0, -2.3, bottom_text, ha='center', fontsize=9, style='italic')\n        # Position bottom text dynamically based on plot range\n        ax.text(0, -plot_range * 0.92, bottom_text, ha='center', fontsize=9, style='italic')\n        \n        # Adjust figure layout to make room for the text box\n        plt.tight_layout()\n        plt.subplots_adjust(right=0.65)  # Make room for text box on the right\n        \n        canvas.draw()\n    \n    # Store figure reference for export\n    demo_window.fig = fig  # Store fig as an attribute of the window\n    \n    def save_visualization():\n        \"\"\"Save the current eccentricity visualization using the standard save dialog.\"\"\"\n        try:\n            import plotly.graph_objects as go\n            import numpy as np\n            \n            # Get current values\n            e_val = e_slider.get()\n            obj_name = object_var.get()\n            a = 1.0  # Default semi-major axis\n            \n            # Get actual semi-major axis if object is selected\n            if obj_name and obj_name in planetary_params and 'a' in planetary_params[obj_name]:\n                a = planetary_params[obj_name]['a']\n            \n            # Create a Plotly figure (not matplotlib)\n            plotly_fig = go.Figure()\n            \n            # Generate orbit points\n            theta = np.linspace(0, 2*np.pi, 1000)\n            \n            if e_val < 1.0:  # Ellipse\n                r = a * (1 - e_val**2) / (1 + e_val * np.cos(theta))\n                orbit_type = \"Ellipse\"\n            elif e_val == 1.0:  # Parabola\n                theta = np.linspace(-np.pi*0.99, np.pi*0.99, 1000)\n                r = 2*a / (1 + np.cos(theta))\n                orbit_type = \"Parabola (escape)\"\n            else:  # Hyperbola\n                max_angle = np.arccos(-1/e_val)\n                theta = np.linspace(-max_angle*0.95, max_angle*0.95, 1000)\n                r = a * (1 - e_val**2) / (1 + e_val * np.cos(theta))\n                orbit_type = \"Hyperbola\"\n            \n            x = r * np.cos(theta)\n            y = r * np.sin(theta)\n            \n            # Add the orbit\n            plotly_fig.add_trace(go.Scatter(\n                x=x, y=y,\n                mode='lines',\n                name=f'{orbit_type} (e={e_val:.6f})',\n                line=dict(color='green', width=3)\n            ))\n            \n            # Add reference circle\n            circle_theta = np.linspace(0, 2*np.pi, 100)\n            plotly_fig.add_trace(go.Scatter(\n                x=a * np.cos(circle_theta),\n                y=a * np.sin(circle_theta),\n                mode='lines',\n                name='Reference circle (e=0)',\n                line=dict(color='gray', width=1, dash='dash')\n            ))\n            \n            # Calculate key points\n            c = a * e_val\n            periapsis = a * (1 - e_val)\n            \n            # Add orbit center\n            plotly_fig.add_trace(go.Scatter(\n                x=[0], y=[0],\n                mode='markers+text',\n                name='Orbit Center',\n                marker=dict(size=8, color='black', symbol='cross'),\n                text=[''],\n                textposition='bottom center',\n                showlegend=True\n            ))\n            \n            # Primary focus (Sun)\n            plotly_fig.add_trace(go.Scatter(\n                x=[0], y=[0],\n                mode='markers+text',\n                name='Primary Focus (Sun)',\n                marker=dict(size=15, color='yellow', line=dict(color='orange', width=2)),\n                text=['Sun'],\n                textposition='bottom center'\n            ))\n            \n            # Empty focus for ellipse\n            if e_val > 0 and e_val < 1:\n                plotly_fig.add_trace(go.Scatter(\n                    x=[-2*c], y=[0],\n                    mode='markers+text',\n                    name='Empty Focus',\n                    marker=dict(size=8, color='lightgray', symbol='circle-open'),\n                    text=[''],\n                    textposition='bottom center'\n                ))\n            \n            # Periapsis\n            plotly_fig.add_trace(go.Scatter(\n                x=[periapsis], y=[0],\n                mode='markers+text',\n                name='Periapsis',\n                marker=dict(size=10, color='red'),\n                text=['Periapsis'],\n                textposition='top center'\n            ))\n            \n            # Apoapsis for closed orbits\n            if e_val < 1:\n                apoapsis = a * (1 + e_val)\n                plotly_fig.add_trace(go.Scatter(\n                    x=[-apoapsis], y=[0],\n                    mode='markers+text',\n                    name='Apoapsis',\n                    marker=dict(size=10, color='green'),\n                    text=['Apoapsis'],\n                    textposition='top center'\n                ))\n            \n            # Create formatted definitions text with better layout\n            b = a * np.sqrt(1 - e_val**2) if e_val < 1 else 0\n            \n            # Build the definitions text with cleaner formatting\n            if e_val < 1:\n                definitions_text = (\n                    f\"<b>Definitions</b><br>\"\n                    f\"<b>* {orbit_type}</b>: e = {e_val:.6f}<br>\"\n                    f\"<b>* Semi-major axis (a)</b>: {a:.3f} AU<br>\"\n                    f\"<b>* Semi-minor axis (b)</b>: {b:.3f} AU<br>\"\n                    f\"<b>* Periapsis</b>: {periapsis:.3f} AU<br>\"\n                    f\"<b>* Apoapsis</b>: {apoapsis:.3f} AU<br>\"\n                    f\"<b>* Focal distance (c)</b>: {c:.3f} AU<br>\"\n                    f\"<b>* Focus separation</b>: {2*c:.3f} AU<br>\"\n                    f\"<b>* Eccentricity</b>: e = c/a = {e_val:.6f}\"\n                )\n            else:\n                definitions_text = (\n                    f\"<b>Definitions</b><br>\"\n                    f\"<b>* {orbit_type}</b>: e = {e_val:.6f}<br>\"\n                    f\"<b>* Semi-major axis (a)</b>: {a:.3f} AU<br>\"\n                    f\"<b>* Periapsis</b>: {periapsis:.3f} AU<br>\"\n                    f\"<b>* Focal distance (c)</b>: {c:.3f} AU<br>\"\n                    f\"<b>* Eccentricity</b>: e = c/a = {e_val:.6f}\"\n                )\n            \n            # Set appropriate axis ranges - account for elongated orbits\n            if e_val <= 1:\n                x_range = 1.2 * a * (1 + e_val)  # Extra space for elongated orbits\n                y_range = 1.2 * a * np.sqrt(1 - e_val**2) if e_val < 1 else 1.2 * a\n                # Use the larger range to maintain aspect ratio\n                axis_range = max(x_range, y_range)\n            else:\n                axis_range = 2 * a\n                \n            # Update layout with title and definitions\n            title_text = \"Orbital Shape vs Eccentricity\"\n            if obj_name and obj_name != \"None\":\n                title_text = f\"{obj_name} - {title_text}\"\n                \n            plotly_fig.update_layout(\n                title=dict(\n                    text=f\"{title_text}<br><sub>{orbit_type}: e = {e_val:.6f}</sub>\",\n                    x=0.5,\n                    xanchor='center'\n                ),\n                xaxis=dict(\n                    title=\"Distance (AU)\", \n                    scaleanchor=\"y\", \n                    scaleratio=1,\n                    zeroline=True,\n                    zerolinecolor='lightgray',\n                    gridcolor='lightgray',\n                    range=[-axis_range, axis_range]\n                ),\n                yaxis=dict(\n                    title=\"Distance (AU)\",\n                    zeroline=True,\n                    zerolinecolor='lightgray',\n                    gridcolor='lightgray',\n                    range=[-axis_range, axis_range]\n                ),\n                showlegend=True,\n                legend=dict(\n                    x=1.02,  # Position to the right of the plot\n                    y=0.98,\n                    xanchor='left',\n                    yanchor='top',\n                    bgcolor='rgba(255,255,255,0.9)',\n                    bordercolor='black',\n                    borderwidth=1\n                ),\n                hovermode='closest',\n                width=1350,  # Wider to accommodate right-side elements\n                height=700,\n                margin=dict(r=250, l=50, t=80, b=50),\n                annotations=[\n                    dict(\n                        text=definitions_text,\n                        xref=\"paper\", yref=\"paper\",\n                        x=1.02,  # Same x position as legend (right side)\n                        y=0.65,  # Position below legend\n                        xanchor='left', \n                        yanchor='top',\n                        showarrow=False,\n                        bordercolor='black',\n                        borderwidth=1,\n                        bgcolor='rgba(255,240,200,0.95)',\n                        font=dict(size=11),\n                        align='left'\n                    )\n                ]\n            )\n            \n            # Generate filename with timestamp\n            from datetime import datetime\n            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n            \n            if obj_name and obj_name != \"None\":\n                default_filename = f\"Eccentricity_{obj_name}_e{e_val:.4f}_{timestamp}\"\n            else:\n                default_filename = f\"Eccentricity_e{e_val:.4f}_{timestamp}\"\n            \n            # Use the existing show_figure_safely function\n            show_figure_safely(plotly_fig, default_filename)\n            \n        except Exception as e:\n            messagebox.showerror(\"Export Error\", \n                            f\"Failed to export visualization:\\n{str(e)}\")\n            import traceback\n            traceback.print_exc()\n\n    # Bind slider to update function\n    e_slider.config(command=update_plot)\n\n    # Initial plot with Earth's values\n    update_plot()  # This draws the initial Earth orbit\n    \n    # Add object selection dropdown\n    select_frame = ttk.Frame(control_frame)\n    select_frame.grid(row=3, column=0, columnspan=4, pady=5)\n    \n    ttk.Label(select_frame, text=\"Select Object:\").grid(row=0, column=0, padx=5, pady=5, sticky='w')\n    \n    # Filter objects that have orbital parameters\n    if objects and params_to_use:\n        objects_with_params = [obj['name'] for obj in objects \n                              if obj['name'] in params_to_use]\n        print(f\"DEBUG: Found {len(objects_with_params)} objects with parameters\")\n    else:\n        # Use all objects from params_to_use\n        objects_with_params = list(params_to_use.keys()) if params_to_use else [\"Earth\"]\n        print(f\"DEBUG: Using {len(objects_with_params)} objects from planetary_params\")\n    \n    object_combo = ttk.Combobox(select_frame, textvariable=object_var, \n                                values=objects_with_params, width=25)\n    object_combo.grid(row=0, column=1, columnspan=2, padx=5, pady=5)\n    \n    # Add an \"Update from Object\" button next to the dropdown\n    def update_from_object():\n        \"\"\"Update the visualization with the selected object's eccentricity\"\"\"\n        selected_obj = object_var.get()\n        print(f\"DEBUG: Update button clicked for object: {selected_obj}\")\n        \n        if not selected_obj:\n            print(\"DEBUG: No object selected\")\n            return\n        \n        # Check if we have the object in our params\n        if selected_obj in params_to_use:\n            params = params_to_use[selected_obj]\n            print(f\"DEBUG: Found params for {selected_obj}: {params}\")\n            \n            if 'e' in params:\n                e_val = params['e']\n                print(f\"DEBUG: Eccentricity value: {e_val}\")\n                \n                # Update slider\n                e_slider.set(e_val)\n                print(f\"DEBUG: Slider set to {e_val}\")\n                \n                # Update entry field\n                e_value_var.set(f\"{e_val:.4f}\")\n                print(f\"DEBUG: Entry field set to {e_val:.4f}\")\n                \n                # Force update the plot\n                update_plot()\n                print(\"DEBUG: update_plot() called\")\n                \n                # Force canvas refresh\n                try:\n                    canvas.draw()\n                    print(\"DEBUG: Canvas draw() called\")\n                except:\n                    print(\"DEBUG: Canvas draw() failed\")\n            else:\n                print(f\"DEBUG: No eccentricity found for {selected_obj}\")\n                messagebox.showwarning(\"No Data\", f\"No eccentricity data found for {selected_obj}\")\n        else:\n            print(f\"DEBUG: {selected_obj} not found in planetary_params\")\n            messagebox.showwarning(\"No Data\", f\"No orbital parameters found for {selected_obj}\")\n    \n    update_button = ttk.Button(select_frame, text=\"Update from Object\", \n                              command=update_from_object, width=20)\n    update_button.grid(row=0, column=3, padx=5, pady=5)\n    \n    # Add export button next to update button\n    export_button = ttk.Button(select_frame, text=\"Export Visualization\", \n                              command=save_visualization, width=20)\n    export_button.grid(row=0, column=4, padx=5, pady=5)\n    \n    # Add tooltip\n    CreateToolTip(export_button,\n        \"Export the visualization as HTML or PNG.\\n\"\n        \"Same options as the orbital parameter visualization.\")    \n    \n    # Add the special case buttons below\n    button_frame = ttk.Frame(control_frame)\n    button_frame.grid(row=4, column=0, columnspan=4, pady=5)\n    \n    special_cases = [\n        (\"Perfect Circle\", 0.0),\n        (\"Parabola (escape)\", 1.0),\n        (\"Mild Hyperbola\", 1.5),\n        (\"Strong Hyperbola\", 2.0),\n        (\"3I/Atlas\", 6.1511),  # Added real high-eccentricity example\n    ]\n    \n    for i, (label, e_val) in enumerate(special_cases):\n        btn = ttk.Button(button_frame, text=label, width=20,\n                        command=lambda e=e_val: (e_slider.set(e), \n                                               e_value_var.set(f\"{e:.6f}\"), \n                                               update_plot()))\n        btn.grid(row=0, column=i, padx=2)\n    \n    # Update instructions\n    instruction_label = ttk.Label(control_frame, \n                                 text=\"For eccentricity illustration purposes: use slider, type a value (0-10), select object + Update, or use quick buttons\",\n                                 font=('TkDefaultFont', 9, 'italic'))\n    instruction_label.grid(row=5, column=0, columnspan=4, pady=(5, 0))\n        \n    return demo_window",
    "start_line": 1065,
    "end_line": 1892,
    "has_docstring": true,
    "docstring": "Create a window with an interactive eccentricity slider visualization.\nShows how eccentricity affects orbital shape from circle to hyperbola.\n\nParameters:\n    parent: Parent window\n    objects: List of celestial objects from main app (optional)\n    planetary_params_override: Override the global planetary_params if needed (optional)",
    "parameters": [
      "parent",
      "objects",
      "planetary_params_override"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_eccentricity_demo_window",
    "component_id": "orbital_param_viz.create_eccentricity_demo_window"
  },
  "orbital_param_viz.validate_entry": {
    "id": "orbital_param_viz.validate_entry",
    "name": "validate_entry",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbital_param_viz.py",
    "relative_path": "orbital_param_viz.py",
    "depends_on": [
      "orbital_param_viz.update_plot"
    ],
    "source_code": "    def validate_entry(*args):\n        try:\n            value = float(e_value_var.get())\n            if 0 <= value <= 10.0:\n                e_slider.set(value)\n                update_plot()\n            else:\n                # Clamp to valid range\n                if value < 0:\n                    e_value_var.set(\"0.0000\")\n                    e_slider.set(0)\n                elif value > 10.0:\n                    e_value_var.set(\"10.0000\")\n                    e_slider.set(10.0)\n                update_plot()\n        except ValueError:\n            pass",
    "start_line": 1106,
    "end_line": 1122,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function validate_entry",
    "component_id": "orbital_param_viz.validate_entry"
  },
  "orbital_param_viz.update_plot": {
    "id": "orbital_param_viz.update_plot",
    "name": "update_plot",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbital_param_viz.py",
    "relative_path": "orbital_param_viz.py",
    "depends_on": [],
    "source_code": "    def update_plot(*args):\n        \"\"\"Update the plot based on slider value\"\"\"\n        e = e_slider.get()\n        print(f\"Update plot called with e={e}\")\n        \n        # Update value display\n        e_value_var.set(f\"{e:.6f}\")\n        \n        # Determine orbit type\n        if e < 0.01:\n            orbit_type = \"Circle\"\n            orbit_color = 'blue'\n        elif e < 1.0:\n            orbit_type = \"Ellipse\"\n            orbit_color = 'green'\n        elif e == 1.0:\n            orbit_type = \"Parabola (theoretical)\"\n            orbit_color = 'orange'\n        else:\n            orbit_type = \"Hyperbola\"\n            orbit_color = 'red'\n        \n        orbit_type_var.set(orbit_type)\n        \n        # Clear the plot\n        ax.clear()\n        \n        # Set up the plot with extra space for text box\n        ax.set_xlim(-3.5, 3.5)\n        ax.set_ylim(-2.5, 2.5)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        ax.axhline(y=0, color='k', linewidth=0.5)\n        ax.axvline(x=0, color='k', linewidth=0.5)\n        \n        # Get the selected object name - now properly accessible\n        selected_obj = object_var.get()\n        \n        # Get the actual semi-major axis for the selected object\n        if selected_obj in params_to_use:\n            params = params_to_use[selected_obj]\n            a = params.get('a', 1.0)  # Use object's actual semi-major axis\n            print(f\"Using {selected_obj}'s semi-major axis: {a} AU\")\n        else:\n            a = 1.0  # Default to 1 AU if no data\n            print(f\"No data for {selected_obj}, using default a=1.0 AU\")\n\n# DYNAMIC AXES SCALING based on the orbit size\n        # For hyperbolic orbits, 'a' is often negative in JPL data (standard convention)\n        # We always use absolute value for distance calculations\n        \n        if e < 1.0:  # Ellipse or circle\n            # For elliptical orbits, 'a' should be positive\n            # The maximum extent is the apoapsis\n            max_extent = abs(a) * (1 + e)\n        elif abs(e - 1.0) < 0.01:  # Parabola\n            # For parabolic orbits, show a reasonable portion\n            max_extent = abs(a) * 3\n        else:  # Hyperbola (e > 1)\n            # For hyperbolic orbits, we need to determine the convention used\n            # If a < 0, it's the JPL convention (common for comets)\n            # If a > 0, it's the standard mathematical convention\n            \n            # Always use positive value for calculations\n            a_for_calc = abs(a)\n            \n            # Calculate key distances\n            r_peri = a_for_calc * (e - 1)  # Periapsis distance (always positive)\n            center_dist = a_for_calc * e    # Distance to hyperbola center\n            \n            # The plot needs to show:\n            # 1. The periapsis point clearly\n            # 2. The hyperbola center (if reasonable)\n            # 3. Enough of the trajectory to see the curve\n            \n            # For very high eccentricity, the center is far away\n            # We should focus on the periapsis region\n            if e > 5:\n                # High eccentricity: focus on periapsis region\n                max_extent = r_peri * 2.5  # Show 2.5x the periapsis distance\n            else:\n                # Moderate eccentricity: show more of the hyperbola\n                max_extent = max(\n                    r_peri * 3,        # At least 3x periapsis distance\n                    center_dist * 1.2  # Include the center if not too far\n                )\n            \n            print(f\"DEBUG: Hyperbola scaling - a={a:.3f}, a_for_calc={a_for_calc:.3f}\")\n            print(f\"DEBUG: e={e:.6f}, r_peri={r_peri:.3f}, center_dist={center_dist:.3f}\")\n            print(f\"DEBUG: max_extent={max_extent:.3f}\")\n        \n        # Add padding (20% extra space)\n        plot_range = max_extent * 1.2\n        \n        # For extremely high eccentricity, ensure minimum visible range\n        if e > 10 and plot_range < 2.0:\n            plot_range = 2.0  # Minimum 2 AU range for visibility\n        \n        print(f\"DEBUG: Final plot_range = +/-{plot_range:.3f} AU\")\n        \n        # Set up the plot with dynamic scaling\n        ax.set_xlim(-plot_range, plot_range)\n        ax.set_ylim(-plot_range, plot_range)\n        ax.set_aspect('equal')\n        ax.grid(True, alpha=0.3)\n        ax.axhline(y=0, color='k', linewidth=0.5)\n        ax.axvline(x=0, color='k', linewidth=0.5)\n\n        if e < 1.0:  # Circle or Ellipse\n            # Calculate orbital parameters\n            b = a * np.sqrt(1 - e**2)  # Semi-minor axis\n            c = a * e  # Focus distance from center\n            \n            # The center of the ellipse is at (-c, 0) from the primary focus\n            center_x = -c\n            center_y = 0\n\n            # Periapsis and apoapsis distances from focus\n            r_peri = a * (1 - e)\n            r_apo = a * (1 + e)\n            \n            # Update parameter display\n            param_labels['periapsis'].config(text=f\"{r_peri:.3f}\")\n            param_labels['apoapsis'].config(text=f\"{r_apo:.3f}\")\n            param_labels['b'].config(text=f\"{b:.3f}\")\n            param_labels['focus'].config(text=f\"{c:.3f}\")\n            \n            # Draw the orbit using polar coordinates from the focus\n            theta = np.linspace(0, 2*np.pi, 1000)\n            r = a * (1 - e**2) / (1 + e * np.cos(theta))\n            x = r * np.cos(theta)\n            y = r * np.sin(theta)\n            \n            ax.plot(x, y, color=orbit_color, linewidth=2, label=f'{orbit_type} (e={e:.6f})')\n            \n            # Mark the orbit center with a cross\n            ax.plot(center_x, center_y, 'k+', markersize=10, markeredgewidth=2, \n                    label='Orbit Center', zorder=4)\n\n            # Mark the foci\n            # Primary focus (Sun) at origin\n            ax.plot(0, 0, 'yo', markersize=10, label='Primary Focus (Sun)', zorder=5)\n            \n            # Empty focus at -2c from the Sun\n            ax.plot(-2*c, 0, 'ko', markersize=6, label='Empty Focus', zorder=5)\n            \n            # Mark periapsis and apoapsis\n            ax.plot(r_peri, 0, 'ro', markersize=8, label='Periapsis', zorder=5)\n            ax.plot(-r_apo, 0, 'go', markersize=8, label='Apoapsis', zorder=5)\n            \n            # Add verification lines to show sum of distances is constant\n            # Draw lines from periapsis to both foci\n            ax.plot([r_peri, 0], [0, 0], 'r--', alpha=0.3, linewidth=1)\n            ax.plot([r_peri, -2*c], [0, 0], 'r--', alpha=0.3, linewidth=1)\n            \n            # Draw lines from apoapsis to both foci\n            ax.plot([-r_apo, 0], [0, 0], 'g--', alpha=0.3, linewidth=1)\n            ax.plot([-r_apo, -2*c], [0, 0], 'g--', alpha=0.3, linewidth=1)\n            \n            # Add text box with definitions - positioned outside plot area\n            textstr = f'''$\\\\mathbf{{Definitions}}$:\n            - $\\\\mathbf{{{orbit_type}}}$: A conic section with eccentricity e = {e:.6f}\n            - $\\\\mathbf{{Semi-major\\\\ axis\\\\ (a)}}$: Half the longest diameter of the ellipse\n                a = {a:.3f} AU\n            - $\\\\mathbf{{Semi-minor\\\\ axis\\\\ (b)}}$: Half the shortest diameter of the ellipse\n                b = {b:.3f} AU\n            - $\\\\mathbf{{Orbit\\\\ Center}}$: Geometric center of the ellipse at ({center_x:.3f}, 0) \n            - $\\\\mathbf{{Foci}}$: Two fixed points; the sum of distances from any\n                point on the ellipse to both foci = {2*a:.3f} AU (constant)\n            - $\\\\mathbf{{Periapsis}}$: Closest point to the primary focus (Sun)\n                Distance = {r_peri:.3f} AU\n            - $\\\\mathbf{{Apoapsis}}$: Farthest point from the primary focus\n                Distance = {r_apo:.3f} AU\n            - $\\\\mathbf{{c,\\\\ distance\\\\ from\\\\ center\\\\ to\\\\ either\\\\ foci}}$: c = {c:.3f} AU\n            - $\\\\mathbf{{Focus\\\\ separation}}$: 2c = {2*c:.3f} AU\n            - $\\\\mathbf{{Eccentricity}}$: e = c / a = {c / a:.6f}'''\n            \n            props = dict(boxstyle='round', facecolor='wheat', alpha=0.8)\n            ax.text(1.02, 0.98, textstr, transform=ax.transAxes, fontsize=8,\n                    verticalalignment='top', bbox=props, \n                    horizontalalignment='left')\n                                \n        else:  # Hyperbola\n                    # For hyperbola, a is the distance from center to vertex\n                    if e > 1:\n                        # IMPORTANT: For hyperbolic orbits, 'a' might be negative in the data\n                        # We need the absolute value for calculations\n                        a_abs = abs(a)\n                        \n                        # Use the object's actual semi-major axis if available\n                        b = a_abs * np.sqrt(e**2 - 1)\n                        c = a_abs * e\n                        r_peri = a_abs * (e - 1)\n                        \n                        # For a hyperbola with focus at origin, center is at (-c, 0)\n                        center_x = -c\n                        center_y = 0\n\n                        # Update parameter display\n                        param_labels['periapsis'].config(text=f\"{r_peri:.3f}\")\n                        param_labels['apoapsis'].config(text=\"N/A\")\n                        param_labels['b'].config(text=f\"{b:.3f}\")\n                        param_labels['focus'].config(text=f\"{c:.3f}\")\n                        \n                        # Draw hyperbola branch from focus\n                        # Valid angle range for hyperbola\n                        theta_max = np.arccos(-1/e)\n                        \n                        print(f\"DEBUG: Hyperbola params - a={a}, a_abs={a_abs}, e={e}, theta_max={np.degrees(theta_max)} deg\")\n                        print(f\"DEBUG: b={b:.3f}, c={c:.3f}, r_peri={r_peri:.3f}, plot_range={plot_range:.3f}\")\n                        \n                        # Generate angles for the hyperbola\n                        # For high eccentricity, we need a focused approach\n                        if e > 5:\n                            # Very high eccentricity - focus on periapsis region\n                            # The trajectory is almost straight, so use a small angle range\n                            theta_range = min(theta_max - 0.01, np.pi/6)  # Max 30 degrees\n                            num_points = 2000\n                        elif e > 2:\n                            # High eccentricity - use moderate angle range\n                            theta_range = min(theta_max - 0.01, np.pi/3)  # Max 60 degrees\n                            num_points = 1000\n                        else:\n                            # Normal hyperbola\n                            theta_range = theta_max - 0.01\n                            num_points = 500\n                        \n                        # Create the angle array\n                        theta = np.linspace(-theta_range, theta_range, num_points)\n                        \n                        # Calculate radius for each angle using the conic section equation\n                        # For hyperbola: r = a(e^2 - 1) / (1 + e*cos(theta))\n                        denominator = 1 + e * np.cos(theta)\n                        \n                        # Avoid division by zero or negative radii\n                        valid_angles = denominator > 0.001  # Small positive threshold\n                        theta = theta[valid_angles]\n                        denominator = denominator[valid_angles]\n                        \n                        r = a_abs * (e**2 - 1) / denominator\n                        \n                        print(f\"DEBUG: Generated {len(theta)} angles, r range: {np.min(r) if len(r) > 0 else 0:.3f} to {np.max(r) if len(r) > 0 else 0:.3f}\")\n                        \n                        # Filter out points that are too far from the origin\n                        # For high eccentricity, be more restrictive\n                        if e > 5:\n                            max_r = min(plot_range, r_peri * 10)\n                        else:\n                            max_r = plot_range * 1.5\n                            \n                        valid_mask = (r > 0) & (r <= max_r)\n                        \n                        print(f\"DEBUG: {np.sum(valid_mask)} valid points out of {len(r)} (max_r={max_r:.3f})\")\n                        \n                        # Apply the mask\n                        if np.sum(valid_mask) > 2:\n                            theta = theta[valid_mask]\n                            r = r[valid_mask]\n                        else:\n                            # Fallback: just show a tiny arc at periapsis\n                            print(f\"WARNING: Too few valid points for e={e:.6f}, using minimal arc\")\n                            theta = np.linspace(-0.01, 0.01, 50)\n                            r = np.full_like(theta, r_peri)  # Just use periapsis distance\n                        \n                        # Convert to Cartesian coordinates\n                        x = r * np.cos(theta)\n                        y = r * np.sin(theta)\n                        \n                        print(f\"DEBUG: Final plot has {len(x)} points\")\n                        print(f\"DEBUG: x range: {np.min(x) if len(x) > 0 else 0:.3f} to {np.max(x) if len(x) > 0 else 0:.3f}\")\n                        print(f\"DEBUG: y range: {np.min(y) if len(y) > 0 else 0:.3f} to {np.max(y) if len(y) > 0 else 0:.3f}\")\n                        \n                        # Plot the hyperbola\n                        if len(x) > 0:\n                            ax.plot(x, y, color=orbit_color, linewidth=2, label=f'{orbit_type} (e={e:.6f})')\n                        \n                        # Mark the hyperbola center with a cross (only if it's within view)\n                        if abs(center_x) < plot_range and abs(center_y) < plot_range:\n                            ax.plot(center_x, center_y, 'k+', markersize=10, markeredgewidth=2, \n                                    label='Hyperbola Center', zorder=4)\n\n                        # Draw asymptotes (corrected formula)\n                        if abs(c) < plot_range * 2:  # Only if center is reasonably close\n                            x_asym = np.linspace(-plot_range, plot_range, 100)\n                            # Asymptotes pass through the center at (-c, 0)\n                            # Slope is +/-b/a\n                            y_asym_upper = (b/a_abs) * (x_asym + c)\n                            y_asym_lower = -(b/a_abs) * (x_asym + c)\n                            \n                            # Only plot points within the viewing area\n                            mask = (np.abs(y_asym_upper) <= plot_range) & (np.abs(x_asym) <= plot_range)\n                            if np.sum(mask) > 1:\n                                ax.plot(x_asym[mask], y_asym_upper[mask], 'k--', alpha=0.3, linewidth=1)\n                                ax.plot(x_asym[mask], y_asym_lower[mask], 'k--', alpha=0.3, linewidth=1)\n                        \n                        # Mark primary focus (Sun) at origin\n                        ax.plot(0, 0, 'yo', markersize=10, label='Primary Focus (Sun)', zorder=5)\n                        \n                        # Mark periapsis\n                        ax.plot(r_peri, 0, 'ro', markersize=8, label='Periapsis', zorder=5)\n                        \n                        # Add text box with definitions - positioned outside plot area\n                        # Calculate actual distances for clarity\n                        geometric_a = abs(center_x) + r_peri  # Sum of absolute distances\n                        \n                        textstr = f'''$\\\\mathbf{{Definitions}}$:\n                        - $\\\\mathbf{{Hyperbola}}$: A conic section with eccentricity > 1; e = {e:.6f} \n                            Represents a fly-by trajectory with excess velocity\n                            \n                        - $\\\\mathbf{{Semi-major\\\\ axis\\\\ 'a'}}$:\n\n                            1) Orbital mechanics, 'a' (in JPL Horizons ephemeris):\n                                Used in calculations; can be a negative sum relative to the Sun (0,0)\n                                Same definition: distance from geometric center to vertex (periapsis), but\n                                    uses the vector distances relative to the Sun, so\n                                a = distance from Sun to periapsis + (negative) distance from Sun to the center \n                                    = {r_peri:.3f} + {center_x:.3f} = {a:.3f} AU\n                            \n                            2) Geometric, 'a' (same as for ellipses):\n                                This is the geometric distance from center to vertex (periapsis), or\n                                Half the major axis distance,\n                                a = distance from Sun to periapsis + (geometric) distance from Sun to the center \n                                    = {r_peri:.3f} + |{center_x:.3f}|  = {geometric_a:.3f} AU\n                            \n                        - $\\\\mathbf{{Focus\\\\ distance\\\\ , c}}$:\n                            This is the distance from center to focus (Sun); uses absolute value of orbital mechanics, a\n                            c = |a| $\\\\cdot$ e = {a_abs:.3f} $\\\\cdot$ {e:.6f} = {c:.3f} AU [OK]\n                            \n                        - $\\\\mathbf{{Eccentricity\\\\ , e}}$:\n                            Eccentricity definition; uses absolute value of orbital mechanics, a\n                            e = c / |a| = {c:.3f} / {a_abs:.3f} = {e:.6f} [OK]'''\n                        \n                        props = dict(boxstyle='round', facecolor='wheat', alpha=0.8)\n                        ax.text(1.02, 0.98, textstr, transform=ax.transAxes, fontsize=8,\n                                verticalalignment='top', bbox=props,\n                                horizontalalignment='left')\n        \n        # Add reference circle (e=0) - scale with the object's semi-major axis\n        if e > 0.01:\n            circle = plt.Circle((0, 0), a, fill=False, color='gray', \n                              linestyle='--', alpha=0.3, label='Reference circle (e=0)')\n            ax.add_patch(circle)\n        \n        # Labels and legend\n        ax.set_xlabel('Distance (AU)')\n        ax.set_ylabel('Distance (AU)')\n        # Use selected_obj in title instead of \"Demo Object\"\n        ax.set_title(f'{selected_obj} - Orbital Shape vs Eccentricity\\n{orbit_type}: e = {e:.6f}')\n        \n        # Position legend to avoid text box\n    #    ax.legend(loc='upper left', fontsize=9)\n        # With this line to position the legend outside the plot area to the left:\n        ax.legend(bbox_to_anchor=(-0.15, 1), loc='upper right', fontsize=9)        \n        \n        # Add educational annotations at the bottom\n        # Calculate the correct sum of distances for the current semi-major axis\n        if e < 0.01:\n            bottom_text = 'Perfect circle: All points equidistant from center'\n        elif e < 0.99:\n            # For an ellipse, the sum of distances to both foci is 2a\n            sum_of_distances = 2 * a\n            bottom_text = f'Ellipse: Sum of distances to both foci = {sum_of_distances:.3f} AU (constant)'\n        elif abs(e - 1.0) < 0.01:\n            bottom_text = 'Parabola: Escape trajectory, never returns'\n        else:\n            bottom_text = 'Hyperbola: Excess velocity, escapes on hyperbolic path'\n        \n    #    ax.text(0, -2.3, bottom_text, ha='center', fontsize=9, style='italic')\n        # Position bottom text dynamically based on plot range\n        ax.text(0, -plot_range * 0.92, bottom_text, ha='center', fontsize=9, style='italic')\n        \n        # Adjust figure layout to make room for the text box\n        plt.tight_layout()\n        plt.subplots_adjust(right=0.65)  # Make room for text box on the right\n        \n        canvas.draw()",
    "start_line": 1178,
    "end_line": 1553,
    "has_docstring": true,
    "docstring": "Update the plot based on slider value",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function update_plot",
    "component_id": "orbital_param_viz.update_plot"
  },
  "orbital_param_viz.save_visualization": {
    "id": "orbital_param_viz.save_visualization",
    "name": "save_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbital_param_viz.py",
    "relative_path": "orbital_param_viz.py",
    "depends_on": [
      "shutdown_handler.show_figure_safely"
    ],
    "source_code": "    def save_visualization():\n        \"\"\"Save the current eccentricity visualization using the standard save dialog.\"\"\"\n        try:\n            import plotly.graph_objects as go\n            import numpy as np\n            \n            # Get current values\n            e_val = e_slider.get()\n            obj_name = object_var.get()\n            a = 1.0  # Default semi-major axis\n            \n            # Get actual semi-major axis if object is selected\n            if obj_name and obj_name in planetary_params and 'a' in planetary_params[obj_name]:\n                a = planetary_params[obj_name]['a']\n            \n            # Create a Plotly figure (not matplotlib)\n            plotly_fig = go.Figure()\n            \n            # Generate orbit points\n            theta = np.linspace(0, 2*np.pi, 1000)\n            \n            if e_val < 1.0:  # Ellipse\n                r = a * (1 - e_val**2) / (1 + e_val * np.cos(theta))\n                orbit_type = \"Ellipse\"\n            elif e_val == 1.0:  # Parabola\n                theta = np.linspace(-np.pi*0.99, np.pi*0.99, 1000)\n                r = 2*a / (1 + np.cos(theta))\n                orbit_type = \"Parabola (escape)\"\n            else:  # Hyperbola\n                max_angle = np.arccos(-1/e_val)\n                theta = np.linspace(-max_angle*0.95, max_angle*0.95, 1000)\n                r = a * (1 - e_val**2) / (1 + e_val * np.cos(theta))\n                orbit_type = \"Hyperbola\"\n            \n            x = r * np.cos(theta)\n            y = r * np.sin(theta)\n            \n            # Add the orbit\n            plotly_fig.add_trace(go.Scatter(\n                x=x, y=y,\n                mode='lines',\n                name=f'{orbit_type} (e={e_val:.6f})',\n                line=dict(color='green', width=3)\n            ))\n            \n            # Add reference circle\n            circle_theta = np.linspace(0, 2*np.pi, 100)\n            plotly_fig.add_trace(go.Scatter(\n                x=a * np.cos(circle_theta),\n                y=a * np.sin(circle_theta),\n                mode='lines',\n                name='Reference circle (e=0)',\n                line=dict(color='gray', width=1, dash='dash')\n            ))\n            \n            # Calculate key points\n            c = a * e_val\n            periapsis = a * (1 - e_val)\n            \n            # Add orbit center\n            plotly_fig.add_trace(go.Scatter(\n                x=[0], y=[0],\n                mode='markers+text',\n                name='Orbit Center',\n                marker=dict(size=8, color='black', symbol='cross'),\n                text=[''],\n                textposition='bottom center',\n                showlegend=True\n            ))\n            \n            # Primary focus (Sun)\n            plotly_fig.add_trace(go.Scatter(\n                x=[0], y=[0],\n                mode='markers+text',\n                name='Primary Focus (Sun)',\n                marker=dict(size=15, color='yellow', line=dict(color='orange', width=2)),\n                text=['Sun'],\n                textposition='bottom center'\n            ))\n            \n            # Empty focus for ellipse\n            if e_val > 0 and e_val < 1:\n                plotly_fig.add_trace(go.Scatter(\n                    x=[-2*c], y=[0],\n                    mode='markers+text',\n                    name='Empty Focus',\n                    marker=dict(size=8, color='lightgray', symbol='circle-open'),\n                    text=[''],\n                    textposition='bottom center'\n                ))\n            \n            # Periapsis\n            plotly_fig.add_trace(go.Scatter(\n                x=[periapsis], y=[0],\n                mode='markers+text',\n                name='Periapsis',\n                marker=dict(size=10, color='red'),\n                text=['Periapsis'],\n                textposition='top center'\n            ))\n            \n            # Apoapsis for closed orbits\n            if e_val < 1:\n                apoapsis = a * (1 + e_val)\n                plotly_fig.add_trace(go.Scatter(\n                    x=[-apoapsis], y=[0],\n                    mode='markers+text',\n                    name='Apoapsis',\n                    marker=dict(size=10, color='green'),\n                    text=['Apoapsis'],\n                    textposition='top center'\n                ))\n            \n            # Create formatted definitions text with better layout\n            b = a * np.sqrt(1 - e_val**2) if e_val < 1 else 0\n            \n            # Build the definitions text with cleaner formatting\n            if e_val < 1:\n                definitions_text = (\n                    f\"<b>Definitions</b><br>\"\n                    f\"<b>* {orbit_type}</b>: e = {e_val:.6f}<br>\"\n                    f\"<b>* Semi-major axis (a)</b>: {a:.3f} AU<br>\"\n                    f\"<b>* Semi-minor axis (b)</b>: {b:.3f} AU<br>\"\n                    f\"<b>* Periapsis</b>: {periapsis:.3f} AU<br>\"\n                    f\"<b>* Apoapsis</b>: {apoapsis:.3f} AU<br>\"\n                    f\"<b>* Focal distance (c)</b>: {c:.3f} AU<br>\"\n                    f\"<b>* Focus separation</b>: {2*c:.3f} AU<br>\"\n                    f\"<b>* Eccentricity</b>: e = c/a = {e_val:.6f}\"\n                )\n            else:\n                definitions_text = (\n                    f\"<b>Definitions</b><br>\"\n                    f\"<b>* {orbit_type}</b>: e = {e_val:.6f}<br>\"\n                    f\"<b>* Semi-major axis (a)</b>: {a:.3f} AU<br>\"\n                    f\"<b>* Periapsis</b>: {periapsis:.3f} AU<br>\"\n                    f\"<b>* Focal distance (c)</b>: {c:.3f} AU<br>\"\n                    f\"<b>* Eccentricity</b>: e = c/a = {e_val:.6f}\"\n                )\n            \n            # Set appropriate axis ranges - account for elongated orbits\n            if e_val <= 1:\n                x_range = 1.2 * a * (1 + e_val)  # Extra space for elongated orbits\n                y_range = 1.2 * a * np.sqrt(1 - e_val**2) if e_val < 1 else 1.2 * a\n                # Use the larger range to maintain aspect ratio\n                axis_range = max(x_range, y_range)\n            else:\n                axis_range = 2 * a\n                \n            # Update layout with title and definitions\n            title_text = \"Orbital Shape vs Eccentricity\"\n            if obj_name and obj_name != \"None\":\n                title_text = f\"{obj_name} - {title_text}\"\n                \n            plotly_fig.update_layout(\n                title=dict(\n                    text=f\"{title_text}<br><sub>{orbit_type}: e = {e_val:.6f}</sub>\",\n                    x=0.5,\n                    xanchor='center'\n                ),\n                xaxis=dict(\n                    title=\"Distance (AU)\", \n                    scaleanchor=\"y\", \n                    scaleratio=1,\n                    zeroline=True,\n                    zerolinecolor='lightgray',\n                    gridcolor='lightgray',\n                    range=[-axis_range, axis_range]\n                ),\n                yaxis=dict(\n                    title=\"Distance (AU)\",\n                    zeroline=True,\n                    zerolinecolor='lightgray',\n                    gridcolor='lightgray',\n                    range=[-axis_range, axis_range]\n                ),\n                showlegend=True,\n                legend=dict(\n                    x=1.02,  # Position to the right of the plot\n                    y=0.98,\n                    xanchor='left',\n                    yanchor='top',\n                    bgcolor='rgba(255,255,255,0.9)',\n                    bordercolor='black',\n                    borderwidth=1\n                ),\n                hovermode='closest',\n                width=1350,  # Wider to accommodate right-side elements\n                height=700,\n                margin=dict(r=250, l=50, t=80, b=50),\n                annotations=[\n                    dict(\n                        text=definitions_text,\n                        xref=\"paper\", yref=\"paper\",\n                        x=1.02,  # Same x position as legend (right side)\n                        y=0.65,  # Position below legend\n                        xanchor='left', \n                        yanchor='top',\n                        showarrow=False,\n                        bordercolor='black',\n                        borderwidth=1,\n                        bgcolor='rgba(255,240,200,0.95)',\n                        font=dict(size=11),\n                        align='left'\n                    )\n                ]\n            )\n            \n            # Generate filename with timestamp\n            from datetime import datetime\n            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n            \n            if obj_name and obj_name != \"None\":\n                default_filename = f\"Eccentricity_{obj_name}_e{e_val:.4f}_{timestamp}\"\n            else:\n                default_filename = f\"Eccentricity_e{e_val:.4f}_{timestamp}\"\n            \n            # Use the existing show_figure_safely function\n            show_figure_safely(plotly_fig, default_filename)\n            \n        except Exception as e:\n            messagebox.showerror(\"Export Error\", \n                            f\"Failed to export visualization:\\n{str(e)}\")\n            import traceback\n            traceback.print_exc()",
    "start_line": 1558,
    "end_line": 1781,
    "has_docstring": true,
    "docstring": "Save the current eccentricity visualization using the standard save dialog.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function save_visualization",
    "component_id": "orbital_param_viz.save_visualization"
  },
  "orbital_param_viz.update_from_object": {
    "id": "orbital_param_viz.update_from_object",
    "name": "update_from_object",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbital_param_viz.py",
    "relative_path": "orbital_param_viz.py",
    "depends_on": [
      "orbital_param_viz.update_plot"
    ],
    "source_code": "    def update_from_object():\n        \"\"\"Update the visualization with the selected object's eccentricity\"\"\"\n        selected_obj = object_var.get()\n        print(f\"DEBUG: Update button clicked for object: {selected_obj}\")\n        \n        if not selected_obj:\n            print(\"DEBUG: No object selected\")\n            return\n        \n        # Check if we have the object in our params\n        if selected_obj in params_to_use:\n            params = params_to_use[selected_obj]\n            print(f\"DEBUG: Found params for {selected_obj}: {params}\")\n            \n            if 'e' in params:\n                e_val = params['e']\n                print(f\"DEBUG: Eccentricity value: {e_val}\")\n                \n                # Update slider\n                e_slider.set(e_val)\n                print(f\"DEBUG: Slider set to {e_val}\")\n                \n                # Update entry field\n                e_value_var.set(f\"{e_val:.4f}\")\n                print(f\"DEBUG: Entry field set to {e_val:.4f}\")\n                \n                # Force update the plot\n                update_plot()\n                print(\"DEBUG: update_plot() called\")\n                \n                # Force canvas refresh\n                try:\n                    canvas.draw()\n                    print(\"DEBUG: Canvas draw() called\")\n                except:\n                    print(\"DEBUG: Canvas draw() failed\")\n            else:\n                print(f\"DEBUG: No eccentricity found for {selected_obj}\")\n                messagebox.showwarning(\"No Data\", f\"No eccentricity data found for {selected_obj}\")\n        else:\n            print(f\"DEBUG: {selected_obj} not found in planetary_params\")\n            messagebox.showwarning(\"No Data\", f\"No orbital parameters found for {selected_obj}\")",
    "start_line": 1810,
    "end_line": 1851,
    "has_docstring": true,
    "docstring": "Update the visualization with the selected object's eccentricity",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function update_from_object",
    "component_id": "orbital_param_viz.update_from_object"
  },
  "orbital_param_viz.create_orbital_viz_window": {
    "id": "orbital_param_viz.create_orbital_viz_window",
    "name": "create_orbital_viz_window",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbital_param_viz.py",
    "relative_path": "orbital_param_viz.py",
    "depends_on": [],
    "source_code": "def create_orbital_viz_window(root, objects, planetary_params, parent_planets=None,\n                            current_positions=None, current_date=None):\n    \"\"\"\n    Create a window for orbital parameter visualization.\n    To be called from palomas_orrery.py\n    \n    Parameters:\n        root: Parent tkinter window\n        objects: List of celestial objects\n        planetary_params: Dictionary of orbital parameters\n        parent_planets: Dictionary mapping planets to their satellites\n        current_positions: Dictionary of current positions {name: {'x': x, 'y': y, 'z': z}}\n        current_date: Current date being displayed\n    \"\"\"\n    # Store these for use in create_visualization\n    stored_positions = current_positions or {}\n    stored_date = current_date or dt.datetime.now()\n\n    # Create new window\n    viz_window = tk.Toplevel(root)\n    viz_window.title(\"Orbital Parameter Visualization\")\n    viz_window.geometry(\"1400x800\")\n    \n    # Create main frame\n    main_frame = ttk.Frame(viz_window)\n    main_frame.pack(fill='both', expand=True, padx=10, pady=10)\n    \n    # Create left frame for controls\n    control_frame = ttk.LabelFrame(main_frame, text=\"Visualization Controls\")\n    control_frame.pack(side='left', fill='y', padx=(0, 10))\n    \n    # Object selection\n    ttk.Label(control_frame, text=\"Select Object:\").grid(row=0, column=0, \n                                                         padx=5, pady=5, sticky='w')\n    \n    # Filter objects that have orbital parameters\n    objects_with_params = [obj['name'] for obj in objects \n                          if obj['name'] in planetary_params]\n    \n    object_var = tk.StringVar(value=\"Earth\")\n\n    object_combo = ttk.Combobox(control_frame, textvariable=object_var, \n                                values=objects_with_params, width=25)\n    object_combo.grid(row=0, column=1, columnspan=2, padx=5, pady=5)\n    \n    # Display options\n    ttk.Label(control_frame, text=\"Display Options:\").grid(row=1, column=0, \n                                                           columnspan=3, padx=5, pady=(15,5))\n    \n    show_orbit_steps_var = tk.BooleanVar(value=True)\n    show_coordinate_frames_var = tk.BooleanVar(value=True)\n    show_final_only_var = tk.BooleanVar(value=False)\n    show_apsidal_markers_var = tk.BooleanVar(value=True)  # ADD THIS LINE\n    \n    ttk.Checkbutton(control_frame, text=\"Show Orbit Transformation Steps\", \n                    variable=show_orbit_steps_var).grid(row=2, column=0, \n                                                        columnspan=3, padx=20, pady=2, sticky='w')\n    ttk.Checkbutton(control_frame, text=\"Show Coordinate Frames\", \n                    variable=show_coordinate_frames_var).grid(row=3, column=0, \n                                                             columnspan=3, padx=20, pady=2, sticky='w')\n    ttk.Checkbutton(control_frame, text=\"Show Final Orbit Only (Simplified)\", \n                    variable=show_final_only_var).grid(row=4, column=0, \n                                                       columnspan=3, padx=20, pady=2, sticky='w')\n    ttk.Checkbutton(control_frame, text=\"Show Perihelion/Aphelion Markers\",   # ADD THESE LINES\n                    variable=show_apsidal_markers_var).grid(row=5, column=0, \n                                                            columnspan=3, padx=20, pady=2, sticky='w')\n    \n    # Add separator\n    ttk.Separator(control_frame, orient='horizontal').grid(row=6, column=0, \n                                                          columnspan=3, sticky='ew', pady=10)\n    \n    # Orbital parameters display\n    param_frame = ttk.LabelFrame(control_frame, text=\"Orbital Elements\")\n    param_frame.grid(row=7, column=0, columnspan=3, padx=5, pady=5, sticky='ew')\n    \n    # Parameter labels\n    param_labels = {}\n    param_names = [\n        ('a', 'Semi-major axis:', 'AU'),\n        ('e', 'Eccentricity:', ''),\n        ('i', 'Inclination:', ' deg'),\n        ('omega', 'Arg. of Periapsis (omega):', ' deg'),\n        ('Omega', 'Long. of Asc. Node (Omega):', ' deg'),\n        ('period', 'Orbital Period:', 'days')\n    ]\n    \n    for idx, (key, label, unit) in enumerate(param_names):\n        ttk.Label(param_frame, text=label).grid(row=idx, column=0, \n                                               padx=5, pady=2, sticky='w')\n        value_label = ttk.Label(param_frame, text=\"---\")\n        value_label.grid(row=idx, column=1, padx=5, pady=2, sticky='e')\n        unit_label = ttk.Label(param_frame, text=unit)\n        unit_label.grid(row=idx, column=2, padx=5, pady=2, sticky='w')\n        param_labels[key] = value_label\n    \n    # Display Earth's parameters immediately\n    if \"Earth\" in planetary_params:\n        params = planetary_params[\"Earth\"]\n        for key, label in param_labels.items():\n            if key in params:\n                value = params[key]\n                if isinstance(value, float):\n                    label.config(text=f\"{value:.4f}\" if key == 'e' \n                               else f\"{value:.2f}\")\n                else:\n                    label.config(text=str(value))\n            else:\n                label.config(text=\"---\")\n\n# Create visualization button\n    def create_visualization():\n        selected_obj = object_var.get()\n        if not selected_obj:\n            messagebox.showwarning(\"No Selection\", \"Please select an object\")\n            return\n        \n        try:\n            # Update parameter display\n            if selected_obj in planetary_params:\n                params = planetary_params[selected_obj]\n                for key, label in param_labels.items():\n                    if key in params:\n                        value = params[key]\n                        if isinstance(value, float):\n                            label.config(text=f\"{value:.4f}\" if key == 'e' \n                                       else f\"{value:.2f}\")\n                        else:\n                            label.config(text=str(value))\n                    else:\n                        label.config(text=\"---\")\n            \n            # Get current position for the selected object\n            current_position = None\n            current_date = stored_date  # Use the stored date\n            \n            # Check if we have a passed position for this object\n            if selected_obj in stored_positions:\n                current_position = stored_positions[selected_obj]\n                print(f\"Using passed position for {selected_obj}: x={current_position['x']:.3f}, y={current_position['y']:.3f}, z={current_position['z']:.3f}\")\n            else:\n                print(f\"No position data passed for {selected_obj}, fetching now...\")\n                \n                # Import fetch_trajectory from the main app\n                try:\n                    from palomas_orrery_helpers import fetch_trajectory\n                    \n                    # Get center info (assuming Sun for now)\n            #        center_id = 10  # Sun's ID\n                    center_id = '10'  # Sun's ID as a string\n                    \n                    # Find the object in the objects list\n                    obj_id = None\n                    id_type = None\n                    for obj in objects:\n                        if obj['name'] == selected_obj:\n                    #        obj_id = obj['id']\n                            obj_id = str(obj['id'])  # Ensure ID is a string too\n                            id_type = obj.get('id_type', None)\n                            break\n                    \n                    if obj_id:\n                        print(f\"  Fetching position for {selected_obj} (ID: {obj_id})...\")\n                        # Fetch the position\n                        trajectory = fetch_trajectory(\n                            obj_id,\n                            [current_date.strftime('%Y-%m-%d')],\n                            center_id=center_id,\n                            id_type=id_type\n                        )\n                        \n                        if trajectory and len(trajectory) > 0 and trajectory[0]:\n                            current_position = trajectory[0]\n                            if 'x' in current_position:\n                                print(f\"  Fetched position: ({current_position['x']:.3f}, {current_position['y']:.3f}, {current_position['z']:.3f})\")\n                            else:\n                                print(f\"  Position data incomplete\")\n                        else:\n                            print(f\"  No position data returned\")\n                    else:\n                        print(f\"  Could not find object ID for {selected_obj}\")\n                        \n                except Exception as ex:\n                    print(f\"  Could not fetch current position: {ex}\")\n                    import traceback\n                    traceback.print_exc()\n\n            # Determine the correct boolean values based on the checkboxes\n            show_final_only = show_final_only_var.get()\n            \n            # If \"Show Final Only\" is checked, it overrides the \"Show Steps\" option.\n            show_steps_val = show_orbit_steps_var.get() and not show_final_only\n            show_axes_val = show_coordinate_frames_var.get()\n            show_apsidal_val = show_apsidal_markers_var.get()            \n\n            # Create an empty figure object to pass to the function.\n            # The function will clear and build this figure internally.\n            fig = go.Figure()\n\n            # Create the visualization with the CORRECT parameter names\n            create_orbital_transformation_viz(\n                fig, # Pass the figure object\n                selected_obj, \n                planetary_params,\n                show_steps=show_steps_val, # Corrected parameter name\n                show_axes=show_axes_val,    # Corrected parameter name\n                parent_planets=parent_planets, # Add this argument\n                show_apsidal_markers=show_apsidal_val,\n        #        plot_date=current_date,        # Changed from dt.datetime.now() to current_date\n                plot_date=stored_date,\n                current_position=current_position  # Added this new parameter\n            )\n            \n            if fig.data:    \n                # Show in browser\n                # Generate a descriptive default filename for the plot\n                current_date_str = dt.datetime.now().strftime('%Y%m%d')\n                default_name = f\"Orbital_Transformation_{selected_obj.replace(' ', '_')}_{current_date_str}\"\n\n                # Use the existing safe showing/saving function from the main application\n                show_figure_safely(fig, default_name)\n                \n        except Exception as e:\n            messagebox.showerror(\"Error\", f\"Failed to create visualization:\\n{str(e)}\")\n    \n    create_button = ttk.Button(control_frame, text=\"Create Orbital Parameter Visualization\", \n                              command=create_visualization, width=40)  # Increased width\n    create_button.grid(row=8, column=0, columnspan=3, pady=20, padx=5)\n    \n    # Add the eccentricity demo button\n    demo_button = ttk.Button(\n        control_frame, \n        text=\"Interactive Orbital Eccentricity Visualization\", \n        command=lambda: create_eccentricity_demo_window(viz_window, objects, planetary_params),\n        width=40  # Increased width\n    )\n    demo_button.grid(row=9, column=0, columnspan=3, pady=10, padx=5)\n\n    # Add debug to verify parameters exist here\n    print(f\"DEBUG in create_orbital_viz_window:\")\n    print(f\"  - objects exists: {objects is not None}\")\n    print(f\"  - planetary_params exists: {planetary_params is not None}\")\n    if planetary_params:\n        print(f\"  - planetary_params has {len(planetary_params)} objects\")\n\n    # Add tooltip for the demo button (using the CreateToolTip class already in orbital_param_viz.py)\n    CreateToolTip(demo_button, \n        \"Launch an interactive visualization showing how eccentricity\\n\"\n        \"affects orbital shape from circle (e=0) through ellipse,\\n\"\n        \"parabola (e=1), to hyperbola (e>1).\")\n\n    # Information text\n    info_frame = ttk.LabelFrame(main_frame, text=\"Understanding the Visualization\")\n    info_frame.pack(side='right', fill='both', expand=True)\n    \n    info_text = tk.Text(info_frame, wrap='word', width=60, height=35)\n    info_text.pack(fill='both', expand=True, padx=5, pady=5)\n    \n    info_content = \"\"\"# ORBITAL PARAMETER TRANSFORMATION VISUALIZATION\n\n    This tool demonstrates how Keplerian orbital elements transform an orbit from its natural coordinate system (perifocal frame) to the standard ecliptic reference frame used in astronomy.\n\n    ## KEY CONCEPTS\n\n    ### Coordinate Frames\n    * **Perifocal Frame (Cyan)**: The orbit's natural coordinate system\n    - X-axis points to periapsis (closest approach)\n    - Orbit lies in XY plane\n    - Specific to each individual orbit\n    - This is the orbit's \"2D blueprint\"\n\n    * **Ecliptic Frame (Red)**: The standard reference frame\n    - XY plane is Earth's orbital plane\n    - X-axis points to vernal equinox ([ARIES])\n    - Same for all objects in the solar system\n    - The universal coordinate system for astronomy\n\n    ### TRANSFORMATION SEQUENCE\n\n    The visualization shows how three sequential rotations place the orbit into its final orientation:\n    **R = Rz(omega) * Rx(i) * Rz(Omega)**\n\n    1. **Initial State (Cyan)**: Perifocal Frame\n    - The orbit in its simplest form\n    - Periapsis aligned on +X axis\n\n    2. **After Omega rotation (Purple)**: Longitude of Ascending Node\n    - Rotates the frame by Omega around Z-axis\n    - Positions the line of nodes at angle Omega from vernal equinox\n    - The X-axis after this rotation IS the line of nodes\n\n    3. **After Omega and i rotation (Orange)**: Inclination\n    - Tilts the frame by i around the line of nodes (X-axis from step 2)\n    - Gives the orbit its inclination relative to the ecliptic plane\n    - The line of nodes remains fixed along the purple X-axis\n\n    4. **Final State (Red)**: Argument of Periapsis\n    - Rotates by omega within the tilted orbital plane\n    - Positions the periapsis at angle omega from the ascending node\n    - Completes the transformation to ecliptic coordinates\n\n    **Important**: The coordinate systems rotate, not the orbit itself! The orbit maintains its shape and orientation relative to each coordinate frame.\n\n    ## VISUAL ELEMENTS\n\n    * **Coordinate Axes**: Shows each reference frame's orientation\n    * **Orbital Curves**: Displays orbit at each transformation stage\n    * **Periapsis/Apoapsis Markers**: \n    - Periapsis: Closest approach (perihelion for Sun, perigee for planets)\n    - Apoapsis: Farthest point (aphelion for Sun, apogee for planets)\n    - Hover over markers to see predicted dates and distances\n    * **Current Position**: Shows the object's location at the selected date\n    * **Line of Nodes**: Where orbit crosses the reference plane (along purple X-axis)\n    * **Ascending Node**: Where orbit rises above the reference plane\n\n    ## ANGULAR PARAMETERS EXPLAINED\n\n    * **Omega (Longitude of Ascending Node)**: 0 deg-360 deg\n    - Measured in the ecliptic plane\n    - From vernal equinox ([ARIES]) to ascending node\n    - Determines the orbit's \"swivel\" orientation\n\n    * **i (Inclination)**: 0 deg-180 deg\n    - Angle between orbital plane and ecliptic\n    - 0 deg = orbit in ecliptic plane\n    - 90 deg = polar orbit\n    - >90 deg = retrograde orbit\n\n    * **omega (Argument of Periapsis)**: 0 deg-360 deg\n    - Measured within the orbital plane\n    - From ascending node to periapsis\n    - Determines where closest approach occurs\n\n    ## INTERACTIVE FEATURES\n\n    * **3D Navigation**:\n    - Click and drag to rotate view\n    - Scroll to zoom in/out\n    - Double-click to reset view\n\n    * **Display Options**:\n    - Toggle transformation steps on/off\n    - Show/hide coordinate frames\n    - Display final orbit only (simplified view)\n    - Toggle perihelion/aphelion markers\n\n    * **Legend Interaction**:\n    - Click legend items to show/hide elements\n    - Useful for focusing on particular aspects of the transformation\n\n    ## REAL-TIME INTEGRATION\n\n    When launched from the main application:\n    * Uses current date from the main plot\n    * Shows actual object position at that date\n    * Displays calculated apsidal dates (perihelion/aphelion)\n    * Integrates with live orbital data\n\n    ## NOTE ON SATELLITE ORBITS\n\n    This visualization shows idealized Keplerian orbits. Real satellite orbits (like the Moon's) are affected by:\n    - Parent planet's equatorial bulge (oblateness)\n    - Gravitational pull from the Sun\n    - Perturbations from other nearby moons\n    - Tidal forces and resonances\n\n    The main application uses refined models (idealized_orbits.py) that account for these effects, providing more accurate satellite positions.\n\n    ## EDUCATIONAL VALUE\n\n    This visualization bridges the gap between:\n    - **Abstract parameters** (a, e, i, omega, Omega) that define orbits mathematically\n    - **Physical reality** of how celestial objects move through 3D space\n\n    By showing the step-by-step transformation, it helps develop intuition for how each parameter affects the final orbit orientation.\"\"\"\n\n    info_text.insert('1.0', info_content)\n    info_text.config(state='disabled')  # Make read-only\n    \n    return viz_window",
    "start_line": 1894,
    "end_line": 2272,
    "has_docstring": true,
    "docstring": "Create a window for orbital parameter visualization.\nTo be called from palomas_orrery.py\n\nParameters:\n    root: Parent tkinter window\n    objects: List of celestial objects\n    planetary_params: Dictionary of orbital parameters\n    parent_planets: Dictionary mapping planets to their satellites\n    current_positions: Dictionary of current positions {name: {'x': x, 'y': y, 'z': z}}\n    current_date: Current date being displayed",
    "parameters": [
      "root",
      "objects",
      "planetary_params",
      "parent_planets",
      "current_positions",
      "current_date"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_orbital_viz_window",
    "component_id": "orbital_param_viz.create_orbital_viz_window"
  },
  "orbital_param_viz.create_visualization": {
    "id": "orbital_param_viz.create_visualization",
    "name": "create_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbital_param_viz.py",
    "relative_path": "orbital_param_viz.py",
    "depends_on": [
      "palomas_orrery_helpers.fetch_trajectory",
      "shutdown_handler.show_figure_safely",
      "orbital_param_viz.create_orbital_transformation_viz"
    ],
    "source_code": "    def create_visualization():\n        selected_obj = object_var.get()\n        if not selected_obj:\n            messagebox.showwarning(\"No Selection\", \"Please select an object\")\n            return\n        \n        try:\n            # Update parameter display\n            if selected_obj in planetary_params:\n                params = planetary_params[selected_obj]\n                for key, label in param_labels.items():\n                    if key in params:\n                        value = params[key]\n                        if isinstance(value, float):\n                            label.config(text=f\"{value:.4f}\" if key == 'e' \n                                       else f\"{value:.2f}\")\n                        else:\n                            label.config(text=str(value))\n                    else:\n                        label.config(text=\"---\")\n            \n            # Get current position for the selected object\n            current_position = None\n            current_date = stored_date  # Use the stored date\n            \n            # Check if we have a passed position for this object\n            if selected_obj in stored_positions:\n                current_position = stored_positions[selected_obj]\n                print(f\"Using passed position for {selected_obj}: x={current_position['x']:.3f}, y={current_position['y']:.3f}, z={current_position['z']:.3f}\")\n            else:\n                print(f\"No position data passed for {selected_obj}, fetching now...\")\n                \n                # Import fetch_trajectory from the main app\n                try:\n                    from palomas_orrery_helpers import fetch_trajectory\n                    \n                    # Get center info (assuming Sun for now)\n            #        center_id = 10  # Sun's ID\n                    center_id = '10'  # Sun's ID as a string\n                    \n                    # Find the object in the objects list\n                    obj_id = None\n                    id_type = None\n                    for obj in objects:\n                        if obj['name'] == selected_obj:\n                    #        obj_id = obj['id']\n                            obj_id = str(obj['id'])  # Ensure ID is a string too\n                            id_type = obj.get('id_type', None)\n                            break\n                    \n                    if obj_id:\n                        print(f\"  Fetching position for {selected_obj} (ID: {obj_id})...\")\n                        # Fetch the position\n                        trajectory = fetch_trajectory(\n                            obj_id,\n                            [current_date.strftime('%Y-%m-%d')],\n                            center_id=center_id,\n                            id_type=id_type\n                        )\n                        \n                        if trajectory and len(trajectory) > 0 and trajectory[0]:\n                            current_position = trajectory[0]\n                            if 'x' in current_position:\n                                print(f\"  Fetched position: ({current_position['x']:.3f}, {current_position['y']:.3f}, {current_position['z']:.3f})\")\n                            else:\n                                print(f\"  Position data incomplete\")\n                        else:\n                            print(f\"  No position data returned\")\n                    else:\n                        print(f\"  Could not find object ID for {selected_obj}\")\n                        \n                except Exception as ex:\n                    print(f\"  Could not fetch current position: {ex}\")\n                    import traceback\n                    traceback.print_exc()\n\n            # Determine the correct boolean values based on the checkboxes\n            show_final_only = show_final_only_var.get()\n            \n            # If \"Show Final Only\" is checked, it overrides the \"Show Steps\" option.\n            show_steps_val = show_orbit_steps_var.get() and not show_final_only\n            show_axes_val = show_coordinate_frames_var.get()\n            show_apsidal_val = show_apsidal_markers_var.get()            \n\n            # Create an empty figure object to pass to the function.\n            # The function will clear and build this figure internally.\n            fig = go.Figure()\n\n            # Create the visualization with the CORRECT parameter names\n            create_orbital_transformation_viz(\n                fig, # Pass the figure object\n                selected_obj, \n                planetary_params,\n                show_steps=show_steps_val, # Corrected parameter name\n                show_axes=show_axes_val,    # Corrected parameter name\n                parent_planets=parent_planets, # Add this argument\n                show_apsidal_markers=show_apsidal_val,\n        #        plot_date=current_date,        # Changed from dt.datetime.now() to current_date\n                plot_date=stored_date,\n                current_position=current_position  # Added this new parameter\n            )\n            \n            if fig.data:    \n                # Show in browser\n                # Generate a descriptive default filename for the plot\n                current_date_str = dt.datetime.now().strftime('%Y%m%d')\n                default_name = f\"Orbital_Transformation_{selected_obj.replace(' ', '_')}_{current_date_str}\"\n\n                # Use the existing safe showing/saving function from the main application\n                show_figure_safely(fig, default_name)\n                \n        except Exception as e:\n            messagebox.showerror(\"Error\", f\"Failed to create visualization:\\n{str(e)}\")",
    "start_line": 2004,
    "end_line": 2116,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_visualization",
    "component_id": "orbital_param_viz.create_visualization"
  },
  "orbital_param_viz.create_orbital_transformation_viz_legacy": {
    "id": "orbital_param_viz.create_orbital_transformation_viz_legacy",
    "name": "create_orbital_transformation_viz_legacy",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orbital_param_viz.py",
    "relative_path": "orbital_param_viz.py",
    "depends_on": [
      "orbital_param_viz.create_orbital_transformation_viz"
    ],
    "source_code": "def create_orbital_transformation_viz_legacy(fig, obj_name, planetary_params, **kwargs):\n    \"\"\"Legacy function for compatibility\"\"\"\n    new_fig = create_orbital_transformation_viz(obj_name, planetary_params, **kwargs)\n    return new_fig if new_fig else fig",
    "start_line": 2275,
    "end_line": 2278,
    "has_docstring": true,
    "docstring": "Legacy function for compatibility",
    "parameters": [
      "fig",
      "obj_name",
      "planetary_params"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_orbital_transformation_viz_legacy",
    "component_id": "orbital_param_viz.create_orbital_transformation_viz_legacy"
  },
  "orrery_integration.OrreryConfiguration": {
    "id": "orrery_integration.OrreryConfiguration",
    "name": "OrreryConfiguration",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orrery_integration.py",
    "relative_path": "orrery_integration.py",
    "depends_on": [],
    "source_code": "class OrreryConfiguration:\n    \"\"\"Configuration for orbit selection and display options.\"\"\"\n    \n    def __init__(self):\n        self.use_refined_orbits = True  # Default to refined if available\n        self.ephemeris_file = \"satellite_ephemerides.json\"\n        self.show_orbit_comparison = False\n        self.refined_orbit_color = 'gold'\n        self.idealized_orbit_color = 'silver'\n        self.orbit_alpha = 0.6\n        \n    def load_from_file(self, config_file: str = \"orrery_config.json\"):\n        \"\"\"Load configuration from JSON file.\"\"\"\n        if os.path.exists(config_file):\n            with open(config_file, 'r') as f:\n                config = json.load(f)\n                for key, value in config.items():\n                    if hasattr(self, key):\n                        setattr(self, key, value)",
    "start_line": 29,
    "end_line": 47,
    "has_docstring": true,
    "docstring": "Configuration for orbit selection and display options.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class OrreryConfiguration",
    "component_id": "orrery_integration.OrreryConfiguration"
  },
  "orrery_integration.get_orbit_function": {
    "id": "orrery_integration.get_orbit_function",
    "name": "get_orbit_function",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orrery_integration.py",
    "relative_path": "orrery_integration.py",
    "depends_on": [
      "refined_orbits.create_refined_orbit"
    ],
    "source_code": "def get_orbit_function(object_name: str, primary: str = None) -> Callable:\n    \"\"\"\n    Get the appropriate orbit function for an object.\n    \n    This is the main integration point - it returns either a refined\n    or idealized orbit based on configuration and availability.\n    \"\"\"\n    \n    # Map object names to their primaries if not provided\n    object_to_primary = {\n        'phobos': 'mars',\n        'deimos': 'mars',\n        'io': 'jupiter',\n        'europa': 'jupiter',\n        'ganymede': 'jupiter',\n        'callisto': 'jupiter',\n        'titan': 'saturn',\n        'enceladus': 'saturn',\n        'moon': 'earth',\n    }\n    \n    obj_lower = object_name.lower()\n    if primary is None and obj_lower in object_to_primary:\n        primary = object_to_primary[obj_lower]\n    \n    # Try refined orbits first if configured\n    if orrery_config.use_refined_orbits and REFINED_AVAILABLE:\n        try:\n            if primary:\n                return refined_orbits.create_refined_orbit(object_name, primary)\n            else:\n                # Try the convenience functions\n                func_name = f\"create_refined_{obj_lower}_orbit\"\n                if hasattr(refined_orbits, func_name):\n                    return getattr(refined_orbits, func_name)()\n        except Exception as e:\n            print(f\"Could not get refined orbit for {object_name}: {e}\")\n    \n    # Fall back to idealized orbits\n    if IDEALIZED_AVAILABLE:\n        func_name = f\"create_{obj_lower}_orbit\"\n        if hasattr(idealized_orbits, func_name):\n            return getattr(idealized_orbits, func_name)()\n    \n    # Last resort: simple circular orbit\n    print(f\"Warning: No orbit function found for {object_name}\")\n    radius = 10000  # Default 10,000 km\n    \n    def default_orbit(t):\n        t = np.asarray(t)\n        return np.array([\n            radius * np.cos(t),\n            radius * np.sin(t),\n            np.zeros_like(t)\n        ]).T.squeeze()\n    \n    return default_orbit",
    "start_line": 54,
    "end_line": 110,
    "has_docstring": true,
    "docstring": "Get the appropriate orbit function for an object.\n\nThis is the main integration point - it returns either a refined\nor idealized orbit based on configuration and availability.",
    "parameters": [
      "object_name",
      "primary"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_orbit_function",
    "component_id": "orrery_integration.get_orbit_function"
  },
  "orrery_integration.default_orbit": {
    "id": "orrery_integration.default_orbit",
    "name": "default_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orrery_integration.py",
    "relative_path": "orrery_integration.py",
    "depends_on": [],
    "source_code": "    def default_orbit(t):\n        t = np.asarray(t)\n        return np.array([\n            radius * np.cos(t),\n            radius * np.sin(t),\n            np.zeros_like(t)\n        ]).T.squeeze()",
    "start_line": 102,
    "end_line": 108,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "t"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function default_orbit",
    "component_id": "orrery_integration.default_orbit"
  },
  "orrery_integration.create_orrery_objects": {
    "id": "orrery_integration.create_orrery_objects",
    "name": "create_orrery_objects",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orrery_integration.py",
    "relative_path": "orrery_integration.py",
    "depends_on": [
      "orrery_integration.get_orbit_function"
    ],
    "source_code": "def create_orrery_objects(config: dict) -> Dict[str, Dict]:\n    \"\"\"\n    Create orrery objects with appropriate orbit functions.\n    \n    This replaces/enhances the object creation in palomas_orrery.py\n    \"\"\"\n    objects = {}\n    \n    for obj_name, obj_config in config.items():\n        # Get orbit function\n        primary = obj_config.get('primary', None)\n        orbit_func = get_orbit_function(obj_name, primary)\n        \n        # Create object entry\n        objects[obj_name] = {\n            'orbit': orbit_func,\n            'color': obj_config.get('color', 'white'),\n            'size': obj_config.get('size', 5),\n            'primary': primary,\n            'show_orbit': obj_config.get('show_orbit', True),\n            'orbit_segments': obj_config.get('orbit_segments', 100),\n            'is_refined': orrery_config.use_refined_orbits and REFINED_AVAILABLE\n        }\n        \n    return objects",
    "start_line": 113,
    "end_line": 137,
    "has_docstring": true,
    "docstring": "Create orrery objects with appropriate orbit functions.\n\nThis replaces/enhances the object creation in palomas_orrery.py",
    "parameters": [
      "config"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_orrery_objects",
    "component_id": "orrery_integration.create_orrery_objects"
  },
  "orrery_integration.plot_objects_enhanced": {
    "id": "orrery_integration.plot_objects_enhanced",
    "name": "plot_objects_enhanced",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orrery_integration.py",
    "relative_path": "orrery_integration.py",
    "depends_on": [],
    "source_code": "def plot_objects_enhanced(objects: Dict, t: float, ax, show_orbits: bool = True, \n                         show_comparison: bool = False):\n    \"\"\"\n    Enhanced version of plot_objects that can show orbit comparisons.\n    \"\"\"\n    import matplotlib.pyplot as plt\n    \n    for name, obj in objects.items():\n        # Get current position\n        pos = obj['orbit'](t)\n        \n        # Plot object\n        ax.scatter(pos[0], pos[1], pos[2], \n                  color=obj['color'], \n                  s=obj['size']**2,\n                  label=name.title())\n        \n        # Plot orbit trail if requested\n        if show_orbits and obj.get('show_orbit', True):\n            t_orbit = np.linspace(0, 2*np.pi, obj.get('orbit_segments', 100))\n            orbit_positions = np.array([obj['orbit'](t) for t in t_orbit])\n            \n            # Choose color based on orbit type\n            orbit_color = (orrery_config.refined_orbit_color \n                          if obj.get('is_refined', False) \n                          else orrery_config.idealized_orbit_color)\n            \n            ax.plot(orbit_positions[:, 0], \n                   orbit_positions[:, 1], \n                   orbit_positions[:, 2],\n                   color=orbit_color,\n                   alpha=orrery_config.orbit_alpha,\n                   linewidth=1)\n        \n        # Show comparison orbits if requested\n        if (show_comparison and orrery_config.show_orbit_comparison \n            and IDEALIZED_AVAILABLE and obj.get('is_refined', False)):\n            \n            # Get idealized orbit for comparison\n            try:\n                func_name = f\"create_{name.lower()}_orbit\"\n                if hasattr(idealized_orbits, func_name):\n                    idealized_func = getattr(idealized_orbits, func_name)()\n                    orbit_positions = np.array([idealized_func(t) for t in t_orbit])\n                    \n                    ax.plot(orbit_positions[:, 0], \n                           orbit_positions[:, 1], \n                           orbit_positions[:, 2],\n                           color=orrery_config.idealized_orbit_color,\n                           alpha=orrery_config.orbit_alpha * 0.5,\n                           linewidth=1,\n                           linestyle='--')\n            except:\n                pass",
    "start_line": 140,
    "end_line": 193,
    "has_docstring": true,
    "docstring": "Enhanced version of plot_objects that can show orbit comparisons.",
    "parameters": [
      "objects",
      "t",
      "ax",
      "show_orbits",
      "show_comparison"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_objects_enhanced",
    "component_id": "orrery_integration.plot_objects_enhanced"
  },
  "orrery_integration.animate_objects_enhanced": {
    "id": "orrery_integration.animate_objects_enhanced",
    "name": "animate_objects_enhanced",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orrery_integration.py",
    "relative_path": "orrery_integration.py",
    "depends_on": [],
    "source_code": "def animate_objects_enhanced(objects: Dict, duration: float = 10.0, fps: int = 30,\n                           show_comparison: bool = False):\n    \"\"\"\n    Enhanced animation function that supports orbit comparisons.\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.animation import FuncAnimation\n    from mpl_toolkits.mplot3d import Axes3D\n    \n    fig = plt.figure(figsize=(12, 10))\n    ax = fig.add_subplot(111, projection='3d')\n    \n    # Set up the plot\n    ax.set_xlabel('X (km)')\n    ax.set_ylabel('Y (km)')\n    ax.set_zlabel('Z (km)')\n    ax.set_title('Solar System Orrery - Enhanced')\n    \n    # Calculate axis limits\n    max_radius = 0\n    for obj in objects.values():\n        test_positions = np.array([obj['orbit'](t) for t in np.linspace(0, 2*np.pi, 50)])\n        max_radius = max(max_radius, np.max(np.abs(test_positions)))\n    \n    ax.set_xlim([-max_radius, max_radius])\n    ax.set_ylim([-max_radius, max_radius])\n    ax.set_zlim([-max_radius/10, max_radius/10])  # Compressed Z axis\n    \n    # Animation update function\n    def update(frame):\n        ax.clear()\n        \n        # Reconfigure axes\n        ax.set_xlabel('X (km)')\n        ax.set_ylabel('Y (km)')\n        ax.set_zlabel('Z (km)')\n        ax.set_xlim([-max_radius, max_radius])\n        ax.set_ylim([-max_radius, max_radius])\n        ax.set_zlim([-max_radius/10, max_radius/10])\n        \n        # Calculate time\n        t = frame / (fps * duration) * 2 * np.pi\n        \n        # Plot objects\n        plot_objects_enhanced(objects, t, ax, show_orbits=True, \n                            show_comparison=show_comparison)\n        \n        # Add time display\n        ax.text2D(0.05, 0.95, f'Time: {t/(2*np.pi)*100:.1f}%', \n                 transform=ax.transAxes)\n        \n        # Add orbit type indicator\n        orbit_type = \"Refined\" if orrery_config.use_refined_orbits else \"Idealized\"\n        ax.text2D(0.05, 0.90, f'Orbits: {orbit_type}', \n                 transform=ax.transAxes, color='gold' if orrery_config.use_refined_orbits else 'silver')\n        \n        # Add legend\n        if frame == 0:\n            ax.legend(loc='upper right')\n    \n    # Create animation\n    n_frames = int(duration * fps)\n    anim = FuncAnimation(fig, update, frames=n_frames, interval=1000/fps, blit=False)\n    \n    return fig, anim",
    "start_line": 196,
    "end_line": 260,
    "has_docstring": true,
    "docstring": "Enhanced animation function that supports orbit comparisons.",
    "parameters": [
      "objects",
      "duration",
      "fps",
      "show_comparison"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function animate_objects_enhanced",
    "component_id": "orrery_integration.animate_objects_enhanced"
  },
  "orrery_integration.update": {
    "id": "orrery_integration.update",
    "name": "update",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orrery_integration.py",
    "relative_path": "orrery_integration.py",
    "depends_on": [
      "orrery_integration.plot_objects_enhanced"
    ],
    "source_code": "    def update(frame):\n        ax.clear()\n        \n        # Reconfigure axes\n        ax.set_xlabel('X (km)')\n        ax.set_ylabel('Y (km)')\n        ax.set_zlabel('Z (km)')\n        ax.set_xlim([-max_radius, max_radius])\n        ax.set_ylim([-max_radius, max_radius])\n        ax.set_zlim([-max_radius/10, max_radius/10])\n        \n        # Calculate time\n        t = frame / (fps * duration) * 2 * np.pi\n        \n        # Plot objects\n        plot_objects_enhanced(objects, t, ax, show_orbits=True, \n                            show_comparison=show_comparison)\n        \n        # Add time display\n        ax.text2D(0.05, 0.95, f'Time: {t/(2*np.pi)*100:.1f}%', \n                 transform=ax.transAxes)\n        \n        # Add orbit type indicator\n        orbit_type = \"Refined\" if orrery_config.use_refined_orbits else \"Idealized\"\n        ax.text2D(0.05, 0.90, f'Orbits: {orbit_type}', \n                 transform=ax.transAxes, color='gold' if orrery_config.use_refined_orbits else 'silver')\n        \n        # Add legend\n        if frame == 0:\n            ax.legend(loc='upper right')",
    "start_line": 225,
    "end_line": 254,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "frame"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function update",
    "component_id": "orrery_integration.update"
  },
  "orrery_integration.plot_palomas_orrery": {
    "id": "orrery_integration.plot_palomas_orrery",
    "name": "plot_palomas_orrery",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orrery_integration.py",
    "relative_path": "orrery_integration.py",
    "depends_on": [
      "orrery_integration.create_orrery_objects",
      "orrery_integration.plot_objects_enhanced"
    ],
    "source_code": "def plot_palomas_orrery(date_time=None, show_orbits=True, use_refined=None):\n    \"\"\"\n    Main plotting function that integrates with palomas_orrery.py\n    \n    Parameters:\n    -----------\n    date_time : datetime, optional\n        Time to display (default: now)\n    show_orbits : bool\n        Whether to show orbit trails\n    use_refined : bool, optional\n        Override the default orbit type (None = use config)\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from mpl_toolkits.mplot3d import Axes3D\n    from datetime import datetime\n    \n    # Override configuration if specified\n    if use_refined is not None:\n        original = orrery_config.use_refined_orbits\n        orrery_config.use_refined_orbits = use_refined\n    \n    # Define objects (this would come from palomas_orrery.py config)\n    orrery_objects = {\n        'mars': {\n            'primary': 'sun',\n            'color': 'red',\n            'size': 6\n        },\n        'phobos': {\n            'primary': 'mars',\n            'color': 'gray',\n            'size': 3\n        },\n        'deimos': {\n            'primary': 'mars',\n            'color': 'lightgray',\n            'size': 2\n        }\n    }\n    \n    # Create objects with appropriate orbits\n    objects = create_orrery_objects(orrery_objects)\n    \n    # Create plot\n    fig = plt.figure(figsize=(12, 10))\n    ax = fig.add_subplot(111, projection='3d')\n    \n    # Calculate time parameter (simplified - would need proper conversion)\n    if date_time is None:\n        date_time = datetime.now()\n    t = 0  # Would calculate from date_time\n    \n    # Plot objects\n    plot_objects_enhanced(objects, t, ax, show_orbits=show_orbits,\n                         show_comparison=orrery_config.show_orbit_comparison)\n    \n    # Configure plot\n    ax.set_xlabel('X (km)')\n    ax.set_ylabel('Y (km)')\n    ax.set_zlabel('Z (km)')\n    \n    orbit_type = \"Refined\" if orrery_config.use_refined_orbits else \"Idealized\"\n    ax.set_title(f\"Paloma's Orrery - {orbit_type} Orbits\\n{date_time.strftime('%Y-%m-%d %H:%M:%S')}\")\n    \n    plt.legend()\n    plt.show()\n    \n    # Restore configuration if overridden\n    if use_refined is not None:\n        orrery_config.use_refined_orbits = original\n    \n    return fig, ax",
    "start_line": 264,
    "end_line": 336,
    "has_docstring": true,
    "docstring": "Main plotting function that integrates with palomas_orrery.py\n\nParameters:\n-----------\ndate_time : datetime, optional\n    Time to display (default: now)\nshow_orbits : bool\n    Whether to show orbit trails\nuse_refined : bool, optional\n    Override the default orbit type (None = use config)",
    "parameters": [
      "date_time",
      "show_orbits",
      "use_refined"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_palomas_orrery",
    "component_id": "orrery_integration.plot_palomas_orrery"
  },
  "orrery_integration.validate_orbit_accuracy": {
    "id": "orrery_integration.validate_orbit_accuracy",
    "name": "validate_orbit_accuracy",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\orrery_integration.py",
    "relative_path": "orrery_integration.py",
    "depends_on": [
      "palomas_orrery.refined_orbit"
    ],
    "source_code": "def validate_orbit_accuracy():\n    \"\"\"Compare refined vs idealized orbits for all available objects.\"\"\"\n    if not (REFINED_AVAILABLE and IDEALIZED_AVAILABLE):\n        print(\"Both orbit systems needed for comparison\")\n        return\n    \n    objects = ['phobos', 'deimos', 'io', 'europa', 'ganymede', 'callisto']\n    \n    print(\"Orbit Comparison Report\")\n    print(\"=\" * 70)\n    print(f\"{'Object':<12} {'Idealized R (km)':<18} {'Refined R (km)':<18} {'Difference':<12}\")\n    print(\"-\" * 70)\n    \n    for obj in objects:\n        try:\n            # Get both orbit types\n            ideal_func = getattr(idealized_orbits, f\"create_{obj}_orbit\", None)\n            refined_func = getattr(refined_orbits, f\"create_refined_{obj}_orbit\", None)\n            \n            if ideal_func and refined_func:\n                ideal_orbit = ideal_func()\n                refined_orbit = refined_func()\n                \n                # Compare at t=0\n                ideal_pos = ideal_orbit(0)\n                refined_pos = refined_orbit(0)\n                \n                ideal_r = np.linalg.norm(ideal_pos)\n                refined_r = np.linalg.norm(refined_pos)\n                diff = refined_r - ideal_r\n                \n                print(f\"{obj.title():<12} {ideal_r:<18.1f} {refined_r:<18.1f} {diff:<+12.1f}\")\n        except Exception as e:\n            print(f\"{obj.title():<12} Error: {e}\")\n    \n    print(\"=\" * 70)",
    "start_line": 340,
    "end_line": 375,
    "has_docstring": true,
    "docstring": "Compare refined vs idealized orbits for all available objects.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function validate_orbit_accuracy",
    "component_id": "orrery_integration.validate_orbit_accuracy"
  },
  "osculating_cache_manager.get_cache_key": {
    "id": "osculating_cache_manager.get_cache_key",
    "name": "get_cache_key",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\osculating_cache_manager.py",
    "relative_path": "osculating_cache_manager.py",
    "depends_on": [],
    "source_code": "def get_cache_key(obj_name, center_body=None):\n    \"\"\"\n    Generate cache key for an object, optionally with center body suffix.\n    \n    This enables storing different osculating elements for the same object\n    relative to different centers (e.g., heliocentric vs barycentric).\n    \n    Parameters:\n        obj_name (str): Display name of object (e.g., 'Pluto', 'Charon')\n        center_body (str, optional): Center body ID (e.g., '@9', '@sun', '9', 'sun')\n    \n    Returns:\n        str: Cache key\n    \n    Examples:\n        get_cache_key('Pluto')           -> 'Pluto'       (heliocentric default)\n        get_cache_key('Pluto', '@sun')   -> 'Pluto'       (explicit heliocentric)\n        get_cache_key('Pluto', '@9')     -> 'Pluto@9'     (barycentric)\n        get_cache_key('Charon', '@9')    -> 'Charon@9'    (barycentric)\n        get_cache_key('Charon', '@999')  -> 'Charon@999'  (Pluto body-centered)\n    \"\"\"\n    # Heliocentric is the default - no suffix needed\n    if center_body is None:\n        return obj_name\n    \n    # Normalize: remove @ prefix if present\n    center = center_body.lstrip('@').lower()\n    \n    # These all mean heliocentric - no suffix\n    if center in ['sun', '0', '10', 'ssb']:  # SSB = Solar System Barycenter\n        return obj_name\n    \n    # Non-heliocentric center - add suffix\n    return f\"{obj_name}@{center_body.lstrip('@')}\"",
    "start_line": 32,
    "end_line": 65,
    "has_docstring": true,
    "docstring": "Generate cache key for an object, optionally with center body suffix.\n\nThis enables storing different osculating elements for the same object\nrelative to different centers (e.g., heliocentric vs barycentric).\n\nParameters:\n    obj_name (str): Display name of object (e.g., 'Pluto', 'Charon')\n    center_body (str, optional): Center body ID (e.g., '@9', '@sun', '9', 'sun')\n\nReturns:\n    str: Cache key\n\nExamples:\n    get_cache_key('Pluto')           -> 'Pluto'       (heliocentric default)\n    get_cache_key('Pluto', '@sun')   -> 'Pluto'       (explicit heliocentric)\n    get_cache_key('Pluto', '@9')     -> 'Pluto@9'     (barycentric)\n    get_cache_key('Charon', '@9')    -> 'Charon@9'    (barycentric)\n    get_cache_key('Charon', '@999')  -> 'Charon@999'  (Pluto body-centered)",
    "parameters": [
      "obj_name",
      "center_body"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_cache_key",
    "component_id": "osculating_cache_manager.get_cache_key"
  },
  "osculating_cache_manager.get_refresh_interval": {
    "id": "osculating_cache_manager.get_refresh_interval",
    "name": "get_refresh_interval",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\osculating_cache_manager.py",
    "relative_path": "osculating_cache_manager.py",
    "depends_on": [],
    "source_code": "def get_refresh_interval(obj_name):\n    \"\"\"\n    Get recommended refresh interval for object (in days).\n    \n    Precedence hierarchy:\n    1. Specific object name (highest priority)\n    2. Pattern matching\n    3. Object type\n    4. Default (lowest priority)\n    \n    Parameters:\n        obj_name (str): Name of object\n    \n    Returns:\n        int: Refresh interval in days\n    \"\"\"\n    \n    # Priority 1: Specific object\n    if obj_name in REFRESH_INTERVALS:\n        return REFRESH_INTERVALS[obj_name]\n    \n    # Priority 2: Pattern matching\n    for key, interval in REFRESH_INTERVALS.items():\n        if key.startswith('pattern:'):\n            pattern = key.replace('pattern:', '')\n            if pattern in obj_name:\n                return interval\n    \n    # Priority 3: Object type (from idealized_orbits.py)\n    if obj_name in FALLBACK_ELEMENTS:\n        obj_type = FALLBACK_ELEMENTS[obj_name].get('object_type')\n        if obj_type:\n            type_key = f'type:{obj_type}'\n            if type_key in REFRESH_INTERVALS:\n                return REFRESH_INTERVALS[type_key]\n    \n    # Priority 4: Default\n    return REFRESH_INTERVALS['default']",
    "start_line": 106,
    "end_line": 143,
    "has_docstring": true,
    "docstring": "Get recommended refresh interval for object (in days).\n\nPrecedence hierarchy:\n1. Specific object name (highest priority)\n2. Pattern matching\n3. Object type\n4. Default (lowest priority)\n\nParameters:\n    obj_name (str): Name of object\n\nReturns:\n    int: Refresh interval in days",
    "parameters": [
      "obj_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_refresh_interval",
    "component_id": "osculating_cache_manager.get_refresh_interval"
  },
  "osculating_cache_manager.save_cache": {
    "id": "osculating_cache_manager.save_cache",
    "name": "save_cache",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\osculating_cache_manager.py",
    "relative_path": "osculating_cache_manager.py",
    "depends_on": [],
    "source_code": "def save_cache(cache):\n    \"\"\"\n    Save cache with two-generation backup protection.\n    \n    File structure:\n        osculating_cache.json          - Current\n        osculating_cache_backup.json   - Last good (one save ago)\n        osculating_cache_backup_old.json - Previous good (two saves ago)\n    \n    Process:\n        1. Write to temp file\n        2. Validate temp file\n        3. Rotate: backup [OK] backup_old\n        4. Copy: current [OK] backup\n        5. Move: temp [OK] current\n    \n    Recovery:\n        - If current corrupted [OK] use backup\n        - If backup corrupted [OK] use backup_old\n    \n    Parameters:\n        cache (dict): Cache data to save\n    \n    Raises:\n        Exception: If save fails (after attempting recovery)\n    \"\"\"\n    try:\n        # Step 1: Write to temp file\n        with open(TEMP_FILE, 'w') as f:\n            json.dump(cache, f, indent=2)\n        \n        # Step 2: Validate temp file\n        with open(TEMP_FILE, 'r') as f:\n            json.load(f)  # Will raise exception if invalid JSON\n        \n        # Step 3: Rotate backups: backup [OK] backup_old\n        if BACKUP_FILE.exists():\n            if BACKUP_OLD.exists():\n                BACKUP_OLD.unlink()  # Remove oldest backup\n            shutil.copy2(BACKUP_FILE, BACKUP_OLD)\n            print(f\"  Rotated: {BACKUP_FILE.name} [OK] {BACKUP_OLD.name}\")\n        \n        # Step 4: Current [OK] backup\n        if CACHE_FILE.exists():\n            shutil.copy2(CACHE_FILE, BACKUP_FILE)\n            print(f\"  Backed up: {CACHE_FILE.name} [OK] {BACKUP_FILE.name}\")\n        \n        # Step 5: Temp [OK] current (atomic on most systems)\n        TEMP_FILE.replace(CACHE_FILE)\n        print(f\"[OK] Saved: {CACHE_FILE.name} (2-gen protected)\")\n        \n    except Exception as e:\n        print(f\"[FAIL] Save failed: {e}\")\n        \n        # Clean up temp file\n        if TEMP_FILE.exists():\n            TEMP_FILE.unlink()\n        \n        # Attempt recovery from backup hierarchy\n        if not CACHE_FILE.exists():\n            if BACKUP_FILE.exists():\n                shutil.copy2(BACKUP_FILE, CACHE_FILE)\n                print(f\"[OK] Recovered from {BACKUP_FILE.name}\")\n            elif BACKUP_OLD.exists():\n                shutil.copy2(BACKUP_OLD, CACHE_FILE)\n                print(f\"[OK] Recovered from {BACKUP_OLD.name}\")\n        \n        raise",
    "start_line": 149,
    "end_line": 216,
    "has_docstring": true,
    "docstring": "Save cache with two-generation backup protection.\n\nFile structure:\n    osculating_cache.json          - Current\n    osculating_cache_backup.json   - Last good (one save ago)\n    osculating_cache_backup_old.json - Previous good (two saves ago)\n\nProcess:\n    1. Write to temp file\n    2. Validate temp file\n    3. Rotate: backup [OK] backup_old\n    4. Copy: current [OK] backup\n    5. Move: temp [OK] current\n\nRecovery:\n    - If current corrupted [OK] use backup\n    - If backup corrupted [OK] use backup_old\n\nParameters:\n    cache (dict): Cache data to save\n\nRaises:\n    Exception: If save fails (after attempting recovery)",
    "parameters": [
      "cache"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function save_cache",
    "component_id": "osculating_cache_manager.save_cache"
  },
  "osculating_cache_manager.load_cache": {
    "id": "osculating_cache_manager.load_cache",
    "name": "load_cache",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\osculating_cache_manager.py",
    "relative_path": "osculating_cache_manager.py",
    "depends_on": [
      "osculating_cache_manager.create_empty_cache"
    ],
    "source_code": "def load_cache():\n    \"\"\"\n    Load cache with two-generation recovery.\n    \n    Tries:\n        1. Main file\n        2. Backup file\n        3. Old backup file\n        4. Returns empty structure if all fail\n    \n    Returns:\n        dict: Cache data or empty cache structure\n    \"\"\"\n    \n    # Try main file\n    if CACHE_FILE.exists():\n        try:\n            with open(CACHE_FILE, 'r') as f:\n                return json.load(f)\n        except Exception as e:\n            print(f\"[WARN] Main cache corrupted: {e}\")\n    \n    # Try backup\n    if BACKUP_FILE.exists():\n        try:\n            with open(BACKUP_FILE, 'r') as f:\n                cache = json.load(f)\n            print(f\"[OK] Recovered from {BACKUP_FILE.name}\")\n            \n            # Restore to main file\n            shutil.copy2(BACKUP_FILE, CACHE_FILE)\n            return cache\n        except Exception as e:\n            print(f\"[WARN] Backup also corrupted: {e}\")\n    \n    # Try old backup\n    if BACKUP_OLD.exists():\n        try:\n            with open(BACKUP_OLD, 'r') as f:\n                cache = json.load(f)\n            print(f\"[OK] Recovered from {BACKUP_OLD.name}\")\n            \n            # Restore to main file\n            shutil.copy2(BACKUP_OLD, CACHE_FILE)\n            return cache\n        except Exception as e:\n            print(f\"[FAIL] All backups corrupted: {e}\")\n    \n    # All failed - return empty cache\n    print(\"[WARN] No valid cache found - starting fresh\")\n    return create_empty_cache()",
    "start_line": 218,
    "end_line": 268,
    "has_docstring": true,
    "docstring": "Load cache with two-generation recovery.\n\nTries:\n    1. Main file\n    2. Backup file\n    3. Old backup file\n    4. Returns empty structure if all fail\n\nReturns:\n    dict: Cache data or empty cache structure",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_cache",
    "component_id": "osculating_cache_manager.load_cache"
  },
  "osculating_cache_manager.create_empty_cache": {
    "id": "osculating_cache_manager.create_empty_cache",
    "name": "create_empty_cache",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\osculating_cache_manager.py",
    "relative_path": "osculating_cache_manager.py",
    "depends_on": [],
    "source_code": "def create_empty_cache():\n    \"\"\"Create empty cache structure with metadata.\"\"\"\n    return {\n        '_metadata': {\n            'cache_version': '1.0',\n            'created': datetime.now().isoformat(),\n            'description': 'Auto-updated cache of osculating orbital elements from JPL Horizons',\n            'note': 'Elements can be copied to idealized_orbits.py for manual backup'\n        }\n    }",
    "start_line": 270,
    "end_line": 279,
    "has_docstring": true,
    "docstring": "Create empty cache structure with metadata.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_empty_cache",
    "component_id": "osculating_cache_manager.create_empty_cache"
  },
  "osculating_cache_manager.calculate_age_days": {
    "id": "osculating_cache_manager.calculate_age_days",
    "name": "calculate_age_days",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\osculating_cache_manager.py",
    "relative_path": "osculating_cache_manager.py",
    "depends_on": [],
    "source_code": "def calculate_age_days(cache_entry):\n    \"\"\"\n    Calculate age of cache entry in days.\n    \n    Parameters:\n        cache_entry (dict): Cache entry with metadata\n    \n    Returns:\n        int: Age in days, or None if can't determine\n    \"\"\"\n    try:\n        fetched_str = cache_entry['metadata']['fetched']\n        fetched = datetime.fromisoformat(fetched_str)\n        age = (datetime.now() - fetched).total_seconds() / 86400\n        return int(age)\n    except:\n        return None",
    "start_line": 285,
    "end_line": 301,
    "has_docstring": true,
    "docstring": "Calculate age of cache entry in days.\n\nParameters:\n    cache_entry (dict): Cache entry with metadata\n\nReturns:\n    int: Age in days, or None if can't determine",
    "parameters": [
      "cache_entry"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_age_days",
    "component_id": "osculating_cache_manager.calculate_age_days"
  },
  "osculating_cache_manager.check_cache_status": {
    "id": "osculating_cache_manager.check_cache_status",
    "name": "check_cache_status",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\osculating_cache_manager.py",
    "relative_path": "osculating_cache_manager.py",
    "depends_on": [
      "osculating_cache_manager.get_refresh_interval",
      "osculating_cache_manager.calculate_age_days",
      "osculating_cache_manager.get_cache_key",
      "osculating_cache_manager.load_cache"
    ],
    "source_code": "def check_cache_status(obj_name, center_body=None):\n    \"\"\"\n    Check cache status for an object.\n    \n    Parameters:\n        obj_name (str): Name of object\n    \n    Returns:\n        dict: Status information with keys:\n            - exists (bool)\n            - age_days (int or None)\n            - recommended_days (int)\n            - is_fresh (bool)\n            - status_text (str): \"[OK] Fresh\" or \"[WARN] Update recommended\" or \"Not in cache\"\n    \"\"\"\n\n    cache = load_cache()\n\n    cache_key = get_cache_key(obj_name, center_body)\n    \n    recommended_days = get_refresh_interval(obj_name)\n    \n    if cache_key not in cache or cache_key.startswith('_'):\n\n        return {\n            'exists': False,\n            'age_days': None,\n            'recommended_days': recommended_days,\n            'is_fresh': False,\n            'status_text': 'Not in cache'\n        }\n    \n#    age_days = calculate_age_days(cache[obj_name])\n    age_days = calculate_age_days(cache[cache_key])\n    \n    if age_days is None:\n        return {\n            'exists': True,\n            'age_days': None,\n            'recommended_days': recommended_days,\n            'is_fresh': False,\n            'status_text': 'Unknown age'\n        }\n    \n    is_fresh = age_days < recommended_days\n    status_text = \"[OK] Fresh\" if is_fresh else \"[WARN] Update recommended\"\n    \n    return {\n        'exists': True,\n        'age_days': age_days,\n        'recommended_days': recommended_days,\n        'is_fresh': is_fresh,\n        'status_text': status_text\n    }",
    "start_line": 304,
    "end_line": 357,
    "has_docstring": true,
    "docstring": "Check cache status for an object.\n\nParameters:\n    obj_name (str): Name of object\n\nReturns:\n    dict: Status information with keys:\n        - exists (bool)\n        - age_days (int or None)\n        - recommended_days (int)\n        - is_fresh (bool)\n        - status_text (str): \"[OK] Fresh\" or \"[WARN] Update recommended\" or \"Not in cache\"",
    "parameters": [
      "obj_name",
      "center_body"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function check_cache_status",
    "component_id": "osculating_cache_manager.check_cache_status"
  },
  "osculating_cache_manager.fetch_osculating_elements": {
    "id": "osculating_cache_manager.fetch_osculating_elements",
    "name": "fetch_osculating_elements",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\osculating_cache_manager.py",
    "relative_path": "osculating_cache_manager.py",
    "depends_on": [
      "osculating_cache_manager.get_refresh_interval",
      "orbit_data_manager.query_horizons_elements"
    ],
    "source_code": "def fetch_osculating_elements(obj_name, horizons_id=None, id_type='smallbody', date=None, center_body=None):\n    \"\"\"\n    Fetch osculating elements from JPL Horizons.\n    \n    Parameters:\n        obj_name (str): Display name of object (used for metadata and messages)\n        horizons_id (str, optional): Horizons ID to query (defaults to obj_name)\n                                     Examples: 'C/2025 N1', '199', '-23'\n        id_type (str): Horizons ID type - 'smallbody', 'majorbody', 'id', etc.\n                       Default: 'smallbody'\n        date (datetime, optional): Date for osculating elements (default: today)\n        center_body (str, optional): Override center body (e.g., '@9' for Pluto barycenter)\n                                     If None, auto-detects based on object ID.\n    \n    Returns:\n        dict: Cache entry with elements and metadata, or None if fetch fails\n        \n    Notes:\n        - obj_name is used for display and metadata (e.g., '3I/ATLAS')\n        - horizons_id is passed to JPL Horizons query (e.g., 'C/2025 N1')\n        - The actual Horizons ID used is stored in metadata['horizons_id']\n        - center_body enables fetching barycentric elements for binary systems\n    \"\"\"\n    if date is None:\n        date = datetime.now()\n    \n    date_str = date.strftime('%Y-%m-%d')\n    \n    # Determine which ID to use for querying\n    query_id = horizons_id if horizons_id else obj_name\n    \n    try:\n        # Import here to avoid circular dependency\n        from orbit_data_manager import query_horizons_elements\n        \n        print(f\"[...] Fetching osculating elements for {obj_name} from JPL Horizons...\", flush=True)\n        if horizons_id and horizons_id != obj_name:\n            print(f\"   Using Horizons ID: {query_id} (id_type: {id_type})\", flush=True)\n        \n        # Query JPL Horizons using proper ID and type\n    #    result = query_horizons_elements(query_id, id_type, date_str)\n        result = query_horizons_elements(query_id, id_type, date_str, center_body=center_body)\n        \n        # Package the result\n        cache_entry = {\n            'elements': {\n                'a': result['a'],\n                'e': result['e'],\n                'i': result['i'],\n                'omega': result['omega'],\n                'Omega': result['Omega'],\n                'epoch': f\"{date_str} osc.\",\n                'TP': result.get('TP'),\n                'MA': result.get('MA'),      # Mean anomaly at epoch (degrees)\n                'TA': result.get('TA'),      # True anomaly at epoch (degrees)\n            },\n\n            'metadata': {\n                'fetched': datetime.now().isoformat(),\n                'source': 'JPL Horizons',\n                'solution_date': result.get('solution_date', date_str),\n                'horizons_id': query_id,  # Store the actual ID we queried with\n                'display_name': obj_name,  # Store the display name separately\n                'refresh_interval_days': get_refresh_interval(obj_name),\n                'center_body': result.get('center_body', '@sun'),  # Store which center was used\n            }\n\n        }\n        \n        # Add optional metadata if available\n        if 'observations' in result:\n            cache_entry['metadata']['observations'] = result['observations']\n        if 'arc_days' in result:\n            cache_entry['metadata']['arc_days'] = result['arc_days']\n        \n        print(f\"[OK] Fetched elements (solution date: {cache_entry['metadata']['solution_date']})\", flush=True)\n        return cache_entry\n        \n    except Exception as e:\n        print(f\"[FAIL] Failed to fetch elements for {obj_name}: {e}\")\n        return None",
    "start_line": 364,
    "end_line": 444,
    "has_docstring": true,
    "docstring": "Fetch osculating elements from JPL Horizons.\n\nParameters:\n    obj_name (str): Display name of object (used for metadata and messages)\n    horizons_id (str, optional): Horizons ID to query (defaults to obj_name)\n                                 Examples: 'C/2025 N1', '199', '-23'\n    id_type (str): Horizons ID type - 'smallbody', 'majorbody', 'id', etc.\n                   Default: 'smallbody'\n    date (datetime, optional): Date for osculating elements (default: today)\n    center_body (str, optional): Override center body (e.g., '@9' for Pluto barycenter)\n                                 If None, auto-detects based on object ID.\n\nReturns:\n    dict: Cache entry with elements and metadata, or None if fetch fails\n    \nNotes:\n    - obj_name is used for display and metadata (e.g., '3I/ATLAS')\n    - horizons_id is passed to JPL Horizons query (e.g., 'C/2025 N1')\n    - The actual Horizons ID used is stored in metadata['horizons_id']\n    - center_body enables fetching barycentric elements for binary systems",
    "parameters": [
      "obj_name",
      "horizons_id",
      "id_type",
      "date",
      "center_body"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_osculating_elements",
    "component_id": "osculating_cache_manager.fetch_osculating_elements"
  },
  "osculating_cache_manager.format_age_string": {
    "id": "osculating_cache_manager.format_age_string",
    "name": "format_age_string",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\osculating_cache_manager.py",
    "relative_path": "osculating_cache_manager.py",
    "depends_on": [],
    "source_code": "def format_age_string(age_days):\n    \"\"\"\n    Format age in human-readable string.\n    \n    Parameters:\n        age_days (int): Age in days\n    \n    Returns:\n        str: Formatted string like \"2 days ago\" or \"3 weeks ago\"\n    \"\"\"\n    if age_days is None:\n        return \"Unknown\"\n    elif age_days == 0:\n        return \"Today\"\n    elif age_days == 1:\n        return \"1 day ago\"\n    elif age_days < 7:\n        return f\"{age_days} days ago\"\n    elif age_days < 30:\n        weeks = age_days // 7\n        return f\"{weeks} week{'s' if weeks > 1 else ''} ago\"\n    elif age_days < 365:\n        months = age_days // 30\n        return f\"{months} month{'s' if months > 1 else ''} ago\"\n    else:\n        years = age_days // 365\n        return f\"{years} year{'s' if years > 1 else ''} ago\"",
    "start_line": 450,
    "end_line": 476,
    "has_docstring": true,
    "docstring": "Format age in human-readable string.\n\nParameters:\n    age_days (int): Age in days\n\nReturns:\n    str: Formatted string like \"2 days ago\" or \"3 weeks ago\"",
    "parameters": [
      "age_days"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function format_age_string",
    "component_id": "osculating_cache_manager.format_age_string"
  },
  "osculating_cache_manager.format_interval_string": {
    "id": "osculating_cache_manager.format_interval_string",
    "name": "format_interval_string",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\osculating_cache_manager.py",
    "relative_path": "osculating_cache_manager.py",
    "depends_on": [],
    "source_code": "def format_interval_string(interval_days):\n    \"\"\"\n    Format refresh interval in human-readable string.\n    \n    Parameters:\n        interval_days (int): Interval in days\n    \n    Returns:\n        str: Formatted string like \"Daily (1 day)\" or \"Weekly (7 days)\"\n    \"\"\"\n    if interval_days == 1:\n        return \"Daily (1 day)\"\n    elif interval_days == 7:\n        return \"Weekly (7 days)\"\n    elif interval_days == 30:\n        return \"Monthly (30 days)\"\n    elif interval_days == 90:\n        return \"Quarterly (90 days)\"\n    else:\n        return f\"Every {interval_days} days\"",
    "start_line": 478,
    "end_line": 497,
    "has_docstring": true,
    "docstring": "Format refresh interval in human-readable string.\n\nParameters:\n    interval_days (int): Interval in days\n\nReturns:\n    str: Formatted string like \"Daily (1 day)\" or \"Weekly (7 days)\"",
    "parameters": [
      "interval_days"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function format_interval_string",
    "component_id": "osculating_cache_manager.format_interval_string"
  },
  "osculating_cache_manager.get_elements_with_prompt": {
    "id": "osculating_cache_manager.get_elements_with_prompt",
    "name": "get_elements_with_prompt",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\osculating_cache_manager.py",
    "relative_path": "osculating_cache_manager.py",
    "depends_on": [
      "osculating_cache_manager.get_cache_key",
      "osculating_cache_manager.format_interval_string",
      "osculating_cache_manager.format_age_string",
      "osculating_cache_manager.get_fallback_elements",
      "osculating_cache_manager.check_cache_status",
      "osculating_cache_manager.fetch_osculating_elements",
      "osculating_cache_manager.load_cache",
      "osculating_cache_manager.save_cache"
    ],
    "source_code": "def get_elements_with_prompt(obj_name, horizons_id=None, id_type='smallbody', plot_date=None, parent_window=None, center_body=None):\n    \"\"\"\n    Get orbital elements with user prompt - ALWAYS prompts with information.\n    \n    This is the main user-facing function. It ALWAYS shows a dialog with:\n    - Age of cached elements (if available)\n    - Recommended refresh frequency\n    - Status (fresh or needs update)\n    \n    User decides whether to update based on visible information.\n    \n    Philosophy: \"System provides information, user makes decision\"\n    (Not: \"System decides for you based on hidden threshold\")\n    \n    Parameters:\n        obj_name (str): Display name of object (used for caching and UI)\n        horizons_id (str, optional): Horizons ID to query (defaults to obj_name)\n                                     Examples: 'C/2025 N1', '199', '-23'\n        id_type (str): Horizons ID type - 'smallbody', 'majorbody', 'id', etc.\n                       Default: 'smallbody'\n        parent_window (tk.Tk, optional): Parent window for dialog\n    \n    Returns:\n        dict: Orbital elements (from cache, fresh fetch, or fallback)\n    \n    Raises:\n        ValueError: If no elements available anywhere\n        \n    Notes:\n        - obj_name is used for cache keys and display (e.g., '3I/ATLAS')\n        - horizons_id is used for JPL Horizons queries (e.g., 'C/2025 N1')\n        - This separation prevents ambiguous queries to Horizons\n    \"\"\"\n    \n    # Check cache status\n#    status = check_cache_status(obj_name)\n    \n    # Check cache status (center-body aware)\n    cache_key = get_cache_key(obj_name, center_body)\n    status = check_cache_status(obj_name, center_body)\n\n    # Build dialog message\n    if status['exists']:\n        age_str = format_age_string(status['age_days'])\n        dialog_msg = f\"{obj_name} orbital elements:\\n\"\n        dialog_msg += f\"  Last updated: {age_str}\\n\"\n        dialog_msg += f\"  Recommended frequency: {format_interval_string(status['recommended_days'])}\\n\"\n        dialog_msg += f\"  Status: {status['status_text']}\\n\\n\"\n        \n        if status['is_fresh']:\n            dialog_msg += \"Update anyway?\"\n        else:\n            dialog_msg += \"Update from JPL Horizons?\"\n    else:\n        dialog_msg = f\"{obj_name} orbital elements:\\n\"\n        dialog_msg += f\"  Status: Not in cache\\n\"\n        dialog_msg += f\"  Recommended frequency: {format_interval_string(status['recommended_days'])}\\n\\n\"\n        dialog_msg += \"Fetch from JPL Horizons?\\n\"\n        dialog_msg += \"(Will use manual dictionary if declined)\"\n    \n    # Show modal dialog - user decides\n    response = messagebox.askyesno(\n        \"Update Orbital Elements?\",\n        dialog_msg,\n        parent=parent_window\n    )\n    \n    if response:  # User clicked YES\n        print(f\"User chose to update {obj_name}\")\n        \n        # Debug: Show what ID we're actually querying\n        query_id = horizons_id if horizons_id else obj_name\n        if horizons_id and horizons_id != obj_name:\n            print(f\"  Using Horizons ID: {query_id} (id_type: {id_type})\", flush=True)\n\n        # Fetch fresh elements\n\n        # Pass horizons_id for query, but obj_name for metadata/display\n#        fresh_entry = fetch_osculating_elements(\n#            obj_name, \n#            horizons_id=horizons_id, \n#            id_type=id_type,\n#            date=plot_date\n#        )        \n        \n        fresh_entry = fetch_osculating_elements(\n            obj_name, \n            horizons_id=horizons_id, \n            id_type=id_type,\n            date=plot_date,\n            center_body=center_body\n        )\n\n        if fresh_entry:\n    #        # Update cache\n    #        cache = load_cache()\n    #        cache[obj_name] = fresh_entry\n    #        save_cache(cache)\n\n            # Update cache with center-aware key\n            cache = load_cache()\n            cache[cache_key] = fresh_entry\n            save_cache(cache)\n\n            return fresh_entry['elements']\n        else:\n            # Fetch failed - fall back\n            print(f\"[WARN] Fetch failed - falling back to cached/manual elements\")\n            return get_fallback_elements(obj_name)\n        \n    else:  # User clicked NO\n        print(f\"User chose to use existing elements for {obj_name}\")\n        return get_fallback_elements(obj_name)",
    "start_line": 500,
    "end_line": 612,
    "has_docstring": true,
    "docstring": "Get orbital elements with user prompt - ALWAYS prompts with information.\n\nThis is the main user-facing function. It ALWAYS shows a dialog with:\n- Age of cached elements (if available)\n- Recommended refresh frequency\n- Status (fresh or needs update)\n\nUser decides whether to update based on visible information.\n\nPhilosophy: \"System provides information, user makes decision\"\n(Not: \"System decides for you based on hidden threshold\")\n\nParameters:\n    obj_name (str): Display name of object (used for caching and UI)\n    horizons_id (str, optional): Horizons ID to query (defaults to obj_name)\n                                 Examples: 'C/2025 N1', '199', '-23'\n    id_type (str): Horizons ID type - 'smallbody', 'majorbody', 'id', etc.\n                   Default: 'smallbody'\n    parent_window (tk.Tk, optional): Parent window for dialog\n\nReturns:\n    dict: Orbital elements (from cache, fresh fetch, or fallback)\n\nRaises:\n    ValueError: If no elements available anywhere\n    \nNotes:\n    - obj_name is used for cache keys and display (e.g., '3I/ATLAS')\n    - horizons_id is used for JPL Horizons queries (e.g., 'C/2025 N1')\n    - This separation prevents ambiguous queries to Horizons",
    "parameters": [
      "obj_name",
      "horizons_id",
      "id_type",
      "plot_date",
      "parent_window",
      "center_body"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_elements_with_prompt",
    "component_id": "osculating_cache_manager.get_elements_with_prompt"
  },
  "osculating_cache_manager.get_fallback_elements": {
    "id": "osculating_cache_manager.get_fallback_elements",
    "name": "get_fallback_elements",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\osculating_cache_manager.py",
    "relative_path": "osculating_cache_manager.py",
    "depends_on": [
      "osculating_cache_manager.calculate_age_days",
      "osculating_cache_manager.format_age_string",
      "osculating_cache_manager.load_cache"
    ],
    "source_code": "def get_fallback_elements(obj_name):\n    \"\"\"\n    Get elements from cache or manual dictionary (fallback).\n    \n    Parameters:\n        obj_name (str): Name of object\n    \n    Returns:\n        dict: Orbital elements\n    \n    Raises:\n        ValueError: If no elements available\n    \"\"\"\n    # Try cache first\n    cache = load_cache()\n    if obj_name in cache and not obj_name.startswith('_'):\n        age = calculate_age_days(cache[obj_name])\n        age_str = format_age_string(age) if age else \"unknown age\"\n        print(f\"[OK] Using cached elements ({age_str})\")\n        return cache[obj_name]['elements']\n    \n    # Try manual dictionary\n    if obj_name in FALLBACK_ELEMENTS:\n        print(f\"[WARN] Using manual dictionary backup for {obj_name}\")\n        return FALLBACK_ELEMENTS[obj_name]\n    \n    # Nothing available\n    raise ValueError(\n        f\"No orbital elements available for {obj_name}\\n\"\n        f\"Not in cache, fetch failed, and not in manual dictionary.\\n\"\n        f\"Try adding to idealized_orbits.py or check network connection.\"\n    )",
    "start_line": 614,
    "end_line": 645,
    "has_docstring": true,
    "docstring": "Get elements from cache or manual dictionary (fallback).\n\nParameters:\n    obj_name (str): Name of object\n\nReturns:\n    dict: Orbital elements\n\nRaises:\n    ValueError: If no elements available",
    "parameters": [
      "obj_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_fallback_elements",
    "component_id": "osculating_cache_manager.get_fallback_elements"
  },
  "osculating_cache_manager.format_for_python_dict": {
    "id": "osculating_cache_manager.format_for_python_dict",
    "name": "format_for_python_dict",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\osculating_cache_manager.py",
    "relative_path": "osculating_cache_manager.py",
    "depends_on": [],
    "source_code": "def format_for_python_dict(obj_name, elements):\n    \"\"\"\n    Format elements as Python dictionary string for easy copying.\n    \n    Useful for copying cache entries to idealized_orbits.py manually.\n    \n    Parameters:\n        obj_name (str): Name of object\n        elements (dict): Orbital elements\n    \n    Returns:\n        str: Formatted Python dictionary string\n    \"\"\"\n    lines = [f\"'{obj_name}': {{\"]\n    \n    for key in ['a', 'e', 'i', 'omega', 'Omega', 'epoch', 'TP']:\n        if key in elements:\n            value = elements[key]\n            if isinstance(value, str):\n                lines.append(f\"    '{key}': '{value}',\")\n            else:\n                lines.append(f\"    '{key}': {value},\")\n    \n    lines.append(\"},\")\n    \n    return \"\\n\".join(lines)",
    "start_line": 651,
    "end_line": 676,
    "has_docstring": true,
    "docstring": "Format elements as Python dictionary string for easy copying.\n\nUseful for copying cache entries to idealized_orbits.py manually.\n\nParameters:\n    obj_name (str): Name of object\n    elements (dict): Orbital elements\n\nReturns:\n    str: Formatted Python dictionary string",
    "parameters": [
      "obj_name",
      "elements"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function format_for_python_dict",
    "component_id": "osculating_cache_manager.format_for_python_dict"
  },
  "paleoclimate_dual_scale.load_modern_temperature_data_ma_bp": {
    "id": "paleoclimate_dual_scale.load_modern_temperature_data_ma_bp",
    "name": "load_modern_temperature_data_ma_bp",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_dual_scale.py",
    "relative_path": "paleoclimate_dual_scale.py",
    "depends_on": [],
    "source_code": "def load_modern_temperature_data_ma_bp():\n    \"\"\"\n    Load modern instrumental temperature data using Ma BP (Before Present = 2025)\n    \n    This is a wrapper that converts the Ma B2100 data from the main module\n    to Ma BP for consistency with the paleoclimate data in the dual-scale viz.\n    \"\"\"\n    try:\n        import json\n        import os\n        \n        # Try multiple possible locations for the temperature file\n    #    possible_paths = [\n    #        'temperature_giss_monthly.json',  # Same directory\n    #        os.path.join(os.path.dirname(__file__), 'temperature_giss_monthly.json'),  # Script directory\n    #        '/mnt/project/temperature_giss_monthly.json'  # Fallback for testing\n    #    ]\n        \n        # Try multiple possible locations for the temperature file\n        possible_paths = [\n            'data/temperature_giss_monthly.json',  # Data subdirectory (primary location)\n            os.path.join(os.path.dirname(__file__), 'data/temperature_giss_monthly.json'),  # Script dir + data/\n            'temperature_giss_monthly.json',  # Legacy root location (backwards compatibility)\n            os.path.join(os.path.dirname(__file__), 'temperature_giss_monthly.json'),\n            '/mnt/project/temperature_giss_monthly.json'  # Fallback for testing\n        ]\n\n        data = None\n        for path in possible_paths:\n            try:\n                with open(path, 'r') as f:\n                    data = json.load(f)\n                break\n            except FileNotFoundError:\n                continue\n        \n        if data is None:\n            print(\"Warning: Could not find temperature_giss_monthly.json\")\n            return None, None\n        \n        records = data['data']\n        \n        # Convert to arrays and get annual averages\n        years = []\n        temps = []\n        \n        for record in records:\n            year = record['year']\n            \n            if year not in years:\n                years.append(year)\n                # Get all months for this year that have valid data\n                year_temps = [r['anomaly_c'] for r in records \n                             if r['year'] == year and r['anomaly_c'] is not None]\n                if year_temps:\n                    temps.append(np.mean(year_temps))\n                else:\n                    # Skip years with no valid data\n                    years.pop()\n        \n        # Convert years to Ma BP (millions of years before present = 2025)\n        # Present = 2025, so years before present = 2025 - year\n        current_year = 2025\n        ages_ma = [(current_year - y) / 1_000_000 for y in years]\n        \n        return ages_ma, temps\n        \n    except (FileNotFoundError, json.JSONDecodeError) as e:\n        print(f\"Warning: Could not load modern temperature data: {e}\")\n        return None, None",
    "start_line": 65,
    "end_line": 134,
    "has_docstring": true,
    "docstring": "Load modern instrumental temperature data using Ma BP (Before Present = 2025)\n\nThis is a wrapper that converts the Ma B2100 data from the main module\nto Ma BP for consistency with the paleoclimate data in the dual-scale viz.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_modern_temperature_data_ma_bp",
    "component_id": "paleoclimate_dual_scale.load_modern_temperature_data_ma_bp"
  },
  "paleoclimate_dual_scale.load_projection_scenarios": {
    "id": "paleoclimate_dual_scale.load_projection_scenarios",
    "name": "load_projection_scenarios",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_dual_scale.py",
    "relative_path": "paleoclimate_dual_scale.py",
    "depends_on": [],
    "source_code": "def load_projection_scenarios():\n    \"\"\"\n    Load future climate projection scenarios\n    \n    SSP scenarios based on:\n    IPCC AR6 Working Group I, Chapter 4, Table 4.2 - Global mean surface air \n    temperature anomalies ( degC) relative to 1850-1900 baseline.\n    \n    Data source: Lee, J.-Y., J. Marotzke, et al. (2021): Future Global Climate: \n    Scenario-based Projections and Near-term Information. In Climate Change 2021: \n    The Physical Science Basis. Contribution of Working Group I to the Sixth \n    Assessment Report of the Intergovernmental Panel on Climate Change.\n    \n    Shared Socioeconomic Pathways (SSPs) represent different future climate \n    scenarios based on varying levels of greenhouse gas emissions and mitigation \n    efforts.\n    \n    Returns:\n        list of dicts: Each dict contains 'name', 'years', 'temps', 'color', 'dash', 'width', 'description'\n    \"\"\"\n    \n    # IPCC AR6 Table 4.2 data points (Global, relative to 1850-1900)\n    # Three key periods: 2021-2040, 2041-2060, 2081-2100\n    \n    # Use period END points for plotting (more accurate representation)\n    ipcc_years = [2040, 2060, 2100]  # End years of the three IPCC periods\n    \n    scenarios = [\n        {\n            'name': 'SSP1-1.9 (IPCC AR6 WG1)',\n            'ipcc_temps': [1.5, 1.7, 1.5],  # IPCC Table 4.2 values\n            'color': '#1976D2',  # Blue - most ambitious\n            'dash': 'solid',\n            'width': 2.5,\n            'description': '1.9 W/m2: Very low emissions, net-zero by 2050, limit to 1.5C',\n            'ssp_label': 'SSP1-1.9 (1.9 W/m2)'\n        },\n        {\n            'name': 'SSP1-2.6 (IPCC AR6 WG1)',\n            'ipcc_temps': [1.6, 1.9, 2.0],  # IPCC Table 4.2 values\n            'color': '#4CAF50',  # Green - Paris Agreement target\n            'dash': 'solid',\n            'width': 2.5,\n            'description': '2.6 W/m2: Low emissions, Paris Agreement, well below 2C',\n            'ssp_label': 'SSP1-2.6 (2.6 W/m2)'\n        },\n        {\n            'name': 'SSP2-4.5 (IPCC AR6 WG1)',\n            'ipcc_temps': [1.6, 2.1, 2.9],  # IPCC Table 4.2 values\n            'color': '#FFA726',  # Orange - intermediate\n            'dash': 'solid',\n            'width': 2.5,\n            'description': '4.5 W/m2: Intermediate emissions, middle-of-the-road',\n            'ssp_label': 'SSP2-4.5 (4.5 W/m2)'\n        },\n        {\n            'name': 'SSP3-7.0 (IPCC AR6 WG1)',\n            'ipcc_temps': [1.6, 2.3, 3.9],  # IPCC Table 4.2 values\n            'color': '#EF5350',  # Red-orange - high emissions\n            'dash': 'solid',\n            'width': 2.5,\n            'description': '7.0 W/m2: High emissions, regional rivalry, continued warming',\n            'ssp_label': 'SSP3-7.0 (7.0 W/m2)'\n        },\n        {\n            'name': 'SSP5-8.5 (IPCC AR6 WG1)',\n            'ipcc_temps': [1.7, 2.6, 4.8],  # IPCC Table 4.2 values\n            'color': '#B71C1C',  # Dark red - fossil fuel intensive\n            'dash': 'solid',\n            'width': 2.5,\n            'description': '8.5 W/m2: Very high emissions, fossil-fuel intensive development',\n            'ssp_label': 'SSP5-8.5 (8.5 W/m2)'\n        }\n    ]\n    \n    # Interpolate to create smooth curves from current (2025) through the IPCC periods\n    import numpy as np\n    \n    for scenario in scenarios:\n        # Start from current conditions (approximately 1.2 degC in 2025)\n        # Then use IPCC values at period endpoints: 2040, 2060, 2100\n        extended_years = [2025] + ipcc_years\n        extended_temps = [1.2] + scenario['ipcc_temps']\n        \n        # Create smooth interpolation - stop at 2100 (no flattening beyond)\n        years_fine = np.linspace(2025, 2100, 50)\n        temps_fine = np.interp(years_fine, extended_years, extended_temps)\n        \n        scenario['years'] = years_fine.tolist()\n        scenario['temps'] = temps_fine.tolist()\n        \n        # Remove the raw IPCC temps (no longer needed)\n        del scenario['ipcc_temps']\n    \n    return scenarios",
    "start_line": 137,
    "end_line": 231,
    "has_docstring": true,
    "docstring": "Load future climate projection scenarios\n\nSSP scenarios based on:\nIPCC AR6 Working Group I, Chapter 4, Table 4.2 - Global mean surface air \ntemperature anomalies ( degC) relative to 1850-1900 baseline.\n\nData source: Lee, J.-Y., J. Marotzke, et al. (2021): Future Global Climate: \nScenario-based Projections and Near-term Information. In Climate Change 2021: \nThe Physical Science Basis. Contribution of Working Group I to the Sixth \nAssessment Report of the Intergovernmental Panel on Climate Change.\n\nShared Socioeconomic Pathways (SSPs) represent different future climate \nscenarios based on varying levels of greenhouse gas emissions and mitigation \nefforts.\n\nReturns:\n    list of dicts: Each dict contains 'name', 'years', 'temps', 'color', 'dash', 'width', 'description'",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_projection_scenarios",
    "component_id": "paleoclimate_dual_scale.load_projection_scenarios"
  },
  "paleoclimate_dual_scale.load_cat_policies_and_action": {
    "id": "paleoclimate_dual_scale.load_cat_policies_and_action",
    "name": "load_cat_policies_and_action",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_dual_scale.py",
    "relative_path": "paleoclimate_dual_scale.py",
    "depends_on": [],
    "source_code": "def load_cat_policies_and_action():\n    \"\"\"\n    Load Climate Action Tracker \"Policies and Action\" temperature range\n    \n    Data source: Climate Action Tracker (2024). \"Global Temperature Estimates - COP29\". \n    Published November 13, 2024. https://climateactiontracker.org/global/temperatures/\n    \n    This represents the projected warming based on currently implemented policies and actions,\n    showing the high and low estimates for this scenario.\n    \n    Returns:\n        dict: Contains 'years', 'high', 'low' arrays for the temperature range\n    \"\"\"\n    # CAT Policies and Action data from November 2024 update\n    # Temperature projections relative to pre-industrial (approximated as 1850-1900)\n    cat_data = {\n        'years': [2030, 2040, 2050, 2060, 2070, 2080, 2090, 2100],\n        'high': [1.47, 1.72, 1.94, 2.14, 2.34, 2.54, 2.73, 2.90],  # Rounded for display\n        'low': [1.47, 1.69, 1.88, 2.03, 2.17, 2.31, 2.42, 2.52],   # Rounded for display\n    }\n    \n    return cat_data",
    "start_line": 234,
    "end_line": 255,
    "has_docstring": true,
    "docstring": "Load Climate Action Tracker \"Policies and Action\" temperature range\n\nData source: Climate Action Tracker (2024). \"Global Temperature Estimates - COP29\". \nPublished November 13, 2024. https://climateactiontracker.org/global/temperatures/\n\nThis represents the projected warming based on currently implemented policies and actions,\nshowing the high and low estimates for this scenario.\n\nReturns:\n    dict: Contains 'years', 'high', 'low' arrays for the temperature range",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_cat_policies_and_action",
    "component_id": "paleoclimate_dual_scale.load_cat_policies_and_action"
  },
  "paleoclimate_dual_scale.create_paleoclimate_dual_scale_visualization": {
    "id": "paleoclimate_dual_scale.create_paleoclimate_dual_scale_visualization",
    "name": "create_paleoclimate_dual_scale_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_dual_scale.py",
    "relative_path": "paleoclimate_dual_scale.py",
    "depends_on": [
      "paleoclimate_dual_scale.load_modern_temperature_data_ma_bp",
      "paleoclimate_wet_bulb_full.calculate_preindustrial_offset",
      "paleoclimate_wet_bulb_full.load_lr04_data",
      "paleoclimate_wet_bulb_full.d18o_to_temperature_approx",
      "paleoclimate_wet_bulb_full.load_holocene_data",
      "paleoclimate_dual_scale.load_projection_scenarios"
    ],
    "source_code": "def create_paleoclimate_dual_scale_visualization():\n    \"\"\"\n    Create dual-scale paleoclimate visualization with side-by-side layout\n    \n    LEFT PLOT (70% width): Deep time with logarithmic scale (4.5 Ga to 1850 CE)\n    RIGHT PLOT (30% width): Modern era with linear scale (1850 CE to 2100 CE)\n    \n    Both plots share the same y-axis (temperature anomaly) allowing for\n    visual connections and cross-plot annotations.\n    \"\"\"\n    \n    if not PLOTLY_AVAILABLE:\n        print(\"Error: Plotly not available\")\n        return None\n    \n    # Load all data\n    lr04_data = load_lr04_data()\n    if not lr04_data:\n        print(\"Error: Could not load LR04 data\")\n        return None\n    \n    holocene_data = load_holocene_data()\n    modern_ages_ma, modern_temps = load_modern_temperature_data_ma_bp()  # Use Ma BP version\n    \n    # Debug: Check if GISS data loaded\n    if modern_ages_ma is None or modern_temps is None:\n        print(\"WARNING: GISS data did not load!\")\n    else:\n        modern_years = [2025 - (age * 1_000_000) for age in modern_ages_ma]\n        print(f\"GISS data loaded: {len(modern_ages_ma)} points from {min(modern_years):.0f} to {max(modern_years):.0f}\")\n    \n    preindustrial_offset = calculate_preindustrial_offset(holocene_data) if holocene_data else 0.0\n    \n    # Process LR04 paleoclimate data\n    records = lr04_data['data']\n    ages_ka = np.array([r['age_ka_bp'] for r in records])\n    d18o_values = np.array([r['d18o_permil'] for r in records])\n    ages_ma = ages_ka / 1000.0\n    temp_anomaly = d18o_to_temperature_approx(d18o_values)\n    temp_anomaly = temp_anomaly - preindustrial_offset\n    \n    # DECISION: Define the transition point (where log becomes linear)\n    TRANSITION_YEAR = 1850  # CE\n    TRANSITION_MA = 0.00025  # Ma BP (250 years before 2025)\n    \n    # Create side-by-side subplots\n    fig = make_subplots(\n        rows=1, cols=2,\n        column_widths=[0.68, 0.32],  # 68% deep time, 32% modern\n        horizontal_spacing=0.02,      # Small gap for visual separation\n        subplot_titles=(\n            \"Deep Time: Earth's Climate History\",\n            \"Modern Era & Projections\"\n        ),\n        specs=[[{\"type\": \"scatter\"}, {\"type\": \"scatter\"}]]\n    )\n    \n    # ============================================================\n    # LEFT PLOT: DEEP TIME (Logarithmic scale, 4.5 Ga to 1850 CE)\n    # ============================================================\n    \n    # Filter paleoclimate data to end at 1850 CE\n    deep_time_mask = ages_ma >= TRANSITION_MA\n    deep_time_ages = ages_ma[deep_time_mask]\n    deep_time_temps = temp_anomaly[deep_time_mask]\n    \n    # Add paleoclimate trace to left plot\n    fig.add_trace(\n        go.Scatter(\n            x=deep_time_ages,\n            y=deep_time_temps,\n            mode='lines',\n            name='Paleoclimate (LR04)',\n            line=dict(color='#2E86AB', width=1.5),\n            hovertemplate='<b>%{x:.3f} Ma</b><br>Temp: %{y:.2f} degC<extra></extra>',\n            showlegend=True\n        ),\n        row=1, col=1\n    )\n    \n    # Add Holocene data to left plot if available\n    if holocene_data:\n        holocene_ages = np.array(holocene_data['ages_ma'])\n        holocene_temps = np.array(holocene_data['temp_median']) - preindustrial_offset\n        \n        # Filter to show only pre-1850 Holocene data in left plot\n        holocene_deep_mask = holocene_ages >= TRANSITION_MA\n        \n        fig.add_trace(\n            go.Scatter(\n                x=holocene_ages[holocene_deep_mask],\n                y=holocene_temps[holocene_deep_mask],\n                mode='lines',\n                name='Holocene (Kaufman 2020)',\n                line=dict(color='#A06CD5', width=2),\n                hovertemplate='<b>%{x:.6f} Ma</b><br>Temp: %{y:.2f} degC<extra></extra>',\n                showlegend=True\n            ),\n            row=1, col=1\n        )\n    \n    # Add geologic period shading to left plot\n    for period in GEOLOGIC_PERIODS:\n        if period['start'] >= TRANSITION_MA:  # Only show periods in deep time\n            fig.add_vrect(\n                x0=period['start'],\n                x1=max(period['end'], TRANSITION_MA),  # Stop at transition\n                fillcolor=period['color'],\n                opacity=0.15,\n                layer=\"below\",\n                line_width=0,\n                row=1, col=1\n            )\n    \n    # Configure left plot x-axis (logarithmic)\n    fig.update_xaxes(\n        title_text=\"Millions of Years Before Present\",\n        type=\"log\",\n        autorange=False,\n        range=[np.log10(4500), np.log10(0.000001)],  # Extended to present (near-zero on log scale)\n        showgrid=True,\n        gridwidth=1,\n        gridcolor='lightgray',\n        row=1, col=1\n    )\n    \n    # Add GISS instrumental data to left plot (extends to present)\n    # This helps users see the equivalence between the two plots\n    if modern_ages_ma is not None and modern_temps is not None:\n        fig.add_trace(\n            go.Scatter(\n                x=modern_ages_ma,\n                y=modern_temps,\n                mode='lines',\n                name='Instrumental (NASA GISS)',\n                line=dict(color='#D32F2F', width=2.5),\n                hovertemplate='<b>%{x:.9f} Ma</b><br>Temp: %{y:.2f} degC<extra></extra>',\n                showlegend=True\n            ),\n            row=1, col=1\n        )\n\n    \n    # ============================================================\n    # RIGHT PLOT: MODERN ERA (Linear scale, 1850 CE to 2100 CE)\n    # ============================================================\n    \n    # Convert modern data from Ma to calendar years\n    if modern_ages_ma is not None and modern_temps is not None:\n        # Filter modern data (post-1850)\n        modern_mask = np.array(modern_ages_ma) < TRANSITION_MA\n        modern_years = [2025 - (age * 1_000_000) for age in np.array(modern_ages_ma)[modern_mask]]\n        modern_temps_filtered = np.array(modern_temps)[modern_mask]\n        \n        # Adjust modern temps to match our baseline\n        modern_temps_adjusted = modern_temps_filtered\n        \n        print(f\"Adding GISS to RIGHT plot: {len(modern_years)} points from {min(modern_years):.0f} to {max(modern_years):.0f}\")\n        \n        fig.add_trace(\n            go.Scatter(\n                x=modern_years,\n                y=modern_temps_adjusted,\n                mode='lines',\n                name='Instrumental (NASA GISS)',\n                line=dict(color='#D32F2F', width=2.5),\n                hovertemplate='<b>Year %{x}</b><br>Temp: %{y:.2f} degC<extra></extra>',\n                showlegend=False  # Hide from legend (already shown in left plot)\n            ),\n            row=1, col=2\n        )\n    \n    \"\"\"\n    # Add Holocene data to right plot (post-1850)\n    if holocene_data:\n        holocene_modern_mask = holocene_ages < TRANSITION_MA\n        holocene_modern_years = [2025 - (age * 1_000_000) for age in holocene_ages[holocene_modern_mask]]\n        holocene_modern_temps = holocene_temps[holocene_modern_mask]\n        \n        fig.add_trace(\n            go.Scatter(\n                x=holocene_modern_years,\n                y=holocene_modern_temps,\n                mode='lines',\n                name='Holocene (Kaufman 2020)',  # Same name as left plot\n                line=dict(color='#A06CD5', width=2),\n                hovertemplate='<b>Year %{x}</b><br>Temp: %{y:.2f} degC<extra></extra>',\n                showlegend=False  # Hide from legend (already shown in left plot)\n            ),\n            row=1, col=2\n        )\n    \"\"\"\n    \n    # Configure right plot x-axis (linear)\n    fig.update_xaxes(\n        title_text=\"Year (CE)\",\n        type=\"linear\",\n        autorange=False,\n        range=[1850, 2100],\n        showgrid=True,\n        gridwidth=1,\n        gridcolor='lightgray',\n        row=1, col=2\n    )\n    \n    # ============================================================\n    # ADD PROJECTION SCENARIOS TO RIGHT PLOT\n    # ============================================================\n    \n    projection_scenarios = load_projection_scenarios()\n    \n    # Plot all SSP scenario lines (clean IPCC AR6 Table 4.2 data)\n    for scenario in projection_scenarios:\n        fig.add_trace(\n            go.Scatter(\n                x=scenario['years'],\n                y=scenario['temps'],\n                mode='lines+markers',\n                name=scenario['name'],\n                line=dict(\n                    color=scenario['color'],\n                    width=scenario['width'],\n                    dash=scenario['dash']\n                ),\n                marker=dict(size=6, symbol='circle'),\n                hovertemplate=(\n                    f\"<b>{scenario['ssp_label']}</b><br>\" +\n                    \"Year: %{x}<br>\" +\n                    \"Temp: %{y:.2f}C<br>\" +\n                    f\"{scenario['description']}<extra></extra>\"\n                ),\n                showlegend=True\n            ),\n            row=1, col=2\n        )\n\n    \n    # ============================================================\n    # ADD CAT \"POLICIES AND ACTION\" RANGE\n    # ============================================================\n    \n#    cat_data = load_cat_policies_and_action()\n    \n    # Add upper boundary (high estimate) - invisible line\n#    fig.add_trace(\n#        go.Scatter(\n#            x=cat_data['years'],\n#            y=cat_data['high'],\n#            mode='lines',\n#            line=dict(width=0),\n#            showlegend=False,\n#            hoverinfo='skip'\n#        ),\n#        row=1, col=2\n#    )\n    \n    # Add lower boundary (low estimate) with fill to create shaded band\n#    fig.add_trace(\n#        go.Scatter(\n#            x=cat_data['years'],\n#            y=cat_data['low'],\n#            mode='lines',\n#            name='Policies & Action (CAT)',\n#            line=dict(width=0),\n#            fill='tonexty',  # Fill to previous trace (the high estimate)\n#            fillcolor='rgba(128, 128, 128, 0.25)',  # Semi-transparent gray\n#            hovertemplate=(\n#                \"<b>Policies & Action (CAT)</b><br>\" +\n#                \"Year: %{x}<br>\" +\n#                \"Range: Current policies already implemented<br>\" +\n#                \"Climate Action Tracker (Nov 2024)<extra></extra>\"\n#            ),\n#            showlegend=True\n#        ),\n#        row=1, col=2\n#    )\n\n    \n    # ============================================================\n    # SHARED Y-AXIS CONFIGURATION\n    # ============================================================\n    \n    # Both plots use same y-axis for temperature\n    fig.update_yaxes(\n        title_text=\"Temperature Anomaly ( degC, relative to 1850-1900)\",\n        showgrid=True,\n        gridwidth=1,\n        gridcolor='lightgray',\n        row=1, col=1\n    )\n        \n    # ============================================================\n    # CROSS-PLOT ANNOTATIONS AND CONNECTIONS\n    # ============================================================\n    \n    # Calculate where the boundary is in paper coordinates\n    # Left plot goes from x=0 to x=0.68, right plot from x=0.70 to x=1.0\n    boundary_x = 0.67  # Position of the transition line as the baseline\n    \n    # Vertical line at 1850 CE boundary (spans both plots)\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"paper\",\n        x0=boundary_x,\n        y0=0.12,  # Just above x-axis\n        x1=boundary_x,\n        y1=0.75,  # Just below title\n        line=dict(\n    #        color=\"rgba(0, 150, 0, 0.4)\",\n            color=\"rgba(0, 0, 0, 1.0)\",\n            width=1,\n            dash=\"dash\"\n        )\n    )\n        \n    # Add baseline threshold line for left graph\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.20,\n        y0=0.0,\n        x1=0.67,\n        y1=0.0,\n        line=dict(\n            color=\"black\",\n            width=2,\n            dash=\"dot\"\n        )\n    )\n    \n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.57,\n        y=-0.50,\n        text=\"Baseline (1850-1900)\",\n        showarrow=False,\n        bgcolor=\"rgba(0,0,0,0)\",\n        font=dict(size=9, color='black'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n\n    # Add baseline threshold line for right graph\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.67,\n        y0=-7.40,\n        x1=1.00,\n        y1=-7.40,\n        line=dict(\n            color=\"black\",\n            width=2,\n            dash=\"dot\"\n        )\n    )\n    \n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.70,\n        y=-7.30,\n        text=\"Baseline (1850-1900)\",\n        showarrow=False,\n        bgcolor=\"rgba(0,0,0,0)\",\n        font=dict(size=9, color='black'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n\n    # Add 3.3 degC peak 90% chance - left plot\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.20,\n        y0=3.3,\n        x1=0.67,\n        y1=3.3,\n        line=dict(\n            color=\"black\",\n            width=1,\n            dash=\"dot\"\n        )\n    )\n    \n    # Add 2.8 degC peak 66% chance - left plot\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.20,\n        y0=2.8,\n        x1=0.67,\n        y1=2.8,\n        line=dict(\n            color=\"black\",\n            width=1,\n            dash=\"dot\"\n        )\n    )\n\n    # Add 2.6 degC peak 50% chance - left plot\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.2,\n        y0=2.6,\n        x1=0.67,\n        y1=2.6,\n        line=dict(\n            color=\"black\",\n            width=1,\n            dash=\"dot\"\n        )\n    )    \n\n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.25,\n        y=2.85,\n        text=\"Current policies continuing: peak warming over the 21st century, 2.6 degC (50%), 2.8 degC (66%), 3.3 degC (90%)\",\n        showarrow=False,\n        bgcolor=\"rgba(255,255,255,0)\",\n        font=dict(size=9, color='black'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n\n    # Add 1.28 degC today - left plot\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.20,\n        y0=1.28,\n        x1=0.67,\n        y1=1.28,\n        line=dict(\n            color=\"green\",\n            width=2,\n            dash=\"dot\"\n        )\n    )\n    \n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.50,\n        y=0.90,\n        text=\"1.28 degC Current Anomaly\",\n        showarrow=False,\n        bgcolor=\"rgba(255,255,255,0)\",\n        font=dict(size=9, color='green'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n\n    # Add 1.28 degC today - right plot\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.68,\n        y0=-4.75,\n        x1=1.00,\n        y1=-4.75,\n        line=dict(\n            color=\"green\",\n            width=2,\n            dash=\"dot\"\n        )\n    )\n    \n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.80,\n        y=-5.20,\n        text=\"1.28 degC Current Anomaly\",\n        showarrow=False,\n        bgcolor=\"rgba(255,255,255,0.8)\",\n        font=dict(size=9, color='green'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n\n    # Add 1.5 degC threshold line (Paris Agreement) - spans both plots\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.68,\n        y0=-4.35,\n        x1=1.00,\n        y1=-4.35,\n        line=dict(\n            color=\"orange\",\n            width=2,\n            dash=\"dot\"\n        )\n    )\n    \n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.80,\n        y=-4.30,\n        text=\"1.5 degC Target\",\n        showarrow=False,\n        bgcolor=\"rgba(255,255,255,0.8)\",\n        font=dict(size=9, color='orange'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n    \n    # Add 2 degC threshold line - spans both plots\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.68,\n        y0=-3.30,\n        x1=1.00,\n        y1=-3.30,\n        line=dict(\n            color=\"red\",\n            width=2,\n            dash=\"dot\"\n        )\n    )\n    \n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.80,\n        y=-3.25,\n        text=\"2 degC Limit\",\n        showarrow=False,\n        bgcolor=\"rgba(255,255,255,0.8)\",\n        font=dict(size=9, color='red'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n    \n    # Add 3.3 degC trajectory line - spans both plots\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.68,\n        y0=-0.50,\n        x1=1.00,\n        y1=-0.50,\n        line=dict(\n            color=\"black\",\n            width=1,\n            dash=\"dot\"\n        )\n    )\n\n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.88,\n        y=-0.50,\n        text=\"Peak: 3.3 degC (90%)\",\n        showarrow=False,\n        bgcolor=\"rgba(0,0,0,0)\",\n        font=dict(size=9, color='black'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n\n    # Add 2.8 degC trajectory line - spans both plots\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.68,\n        y0=-1.50,\n        x1=1.00,\n        y1=-1.50,\n        line=dict(\n            color=\"black\",\n            width=1,\n            dash=\"dot\"\n        )\n    )\n    \n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.88,\n        y=-1.50,\n        text=\"Peak: 2.8 degC (66%)\",\n        showarrow=False,\n        bgcolor=\"rgba(0,0,0,0)\",\n        font=dict(size=9, color='black'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n\n    # Add 2.6 degC trajectory line - spans both plots\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.68,\n        y0=-1.90,\n        x1=1.00,\n        y1=-1.90,\n        line=dict(\n            color=\"black\",\n            width=1,\n            dash=\"dot\"\n        )\n    )\n\n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.88,\n        y=-1.90,\n        text=\"Peak: 2.6 degC (50%)\",\n        showarrow=False,\n        bgcolor=\"rgba(0,0,0,0)\",\n        font=dict(size=9, color='black'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n\n    # Add annotation for Holocene stability\n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.45,\n        y=1.0,\n        text=\"Holocene<br>Stable Climate<br>(12,000 years)\",\n        showarrow=False,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='#A06CD5',\n        ax=0,\n        ay=-40,\n        font=dict(size=9, color='#A06CD5'),\n        bgcolor='rgba(255,255,255,0.9)',\n        bordercolor='#A06CD5',\n        borderwidth=1\n    )\n    \n    # Add arrow connecting Holocene stability to modern rapid change\n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"paper\",\n        x=0.60,\n        y=0.90,\n        ax=0.75,\n        ay=0.55,\n        text=\"Rapid departure<br>from stability\",\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=2,\n        arrowcolor='#D32F2F',\n        font=dict(size=9, color='#D32F2F'),\n        bgcolor='rgba(255,255,255,0.9)',\n        bordercolor='#D32F2F',\n        borderwidth=1\n    )\n    \n    # Add vertical line at 2050 in right plot (net-zero target year)\n    fig.add_vline(\n        x=2050,\n        line_width=2,\n        line_dash=\"dash\",\n        line_color=\"rgba(100,100,100,0.4)\",\n        row=1, col=2\n    )\n    \n    fig.add_annotation(\n        xref=\"x2\",  # Right plot x-axis\n        yref=\"paper\",\n        x=2050,\n        y=0.92,\n        text=\"2050<br>Net-Zero<br>Target\",\n        showarrow=False,\n        font=dict(size=8, color='#666'),\n        bgcolor='rgba(255,255,255,0.9)',\n        bordercolor='#999',\n        borderwidth=1,\n        xanchor='center',\n        yanchor='bottom'\n    )\n\n\n    \n    # ============================================================\n    # LAYOUT AND STYLING\n    # ============================================================\n    \n    fig.update_layout(\n        title={\n            'text': \"Earth's Climate: Deep Time to Future<br><sub>Dual-Scale View: Geological Context + Modern Projections</sub>\",\n            'x': 0.5,\n            'xanchor': 'center',\n            'font': {'size': 18}\n        },\n        hovermode='closest',\n        showlegend=True,\n        legend=dict(\n            x=0.01,\n            y=0.99,\n            xanchor='left',\n            yanchor='top',\n            bgcolor='rgba(255,255,255,0.9)',\n            bordercolor='#333',\n            borderwidth=1\n        ),\n        plot_bgcolor='white',\n        height=600,\n        margin=dict(t=100, b=80, l=80, r=40)\n    )\n    \n    # Add info box explaining the dual-scale approach\n    info_text = (\n        \"<b>Dual-Scale Visualization</b><br>\"\n        \"<br>\"\n        \"<b>Left:</b> 4.5 billion years (log scale)<br>\"\n        \"<b>Right:</b> 1850-2100 CE (linear scale)<br>\"\n        \"<br>\"\n        \"Same temperature axis enables<br>\"\n        \"direct visual comparison across<br>\"\n        \"geological and human timescales\"\n    )\n    \n    fig.add_annotation(\n        text=info_text,\n        xref=\"paper\", yref=\"paper\",\n        x=0.02, y=0.38,\n        xanchor=\"left\", yanchor=\"top\",\n        bgcolor=\"rgba(255,255,255,0.95)\",\n        bordercolor=\"#2E86AB\",\n        borderwidth=2,\n        borderpad=8,\n        showarrow=False,\n        font=dict(size=9),\n        align=\"left\"\n    )\n    \n    \n    # Add SSP explanation box\n    ssp_text = (\n        \"<b>Shared Socioeconomic Pathways (SSP)</b><br>\"\n        \"<b>Source</b>: IPCC AR6<br>\"\n        \"<b>Numbers:</b> Radiative forcing (W/m2) by 2100<br>\"\n        \"<b>Data periods:</b> 2021-2040, 2041-2060, 2081-2100<br>\"\n        \"<b>Plot points:</b> Period endpoints (2040, 2060, 2100)<br>\"\n        \"<b>Lines:</b> Smooth interpolations between endpoints<br>\"\n        \"<br>\"\n        \"<b>Peak Warming:</b> UNEP 2025 Emissions Gap Report<br>\"\n        \"Shows the range with current policies continuing\"\n    )\n    \n    fig.add_annotation(\n        text=ssp_text,\n        xref=\"paper\", yref=\"paper\",\n        x=0.87, y=0.99,\n        xanchor=\"right\", yanchor=\"top\",\n        bgcolor=\"rgba(255,255,255,0.95)\",\n        bordercolor=\"#2E86AB\",\n        borderwidth=2,\n        borderpad=8,\n        showarrow=False,\n        font=dict(size=9),\n        align=\"left\"\n    )\n    \n    # Citation\n    fig.add_annotation(\n        text=(\n            \"<b>Data Sources:</b><br>\" +\n            \"Paleoclimate: Lisiecki, L.E.; Raymo, M.E. (2005): NOAA/WDS Paleoclimatology - Pliocene-Pleistocene Benthic Stack | \"\n            \"Holocene: Kaufman, D.S.; McKay, N.P.; Routson, C. (2020): NOAA/WDS Paleoclimatology - Temperature 12k Database | \" \n            \"Instrumental: NASA Goddard Institute for Space Studies |<br>\"\n            \"Future Projections: IPCC AR6 WG1, Table 4.2 - Lee, J.-Y., J. Marotzke, et al. (2021): Climate Change 2021: The Physical Science Basis | \"\n            \"Peak warming over the 21st century, Figure 4.2, Emissions Gap Report 2025, UNEP | \"\n            \"Visualization: Paloma's Orrery\"\n        ),\n     \n        xref=\"paper\", yref=\"paper\",\n        x=0.5, y=-0.10,\n        xanchor=\"center\", yanchor=\"top\",\n        showarrow=False,\n        font=dict(size=9, color='#666')\n    )\n    \n    return fig",
    "start_line": 258,
    "end_line": 1062,
    "has_docstring": true,
    "docstring": "Create dual-scale paleoclimate visualization with side-by-side layout\n\nLEFT PLOT (70% width): Deep time with logarithmic scale (4.5 Ga to 1850 CE)\nRIGHT PLOT (30% width): Modern era with linear scale (1850 CE to 2100 CE)\n\nBoth plots share the same y-axis (temperature anomaly) allowing for\nvisual connections and cross-plot annotations.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_paleoclimate_dual_scale_visualization",
    "component_id": "paleoclimate_dual_scale.create_paleoclimate_dual_scale_visualization"
  },
  "paleoclimate_dual_scale.main": {
    "id": "paleoclimate_dual_scale.main",
    "name": "main",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_dual_scale.py",
    "relative_path": "paleoclimate_dual_scale.py",
    "depends_on": [
      "paleoclimate_dual_scale.create_paleoclimate_dual_scale_visualization",
      "save_utils.save_plot"
    ],
    "source_code": "def main():\n    \"\"\"Test the dual-scale visualization\"\"\"\n    if not PLOTLY_AVAILABLE:\n        print(\"Error: Plotly not available\")\n        return\n    \n    print(\"Creating dual-scale paleoclimate visualization...\")\n    fig = create_paleoclimate_dual_scale_visualization()\n    \n    if fig:\n        print(\"[OK] Visualization created successfully\")\n        # Offer to save\n        save_plot(fig, \"paleoclimate_dual_scale\")\n        print(\"Opening in browser...\")\n        fig.show()\n    else:\n        print(\"[FAIL] Could not create visualization - check if data is cached\")",
    "start_line": 1065,
    "end_line": 1081,
    "has_docstring": true,
    "docstring": "Test the dual-scale visualization",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "paleoclimate_dual_scale.main"
  },
  "paleoclimate_human_origins_full.d18o_to_temperature_approx": {
    "id": "paleoclimate_human_origins_full.d18o_to_temperature_approx",
    "name": "d18o_to_temperature_approx",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_human_origins_full.py",
    "relative_path": "paleoclimate_human_origins_full.py",
    "depends_on": [],
    "source_code": "def d18o_to_temperature_approx(d18o_values):\n    \"\"\"\n    Convert benthic delta18O to approximate temperature anomaly\n    \n    This is a simplified conversion. Benthic delta18O reflects both \n    ice volume and deep ocean temperature. The relationship varies\n    over time, but rough approximation:\n    - Higher delta18O = More ice + Colder temperatures\n    - Lower delta18O = Less ice + Warmer temperatures\n    \n    Using simplified conversion: ~4-5 degC per 1 permil change\n    Normalized to show relative changes from present\n    \"\"\"\n    # Modern benthic delta18O is around 3.2 permil\n    modern_d18o = 3.23  # From LR04 data at 0 ka\n    \n    # Convert to temperature anomaly (inverted because higher delta18O = colder)\n    # Using ~4.5 degC per 1 permil as approximation\n    temp_anomaly = -(np.array(d18o_values) - modern_d18o) * 4.5\n    \n    return temp_anomaly",
    "start_line": 235,
    "end_line": 255,
    "has_docstring": true,
    "docstring": "Convert benthic delta18O to approximate temperature anomaly\n\nThis is a simplified conversion. Benthic delta18O reflects both \nice volume and deep ocean temperature. The relationship varies\nover time, but rough approximation:\n- Higher delta18O = More ice + Colder temperatures\n- Lower delta18O = Less ice + Warmer temperatures\n\nUsing simplified conversion: ~4-5 degC per 1 permil change\nNormalized to show relative changes from present",
    "parameters": [
      "d18o_values"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function d18o_to_temperature_approx",
    "component_id": "paleoclimate_human_origins_full.d18o_to_temperature_approx"
  },
  "paleoclimate_human_origins_full.load_lr04_data": {
    "id": "paleoclimate_human_origins_full.load_lr04_data",
    "name": "load_lr04_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_human_origins_full.py",
    "relative_path": "paleoclimate_human_origins_full.py",
    "depends_on": [],
    "source_code": "def load_lr04_data():\n    \"\"\"Load LR04 benthic stack from cache\"\"\"\n    try:\n        with open(LR04_CACHE, 'r') as f:\n            data = json.load(f)\n        return data\n    except FileNotFoundError:\n        return None\n    except json.JSONDecodeError:\n        return None",
    "start_line": 257,
    "end_line": 266,
    "has_docstring": true,
    "docstring": "Load LR04 benthic stack from cache",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_lr04_data",
    "component_id": "paleoclimate_human_origins_full.load_lr04_data"
  },
  "paleoclimate_human_origins_full.load_scotese_phanerozoic_data": {
    "id": "paleoclimate_human_origins_full.load_scotese_phanerozoic_data",
    "name": "load_scotese_phanerozoic_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_human_origins_full.py",
    "relative_path": "paleoclimate_human_origins_full.py",
    "depends_on": [],
    "source_code": "def load_scotese_phanerozoic_data():\n    \"\"\"\n    Load Scotese et al. (2021) Phanerozoic temperature data\n    \n    Returns global average temperatures from 540 Ma to 0 Ma\n    Based on pole-to-equator temperature reconstructions\n    \"\"\"\n    try:\n        import csv\n        \n        ages_ma = []\n        temps_global = []\n        \n        with open(SCOTESE_PHANEROZOIC, 'r', encoding='utf-8-sig') as f:\n            reader = csv.reader(f)\n            \n            # Read header row (ages)\n            header = next(reader)\n            # Remove the 'latitude/age' label and convert to float\n            age_values = [float(age) for age in header[1:]]\n            \n            # Read all latitude rows\n            temp_grid = []\n            for row in reader:\n                if row and row[0]:  # Skip empty rows\n                    try:\n                        # Skip the latitude label, convert temps to float\n                        temps = [float(t) for t in row[1:] if t]\n                        if temps:  # Only add non-empty rows\n                            temp_grid.append(temps)\n                    except (ValueError, IndexError):\n                        continue\n            \n            # Calculate global average by averaging across all latitudes for each age\n            if temp_grid:\n                # Convert to numpy for easier calculation\n                import numpy as np\n                temp_array = np.array(temp_grid)\n                \n                # Global average is mean across all latitudes (rows)\n                global_avg_temps = np.mean(temp_array, axis=0)\n                \n                ages_ma = age_values\n                temps_global = global_avg_temps.tolist()\n        \n        if ages_ma and temps_global:\n            return {\n                'ages_ma': ages_ma,\n                'temp_global': temps_global\n            }\n        return None\n        \n    except (FileNotFoundError, Exception) as e:\n        print(f\"Warning: Could not load Scotese Phanerozoic data: {e}\")\n        return None",
    "start_line": 268,
    "end_line": 322,
    "has_docstring": true,
    "docstring": "Load Scotese et al. (2021) Phanerozoic temperature data\n\nReturns global average temperatures from 540 Ma to 0 Ma\nBased on pole-to-equator temperature reconstructions",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_scotese_phanerozoic_data",
    "component_id": "paleoclimate_human_origins_full.load_scotese_phanerozoic_data"
  },
  "paleoclimate_human_origins_full.load_holocene_data": {
    "id": "paleoclimate_human_origins_full.load_holocene_data",
    "name": "load_holocene_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_human_origins_full.py",
    "relative_path": "paleoclimate_human_origins_full.py",
    "depends_on": [],
    "source_code": "def load_holocene_data():\n    \"\"\"Load Kaufman et al. (2020) Holocene temperature reconstruction\"\"\"\n    holocene_file = os.path.join(PALEO_DATA_DIR, 'temp12k_allmethods_percentiles.csv')\n    \n    try:\n\n        import csv\n        ages_years = []\n        temps_median = []\n        temps_5th = []\n        temps_95th = []\n        \n        with open(holocene_file, 'r') as f:\n            reader = csv.DictReader(f)\n            # Strip whitespace from fieldnames\n            reader.fieldnames = [name.strip() for name in reader.fieldnames]\n            \n            for row in reader:\n                ages_years.append(float(row['ages']))\n                temps_median.append(float(row['global_median']))\n                temps_5th.append(float(row['global_5']))\n                temps_95th.append(float(row['global_95']))\n        \n        # Convert years BP to Ma BP\n        ages_ma = [age / 1_000_000 for age in ages_years]\n        \n        return {\n            'ages_ma': ages_ma,\n            'temp_median': temps_median,\n            'temp_5th': temps_5th,\n            'temp_95th': temps_95th\n        }\n    except (FileNotFoundError, KeyError) as e:\n        print(f\"Warning: Could not load Holocene data: {e}\")\n        return None",
    "start_line": 325,
    "end_line": 359,
    "has_docstring": true,
    "docstring": "Load Kaufman et al. (2020) Holocene temperature reconstruction",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_holocene_data",
    "component_id": "paleoclimate_human_origins_full.load_holocene_data"
  },
  "paleoclimate_human_origins_full.calculate_preindustrial_offset": {
    "id": "paleoclimate_human_origins_full.calculate_preindustrial_offset",
    "name": "calculate_preindustrial_offset",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_human_origins_full.py",
    "relative_path": "paleoclimate_human_origins_full.py",
    "depends_on": [],
    "source_code": "def calculate_preindustrial_offset(holocene_data):\n    \"\"\"\n    Calculate offset to normalize to pre-industrial (1850-1900) baseline\n    \n    The Kaufman data is relative to 19th century. We need to find what\n    the temperature was during 1850-1900 period (roughly 75-125 years BP)\n    and use that as our zero point.\n    \"\"\"\n    if not holocene_data:\n        return 0.0\n    \n    ages_years = [age * 1_000_000 for age in holocene_data['ages_ma']]\n    temps = holocene_data['temp_median']\n    \n    # Find temperatures for 1850-1900 period (75-175 years BP to be safe)\n    preindustrial_temps = []\n    for age, temp in zip(ages_years, temps):\n        if 75 <= age <= 175:\n            preindustrial_temps.append(temp)\n    \n    if preindustrial_temps:\n        # Average of pre-industrial period\n        return np.mean(preindustrial_temps)\n    else:\n        # If we don't have data for that exact period, use closest point\n        # Find index closest to 100 years BP\n        closest_idx = min(range(len(ages_years)), \n                         key=lambda i: abs(ages_years[i] - 100))\n        return temps[closest_idx]",
    "start_line": 361,
    "end_line": 389,
    "has_docstring": true,
    "docstring": "Calculate offset to normalize to pre-industrial (1850-1900) baseline\n\nThe Kaufman data is relative to 19th century. We need to find what\nthe temperature was during 1850-1900 period (roughly 75-125 years BP)\nand use that as our zero point.",
    "parameters": [
      "holocene_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_preindustrial_offset",
    "component_id": "paleoclimate_human_origins_full.calculate_preindustrial_offset"
  },
  "paleoclimate_human_origins_full.load_modern_temperature_data": {
    "id": "paleoclimate_human_origins_full.load_modern_temperature_data",
    "name": "load_modern_temperature_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_human_origins_full.py",
    "relative_path": "paleoclimate_human_origins_full.py",
    "depends_on": [],
    "source_code": "def load_modern_temperature_data():\n    \"\"\"Load modern instrumental temperature data to extend to present\"\"\"\n    try:\n        with open('data/temperature_giss_monthly.json', 'r') as f:\n            data = json.load(f)\n        \n        records = data['data']\n        \n        # Convert to arrays and get annual averages\n        years = []\n        temps = []\n        \n        for record in records:\n            year = record['year']\n            \n            if year not in years:\n                years.append(year)\n                # Get all months for this year that have valid data\n                year_temps = [r['anomaly_c'] for r in records \n                             if r['year'] == year and r['anomaly_c'] is not None]\n                if year_temps:\n                    temps.append(np.mean(year_temps))\n                else:\n                    # Skip years with no valid data\n                    years.pop()\n        \n        # Convert years to Ma BP (millions of years before present)\n        # Present = 2025, so years before present = 2025 - year\n        # Ma = (2025 - year) / 1,000,000\n        current_year = 2025\n        ages_ma = [(current_year - y) / 1_000_000 for y in years]\n        \n        return ages_ma, temps\n        \n    except (FileNotFoundError, json.JSONDecodeError) as e:\n        print(f\"Warning: Could not load modern temperature data: {e}\")\n        return None, None",
    "start_line": 391,
    "end_line": 427,
    "has_docstring": true,
    "docstring": "Load modern instrumental temperature data to extend to present",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_modern_temperature_data",
    "component_id": "paleoclimate_human_origins_full.load_modern_temperature_data"
  },
  "paleoclimate_human_origins_full.create_paleoclimate_visualization": {
    "id": "paleoclimate_human_origins_full.create_paleoclimate_visualization",
    "name": "create_paleoclimate_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_human_origins_full.py",
    "relative_path": "paleoclimate_human_origins_full.py",
    "depends_on": [
      "paleoclimate_human_origins_full.load_scotese_phanerozoic_data",
      "paleoclimate_human_origins_full.load_holocene_data",
      "paleoclimate_human_origins_full.load_modern_temperature_data",
      "paleoclimate_human_origins_full.load_lr04_data",
      "paleoclimate_human_origins_full.d18o_to_temperature_approx",
      "paleoclimate_human_origins_full.calculate_preindustrial_offset"
    ],
    "source_code": "def create_paleoclimate_visualization():\n    \"\"\"\n    Create Phanerozoic paleoclimate visualization\n    \n    Shows temperature over the past 540 million years with:\n    - Geologic period shading\n    - Multiple datasets: Scotese (540-5 Ma), LR04 (5-0.01 Ma), Holocene (12 ka), Modern (1880-present)\n    - Zoomable to see detail from hundreds of millions of years down to millennia\n    \"\"\"\n    \n    if not PLOTLY_AVAILABLE:\n        return None\n    \n    # Load all data sources\n    scotese_data = load_scotese_phanerozoic_data()\n    lr04_data = load_lr04_data()\n    holocene_data = load_holocene_data()\n    modern_ages_ma, modern_temps = load_modern_temperature_data()\n    \n    # Calculate pre-industrial baseline offset\n    preindustrial_offset = calculate_preindustrial_offset(holocene_data) if holocene_data else 0.0\n    \n    # --- Process LR04 Data ---\n    if not lr04_data:\n        return None\n    \n    records = lr04_data['data']\n    ages_ka = np.array([r['age_ka_bp'] for r in records])\n    d18o_values = np.array([r['d18o_permil'] for r in records])\n    ages_ma_lr04 = ages_ka / 1000.0\n    temp_anomaly_lr04 = d18o_to_temperature_approx(d18o_values)\n    temp_anomaly_lr04 = temp_anomaly_lr04 - preindustrial_offset\n    \n    # Filter to end at Holocene start (12 ka = 0.012 Ma)\n    # LR04 optimized for ice age cycles; Kaufman better for Holocene\n    holocene_start_ma = 0.012\n    mask_lr04 = ages_ma_lr04 >= holocene_start_ma\n    ages_ma_lr04 = ages_ma_lr04[mask_lr04]\n    temp_anomaly_lr04 = temp_anomaly_lr04[mask_lr04]\n\n    # --- Process Scotese Data ---\n    scotese_ages_ma = None\n    scotese_temps = None\n    \n    if scotese_data:\n        scotese_ages_ma = np.array(scotese_data['ages_ma'])\n        scotese_temps_raw = np.array(scotese_data['temp_global'])\n        \n        # Normalize Scotese data to match LR04 at the transition point (~5 Ma)\n        # Find Scotese value at 5 Ma\n        transition_age = 5.0\n        scotese_at_transition = np.interp(transition_age, scotese_ages_ma, scotese_temps_raw)\n        \n        # Find LR04 value at 5 Ma\n        lr04_at_transition = np.interp(transition_age, ages_ma_lr04, temp_anomaly_lr04)\n        \n        # Calculate offset to align them\n        scotese_offset = lr04_at_transition - scotese_at_transition\n        scotese_temps = scotese_temps_raw + scotese_offset\n        \n        # Filter to use Scotese data for deep time (>2 Ma)\n        # Scotese method: Lithologic indicators + Koppen belts (~5 Myr resolution)\n        # Optimized for deep time patterns, not high-resolution recent climate\n        # Use LR04/Holocene/Modern for <2 Ma (higher temporal resolution)\n        mask = scotese_ages_ma >= 2.0\n        scotese_ages_ma = scotese_ages_ma[mask]\n        scotese_temps = scotese_temps[mask]\n\n    # Create figure with secondary y-axis\n    fig = make_subplots(\n        rows=1, cols=1,\n        specs=[[{\"secondary_y\": True}]]\n    )\n    \n    # Add Scotese Phanerozoic temperature trace (540-5 Ma) - plotted first so it's behind\n    if scotese_ages_ma is not None and scotese_temps is not None:\n        fig.add_trace(\n            go.Scatter(\n                x=scotese_ages_ma,\n                y=scotese_temps,\n                mode='lines',\n                name='Phanerozoic Global Temperature (Scotese et al. 2021)',\n                line=dict(color='#003049', width=2),\n        #        hovertemplate='Age: %{x:.1f} Ma<br>Temp Anomaly: %{y:.1f} degC<extra></extra>'\n                hovertemplate='Age: %{x:.1f} Ma<br>Temp Anomaly: %{y:.1f} degC<br><i>~5 Myr resolution (deep time method)</i><extra></extra>'\n            ),\n            secondary_y=False\n        )\n    \n    # Add LR04 temperature trace (5.3 Ma - 10 ka)\n    fig.add_trace(\n        go.Scatter(\n            x=ages_ma_lr04,\n            y=temp_anomaly_lr04,\n            mode='lines',\n            name='Paleoclimate Benthic Stack (Lisiecki & Raymo 2005)',\n            line=dict(color='#C1121F', width=1.5),\n            hovertemplate='Age: %{x:.3f} Ma<br>Temp Anomaly: %{y:.1f} degC<extra></extra>'\n        ),\n        secondary_y=False\n    )\n    \n    # Add Holocene reconstruction trace\n    if holocene_data:\n        # Normalize Holocene data to pre-industrial\n        holocene_temps_normalized = [t - preindustrial_offset for t in holocene_data['temp_median']]\n        \n        # Filter to end at 1880 CE (where instrumental record begins)\n        # 1880 CE = 145 years before 2025 = 0.000145 Ma\n        instrumental_start_ma = 0.000145\n        holocene_ages_filtered = []\n        holocene_temps_filtered = []\n        for age, temp in zip(holocene_data['ages_ma'], holocene_temps_normalized):\n            if age >= instrumental_start_ma:  # Older than 1880\n                holocene_ages_filtered.append(age)\n                holocene_temps_filtered.append(temp)\n\n        fig.add_trace(\n            go.Scatter(\n        #        x=holocene_data['ages_ma'],\n        #        y=holocene_temps_normalized,\n                x=holocene_ages_filtered,\n                y=holocene_temps_filtered,                \n                mode='lines',\n                name='Holocene Reconstruction (Kaufman 2020)',\n                line=dict(color=\"#2CC174\", width=2),\n                hovertemplate='Age: %{x:.6f} Ma<br>Temp Anomaly: %{y:.2f} degC<extra></extra>'\n            ),\n            secondary_y=False\n        )\n\n    # ADD THIS: Add modern instrumental data\n    if modern_ages_ma and modern_temps:\n\n        # Normalize instrumental data to pre-industrial\n        # NASA GISS is relative to 1951-1980, need to shift to 1850-1900\n        # From literature: 1951-1980 was ~0.7 degC warmer than 1850-1900\n        giss_to_preindustrial_offset = 0.7\n        modern_temps_normalized = [t + giss_to_preindustrial_offset - preindustrial_offset \n                                   for t in modern_temps]\n        \n        fig.add_trace(\n            go.Scatter(\n                x=modern_ages_ma,\n                y=modern_temps,\n                mode='lines',\n                name='Instrumental Record 1880-2025 (NASA GISS)',\n                line=dict(color=\"#3586B5\", width=3),  # Bright orange-red\n                hovertemplate='Year: %{customdata}<br>Temp Anomaly: %{y:.2f} degC<extra></extra>',\n                customdata=[2025 - int(age * 1_000_000) for age in modern_ages_ma]\n            ),\n            secondary_y=False\n        )\n        \n        # Add Younger Dryas regional temperature bands\n        # Shows spatial heterogeneity: different regions experienced different cooling\n        # Based on paleoclimate reconstructions and ice core data\n        \n        yd_start = 0.0129  # 12,900 years ago\n        yd_end = 0.0117    # 11,700 years ago\n        \n        # Band 1: Global average cooling (~0.5-1.5 degC)\n        # Subtle signal when averaged over entire planet\n        fig.add_trace(\n            go.Scatter(\n                x=[yd_start, yd_start, yd_end, yd_end, yd_start],\n                y=[0, -1.5, -1.5, 0, 0],\n                fill='toself',\n                fillcolor='rgba(0,206,209,0.1)',  # Very light turquoise\n                line=dict(width=0),\n                mode='lines',\n                name='YD Global (~1 degC)',\n                showlegend=False,\n                hovertemplate='Younger Dryas (Global)<br>Estimated: 0.5-1.5 degC cooling<br><i>Global average signal</i><extra></extra>'\n            ),\n            secondary_y=False\n        )\n        \n        # Band 2: Northern Hemisphere mid-latitudes (Europe & North America, ~2-6 degC)\n        # Regional cooling where most humans lived\n        fig.add_trace(\n            go.Scatter(\n                x=[yd_start, yd_start, yd_end, yd_end, yd_start],\n                y=[-2, -6, -6, -2, -2],\n                fill='toself',\n                fillcolor='rgba(0,206,209,0.4)',  # Medium turquoise\n                line=dict(width=0),\n                mode='lines',\n                name='YD Regional (~4 degC)',\n                showlegend=False,\n                hovertemplate='Younger Dryas (Regional)<br>Europe & North America: 2-6 degC cooling<br><i>Mid-latitude Northern Hemisphere</i><extra></extra>'\n            ),\n            secondary_y=False\n        )\n        \n        # Band 3: Greenland/North Atlantic extreme (~8-10 degC)\n        # Maximum regional impact from ice core records\n        fig.add_trace(\n            go.Scatter(\n                x=[yd_start, yd_start, yd_end, yd_end, yd_start],\n                y=[-8, -10, -10, -8, -8],\n                fill='toself',\n                fillcolor='rgba(0,206,209,0.9)',  # Darker turquoise\n                line=dict(width=0),\n                mode='lines',\n                name='YD Greenland (~9 degC)',\n                showlegend=False,\n                hovertemplate='Younger Dryas (Greenland)<br>GISP2 ice core: 8-10 degC cooling<br><i>Maximum regional impact</i><extra></extra>'\n            ),\n            secondary_y=False\n        )\n\n        # ============================================================\n        # MARINE ISOTOPE STAGES (MIS) - Pleistocene Climate Pulses\n        # Vertical bands showing glacial (cold/blue) and interglacial\n        # (warm/red) periods that controlled migration corridors\n        # ============================================================\n        \n        for mis in MIS_STAGES:\n            # Different colors for warm (interglacial) vs cold (glacial)\n            if mis['type'] == 'warm':\n                color = \"rgba(255, 99, 71, 0.12)\"  # Tomato, subtle\n            else:\n                color = \"rgba(100, 149, 237, 0.12)\"  # Cornflower blue, subtle\n            \n            fig.add_vrect(\n                x0=mis['start_ma'], x1=mis['end_ma'],\n                fillcolor=color,\n                layer=\"below\",\n                line_width=0,\n            )\n            \n            # Add hoverable annotation at top of each MIS band\n            mid_x = (mis['start_ma'] + mis['end_ma']) / 2\n            fig.add_trace(\n                go.Scatter(\n                    x=[mid_x],\n                    y=[8.5],  # Near top of chart\n                    mode='markers',\n                    marker=dict(\n                        symbol='diamond' if mis['type'] == 'warm' else 'square',\n                        size=8,\n                        color='rgba(255, 99, 71, 0.7)' if mis['type'] == 'warm' else 'rgba(100, 149, 237, 0.7)',\n                        line=dict(width=1, color='white')\n                    ),\n                    hovertemplate=(\n                        f\"<b>{mis['name']}</b><br>\"\n                        f\"<b>{mis['start_ma']*1000:.0f} - {mis['end_ma']*1000:.0f} ka</b><br>\"\n                        f\"{mis['note']}\"\n                        \"<extra></extra>\"\n                    ),\n                    showlegend=False\n                ),\n                secondary_y=False\n            )\n        \n        # Add special climate events (Toba, Green Sahara windows)\n        for event in CLIMATE_EVENTS:\n            # Different markers for different event types\n            if event['type'] == 'catastrophe':\n                symbol = 'triangle-down'\n                color = 'rgba(255, 0, 0, 0.8)'\n                size = 12\n            else:  # corridor\n                symbol = 'star'\n                color = 'rgba(34, 139, 34, 0.8)'\n                size = 10\n            \n            fig.add_trace(\n                go.Scatter(\n                    x=[event['age_ma']],\n                    y=[7.5],  # Slightly below MIS markers\n                    mode='markers',\n                    marker=dict(\n                        symbol=symbol,\n                        size=size,\n                        color=color,\n                        line=dict(width=1, color='white')\n                    ),\n                    hovertemplate=(\n                        f\"<b>{event['name']}</b><br>\"\n                        f\"<b>{event['age_ma']*1000:.0f} ka</b><br>\"\n                        f\"{event['note']}\"\n                        \"<extra></extra>\"\n                    ),\n                    showlegend=False\n                ),\n                secondary_y=False\n            )\n\n        # ============================================================\n        # HOMININ EVOLUTION MARKERS\n        # Small triangle markers at bottom of chart showing earliest\n        # evidence for key hominoid/hominin species\n        # \n        # Two marker types:\n        #   - Filled triangles: fossil-confirmed species\n        #   - Open triangles: ghost populations (DNA-only evidence)\n        #\n        # Markers use manual y_offset values defined in HOMININ_SPECIES\n        # for precise control over vertical positioning.\n        # ============================================================\n        \n        # Base y-position\n        base_y_position = -10.0\n        \n        # Build y-positions from manual offsets\n        species_y_positions = {\n            sp['name']: base_y_position + sp.get('y_offset', 0.0)\n            for sp in HOMININ_SPECIES\n        }\n        \n        # Separate fossil-confirmed from ghost populations\n        fossil_species = [sp for sp in HOMININ_SPECIES if sp.get('evidence', 'fossil') == 'fossil']\n        ghost_species = [sp for sp in HOMININ_SPECIES if sp.get('evidence') == 'dna_only']\n        \n        # Add faint vertical lines from each marker down to x-axis (all species)\n        for sp in HOMININ_SPECIES:\n            # Use slightly different line style for ghost populations\n            line_alpha = 0.2 if sp.get('evidence') == 'dna_only' else 0.3\n            marker_y = species_y_positions[sp['name']]\n            fig.add_shape(\n                type=\"line\",\n                x0=sp['age_ma'],\n                y0=marker_y,\n                x1=sp['age_ma'],\n                y1=9.5,  # Extend to top of chart area\n                line=dict(\n                    color=f\"rgba(128, 128, 128, {line_alpha})\",\n                    width=1,\n                    dash=\"dot\"\n                ),\n                xref=\"x\",\n                yref=\"y\"\n            )\n        \n        # Add FOSSIL-CONFIRMED species (filled triangles)\n        if fossil_species:\n            fossil_ages = [sp['age_ma'] for sp in fossil_species]\n            fossil_y = [species_y_positions[sp['name']] for sp in fossil_species]\n            fossil_names = [sp['name'] for sp in fossil_species]\n            fossil_notes = [sp['note'] for sp in fossil_species]\n            \n            fig.add_trace(\n                go.Scatter(\n                    x=fossil_ages,\n                    y=fossil_y,\n                    mode='markers',\n                    marker=dict(\n                        symbol='triangle-up',\n                        size=10,\n                        color='rgba(70, 70, 70, 0.7)',\n                        line=dict(width=1, color='#333')\n                    ),\n                    hovertemplate=(\n                        '<b>%{customdata[0]}</b><br>'\n                        '<b>%{customdata[1]:.2f} Ma</b><br>'\n                        '%{customdata[2]}'\n                        '<extra></extra>'\n                    ),\n                    customdata=[[name, age, note] for name, age, note in \n                               zip(fossil_names, fossil_ages, fossil_notes)],\n                    name='Hominin species earliest evidence (fossil)',\n                    showlegend=True\n                ),\n                secondary_y=False\n            )\n        \n        # Add GHOST POPULATIONS (open triangles)\n        if ghost_species:\n            ghost_ages = [sp['age_ma'] for sp in ghost_species]\n            ghost_y = [species_y_positions[sp['name']] for sp in ghost_species]\n            ghost_names = [sp['name'] for sp in ghost_species]\n            ghost_notes = [sp['note'] for sp in ghost_species]\n            \n            fig.add_trace(\n                go.Scatter(\n                    x=ghost_ages,\n                    y=ghost_y,\n                    mode='markers',\n                    marker=dict(\n                        symbol='triangle-up-open',  # Open triangle\n                        size=11,\n                        color='rgba(100, 100, 100, 0.9)',\n                        line=dict(width=2, color='#555')\n                    ),\n                    hovertemplate=(\n                        '<b>%{customdata[0]}</b><br>'\n                        '<b>Split time: ~%{customdata[1]:.1f} Ma</b><br>'\n                        '%{customdata[2]}'\n                        '<extra></extra>'\n                    ),\n                    customdata=[[name, age, note] for name, age, note in \n                               zip(ghost_names, ghost_ages, ghost_notes)],\n                    name='\"Ghost\" populations earliest evidence (DNA only)',\n                    showlegend=True\n                ),\n                secondary_y=False\n            )\n        \n        # Add legend entries for MIS stages\n        # Warm/Interglacial legend entry\n        fig.add_trace(\n            go.Scatter(\n                x=[None], y=[None],\n                mode='markers',\n                marker=dict(symbol='diamond', size=10, color='rgba(255, 99, 71, 0.7)'),\n                name='Marine Isotope Stages (MIS) - Warm',\n                showlegend=True\n            ),\n            secondary_y=False\n        )\n        # Cold/Glacial legend entry\n        fig.add_trace(\n            go.Scatter(\n                x=[None], y=[None],\n                mode='markers',\n                marker=dict(symbol='square', size=10, color='rgba(100, 149, 237, 0.7)'),\n                name='Marine Isotope Stages (MIS) - Cold',\n                showlegend=True\n            ),\n            secondary_y=False\n        )\n        # Climate events legend entry\n        fig.add_trace(\n            go.Scatter(\n                x=[None], y=[None],\n                mode='markers',\n                marker=dict(symbol='star', size=10, color='rgba(34, 139, 34, 0.8)'),\n                name='Climate Windows',\n                showlegend=True\n            ),\n            secondary_y=False\n        )\n\n        # Mark \"present day\"\n        fig.add_vline(\n            x=0.000001,  # Very close to present (1 year ago)\n            line_dash=\"solid\",\n            line_color=\"red\",\n            line_width=2\n        )\n        \n        # Add annotation for present - positioned at far right\n        fig.add_annotation(\n            x=np.log10(0.000001),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.0,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"2025\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>Present Day (2025 CE)</b><br>'\n                      'Global temp: +1.28 degC above pre-industrial<br>'\n                      'Atmospheric CO2: ~425 ppm<br>'\n                      'Warmest decade in recorded history<br>'\n                      'Rate of change: ~0.2 degC per decade<br>'\n                      'Unprecedented in Holocene stability',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )\n\n        # =====================================================================\n        # RECENT HEAT EVENTS - Reference to Earth System Controller\n        # Add this after the existing annotations (around line 1765)\n        # =====================================================================\n\n        # Recent Heat Events marker (clusters all modern events)\n        fig.add_annotation(\n            x=np.log10(0.000005),  # visible near right edge\n            y=6.0,  # Slightly above current anomaly line\n            text='VIEW HEAT WAVES',\n            showarrow=False,\n            font=dict(size=9, color='#FF4500'),  # Orange-red\n            bgcolor='rgba(255,255,255,0.9)',\n            bordercolor='#FF4500',\n            borderwidth=2,\n            borderpad=4,\n            hovertext='<b>View Recent Extreme Heat Events in Google Earth</b><br>'\n                    '<br>'\n                    '1995: Chicago Heat Wave (739 deaths)<br>'\n                    '2003: Europe Heat Wave (70,000+ deaths)<br>'\n                    '2021: Pacific NW Heat Dome (1,200+ deaths)<br>'\n                    '2022: China Yangtze Basin (70-day event)<br>'\n                    '2023: Amazon \"Boiling River\"<br>'\n                    '2024: Mali/Sahel, Delhi Heat Belt, Persian Gulf<br>'\n                    '2025: Pakistan Heat Wave<br>'\n                    '<br>'\n                    '<b>KML layers available in data/ folder</b><br>'\n                    'Use KML Layer Controller in Earth System Visualization to open<br>'\n                    'Note: Google Earth Pro preinstalled required to open KML files',\n            hoverlabel=dict(bgcolor='rgba(255,69,0,0.9)', font_size=11, font_color='white')\n        )\n\n        # Add annotation for 10 years ago (2015) - positioned at far right\n        fig.add_annotation(\n            x=np.log10(0.00001),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.0,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"2015\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>2015 CE</b><br>'\n                      'Year of Paris Climate Agreement<br>'\n                      'Global temp: +1.0 degC above pre-industrial<br>'\n                      'Hottest year on record (at the time)<br>'\n                      '196 nations commit to climate action<br>'\n                      'Beginning of renewable energy surge',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )\n\n        # Add annotation for 100 years ago (1925) - positioned at far right\n        fig.add_annotation(\n            x=np.log10(0.0001),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.0,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"1925\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>1925 CE</b><br>'\n                      'The Roaring Twenties<br>'\n                      'Global temp: ~0.1 degC above pre-industrial<br>'\n                      'World population: 2 billion<br>'\n                      'Early automobile age begins<br>'\n                      'CO2 starting to rise from coal use<br>'\n                      'Beginning of modern warming signal',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )\n\n        # Add annotation for 1000 years ago (1025) - positioned at far right\n        fig.add_annotation(\n            x=np.log10(0.001),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"1025\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>1025 CE (Medieval Period)</b><br>'\n                      'Height of Medieval Warm Period<br>'\n                      'Vikings settled Greenland<br>'\n                      'Stable Holocene climate continues<br>'\n                      'Global temp within Holocene range<br>'\n                      'Agriculture thriving across Europe/Asia<br>'\n                      'Pre-industrial baseline conditions',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )  \n\n        # Add annotation for 10,000 years ago (10,000 bce) - positioned at far right\n        fig.add_annotation(\n            x=np.log10(0.01),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"10,000 BCE\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>10,000 BCE</b><br>'\n                      'End of last Ice Age<br>'\n                      'Beginning of Holocene interglacial<br>'\n                      'Agricultural Revolution begins<br>'\n                      'Humans start farming in Fertile Crescent<br>'\n                      'Climate stability enables civilization<br>'\n                      'World population: ~5 million',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )                       \n\n        # Add annotation for 100,000 years ago (100,000 bce) - positioned at far right\n        fig.add_annotation(\n            x=np.log10(0.1),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"100,000 BCE\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>100,000 BCE</b><br>'\n                      'Deep in Pleistocene Ice Age<br>'\n                      'Modern humans in Africa<br>'\n                      'Neanderthals in Europe<br>'\n                      'Sea levels ~100m lower than today<br>'\n                      'Massive ice sheets cover continents<br>'\n                      'Temp ~5-10 degC colder than present',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )  \n\n        # Add annotation for 1,000,000 years ago (1,000,000 bce) - positioned at far right\n        fig.add_annotation(\n            x=np.log10(1.0),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"1 million BCE (1 Ma)\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>1 Million Years Ago</b><br>'\n                      'Early Pleistocene Ice Age<br>'\n                      'Homo erectus using fire<br>'\n                      '100,000-year glacial cycles begin<br>'\n                      'Ice sheets grow and retreat<br>'\n                      'Human ancestors adapting to change<br>'\n                      'Stone tool technology advancing',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )  \n\n        # Add annotation for 10 Ma years ago - positioned at far right\n        fig.add_annotation(\n            x=np.log10(10),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"10 Ma\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>10 Million Years Ago</b><br>'\n                      'Late Miocene Epoch<br>'\n                      'Grasslands expanding worldwide<br>'\n                      'Great apes diversifying in Africa<br>'\n                      'Antarctica fully ice-covered<br>'\n                      'Global cooling trend underway<br>'\n                      'Modern ocean circulation patterns form',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )\n\n        # Add annotation for 100 Ma years ago - positioned at far right\n        fig.add_annotation(\n            x=np.log10(100),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"100 Ma\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>100 Million Years Ago</b><br>'\n                      'Mid-Cretaceous greenhouse world<br>'\n                      'Dinosaurs at peak diversity<br>'\n                      'No polar ice caps<br>'\n                      'Sea levels 200m higher than today<br>'\n                      'CO2 ~4x higher than pre-industrial<br>'\n                      'Temp ~10 degC warmer than present',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        ) \n\n        # Add annotation for 540 Ma years ago - positioned at far right\n        fig.add_annotation(\n            x=np.log10(540),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"<540 Ma\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>Phanerozoic Eon (0.538 billion years)</b><br>'\n                      'Beginning of Cambrian Period 538.8 million years ago. Cambrian Explosion of life.<br>'\n                      'First animals with shells. Trilobites, early fish appear. Complex ecosystems emerge.<br><br>'\n                      '<b>Proterozoic Eon (2.0 billion years)</b><br>'\n                      '2.5 Billion Years Ago (Ga) to 538.8 Million Years Ago (Ma)<br>'\n                      'Great Oxidation Event. Complex (eukaryotic) cells. Assembly and breakup of supercontinents.<br>' \n                      'First large, soft-bodied multicellular animals (Ediacaran biota).<br><br>'\n                      '<b>Archean Eon (1.5 billion years)</b><br>'\n                      '4.0 Ga to 2.5 Ga<br>'\n                      'Formation of the first continental crust (cratons), the cooling of the planet, and the<br>' \n                      'origin of life (represented by microbial fossils like stromatolites).<br><br>'\n                      '<b>Hadean Eon (0.5 billion years)</b><br>'\n                      '4.54 Ga to 4.0 Ga<br>'\n                      'Earth\\'s formation (4.54 Ga). Intense meteorite bombardment.<br>' \n                      'Initial differentiation of the planet\\'s core, mantle, and crust.',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        ) \n\n# Add geologic period shading - use actual Ma values, not log\n    for period in GEOLOGIC_PERIODS:\n        # Use the actual Ma values - the log axis will transform them\n        fig.add_shape(\n            type=\"rect\",\n            xref=\"x\",\n            yref=\"paper\",\n            x0=period['start'],  # Use actual value, not log!\n            y0=0,\n            x1=period['end'],     # Use actual value, not log!\n            y1=1,\n            fillcolor=period['color'],\n            opacity=0.2,\n            layer=\"below\",\n            line_width=0\n        )\n        \n        # Calculate midpoint and width in log space for label positioning\n        start_log = np.log10(period['start'])\n        end_log = np.log10(period['end'])\n        midpoint_log = (start_log + end_log) / 2\n        period_width = abs(start_log - end_log)\n        \n        # Adjust font size based on period width\n        if period_width > 0.3:\n            font_size = 10\n            opacity = 1.0\n        elif period_width > 0.15:\n            font_size = 8\n            opacity = 0.9\n        else:\n            font_size = 7\n            opacity = 0.8\n        \n        # But for annotations, we still need log space\n        fig.add_annotation(\n            x=midpoint_log,\n            xref=\"x\",\n            y=1.02,\n            yref=\"paper\",\n            text=period['name'],\n            showarrow=False,\n            font=dict(size=font_size, color='#333'),\n            textangle=-45,\n            xanchor='left',\n            yanchor='bottom',\n            opacity=opacity\n        )\n\n\n    # Add era labels (broader time divisions)\n    eras = [\n        {'name': 'Precambrian', 'start': 4500, 'end': 541, 'color': '#8B4789'},\n        {'name': 'Paleozoic', 'start': 541, 'end': 252.2, 'color': '#7FA056'},\n        {'name': 'Mesozoic', 'start': 252.2, 'end': 66.0, 'color': '#34B2C9'},\n        {'name': 'Cenozoic', 'start': 66.0, 'end': 0.000001, 'color': '#FD9A52'}\n    ]\n    \n    \"\"\"\n    # Add Phanerozoic Eon label (spans Paleozoic + Mesozoic + Cenozoic)\n    # Calculate midpoint across all three Phanerozoic eras\n    phanerozoic_start = 541  # Beginning of Cambrian\n    phanerozoic_end = 0.000001  # Present\n    phanerozoic_midpoint_log = (np.log10(phanerozoic_start) + np.log10(phanerozoic_end)) / 2\n    \n    fig.add_annotation(\n        x=phanerozoic_midpoint_log,\n        y=1.065,  # Position above era labels\n        yref=\"paper\",\n        text=\"<b>PHANEROZOIC EON (540 Ma - Present)</b>\",\n        showarrow=False,\n        font=dict(size=14, color='#2C5F2D'),  # Dark green\n        xanchor='center',\n        yanchor='bottom',\n        bgcolor='rgba(255,255,255,0.7)',\n        bordercolor='#2C5F2D',\n        borderwidth=2,\n        borderpad=4\n    )\n    \"\"\"\n    \n    for era in eras:\n        # Calculate midpoint in log space\n        midpoint_log = (np.log10(era['start']) + np.log10(era['end'])) / 2\n        \n        fig.add_annotation(\n            x=midpoint_log,\n            y=1.00,  # Position above the period labels\n            yref=\"paper\",\n            text=f\"<b>{era['name']}</b>\",\n            showarrow=False,\n            font=dict(size=12, color=era['color']),\n            xanchor='center',\n            yanchor='bottom'\n        )\n\n    # Mark the Holocene explicitly\n    fig.add_trace(\n        go.Scatter(\n            x=[0.0117, 0.0117],\n    #        y=[temp_anomaly_lr04.min(), temp_anomaly_lr04.max()],\n            y=[-13.0, 0.0],            \n            mode='lines',\n            name='Holocene Begins (11.7 ka)',\n            line=dict(color='green', width=2, dash='dash'),\n            showlegend=False,\n            hoverinfo='skip'\n        ),\n        secondary_y=False\n    )\n    \n    # ax=0, ay=-40 [OK] Straight down [DOWN]\n    # ax=40, ay=0 [OK] Straight right [RIGHT]\n    # ax=40, ay=-60 [OK] Diagonal up-right [UP-RIGHT]\n    # ax=-40, ay=40 [OK] Diagonal down-left [DOWN-LEFT]\n\n    # Anthropocene (recent, so use arrow like others)\n    fig.add_annotation(\n        x=np.log10(0.000075),  # 1950 CE is 75 years ago\n        y=0.0,\n        text='Proposed Anthropocene<br>(after 1950 CE)',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='red',\n        ax=28,\n        ay=-70,\n        font=dict(size=9, color='red'),\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor='red',\n        borderwidth=1,\n        hovertext='<b>Proposed Anthropocene Epoch</b><br>'\n                  'Proposed start: 1950 CE (Great Acceleration)<br>'\n                  'Human activity dominates Earth system<br>'\n                  'Nuclear testing, plastic, concrete markers<br>'\n                  'CO2 rising faster than any natural event<br>'\n                  'Sixth mass extinction underway<br>'\n                  'Geologists debate: new epoch or event?',\n        hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n    )\n\n    # Origin of Humanity - about 350 to 160,000 years ago\n    # Add visual period marker (blue shaded region showing event duration)\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"paper\",\n        x0=0.350,  # 350,000 ya\n        x1=0.160,  # 160,000 ya\n        y0=0,\n        y1=1,\n    #    fillcolor='#00D188,0.3', \n        fillcolor='rgba(0, 209, 136,0.1)',\n        line=dict(width=0),\n        layer=\"below\"\n    )\n    \n    fig.add_annotation(\n        x=np.log10(0.25),  \n        y=4.5,\n        text='Origin of Humanity',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor=\"#00D188\",  \n        ax=0,\n        ay=0, \n        font=dict(size=9, color='#00D188'),\n        bgcolor='rgba(0, 209, 136,0)',\n        bordercolor='#00D188',\n        borderwidth=1,          \n        hovertext='<b>Origin of Humanity (350,000-160,000 years ago)</b><br>'\n        'The generally accepted range for the origin of Homo sapiens is between 300,000 and 200,000 years ago,<br>' \n        'although recent discoveries continually push the minimum date back. This range is based on the oldest<br>' \n        'widely recognized fossil evidence, all found in Africa.<br>' \n        '<b>Earliest Evidence (c. 300,000 years ago):</b> Fossils from the Jebel Irhoud site in Morocco, dated<br>' \n        'to approximately 300,000 years ago (with a range of 350,000 - 280,000 years ago), are currently the<br>' \n        'oldest known remains classified as early Homo sapiens. These specimens possess a mix of archaic and<br>' \n        'modern facial features.<br>' \n        '<b>Early Modern Humans (c. 233,000 - 160,000 years ago):</b><br>' \n        '- Omo I remains from Ethiopia, recently re-dated to at least 230,000 years ago.<br>' \n        '- Fossils from Herto, Ethiopia, dated to about 160,000 years ago.<br>' \n        '- The Florisbad Skull from South Africa, dated to about 260,000 years ago.<br>' \n        'The current scientific consensus suggests that Homo sapiens did not originate in a single \"cradle\"<br>' \n        'but rather emerged across the entire African continent from a widespread population of ancestral humans.<br>',                  \n        hoverlabel=dict(bgcolor='rgba(0, 209, 136,0.7)', font_size=11)\n    )\n\n    # Younger Dryas - the \"Big Freeze\" that interrupted deglaciation\n    # Add visual period marker (blue shaded region showing event duration)\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"paper\",\n        x0=0.0129,  # 12,900 years ago (start)\n        x1=0.0117,  # 11,700 years ago (end)\n        y0=0,\n        y1=1,\n        fillcolor='rgba(0,206,209,0)',  # Light turquoise\n        line=dict(width=0),\n        layer=\"below\"\n    )\n    \n    fig.add_annotation(\n        x=np.log10(0.0123),  # ~12,300 years ago (middle of YD)\n        y=-3.1,\n        text='Younger Dryas<br>(\"Big Freeze\")',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='#00CED1',  # Dark turquoise\n        ax=-95,\n        ay=-95, \n        font=dict(size=9, color='#00CED1'),\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor='#00CED1',\n        borderwidth=1,          \n        hovertext='<b>Younger Dryas (12,900-11,700 years ago)</b><br>'\n                  'Abrupt cooling event with regional variations:<br>'\n                  '  * <b>Global</b>: ~1 degC cooling (averaged)<br>'\n                  '  * <b>Europe/N. America</b>: 2-6 degC cooling<br>'\n                  '  * <b>Greenland</b>: 8-10 degC cooling (ice cores)<br>'\n                  '<i>Brief event smoothed in 100-year resolution data</i><br>'\n                  'Meltwater disrupted Gulf Stream circulation<br>'\n                  'Led to megafauna extinctions & agricultural origins<br>'\n                  '<b>Three turquoise bands show regional cooling ranges</b>',                  \n        hoverlabel=dict(bgcolor='rgba(0,206,209,0.9)', font_size=11)\n    )\n    \n    # Add annotation for Holocene - positioned directly over the line\n    fig.add_annotation(\n#        x=0.0117,\n        x=np.log10(0.0117),  # Use log10 for log-scale x-axis\n        xref='x',        \n        y=1.5,  # Adjust this value to position vertically where you want\n        text=\"<b>Start of Holocene</b>\",\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='green',\n        ax=0,\n        ay=-42,\n        font=dict(size=9, color='green'),\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor='green',\n        borderwidth=1,\n        hovertext='<b>Holocene Begins (11,700 years ago)</b><br>'\n                  'End of last glacial period<br>'\n                  'Rapid warming of ~5 degC in centuries<br>'\n                  'Ice sheets retreat, sea level rises 120m<br>'\n                  'Stable, warm climate enables agriculture<br>'\n                  'Human civilization flourishes<br>'\n                  'Most stable climate in 800,000 years',\n        hoverlabel=dict(bgcolor='rgba(34,139,34,0.9)', font_size=11)\n    )\n\n    # Medieval Warm Period\n    # Add visual period marker (orange shaded region)\n    # MWP: 950-1250 CE = 1075-775 years ago\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"paper\",\n        x0=0.001075,  # 950 CE (1075 years ago)\n        x1=0.000775,  # 1250 CE (775 years ago)\n        y0=0,\n        y1=1,\n        fillcolor='rgba(255,140,0,0.12)',  # Light orange\n        line=dict(width=0),\n        layer=\"below\"\n    )\n    \n    fig.add_annotation(\n            x=np.log10(0.000925),  # ~1100 CE (middle of MWP) is 925 years ago\n            y=0.10,\n            text='Medieval Warm Period',\n            showarrow=True,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=1.5,\n            arrowcolor='#FF8C00',  # Dark orange\n            ax=-45,\n            ay=-55,\n            font=dict(size=9, color='#FF8C00'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='#FF8C00',\n            borderwidth=1,\n            hovertext='<b>Medieval Warm Period (950-1250 CE)</b><br>'\n                    'Regional warming in North Atlantic/Europe<br>'\n                    'Vikings settled Greenland, agricultural boom<br>'\n                    '<br>'\n                    '<b>Temperature Ranges (see horizontal bands):</b><br>'\n                    '* Regional (light orange): +0.3 to +0.5 degC<br>'\n                    '* Global average (dark orange): +0.1 to +0.2 degC<br>'\n                    '<br>'\n                    '<i>Note: Century-scale event smoothed in 100-yr data</i><br>'\n                    'Shows: Small global changes = large regional impacts<br>'\n                    '<b>[ZOOM] Zoom to 500-1500 CE to see temperature bands clearly!</b><br>'\n                    '<b>Orange vertical region shows event duration</b>',\n            hoverlabel=dict(bgcolor='rgba(255,140,0,0.9)', font_size=11)\n        )\n\n# Medieval Warm Period - Temperature Range Bands\n    # Showing BOTH regional and global ranges with nested opacity\n    \n    # Regional range (North Atlantic/Europe): ~+0.3 to +0.5 degC\n    # Lighter, wider band showing local impact\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"y\",\n        x0=0.001075,  # 950 CE\n        x1=0.000775,  # 1250 CE\n        y0=0.3,  # Regional range (wider)\n        y1=0.5,\n        fillcolor='rgba(255,140,0,0.15)',  # Light orange\n        line=dict(width=0),  # No border (cleaner)\n        layer=\"below\"\n    )\n    \n    # Global range: ~+0.1 to +0.2 degC\n    # Darker, narrower band showing planetary average\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"y\",\n        x0=0.001075,  # 950 CE\n        x1=0.000775,  # 1250 CE\n        y0=0.1,  # Global range (narrower)\n        y1=0.2,\n        fillcolor='rgba(255,140,0,0.35)',  # Darker orange\n        line=dict(width=0),\n        layer=\"below\"\n    )\n\n    # Little Ice Age\n    # Add visual period marker (blue shaded region)\n    # LIA: 1300-1850 CE = 725-175 years ago\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"paper\",\n        x0=0.000725,  # 1300 CE (725 years ago)\n        x1=0.000175,  # 1850 CE (175 years ago)\n        y0=0,\n        y1=1,\n        fillcolor='rgba(65,105,225,0.12)',  # Light royal blue\n        line=dict(width=0),\n        layer=\"below\"\n    )\n    \n    fig.add_annotation(\n        x=np.log10(0.000450),  # ~1575 CE (middle of LIA) is 450 years ago\n        y=-0.2,\n        text='Little Ice Age',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='#4169E1',  # Royal blue\n        ax=20,\n        ay=-55, \n        font=dict(size=9, color='#4169E1'),\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor='#4169E1',\n        borderwidth=1,\n        hovertext='<b>Little Ice Age (1300-1850 CE)</b><br>'\n                  'Regional cooling in North Atlantic/Europe<br>'\n                  'Viking Greenland abandoned, Thames froze, famines<br>'\n                  '<br>'\n                  '<b>Temperature Ranges (see horizontal bands):</b><br>'\n                  '* Regional (light blue): -0.5 to -1.0 degC<br>'\n                  '* Global average (dark blue): -0.2 to -0.3 degC<br>'\n                  '<br>'\n                  '<i>Note: Best visible in regional high-res proxies</i><br>'\n                  'Even small global changes affect civilizations<br>'\n                  '<b>[ZOOM] Zoom to 1200-1900 CE to see temperature bands clearly!</b><br>'\n                  '<b>Blue vertical region shows event duration</b>',\n        hoverlabel=dict(bgcolor='rgba(65,105,225,0.9)', font_size=11)\n    )\n\n# Little Ice Age - Temperature Range Bands\n    # Showing BOTH regional and global ranges with nested opacity\n    \n    # Regional range (North Atlantic/Europe): ~-0.5 to -1.0 degC\n    # Lighter, wider band showing local impact\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"y\",\n        x0=0.000725,  # 1300 CE\n        x1=0.000175,  # 1850 CE\n        y0=-1.0,  # Regional range (wider)\n        y1=-0.5,\n        fillcolor='rgba(65,105,225,0.15)',  # Light blue\n        line=dict(width=0),\n        layer=\"below\"\n    )\n    \n    # Global range: ~-0.2 to -0.3 degC\n    # Darker, narrower band showing planetary average\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"y\",\n        x0=0.000725,  # 1300 CE\n        x1=0.000175,  # 1850 CE\n        y0=-0.3,  # Global range (narrower)\n        y1=-0.2,\n        fillcolor='rgba(65,105,225,0.35)',  # Darker blue\n        line=dict(width=0),\n        layer=\"below\"\n    )    \n\n# K-Pg Extinction\n    fig.add_annotation(\n#        x=66.0, \n        x=np.log10(66.0),\n        y=-8,\n        text='K-Pg Extinction<br>(Dinosaurs)',\n        showarrow=False, arrowhead=2, arrowsize=1, arrowwidth=1.5, arrowcolor='#333',\n        ax=0, ay=-40,\n        font=dict(size=9, color='#333'),\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,\n        hovertext='<b>K-Pg Extinction (66 Million Years Ago)</b><br>'\n                  'Asteroid impact in Yucatan Peninsula<br>'\n                  'Chicxulub crater: 180 km diameter<br>'\n                  '~75% of species extinct (including dinosaurs)<br>'\n                  'Impact winter: years of darkness and cold<br>'\n                  'Ended Mesozoic Era, began Age of Mammals<br>'\n                  'Birds (avian dinosaurs) survived',\n        hoverlabel=dict(bgcolor='rgba(50,50,50,0.9)', font_size=11)\n    )\n    \n    # PETM\n    fig.add_annotation(\n        x=np.log10(56.0),\n        y=15.78,\n        text='PETM<br>(Thermal Maximum)',\n        showarrow=True, arrowhead=2, arrowsize=1, arrowwidth=1.5, arrowcolor='#333',\n        ax=0, \n        ay=-90,\n        font=dict(size=9, color='#333'),\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,\n        hovertext='<b>PETM - Paleocene-Eocene Thermal Maximum</b><br>'\n                  '~56 million years ago<br>'\n                  'Rapid warming of ~5-8 degC in <10,000 years<br>'\n                  'Massive carbon release (volcanic/methane)<br>'\n                  'Ocean acidification, deep-sea extinctions<br>'\n                  'Mammals diversified and spread globally<br>'\n                  'Closest ancient analog to modern warming',\n        hoverlabel=dict(bgcolor='rgba(50,50,50,0.9)', font_size=11)\n    )\n    \n    # Grande Coupure\n    fig.add_annotation(\n        x=np.log10(34.0),\n        y=8.44,\n        text='Grande Coupure<br>(Cooling begins)',\n        showarrow=True, arrowhead=2, arrowsize=1, arrowwidth=1.5, arrowcolor='#333',\n        ax=40, \n        ay=-40,\n        font=dict(size=9, color='#333'),\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,\n        hovertext='<b>Grande Coupure - The \"Great Cut\"</b><br>'\n                  '~34 million years ago (Eocene-Oligocene)<br>'\n                  'Abrupt cooling, ice sheets form on Antarctica<br>'\n                  'Drop of ~4 degC in less than 400,000 years<br>'\n                  'Opening of Drake Passage (Antarctica-S.America)<br>'\n                  'Circumpolar current isolates Antarctica<br>'\n                  'Major faunal turnover in Europe',\n        hoverlabel=dict(bgcolor='rgba(50,50,50,0.9)', font_size=11)\n    )\n    \n    # Ice Ages Begin - positioned to align with data\n    fig.add_annotation(\n        x=np.log10(2.58),  # Use log10 for log-scale x-axis\n        y=0.5,  # Adjusted y position to be closer to where data is\n        text='Ice Ages Begin',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='#333',\n        ax=0,\n        ay=-40,\n        font=dict(size=9, color='#333'),\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor='#333',\n        borderwidth=1,\n        hovertext='<b>Quaternary Ice Age Begins</b><br>'\n                  '~2.6 million years ago (Pleistocene)<br>'\n                  'Regular glacial-interglacial cycles begin<br>'\n                  '41,000-year cycles, then 100,000-year cycles<br>'\n                  'Ice sheets cover Northern Hemisphere<br>'\n                  'Human ancestors adapt to climate swings<br>'\n                  'Still in this ice age today (Holocene = warm phase)',\n        hoverlabel=dict(bgcolor='rgba(50,50,50,0.9)', font_size=11)\n    )\n    \n    # ===== DEEP TIME EVENTS (with ? hover for minimal clutter) =====\n    \n    # Cretaceous Thermal Maximum\n    fig.add_annotation(\n        x=np.log10(90),\n        y=20,\n        text='CTM',\n        showarrow=False,\n        font=dict(size=9, color='#333'),\n    #    font=dict(size=16, color='#7FC64E'),  # Cretaceous green\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,    \n    #    bgcolor='rgba(255,255,255,0.9)',\n    #    bordercolor='#7FC64E',\n    #    borderwidth=2,\n        borderpad=4,\n        hovertext='<b>Cretaceous Thermal Maximum (~90 Ma)</b><br>'\n                  'Peak Mesozoic greenhouse conditions<br>'\n                  'Global temp ~20 degC above pre-industrial<br>'\n                  'High CO2, no polar ice, warm oceans<br>'\n                  'Dinosaurs thrived in hot world',\n        hoverlabel=dict(bgcolor='rgba(127,198,78,0.9)', font_size=11)\n    )\n    \n    # Permian-Triassic Extinction\n    fig.add_annotation(\n        x=np.log10(252),\n        y=25.5,\n        text='P-T Ext.',\n        showarrow=False,\n        font=dict(size=9, color='#333'),        \n    #    font=dict(size=16, color='#F04028'),  # Permian red\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,    \n    #    bgcolor='rgba(255,255,255,0.9)',\n    #    bordercolor='#F04028',\n    #    borderwidth=2,\n        borderpad=4,\n        hovertext='<b>Permian-Triassic Extinction (~252 Ma)</b><br>'\n                  'The \"Great Dying\" - worst mass extinction<br>'\n                  '~96% of marine species extinct<br>'\n                  '~70% of terrestrial vertebrates extinct<br>'\n                  'Caused by Siberian Traps volcanism<br>'\n                  'Massive CO2 release, ocean anoxia<br>'\n                  'Global temp ~28 degC (peak hothouse)',\n        hoverlabel=dict(bgcolor='rgba(240,64,40,0.9)', font_size=11)\n    )\n    \n    # Carboniferous Icehouse\n    fig.add_annotation(\n        x=np.log10(300),\n        y=-3.5,\n        text='Icenhouse',\n        showarrow=False,\n        font=dict(size=9, color='#333'),        \n    #    font=dict(size=16, color='#67A599'),  # Carboniferous teal\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,    \n    #    bgcolor='rgba(255,255,255,0.9)',\n    #    bordercolor='#67A599',\n    #    borderwidth=2,\n        borderpad=4,\n        hovertext='<b>Carboniferous Icehouse (~300 Ma)</b><br>'\n                  'The \"Coal Age\" - vast tropical forests<br>'\n                  'Trees evolved lignin (hard to decompose)<br>'\n                  'Massive carbon burial [OK] coal deposits<br>'\n                  'Drew down atmospheric CO2<br>'\n                  'Triggered glaciation (~12 degC drop)<br>'\n                  'First forests changed the planet!',\n        hoverlabel=dict(bgcolor='rgba(103,165,153,0.9)', font_size=11)\n    )\n    \n    # Late Ordovician Glaciation\n    fig.add_annotation(\n        x=np.log10(445),\n        y=-8,\n        text='Glaciation',\n        showarrow=False,\n        font=dict(size=9, color='#333'),        \n    #    font=dict(size=16, color='#009270'),  # Ordovician green\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,    \n    #    bgcolor='rgba(255,255,255,0.9)',\n    #    bordercolor='#009270',\n    #    borderwidth=2,\n        borderpad=4,\n        hovertext='<b>Late Ordovician Glaciation (~445 Ma)</b><br>'\n                  'First major Phanerozoic icehouse<br>'\n                  'Rapid cooling to ~5 degC<br>'\n                  'Massive ice sheets on Gondwana<br>'\n                  'Sea level drop of ~100m<br>'\n                  'End-Ordovician mass extinction<br>'\n                  '~85% of marine species extinct',\n        hoverlabel=dict(bgcolor='rgba(0,146,112,0.9)', font_size=11)\n    )\n    \n    # End-Triassic Extinction (optional but you said \"all\"!)\n    fig.add_annotation(\n        x=np.log10(201),\n        y=18,\n        text='E-T Ext.',\n        showarrow=False,\n        font=dict(size=9, color='#333'),        \n    #    font=dict(size=16, color='#812B92'),  # Triassic purple\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,    \n    #    bgcolor='rgba(255,255,255,0.9)',\n    #    bordercolor='#812B92',\n    #    borderwidth=2,\n        borderpad=4,\n        hovertext='<b>End-Triassic Extinction (~201 Ma)</b><br>'\n                  'One of the \"Big Five\" mass extinctions<br>'\n                  '~75% of species extinct<br>'\n                  'Caused by CAMP volcanism<br>'\n                  '(Central Atlantic Magmatic Province)<br>'\n                  'CO2 spike, ocean acidification<br>'\n                  'Opened ecological space for dinosaurs',\n        hoverlabel=dict(bgcolor='rgba(129,43,146,0.9)', font_size=11)\n    )\n        \n\n    # Add 3.3 degC\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.0,\n        y0=3.3,\n        x1=0.94,\n        y1=3.3,\n        line=dict(\n            color=\"red\",\n            width=1,\n            dash=\"dot\"\n        )\n    )\n    \n    # Add 2.8 degC \n#    fig.add_shape(\n#        type=\"line\",\n#        xref=\"paper\",\n#        yref=\"y\",\n#        x0=0.0,\n#        y0=2.8,\n#        x1=0.94,\n#        y1=2.8,\n#        line=dict(\n#            color=\"red\",\n#            width=1,\n#            dash=\"dot\"\n#        )\n#    )\n\n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.77,\n        y=3.40,\n        text=\"Current Policies (UNEP): 2.6 degC - 3.3 degC\",\n        showarrow=False,\n        bgcolor=\"rgba(255,255,255,0)\",\n        font=dict(size=9, color='red'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n\n    # Add 2.6 degC \n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.0,\n        y0=2.6,\n        x1=0.94,\n        y1=2.6,\n        line=dict(\n            color=\"red\",\n            width=1,\n            dash=\"dot\"\n        )\n    )\n    \n#    fig.add_annotation(\n#        xref=\"paper\",\n#        yref=\"y\",\n#        x=0.82,\n#        y=3.10,\n#        text=\"2.5 degC to 2.9 degC Trajectory\",\n#        showarrow=False,\n#        bgcolor=\"rgba(255,255,255,0.8)\",\n#        font=dict(size=9, color='black'),\n#        xanchor='left',\n#        yanchor='bottom'\n#    )\n\n    # Add 1.28 degC current anomaly line - spans both plots\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.0,\n        y0=1.28,\n        x1=0.94,\n        y1=1.28,\n        line=dict(\n            color=\"green\",\n            width=1,\n            dash=\"dot\"\n        )\n    )\n    \n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.80,\n        y=1.40,\n        text=\"1.28 degC -- Current Anomaly\",\n        showarrow=False,\n        bgcolor=\"rgba(255,255,255,0)\",\n        font=dict(size=9, color='green'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n\n    # Add 0 degC baseline - spans both plots\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.0,\n        y0=0,\n        x1=0.94,\n        y1=0,\n        line=dict(\n            color=\"black\",\n            width=1,\n            dash=\"dot\"\n        )\n    )\n    \n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.80,\n        y=-1.0,\n        text=\"0 degC -- 1850 - 1900 Baseline\",\n        showarrow=False,\n        bgcolor=\"rgba(255,255,255,0)\",\n        font=dict(size=9, color='black'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n\n    info_text = (\n        \"<b>Earth's Climate History and Human Origins</b><br>\"\n        \"<br>\"\n        \"[EARTH] <b>Phanerozoic:</b> Scotese et al. 2021 (540 Ma); \"\n        \"   <i>Method: Lithologic indicators + delta^18O + models</i><br>\"\n        \"[CLOCK] <b>Paleoclimate:</b> LR04 Benthic Stack (5.3 Ma); \"\n        \"   <i>Method: Benthic foraminifera delta^18O</i><br>\"\n        \"[SNOW] <b>Younger Dryas:</b> Alley (GISP2 ice core, 2000); \"\n        \"   <i>Method: Greenland ice core delta^18O</i><br>\"\n        \"[TEMP] <b>Holocene:</b> Kaufman et al. 2020 (12 ka); \"\n        \"   <i>Method: Multi-proxy (pollen, sediments, biomarkers)</i><br>\"\n        \"[SUN] <b>Modern:</b> NASA GISS (1880-2025); \"\n        \"   <i>Method: Instrumental (thermometers, satellites)</i><br>\"\n        \"* Time Span: 540 Ma to 2100 CE<br>\"\n        \"[CHART] Baseline: Pre-industrial (1850-1900)<br>\"\n        \"<br>\"\n#        \"[INFO] <b>Overlapping curves show method differences</b> \"\n#        \"   Scientific uncertainty is normal and expected!<br>\"\n#        \"<br>\"\n        \"[*] <b>Proxy Handoffs:</b> Each dataset ends where higher-resolution methods begin<br>\"\n#        \"<br>\"\n\n#        \"* Phanerozoic 'double hump' (540 Ma)<br>\"\n#        \"* Mesozoic greenhouse (252-66 Ma)<br>\"\n#        \"* Ice age cycles (last 2.6 Ma)<br>\"\n#        \"* Holocene stability (last 12,000 years)<br>\"\n#        \"<br>\"\n        \"[*] <b>Key Insight:</b> The Holocene's stable climate \"\n        \"enabled human civilization to flourish.<br>\"\n        \"[ZOOM] <b>Use zoom to explore details!</b>\"\n    )    \n\n    fig.add_annotation(\n        text=info_text,\n        xref=\"paper\", yref=\"paper\",\n        x=0.50, y=0.95,\n        xanchor=\"left\", yanchor=\"top\",\n        bgcolor=\"rgba(255,255,255,0.9)\",\n        bordercolor=\"#2E86AB\",\n        borderwidth=2,\n        borderpad=10,\n        showarrow=False,\n        font=dict(size=10),\n        align=\"left\"\n    )\n    \n    fig.update_xaxes(\n        title_text=\"Millions of Years Before Present (Ma, logarithmic scale)\",\n        autorange=False,\n        range=[np.log10(540), np.log10(0.000001)],  # 540 Ma to ~present\n        type=\"log\",\n        showgrid=True,\n        gridwidth=1,\n        gridcolor='lightgray'\n    )   \n\n    fig.update_yaxes(\n        title_text=\"Temperature Anomaly ( degC, relative to present)\",\n        secondary_y=False,\n        showgrid=True,\n        gridwidth=1,\n        gridcolor='lightgray'\n    )\n    \n    # Layout\n    fig.update_layout(\n        title={\n            'text': \"Earth's Climate History: 540 Million Years to 2100 CE (Phanerozoic Eon)<br><sub>From Cambrian Explosion to Present</sub>\",\n            'x': 0.5,\n            'xanchor': 'center',\n            'font': {'size': 18}\n        },\n        hovermode='closest',\n        showlegend=True,\n        legend=dict(\n            x=0.94,\n            y=0.00,\n            xanchor='right',\n            yanchor='bottom',\n            bgcolor='rgba(255,255,255,0.9)',\n            bordercolor='#2E86AB',\n            borderwidth=2,\n            font=dict(size=10)\n        ),\n        plot_bgcolor='white',\n        height=700,\n        margin=dict(t=80, b=80, l=80, r=80)\n    )\n    \n    # Add source citation\n    fig.add_annotation(\n        text=\"Data: Scotese et al. (2021) Phanerozoic | Lisiecki & Raymo (2005) LR04 | Kaufman et al. (2020) Holocene | Alley (2000) GISP2 Ice Core (YD) | NASA GISS | Paloma's Orrery\",\n        xref=\"paper\", yref=\"paper\",\n        x=0.5, y=-0.10,\n        xanchor=\"center\", yanchor=\"top\",\n        showarrow=False,\n        font=dict(size=9, color='#666')\n    )\n    \n    return fig",
    "start_line": 429,
    "end_line": 2041,
    "has_docstring": true,
    "docstring": "Create Phanerozoic paleoclimate visualization\n\nShows temperature over the past 540 million years with:\n- Geologic period shading\n- Multiple datasets: Scotese (540-5 Ma), LR04 (5-0.01 Ma), Holocene (12 ka), Modern (1880-present)\n- Zoomable to see detail from hundreds of millions of years down to millennia",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_paleoclimate_visualization",
    "component_id": "paleoclimate_human_origins_full.create_paleoclimate_visualization"
  },
  "paleoclimate_human_origins_full.main": {
    "id": "paleoclimate_human_origins_full.main",
    "name": "main",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_human_origins_full.py",
    "relative_path": "paleoclimate_human_origins_full.py",
    "depends_on": [
      "paleoclimate_human_origins_full.create_paleoclimate_visualization",
      "save_utils.save_plot"
    ],
    "source_code": "def main():\n    \"\"\"Test the visualization\"\"\"\n    if not PLOTLY_AVAILABLE:\n        print(\"Error: Plotly not available\")\n        return\n    \n    print(\"Creating paleoclimate visualization...\")\n    fig = create_paleoclimate_visualization()\n    \n    if fig:\n        print(\"[OK] Visualization created successfully\")\n        # Offer to save\n        save_plot(fig, \"paleoclimate_540Ma_to_present\")        \n        print(\"Opening in browser...\")\n        fig.show()\n    else:\n        print(\"[FAIL] Could not create visualization - check if data is cached\")\n        print(f\"Expected data file: {LR04_CACHE}\")",
    "start_line": 2043,
    "end_line": 2060,
    "has_docstring": true,
    "docstring": "Test the visualization",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "paleoclimate_human_origins_full.main"
  },
  "paleoclimate_visualization.d18o_to_temperature_approx": {
    "id": "paleoclimate_visualization.d18o_to_temperature_approx",
    "name": "d18o_to_temperature_approx",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_visualization.py",
    "relative_path": "paleoclimate_visualization.py",
    "depends_on": [],
    "source_code": "def d18o_to_temperature_approx(d18o_values):\n    \"\"\"\n    Convert benthic 18O to approximate temperature anomaly\n    \n    This is a simplified conversion. Benthic 18O reflects both \n    ice volume and deep ocean temperature. The relationship varies\n    over time, but rough approximation:\n    - Higher 18O = More ice + Colder temperatures\n    - Lower 18O = Less ice + Warmer temperatures\n    \n    Using simplified conversion: ~4-5C per 1 change\n    Normalized to show relative changes from present\n    \"\"\"\n    # Modern benthic 18O is around 3.2\n    modern_d18o = 3.23  # From LR04 data at 0 ka\n    \n    # Convert to temperature anomaly (inverted because higher 18O = colder)\n    # Using ~4.5C per 1 as approximation\n    temp_anomaly = -(np.array(d18o_values) - modern_d18o) * 4.5\n    \n    return temp_anomaly",
    "start_line": 58,
    "end_line": 78,
    "has_docstring": true,
    "docstring": "Convert benthic 18O to approximate temperature anomaly\n\nThis is a simplified conversion. Benthic 18O reflects both \nice volume and deep ocean temperature. The relationship varies\nover time, but rough approximation:\n- Higher 18O = More ice + Colder temperatures\n- Lower 18O = Less ice + Warmer temperatures\n\nUsing simplified conversion: ~4-5C per 1 change\nNormalized to show relative changes from present",
    "parameters": [
      "d18o_values"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function d18o_to_temperature_approx",
    "component_id": "paleoclimate_visualization.d18o_to_temperature_approx"
  },
  "paleoclimate_visualization.load_lr04_data": {
    "id": "paleoclimate_visualization.load_lr04_data",
    "name": "load_lr04_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_visualization.py",
    "relative_path": "paleoclimate_visualization.py",
    "depends_on": [],
    "source_code": "def load_lr04_data():\n    \"\"\"Load LR04 benthic stack from cache\"\"\"\n    try:\n        with open(LR04_CACHE, 'r') as f:\n            data = json.load(f)\n        return data\n    except FileNotFoundError:\n        return None\n    except json.JSONDecodeError:\n        return None",
    "start_line": 80,
    "end_line": 89,
    "has_docstring": true,
    "docstring": "Load LR04 benthic stack from cache",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_lr04_data",
    "component_id": "paleoclimate_visualization.load_lr04_data"
  },
  "paleoclimate_visualization.load_holocene_data": {
    "id": "paleoclimate_visualization.load_holocene_data",
    "name": "load_holocene_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_visualization.py",
    "relative_path": "paleoclimate_visualization.py",
    "depends_on": [],
    "source_code": "def load_holocene_data():\n    \"\"\"Load Kaufman et al. (2020) Holocene temperature reconstruction\"\"\"\n    holocene_file = os.path.join(PALEO_DATA_DIR, 'temp12k_allmethods_percentiles.csv')\n    \n    try:\n\n        import csv\n        ages_years = []\n        temps_median = []\n        temps_5th = []\n        temps_95th = []\n        \n        with open(holocene_file, 'r') as f:\n            reader = csv.DictReader(f)\n            # Strip whitespace from fieldnames\n            reader.fieldnames = [name.strip() for name in reader.fieldnames]\n            \n            for row in reader:\n                ages_years.append(float(row['ages']))\n                temps_median.append(float(row['global_median']))\n                temps_5th.append(float(row['global_5']))\n                temps_95th.append(float(row['global_95']))\n        \n        # Convert years BP to Ma BP\n        ages_ma = [age / 1_000_000 for age in ages_years]\n        \n        return {\n            'ages_ma': ages_ma,\n            'temp_median': temps_median,\n            'temp_5th': temps_5th,\n            'temp_95th': temps_95th\n        }\n    except (FileNotFoundError, KeyError) as e:\n        print(f\"Warning: Could not load Holocene data: {e}\")\n        return None",
    "start_line": 92,
    "end_line": 126,
    "has_docstring": true,
    "docstring": "Load Kaufman et al. (2020) Holocene temperature reconstruction",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_holocene_data",
    "component_id": "paleoclimate_visualization.load_holocene_data"
  },
  "paleoclimate_visualization.calculate_preindustrial_offset": {
    "id": "paleoclimate_visualization.calculate_preindustrial_offset",
    "name": "calculate_preindustrial_offset",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_visualization.py",
    "relative_path": "paleoclimate_visualization.py",
    "depends_on": [],
    "source_code": "def calculate_preindustrial_offset(holocene_data):\n    \"\"\"\n    Calculate offset to normalize to pre-industrial (1850-1900) baseline\n    \n    The Kaufman data is relative to 19th century. We need to find what\n    the temperature was during 1850-1900 period (roughly 75-125 years BP)\n    and use that as our zero point.\n    \"\"\"\n    if not holocene_data:\n        return 0.0\n    \n    ages_years = [age * 1_000_000 for age in holocene_data['ages_ma']]\n    temps = holocene_data['temp_median']\n    \n    # Find temperatures for 1850-1900 period (75-175 years BP to be safe)\n    preindustrial_temps = []\n    for age, temp in zip(ages_years, temps):\n        if 75 <= age <= 175:\n            preindustrial_temps.append(temp)\n    \n    if preindustrial_temps:\n        # Average of pre-industrial period\n        return np.mean(preindustrial_temps)\n    else:\n        # If we don't have data for that exact period, use closest point\n        # Find index closest to 100 years BP\n        closest_idx = min(range(len(ages_years)), \n                         key=lambda i: abs(ages_years[i] - 100))\n        return temps[closest_idx]",
    "start_line": 128,
    "end_line": 156,
    "has_docstring": true,
    "docstring": "Calculate offset to normalize to pre-industrial (1850-1900) baseline\n\nThe Kaufman data is relative to 19th century. We need to find what\nthe temperature was during 1850-1900 period (roughly 75-125 years BP)\nand use that as our zero point.",
    "parameters": [
      "holocene_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_preindustrial_offset",
    "component_id": "paleoclimate_visualization.calculate_preindustrial_offset"
  },
  "paleoclimate_visualization.load_modern_temperature_data": {
    "id": "paleoclimate_visualization.load_modern_temperature_data",
    "name": "load_modern_temperature_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_visualization.py",
    "relative_path": "paleoclimate_visualization.py",
    "depends_on": [],
    "source_code": "def load_modern_temperature_data():\n    \"\"\"Load modern instrumental temperature data to extend to present\"\"\"\n    try:\n        with open('temperature_giss_monthly.json', 'r') as f:\n            data = json.load(f)\n        \n        records = data['data']\n        \n        # Convert to arrays and get annual averages\n        years = []\n        temps = []\n        \n        for record in records:\n            year = record['year']\n            \n            if year not in years:\n                years.append(year)\n                # Get all months for this year that have valid data\n                year_temps = [r['anomaly_c'] for r in records \n                             if r['year'] == year and r['anomaly_c'] is not None]\n                if year_temps:\n                    temps.append(np.mean(year_temps))\n                else:\n                    # Skip years with no valid data\n                    years.pop()\n        \n        # Convert years to Ma BP (millions of years before present)\n        # Present = 2025, so years before present = 2025 - year\n        # Ma = (2025 - year) / 1,000,000\n        current_year = 2025\n        ages_ma = [(current_year - y) / 1_000_000 for y in years]\n        \n        return ages_ma, temps\n        \n    except (FileNotFoundError, json.JSONDecodeError) as e:\n        print(f\"Warning: Could not load modern temperature data: {e}\")\n        return None, None",
    "start_line": 158,
    "end_line": 194,
    "has_docstring": true,
    "docstring": "Load modern instrumental temperature data to extend to present",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_modern_temperature_data",
    "component_id": "paleoclimate_visualization.load_modern_temperature_data"
  },
  "paleoclimate_visualization.create_paleoclimate_visualization": {
    "id": "paleoclimate_visualization.create_paleoclimate_visualization",
    "name": "create_paleoclimate_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_visualization.py",
    "relative_path": "paleoclimate_visualization.py",
    "depends_on": [
      "paleoclimate_visualization.load_lr04_data",
      "paleoclimate_visualization.load_modern_temperature_data",
      "paleoclimate_visualization.calculate_preindustrial_offset",
      "paleoclimate_visualization.d18o_to_temperature_approx",
      "paleoclimate_visualization.load_holocene_data"
    ],
    "source_code": "def create_paleoclimate_visualization():\n    \"\"\"\n    Create Cenozoic paleoclimate visualization\n    \n    Shows temperature and CO over the past 66 million years with:\n    - Geologic period shading\n    - Dual-axis plot (temp + CO)\n    - Zoomable to see detail from millions of years down to millennia\n    \"\"\"\n    \n    if not PLOTLY_AVAILABLE:\n        return None\n    \n    # Load data\n    lr04_data = load_lr04_data()\n    if not lr04_data:\n        return None\n    \n    records = lr04_data['data']\n\n     # ADD THIS: Load modern instrumental data\n    modern_ages_ma, modern_temps = load_modern_temperature_data()   \n    \n    # Load Holocene reconstruction data\n    holocene_data = load_holocene_data()\n    \n    # Calculate pre-industrial baseline offset\n    preindustrial_offset = calculate_preindustrial_offset(holocene_data) if holocene_data else 0.0\n\n    # Extract and process data\n    ages_ka = np.array([r['age_ka_bp'] for r in records])\n    d18o_values = np.array([r['d18o_permil'] for r in records])\n    \n    # Convert ages to Ma (millions of years) for better display\n    ages_ma = ages_ka / 1000.0\n    \n    # Convert 18O to approximate temperature anomaly\n    temp_anomaly = d18o_to_temperature_approx(d18o_values)\n    \n    # Normalize to pre-industrial baseline\n    temp_anomaly = temp_anomaly - preindustrial_offset\n\n    # Create figure with secondary y-axis\n    fig = make_subplots(\n        rows=1, cols=1,\n        specs=[[{\"secondary_y\": True}]]\n    )\n    \n    # Add temperature trace\n    fig.add_trace(\n        go.Scatter(\n            x=ages_ma,\n            y=temp_anomaly,\n            mode='lines',\n            name='Paleoclimate Benthic Stack (Lisiecki & Raymo 2005)',\n            line=dict(color='#C1121F', width=1.5),\n            hovertemplate='Age: %{x:.3f} Ma<br>Temp Anomaly: %{y:.1f}C<extra></extra>'\n        ),\n        secondary_y=False\n    )\n    \n    # Add Holocene reconstruction trace\n    if holocene_data:\n        # Normalize Holocene data to pre-industrial\n        holocene_temps_normalized = [t - preindustrial_offset for t in holocene_data['temp_median']]\n        \n        fig.add_trace(\n            go.Scatter(\n                x=holocene_data['ages_ma'],\n                y=holocene_temps_normalized,\n                mode='lines',\n                name='Holocene Reconstruction (Kaufman 2020)',\n                line=dict(color=\"#2CC174\", width=2),\n                hovertemplate='Age: %{x:.6f} Ma<br>Temp Anomaly: %{y:.2f}C<extra></extra>'\n            ),\n            secondary_y=False\n        )\n\n    # ADD THIS: Add modern instrumental data\n    if modern_ages_ma and modern_temps:\n\n        # Normalize instrumental data to pre-industrial\n        # NASA GISS is relative to 1951-1980, need to shift to 1850-1900\n        # From literature: 1951-1980 was ~0.7C warmer than 1850-1900\n        giss_to_preindustrial_offset = 0.7\n        modern_temps_normalized = [t + giss_to_preindustrial_offset - preindustrial_offset \n                                   for t in modern_temps]\n        \n        fig.add_trace(\n            go.Scatter(\n                x=modern_ages_ma,\n                y=modern_temps,\n                mode='lines',\n                name='Instrumental Record 1880-2025 (NASA GISS)',\n                line=dict(color=\"#3586B5\", width=3),  # Bright orange-red\n                hovertemplate='Year: %{customdata}<br>Temp Anomaly: %{y:.2f}C<extra></extra>',\n                customdata=[2025 - int(age * 1_000_000) for age in modern_ages_ma]\n            ),\n            secondary_y=False\n        )\n        \n\n        # Mark \"present day\"\n        fig.add_vline(\n            x=0.000001,  # Very close to present (1 year ago)\n            line_dash=\"solid\",\n            line_color=\"red\",\n            line_width=2\n        )\n        \n        # Add annotation for present - positioned at far right\n        fig.add_annotation(\n    #        x=0.000001,\n            x=np.log10(0.000001),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"Present<br>(2025)\",\n            showarrow=True,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1\n        )\n\n# Add geologic period shading - use actual Ma values, not log\n    for period in GEOLOGIC_PERIODS:\n        # Use the actual Ma values - the log axis will transform them\n        fig.add_shape(\n            type=\"rect\",\n            xref=\"x\",\n            yref=\"paper\",\n            x0=period['start'],  # Use actual value, not log!\n            y0=0,\n            x1=period['end'],     # Use actual value, not log!\n            y1=1,\n            fillcolor=period['color'],\n            opacity=0.2,\n            layer=\"below\",\n            line_width=0\n        )\n        \n        # Calculate midpoint and width in log space for label positioning\n        start_log = np.log10(period['start'])\n        end_log = np.log10(period['end'])\n        midpoint_log = (start_log + end_log) / 2\n        period_width = abs(start_log - end_log)\n        \n        # Adjust font size based on period width\n        if period_width > 0.3:\n            font_size = 10\n            opacity = 1.0\n        elif period_width > 0.15:\n            font_size = 8\n            opacity = 0.9\n        else:\n            font_size = 7\n            opacity = 0.8\n        \n        # But for annotations, we still need log space\n        fig.add_annotation(\n            x=midpoint_log,\n            xref=\"x\",\n            y=1.02,\n            yref=\"paper\",\n            text=period['name'],\n            showarrow=False,\n            font=dict(size=font_size, color='#333'),\n            textangle=-45,\n            xanchor='left',\n            yanchor='bottom',\n            opacity=opacity\n        )\n\n\n    # Add era labels (broader time divisions)\n    eras = [\n        {'name': 'Precambrian', 'start': 4500, 'end': 541, 'color': '#8B4789'},\n        {'name': 'Paleozoic', 'start': 541, 'end': 252.2, 'color': '#7FA056'},\n        {'name': 'Mesozoic', 'start': 252.2, 'end': 66.0, 'color': '#34B2C9'},\n        {'name': 'Cenozoic', 'start': 66.0, 'end': 0.000001, 'color': '#FD9A52'}\n    ]\n    \n    for era in eras:\n        # Calculate midpoint in log space\n        midpoint_log = (np.log10(era['start']) + np.log10(era['end'])) / 2\n        \n        fig.add_annotation(\n            x=midpoint_log,\n            y=1.00,  # Position above the period labels\n            yref=\"paper\",\n            text=f\"<b>{era['name']}</b>\",\n            showarrow=False,\n            font=dict(size=12, color=era['color']),\n            xanchor='center',\n            yanchor='bottom'\n        )\n\n    # Mark the Holocene explicitly\n    fig.add_trace(\n        go.Scatter(\n            x=[0.0117, 0.0117],\n            y=[temp_anomaly.min(), temp_anomaly.max()],\n            mode='lines',\n            name='Holocene Begins (11.7 ka)',\n            line=dict(color='green', width=2, dash='dash'),\n            showlegend=True,\n            hoverinfo='skip'\n        ),\n        secondary_y=False\n    )\n    \n    # Add annotation for Holocene - positioned directly over the line\n    fig.add_annotation(\n#        x=0.0117,\n        x=np.log10(0.0117),  # Use log10 for log-scale x-axis\n        xref='x',        \n        y=6,  # Adjust this value to position vertically where you want\n        text=\"Start of Holocene<br>(11,700 years ago)\",\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='green',\n        ax=0,\n        ay=-40,\n        font=dict(size=9, color='green'),\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor='green',\n        borderwidth=1\n    )\n\n    \n    # Ice Ages Begin - positioned to align with data\n    fig.add_annotation(\n        x=np.log10(2.58),  # Use log10 for log-scale x-axis\n        y=0.5,  # Adjusted y position to be closer to where data is\n        text='Ice Ages Begin',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='#333',\n        ax=0,\n        ay=-40,\n        font=dict(size=9, color='#333'),\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor='#333',\n        borderwidth=1\n    )\n    \n    info_text = (\n        \"<b>Earth's Climate History</b><br>\"\n        \"<br>\"\n        \" Paleoclimate: LR04 Benthic Stack (5.3 Ma)<br>\"\n        \" Holocene: Kaufman et al. 2020 (12 ka)<br>\"\n        \" Modern: NASA GISS (1880-2025)<br>\"\n        \" Time Span: 4.5 Ga to 2100 CE<br>\"\n        \" Baseline: Pre-industrial (1850-1900)<br>\"\n        \"<br>\"\n        \" <b>Use zoom to explore:</b><br>\"\n        \" Ice age cycles (last 2.6 Ma)<br>\"\n        \" Holocene stability (last 12,000 years)<br>\"\n        \" Individual glacial/interglacial periods<br>\"\n        \"<br>\"\n        \" <b>Key Insight:</b> The Holocene's stable climate<br>\"\n        \"enabled human civilization to flourish.\"\n    )    \n\n    fig.add_annotation(\n        text=info_text,\n        xref=\"paper\", yref=\"paper\",\n        x=0.02, y=0.50,\n        xanchor=\"left\", yanchor=\"top\",\n        bgcolor=\"rgba(255,255,255,0.9)\",\n        bordercolor=\"#2E86AB\",\n        borderwidth=2,\n        borderpad=10,\n        showarrow=False,\n        font=dict(size=10),\n        align=\"left\"\n    )\n    \n    fig.update_xaxes(\n        title_text=\"Millions of Years Before Present (Ma)\",\n        autorange=False,\n        range=[np.log10(4500), np.log10(0.000001)],  # 4.5 Ga to ~present\n        type=\"log\",\n        showgrid=True,\n        gridwidth=1,\n        gridcolor='lightgray'\n    )   \n\n    fig.update_yaxes(\n        title_text=\"Temperature Anomaly (C, relative to present)\",\n        secondary_y=False,\n        showgrid=True,\n        gridwidth=1,\n        gridcolor='lightgray'\n    )\n    \n    # Layout\n    fig.update_layout(\n        title={\n            'text': \"Earth's Climate History: 530 Million Year Ago (Pliocene) to Present (Holocene)<br><sub>From Planet Formation to Climate Projections</sub>\",\n            'x': 0.5,\n            'xanchor': 'center',\n            'font': {'size': 18}\n        },\n        hovermode='closest',\n        showlegend=True,\n        legend=dict(\n            x=0.90,\n            y=0.02,\n            xanchor='right',\n            yanchor='bottom',\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='#333',\n            borderwidth=1\n        ),\n        plot_bgcolor='white',\n        height=700,\n        margin=dict(t=100, b=80, l=80, r=80)\n    )\n    \n    # Add source citation\n    fig.add_annotation(\n        text=\"Data: Lisiecki & Raymo (2005) LR04 | Kaufman et al. (2020) Holocene | NASA GISS | Paloma's Orrery\",\n        xref=\"paper\", yref=\"paper\",\n        x=0.5, y=-0.12,\n        xanchor=\"center\", yanchor=\"top\",\n        showarrow=False,\n        font=dict(size=9, color='#666')\n    )\n    \n    return fig",
    "start_line": 196,
    "end_line": 537,
    "has_docstring": true,
    "docstring": "Create Cenozoic paleoclimate visualization\n\nShows temperature and CO over the past 66 million years with:\n- Geologic period shading\n- Dual-axis plot (temp + CO)\n- Zoomable to see detail from millions of years down to millennia",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_paleoclimate_visualization",
    "component_id": "paleoclimate_visualization.create_paleoclimate_visualization"
  },
  "paleoclimate_visualization.main": {
    "id": "paleoclimate_visualization.main",
    "name": "main",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_visualization.py",
    "relative_path": "paleoclimate_visualization.py",
    "depends_on": [
      "paleoclimate_visualization.create_paleoclimate_visualization",
      "save_utils.save_plot"
    ],
    "source_code": "def main():\n    \"\"\"Test the visualization\"\"\"\n    if not PLOTLY_AVAILABLE:\n        print(\"Error: Plotly not available\")\n        return\n    \n    print(\"Creating paleoclimate visualization...\")\n    fig = create_paleoclimate_visualization()\n    \n    if fig:\n        print(\" Visualization created successfully\")\n        # Offer to save\n        save_plot(fig, \"paleoclimate_cenozoic_66Ma\")\n        print(\"Opening in browser...\")\n        fig.show()\n    \n    else:\n        print(\" Could not create visualization - check if data is cached\")\n        print(f\"Expected data file: {LR04_CACHE}\")",
    "start_line": 539,
    "end_line": 557,
    "has_docstring": true,
    "docstring": "Test the visualization",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "paleoclimate_visualization.main"
  },
  "paleoclimate_visualization_full.d18o_to_temperature_approx": {
    "id": "paleoclimate_visualization_full.d18o_to_temperature_approx",
    "name": "d18o_to_temperature_approx",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_visualization_full.py",
    "relative_path": "paleoclimate_visualization_full.py",
    "depends_on": [],
    "source_code": "def d18o_to_temperature_approx(d18o_values):\n    \"\"\"\n    Convert benthic delta18O to approximate temperature anomaly\n    \n    This is a simplified conversion. Benthic delta18O reflects both \n    ice volume and deep ocean temperature. The relationship varies\n    over time, but rough approximation:\n    - Higher delta18O = More ice + Colder temperatures\n    - Lower delta18O = Less ice + Warmer temperatures\n    \n    Using simplified conversion: ~4-5 degC per 1 permil change\n    Normalized to show relative changes from present\n    \"\"\"\n    # Modern benthic delta18O is around 3.2 permil\n    modern_d18o = 3.23  # From LR04 data at 0 ka\n    \n    # Convert to temperature anomaly (inverted because higher delta18O = colder)\n    # Using ~4.5 degC per 1 permil as approximation\n    temp_anomaly = -(np.array(d18o_values) - modern_d18o) * 4.5\n    \n    return temp_anomaly",
    "start_line": 61,
    "end_line": 81,
    "has_docstring": true,
    "docstring": "Convert benthic delta18O to approximate temperature anomaly\n\nThis is a simplified conversion. Benthic delta18O reflects both \nice volume and deep ocean temperature. The relationship varies\nover time, but rough approximation:\n- Higher delta18O = More ice + Colder temperatures\n- Lower delta18O = Less ice + Warmer temperatures\n\nUsing simplified conversion: ~4-5 degC per 1 permil change\nNormalized to show relative changes from present",
    "parameters": [
      "d18o_values"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function d18o_to_temperature_approx",
    "component_id": "paleoclimate_visualization_full.d18o_to_temperature_approx"
  },
  "paleoclimate_visualization_full.load_lr04_data": {
    "id": "paleoclimate_visualization_full.load_lr04_data",
    "name": "load_lr04_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_visualization_full.py",
    "relative_path": "paleoclimate_visualization_full.py",
    "depends_on": [],
    "source_code": "def load_lr04_data():\n    \"\"\"Load LR04 benthic stack from cache\"\"\"\n    try:\n        with open(LR04_CACHE, 'r') as f:\n            data = json.load(f)\n        return data\n    except FileNotFoundError:\n        return None\n    except json.JSONDecodeError:\n        return None",
    "start_line": 83,
    "end_line": 92,
    "has_docstring": true,
    "docstring": "Load LR04 benthic stack from cache",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_lr04_data",
    "component_id": "paleoclimate_visualization_full.load_lr04_data"
  },
  "paleoclimate_visualization_full.load_scotese_phanerozoic_data": {
    "id": "paleoclimate_visualization_full.load_scotese_phanerozoic_data",
    "name": "load_scotese_phanerozoic_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_visualization_full.py",
    "relative_path": "paleoclimate_visualization_full.py",
    "depends_on": [],
    "source_code": "def load_scotese_phanerozoic_data():\n    \"\"\"\n    Load Scotese et al. (2021) Phanerozoic temperature data\n    \n    Returns global average temperatures from 540 Ma to 0 Ma\n    Based on pole-to-equator temperature reconstructions\n    \"\"\"\n    try:\n        import csv\n        \n        ages_ma = []\n        temps_global = []\n        \n        with open(SCOTESE_PHANEROZOIC, 'r', encoding='utf-8-sig') as f:\n            reader = csv.reader(f)\n            \n            # Read header row (ages)\n            header = next(reader)\n            # Remove the 'latitude/age' label and convert to float\n            age_values = [float(age) for age in header[1:]]\n            \n            # Read all latitude rows\n            temp_grid = []\n            for row in reader:\n                if row and row[0]:  # Skip empty rows\n                    try:\n                        # Skip the latitude label, convert temps to float\n                        temps = [float(t) for t in row[1:] if t]\n                        if temps:  # Only add non-empty rows\n                            temp_grid.append(temps)\n                    except (ValueError, IndexError):\n                        continue\n            \n            # Calculate global average by averaging across all latitudes for each age\n            if temp_grid:\n                # Convert to numpy for easier calculation\n                import numpy as np\n                temp_array = np.array(temp_grid)\n                \n                # Global average is mean across all latitudes (rows)\n                global_avg_temps = np.mean(temp_array, axis=0)\n                \n                ages_ma = age_values\n                temps_global = global_avg_temps.tolist()\n        \n        if ages_ma and temps_global:\n            return {\n                'ages_ma': ages_ma,\n                'temp_global': temps_global\n            }\n        return None\n        \n    except (FileNotFoundError, Exception) as e:\n        print(f\"Warning: Could not load Scotese Phanerozoic data: {e}\")\n        return None",
    "start_line": 94,
    "end_line": 148,
    "has_docstring": true,
    "docstring": "Load Scotese et al. (2021) Phanerozoic temperature data\n\nReturns global average temperatures from 540 Ma to 0 Ma\nBased on pole-to-equator temperature reconstructions",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_scotese_phanerozoic_data",
    "component_id": "paleoclimate_visualization_full.load_scotese_phanerozoic_data"
  },
  "paleoclimate_visualization_full.load_holocene_data": {
    "id": "paleoclimate_visualization_full.load_holocene_data",
    "name": "load_holocene_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_visualization_full.py",
    "relative_path": "paleoclimate_visualization_full.py",
    "depends_on": [],
    "source_code": "def load_holocene_data():\n    \"\"\"Load Kaufman et al. (2020) Holocene temperature reconstruction\"\"\"\n    holocene_file = os.path.join(PALEO_DATA_DIR, 'temp12k_allmethods_percentiles.csv')\n    \n    try:\n\n        import csv\n        ages_years = []\n        temps_median = []\n        temps_5th = []\n        temps_95th = []\n        \n        with open(holocene_file, 'r') as f:\n            reader = csv.DictReader(f)\n            # Strip whitespace from fieldnames\n            reader.fieldnames = [name.strip() for name in reader.fieldnames]\n            \n            for row in reader:\n                ages_years.append(float(row['ages']))\n                temps_median.append(float(row['global_median']))\n                temps_5th.append(float(row['global_5']))\n                temps_95th.append(float(row['global_95']))\n        \n        # Convert years BP to Ma BP\n        ages_ma = [age / 1_000_000 for age in ages_years]\n        \n        return {\n            'ages_ma': ages_ma,\n            'temp_median': temps_median,\n            'temp_5th': temps_5th,\n            'temp_95th': temps_95th\n        }\n    except (FileNotFoundError, KeyError) as e:\n        print(f\"Warning: Could not load Holocene data: {e}\")\n        return None",
    "start_line": 151,
    "end_line": 185,
    "has_docstring": true,
    "docstring": "Load Kaufman et al. (2020) Holocene temperature reconstruction",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_holocene_data",
    "component_id": "paleoclimate_visualization_full.load_holocene_data"
  },
  "paleoclimate_visualization_full.calculate_preindustrial_offset": {
    "id": "paleoclimate_visualization_full.calculate_preindustrial_offset",
    "name": "calculate_preindustrial_offset",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_visualization_full.py",
    "relative_path": "paleoclimate_visualization_full.py",
    "depends_on": [],
    "source_code": "def calculate_preindustrial_offset(holocene_data):\n    \"\"\"\n    Calculate offset to normalize to pre-industrial (1850-1900) baseline\n    \n    The Kaufman data is relative to 19th century. We need to find what\n    the temperature was during 1850-1900 period (roughly 75-125 years BP)\n    and use that as our zero point.\n    \"\"\"\n    if not holocene_data:\n        return 0.0\n    \n    ages_years = [age * 1_000_000 for age in holocene_data['ages_ma']]\n    temps = holocene_data['temp_median']\n    \n    # Find temperatures for 1850-1900 period (75-175 years BP to be safe)\n    preindustrial_temps = []\n    for age, temp in zip(ages_years, temps):\n        if 75 <= age <= 175:\n            preindustrial_temps.append(temp)\n    \n    if preindustrial_temps:\n        # Average of pre-industrial period\n        return np.mean(preindustrial_temps)\n    else:\n        # If we don't have data for that exact period, use closest point\n        # Find index closest to 100 years BP\n        closest_idx = min(range(len(ages_years)), \n                         key=lambda i: abs(ages_years[i] - 100))\n        return temps[closest_idx]",
    "start_line": 187,
    "end_line": 215,
    "has_docstring": true,
    "docstring": "Calculate offset to normalize to pre-industrial (1850-1900) baseline\n\nThe Kaufman data is relative to 19th century. We need to find what\nthe temperature was during 1850-1900 period (roughly 75-125 years BP)\nand use that as our zero point.",
    "parameters": [
      "holocene_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_preindustrial_offset",
    "component_id": "paleoclimate_visualization_full.calculate_preindustrial_offset"
  },
  "paleoclimate_visualization_full.load_modern_temperature_data": {
    "id": "paleoclimate_visualization_full.load_modern_temperature_data",
    "name": "load_modern_temperature_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_visualization_full.py",
    "relative_path": "paleoclimate_visualization_full.py",
    "depends_on": [],
    "source_code": "def load_modern_temperature_data():\n    \"\"\"Load modern instrumental temperature data to extend to present\"\"\"\n    try:\n        with open('data/temperature_giss_monthly.json', 'r') as f:\n            data = json.load(f)\n        \n        records = data['data']\n        \n        # Convert to arrays and get annual averages\n        years = []\n        temps = []\n        \n        for record in records:\n            year = record['year']\n            \n            if year not in years:\n                years.append(year)\n                # Get all months for this year that have valid data\n                year_temps = [r['anomaly_c'] for r in records \n                             if r['year'] == year and r['anomaly_c'] is not None]\n                if year_temps:\n                    temps.append(np.mean(year_temps))\n                else:\n                    # Skip years with no valid data\n                    years.pop()\n        \n        # Convert years to Ma BP (millions of years before present)\n        # Present = 2025, so years before present = 2025 - year\n        # Ma = (2025 - year) / 1,000,000\n        current_year = 2025\n        ages_ma = [(current_year - y) / 1_000_000 for y in years]\n        \n        return ages_ma, temps\n        \n    except (FileNotFoundError, json.JSONDecodeError) as e:\n        print(f\"Warning: Could not load modern temperature data: {e}\")\n        return None, None",
    "start_line": 217,
    "end_line": 253,
    "has_docstring": true,
    "docstring": "Load modern instrumental temperature data to extend to present",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_modern_temperature_data",
    "component_id": "paleoclimate_visualization_full.load_modern_temperature_data"
  },
  "paleoclimate_visualization_full.create_paleoclimate_visualization": {
    "id": "paleoclimate_visualization_full.create_paleoclimate_visualization",
    "name": "create_paleoclimate_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_visualization_full.py",
    "relative_path": "paleoclimate_visualization_full.py",
    "depends_on": [
      "paleoclimate_visualization_full.calculate_preindustrial_offset",
      "paleoclimate_visualization_full.load_modern_temperature_data",
      "paleoclimate_visualization_full.d18o_to_temperature_approx",
      "paleoclimate_visualization_full.load_lr04_data",
      "paleoclimate_visualization_full.load_scotese_phanerozoic_data",
      "paleoclimate_visualization_full.load_holocene_data"
    ],
    "source_code": "def create_paleoclimate_visualization():\n    \"\"\"\n    Create Phanerozoic paleoclimate visualization\n    \n    Shows temperature over the past 540 million years with:\n    - Geologic period shading\n    - Multiple datasets: Scotese (540-5 Ma), LR04 (5-0.01 Ma), Holocene (12 ka), Modern (1880-present)\n    - Zoomable to see detail from hundreds of millions of years down to millennia\n    \"\"\"\n    \n    if not PLOTLY_AVAILABLE:\n        return None\n    \n    # Load all data sources\n    scotese_data = load_scotese_phanerozoic_data()\n    lr04_data = load_lr04_data()\n    holocene_data = load_holocene_data()\n    modern_ages_ma, modern_temps = load_modern_temperature_data()\n    \n    # Calculate pre-industrial baseline offset\n    preindustrial_offset = calculate_preindustrial_offset(holocene_data) if holocene_data else 0.0\n    \n    # --- Process LR04 Data ---\n    if not lr04_data:\n        return None\n    \n    records = lr04_data['data']\n    ages_ka = np.array([r['age_ka_bp'] for r in records])\n    d18o_values = np.array([r['d18o_permil'] for r in records])\n    ages_ma_lr04 = ages_ka / 1000.0\n    temp_anomaly_lr04 = d18o_to_temperature_approx(d18o_values)\n    temp_anomaly_lr04 = temp_anomaly_lr04 - preindustrial_offset\n    \n    # Filter to end at Holocene start (12 ka = 0.012 Ma)\n    # LR04 optimized for ice age cycles; Kaufman better for Holocene\n    holocene_start_ma = 0.012\n    mask_lr04 = ages_ma_lr04 >= holocene_start_ma\n    ages_ma_lr04 = ages_ma_lr04[mask_lr04]\n    temp_anomaly_lr04 = temp_anomaly_lr04[mask_lr04]\n\n    # --- Process Scotese Data ---\n    scotese_ages_ma = None\n    scotese_temps = None\n    \n    if scotese_data:\n        scotese_ages_ma = np.array(scotese_data['ages_ma'])\n        scotese_temps_raw = np.array(scotese_data['temp_global'])\n        \n        # Normalize Scotese data to match LR04 at the transition point (~5 Ma)\n        # Find Scotese value at 5 Ma\n        transition_age = 5.0\n        scotese_at_transition = np.interp(transition_age, scotese_ages_ma, scotese_temps_raw)\n        \n        # Find LR04 value at 5 Ma\n        lr04_at_transition = np.interp(transition_age, ages_ma_lr04, temp_anomaly_lr04)\n        \n        # Calculate offset to align them\n        scotese_offset = lr04_at_transition - scotese_at_transition\n        scotese_temps = scotese_temps_raw + scotese_offset\n        \n        # Filter to use Scotese data for deep time (>2 Ma)\n        # Scotese method: Lithologic indicators + Koppen belts (~5 Myr resolution)\n        # Optimized for deep time patterns, not high-resolution recent climate\n        # Use LR04/Holocene/Modern for <2 Ma (higher temporal resolution)\n        mask = scotese_ages_ma >= 2.0\n        scotese_ages_ma = scotese_ages_ma[mask]\n        scotese_temps = scotese_temps[mask]\n\n    # Create figure with secondary y-axis\n    fig = make_subplots(\n        rows=1, cols=1,\n        specs=[[{\"secondary_y\": True}]]\n    )\n    \n    # Add Scotese Phanerozoic temperature trace (540-5 Ma) - plotted first so it's behind\n    if scotese_ages_ma is not None and scotese_temps is not None:\n        fig.add_trace(\n            go.Scatter(\n                x=scotese_ages_ma,\n                y=scotese_temps,\n                mode='lines',\n                name='Phanerozoic Global Temperature (Scotese et al. 2021)',\n                line=dict(color='#003049', width=2),\n        #        hovertemplate='Age: %{x:.1f} Ma<br>Temp Anomaly: %{y:.1f} degC<extra></extra>'\n                hovertemplate='Age: %{x:.1f} Ma<br>Temp Anomaly: %{y:.1f} degC<br><i>~5 Myr resolution (deep time method)</i><extra></extra>'\n            ),\n            secondary_y=False\n        )\n    \n    # Add LR04 temperature trace (5.3 Ma - 10 ka)\n    fig.add_trace(\n        go.Scatter(\n            x=ages_ma_lr04,\n            y=temp_anomaly_lr04,\n            mode='lines',\n            name='Paleoclimate Benthic Stack (Lisiecki & Raymo 2005)',\n            line=dict(color='#C1121F', width=1.5),\n            hovertemplate='Age: %{x:.3f} Ma<br>Temp Anomaly: %{y:.1f} degC<extra></extra>'\n        ),\n        secondary_y=False\n    )\n    \n    # Add Holocene reconstruction trace\n    if holocene_data:\n        # Normalize Holocene data to pre-industrial\n        holocene_temps_normalized = [t - preindustrial_offset for t in holocene_data['temp_median']]\n        \n        # Filter to end at 1880 CE (where instrumental record begins)\n        # 1880 CE = 145 years before 2025 = 0.000145 Ma\n        instrumental_start_ma = 0.000145\n        holocene_ages_filtered = []\n        holocene_temps_filtered = []\n        for age, temp in zip(holocene_data['ages_ma'], holocene_temps_normalized):\n            if age >= instrumental_start_ma:  # Older than 1880\n                holocene_ages_filtered.append(age)\n                holocene_temps_filtered.append(temp)\n\n        fig.add_trace(\n            go.Scatter(\n        #        x=holocene_data['ages_ma'],\n        #        y=holocene_temps_normalized,\n                x=holocene_ages_filtered,\n                y=holocene_temps_filtered,                \n                mode='lines',\n                name='Holocene Reconstruction (Kaufman 2020)',\n                line=dict(color=\"#2CC174\", width=2),\n                hovertemplate='Age: %{x:.6f} Ma<br>Temp Anomaly: %{y:.2f} degC<extra></extra>'\n            ),\n            secondary_y=False\n        )\n\n    # ADD THIS: Add modern instrumental data\n    if modern_ages_ma and modern_temps:\n\n        # Normalize instrumental data to pre-industrial\n        # NASA GISS is relative to 1951-1980, need to shift to 1850-1900\n        # From literature: 1951-1980 was ~0.7 degC warmer than 1850-1900\n        giss_to_preindustrial_offset = 0.7\n        modern_temps_normalized = [t + giss_to_preindustrial_offset - preindustrial_offset \n                                   for t in modern_temps]\n        \n        fig.add_trace(\n            go.Scatter(\n                x=modern_ages_ma,\n                y=modern_temps,\n                mode='lines',\n                name='Instrumental Record 1880-2025 (NASA GISS)',\n                line=dict(color=\"#3586B5\", width=3),  # Bright orange-red\n                hovertemplate='Year: %{customdata}<br>Temp Anomaly: %{y:.2f} degC<extra></extra>',\n                customdata=[2025 - int(age * 1_000_000) for age in modern_ages_ma]\n            ),\n            secondary_y=False\n        )\n        \n        # Add Younger Dryas regional temperature bands\n        # Shows spatial heterogeneity: different regions experienced different cooling\n        # Based on paleoclimate reconstructions and ice core data\n        \n        yd_start = 0.0129  # 12,900 years ago\n        yd_end = 0.0117    # 11,700 years ago\n        \n        # Band 1: Global average cooling (~0.5-1.5 degC)\n        # Subtle signal when averaged over entire planet\n        fig.add_trace(\n            go.Scatter(\n                x=[yd_start, yd_start, yd_end, yd_end, yd_start],\n                y=[0, -1.5, -1.5, 0, 0],\n                fill='toself',\n                fillcolor='rgba(0,206,209,0.1)',  # Very light turquoise\n                line=dict(width=0),\n                mode='lines',\n                name='YD Global (~1 degC)',\n                showlegend=True,\n                hovertemplate='Younger Dryas (Global)<br>Estimated: 0.5-1.5 degC cooling<br><i>Global average signal</i><extra></extra>'\n            ),\n            secondary_y=False\n        )\n        \n        # Band 2: Northern Hemisphere mid-latitudes (Europe & North America, ~2-6 degC)\n        # Regional cooling where most humans lived\n        fig.add_trace(\n            go.Scatter(\n                x=[yd_start, yd_start, yd_end, yd_end, yd_start],\n                y=[-2, -6, -6, -2, -2],\n                fill='toself',\n                fillcolor='rgba(0,206,209,0.4)',  # Medium turquoise\n                line=dict(width=0),\n                mode='lines',\n                name='YD Regional (~4 degC)',\n                showlegend=True,\n                hovertemplate='Younger Dryas (Regional)<br>Europe & North America: 2-6 degC cooling<br><i>Mid-latitude Northern Hemisphere</i><extra></extra>'\n            ),\n            secondary_y=False\n        )\n        \n        # Band 3: Greenland/North Atlantic extreme (~8-10 degC)\n        # Maximum regional impact from ice core records\n        fig.add_trace(\n            go.Scatter(\n                x=[yd_start, yd_start, yd_end, yd_end, yd_start],\n                y=[-8, -10, -10, -8, -8],\n                fill='toself',\n                fillcolor='rgba(0,206,209,0.9)',  # Darker turquoise\n                line=dict(width=0),\n                mode='lines',\n                name='YD Greenland (~9 degC)',\n                showlegend=True,\n                hovertemplate='Younger Dryas (Greenland)<br>GISP2 ice core: 8-10 degC cooling<br><i>Maximum regional impact</i><extra></extra>'\n            ),\n            secondary_y=False\n        )\n\n        # Mark \"present day\"\n        fig.add_vline(\n            x=0.000001,  # Very close to present (1 year ago)\n            line_dash=\"solid\",\n            line_color=\"red\",\n            line_width=2\n        )\n        \n        # Add annotation for present - positioned at far right\n        fig.add_annotation(\n            x=np.log10(0.000001),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.0,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"2025\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>Present Day (2025 CE)</b><br>'\n                      'Global temp: +1.28 degC above pre-industrial<br>'\n                      'Atmospheric CO2: ~425 ppm<br>'\n                      'Warmest decade in recorded history<br>'\n                      'Rate of change: ~0.2 degC per decade<br>'\n                      'Unprecedented in Holocene stability',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )\n\n        # Add annotation for 10 years ago (2015) - positioned at far right\n        fig.add_annotation(\n            x=np.log10(0.00001),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.0,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"2015\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>2015 CE</b><br>'\n                      'Year of Paris Climate Agreement<br>'\n                      'Global temp: +1.0 degC above pre-industrial<br>'\n                      'Hottest year on record (at the time)<br>'\n                      '196 nations commit to climate action<br>'\n                      'Beginning of renewable energy surge',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )\n\n        # Add annotation for 100 years ago (1925) - positioned at far right\n        fig.add_annotation(\n            x=np.log10(0.0001),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.0,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"1925\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>1925 CE</b><br>'\n                      'The Roaring Twenties<br>'\n                      'Global temp: ~0.1 degC above pre-industrial<br>'\n                      'World population: 2 billion<br>'\n                      'Early automobile age begins<br>'\n                      'CO2 starting to rise from coal use<br>'\n                      'Beginning of modern warming signal',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )\n\n        # Add annotation for 1000 years ago (1025) - positioned at far right\n        fig.add_annotation(\n            x=np.log10(0.001),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"1025\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>1025 CE (Medieval Period)</b><br>'\n                      'Height of Medieval Warm Period<br>'\n                      'Vikings settled Greenland<br>'\n                      'Stable Holocene climate continues<br>'\n                      'Global temp within Holocene range<br>'\n                      'Agriculture thriving across Europe/Asia<br>'\n                      'Pre-industrial baseline conditions',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )  \n\n        # Add annotation for 10,000 years ago (10,000 bce) - positioned at far right\n        fig.add_annotation(\n            x=np.log10(0.01),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"10,000 BCE\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>10,000 BCE</b><br>'\n                      'End of last Ice Age<br>'\n                      'Beginning of Holocene interglacial<br>'\n                      'Agricultural Revolution begins<br>'\n                      'Humans start farming in Fertile Crescent<br>'\n                      'Climate stability enables civilization<br>'\n                      'World population: ~5 million',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )                       \n\n        # Add annotation for 100,000 years ago (100,000 bce) - positioned at far right\n        fig.add_annotation(\n            x=np.log10(0.1),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"100,000 BCE\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>100,000 BCE</b><br>'\n                      'Deep in Pleistocene Ice Age<br>'\n                      'Modern humans in Africa<br>'\n                      'Neanderthals in Europe<br>'\n                      'Sea levels ~100m lower than today<br>'\n                      'Massive ice sheets cover continents<br>'\n                      'Temp ~5-10 degC colder than present',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )  \n\n        # Add annotation for 1,000,000 years ago (1,000,000 bce) - positioned at far right\n        fig.add_annotation(\n            x=np.log10(1.0),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"1 million BCE (1 Ma)\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>1 Million Years Ago</b><br>'\n                      'Early Pleistocene Ice Age<br>'\n                      'Homo erectus using fire<br>'\n                      '100,000-year glacial cycles begin<br>'\n                      'Ice sheets grow and retreat<br>'\n                      'Human ancestors adapting to change<br>'\n                      'Stone tool technology advancing',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )  \n\n        # Add annotation for 10 Ma years ago - positioned at far right\n        fig.add_annotation(\n            x=np.log10(10),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"10 Ma\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>10 Million Years Ago</b><br>'\n                      'Late Miocene Epoch<br>'\n                      'Grasslands expanding worldwide<br>'\n                      'Great apes diversifying in Africa<br>'\n                      'Antarctica fully ice-covered<br>'\n                      'Global cooling trend underway<br>'\n                      'Modern ocean circulation patterns form',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )\n\n        # Add annotation for 100 Ma years ago - positioned at far right\n        fig.add_annotation(\n            x=np.log10(100),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"100 Ma\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>100 Million Years Ago</b><br>'\n                      'Mid-Cretaceous greenhouse world<br>'\n                      'Dinosaurs at peak diversity<br>'\n                      'No polar ice caps<br>'\n                      'Sea levels 200m higher than today<br>'\n                      'CO2 ~4x higher than pre-industrial<br>'\n                      'Temp ~10 degC warmer than present',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        ) \n\n        # Add annotation for 540 Ma years ago - positioned at far right\n        fig.add_annotation(\n            x=np.log10(540),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"<540 Ma\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>Phanerozoic Eon (0.538 billion years)</b><br>'\n                      'Beginning of Cambrian Period 538.8 million years ago. Cambrian Explosion of life.<br>'\n                      'First animals with shells. Trilobites, early fish appear. Complex ecosystems emerge.<br><br>'\n                      '<b>Proterozoic Eon (2.0 billion years)</b><br>'\n                      '2.5 Billion Years Ago (Ga) to 538.8 Million Years Ago (Ma)<br>'\n                      'Great Oxidation Event. Complex (eukaryotic) cells. Assembly and breakup of supercontinents.<br>' \n                      'First large, soft-bodied multicellular animals (Ediacaran biota).<br><br>'\n                      '<b>Archean Eon (1.5 billion years)</b><br>'\n                      '4.0 Ga to 2.5 Ga<br>'\n                      'Formation of the first continental crust (cratons), the cooling of the planet, and the<br>' \n                      'origin of life (represented by microbial fossils like stromatolites).<br><br>'\n                      '<b>Hadean Eon (0.5 billion years)</b><br>'\n                      '4.54 Ga to 4.0 Ga<br>'\n                      'Earth\\'s formation (4.54 Ga). Intense meteorite bombardment.<br>' \n                      'Initial differentiation of the planet\\'s core, mantle, and crust.',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        ) \n\n# Add geologic period shading - use actual Ma values, not log\n    for period in GEOLOGIC_PERIODS:\n        # Use the actual Ma values - the log axis will transform them\n        fig.add_shape(\n            type=\"rect\",\n            xref=\"x\",\n            yref=\"paper\",\n            x0=period['start'],  # Use actual value, not log!\n            y0=0,\n            x1=period['end'],     # Use actual value, not log!\n            y1=1,\n            fillcolor=period['color'],\n            opacity=0.2,\n            layer=\"below\",\n            line_width=0\n        )\n        \n        # Calculate midpoint and width in log space for label positioning\n        start_log = np.log10(period['start'])\n        end_log = np.log10(period['end'])\n        midpoint_log = (start_log + end_log) / 2\n        period_width = abs(start_log - end_log)\n        \n        # Adjust font size based on period width\n        if period_width > 0.3:\n            font_size = 10\n            opacity = 1.0\n        elif period_width > 0.15:\n            font_size = 8\n            opacity = 0.9\n        else:\n            font_size = 7\n            opacity = 0.8\n        \n        # But for annotations, we still need log space\n        fig.add_annotation(\n            x=midpoint_log,\n            xref=\"x\",\n            y=1.02,\n            yref=\"paper\",\n            text=period['name'],\n            showarrow=False,\n            font=dict(size=font_size, color='#333'),\n            textangle=-45,\n            xanchor='left',\n            yanchor='bottom',\n            opacity=opacity\n        )\n\n\n    # Add era labels (broader time divisions)\n    eras = [\n        {'name': 'Precambrian', 'start': 4500, 'end': 541, 'color': '#8B4789'},\n        {'name': 'Paleozoic', 'start': 541, 'end': 252.2, 'color': '#7FA056'},\n        {'name': 'Mesozoic', 'start': 252.2, 'end': 66.0, 'color': '#34B2C9'},\n        {'name': 'Cenozoic', 'start': 66.0, 'end': 0.000001, 'color': '#FD9A52'}\n    ]\n    \n    \"\"\"\n    # Add Phanerozoic Eon label (spans Paleozoic + Mesozoic + Cenozoic)\n    # Calculate midpoint across all three Phanerozoic eras\n    phanerozoic_start = 541  # Beginning of Cambrian\n    phanerozoic_end = 0.000001  # Present\n    phanerozoic_midpoint_log = (np.log10(phanerozoic_start) + np.log10(phanerozoic_end)) / 2\n    \n    fig.add_annotation(\n        x=phanerozoic_midpoint_log,\n        y=1.065,  # Position above era labels\n        yref=\"paper\",\n        text=\"<b>PHANEROZOIC EON (540 Ma - Present)</b>\",\n        showarrow=False,\n        font=dict(size=14, color='#2C5F2D'),  # Dark green\n        xanchor='center',\n        yanchor='bottom',\n        bgcolor='rgba(255,255,255,0.7)',\n        bordercolor='#2C5F2D',\n        borderwidth=2,\n        borderpad=4\n    )\n    \"\"\"\n    \n    for era in eras:\n        # Calculate midpoint in log space\n        midpoint_log = (np.log10(era['start']) + np.log10(era['end'])) / 2\n        \n        fig.add_annotation(\n            x=midpoint_log,\n            y=1.00,  # Position above the period labels\n            yref=\"paper\",\n            text=f\"<b>{era['name']}</b>\",\n            showarrow=False,\n            font=dict(size=12, color=era['color']),\n            xanchor='center',\n            yanchor='bottom'\n        )\n\n    # Mark the Holocene explicitly\n    fig.add_trace(\n        go.Scatter(\n            x=[0.0117, 0.0117],\n    #        y=[temp_anomaly_lr04.min(), temp_anomaly_lr04.max()],\n            y=[-13.0, 0.0],            \n            mode='lines',\n            name='Holocene Begins (11.7 ka)',\n            line=dict(color='green', width=2, dash='dash'),\n            showlegend=True,\n            hoverinfo='skip'\n        ),\n        secondary_y=False\n    )\n    \n    # ax=0, ay=-40 [OK] Straight down [DOWN]\n    # ax=40, ay=0 [OK] Straight right [RIGHT]\n    # ax=40, ay=-60 [OK] Diagonal up-right [UP-RIGHT]\n    # ax=-40, ay=40 [OK] Diagonal down-left [DOWN-LEFT]\n\n    # Anthropocene (recent, so use arrow like others)\n    fig.add_annotation(\n        x=np.log10(0.000075),  # 1950 CE is 75 years ago\n        y=0.0,\n        text='Proposed Anthropocene<br>(after 1950 CE)',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='red',\n        ax=28,\n        ay=-70,\n        font=dict(size=9, color='red'),\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor='red',\n        borderwidth=1,\n        hovertext='<b>Proposed Anthropocene Epoch</b><br>'\n                  'Proposed start: 1950 CE (Great Acceleration)<br>'\n                  'Human activity dominates Earth system<br>'\n                  'Nuclear testing, plastic, concrete markers<br>'\n                  'CO2 rising faster than any natural event<br>'\n                  'Sixth mass extinction underway<br>'\n                  'Geologists debate: new epoch or event?',\n        hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n    )\n\n    # Origin of Humanity - about 350 to 160,000 years ago\n    # Add visual period marker (blue shaded region showing event duration)\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"paper\",\n        x0=0.350,  # 350,000 ya\n        x1=0.160,  # 160,000 ya\n        y0=0,\n        y1=1,\n    #    fillcolor='#00D188,0.3', \n        fillcolor='rgba(0, 209, 136,0.1)',\n        line=dict(width=0),\n        layer=\"below\"\n    )\n    \n    fig.add_annotation(\n        x=np.log10(0.25),  \n        y=4.5,\n        text='Origin of Humanity',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor=\"#00D188\",  \n        ax=0,\n        ay=0, \n        font=dict(size=9, color='#00D188'),\n        bgcolor='rgba(0, 209, 136,0)',\n        bordercolor='#00D188',\n        borderwidth=1,          \n        hovertext='<b>Origin of Humanity (350,000-160,000 years ago)</b><br>'\n        'The generally accepted range for the origin of Homo sapiens is between 300,000 and 200,000 years ago,<br>' \n        'although recent discoveries continually push the minimum date back. This range is based on the oldest<br>' \n        'widely recognized fossil evidence, all found in Africa.<br>' \n        '<b>Earliest Evidence (c. 300,000 years ago):</b> Fossils from the Jebel Irhoud site in Morocco, dated<br>' \n        'to approximately 300,000 years ago (with a range of 350,000 - 280,000 years ago), are currently the<br>' \n        'oldest known remains classified as early Homo sapiens. These specimens possess a mix of archaic and<br>' \n        'modern facial features.<br>' \n        '<b>Early Modern Humans (c. 233,000 - 160,000 years ago):</b><br>' \n        '- Omo I remains from Ethiopia, recently re-dated to at least 230,000 years ago.<br>' \n        '- Fossils from Herto, Ethiopia, dated to about 160,000 years ago.<br>' \n        '- The Florisbad Skull from South Africa, dated to about 260,000 years ago.<br>' \n        'The current scientific consensus suggests that Homo sapiens did not originate in a single \"cradle\"<br>' \n        'but rather emerged across the entire African continent from a widespread population of ancestral humans.<br>',                  \n        hoverlabel=dict(bgcolor='rgba(0, 209, 136,0.7)', font_size=11)\n    )\n\n    # Younger Dryas - the \"Big Freeze\" that interrupted deglaciation\n    # Add visual period marker (blue shaded region showing event duration)\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"paper\",\n        x0=0.0129,  # 12,900 years ago (start)\n        x1=0.0117,  # 11,700 years ago (end)\n        y0=0,\n        y1=1,\n        fillcolor='rgba(0,206,209,0)',  # Light turquoise\n        line=dict(width=0),\n        layer=\"below\"\n    )\n    \n    fig.add_annotation(\n        x=np.log10(0.0123),  # ~12,300 years ago (middle of YD)\n        y=-3.1,\n        text='Younger Dryas<br>(\"Big Freeze\")',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='#00CED1',  # Dark turquoise\n        ax=-95,\n        ay=-95, \n        font=dict(size=9, color='#00CED1'),\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor='#00CED1',\n        borderwidth=1,          \n        hovertext='<b>Younger Dryas (12,900-11,700 years ago)</b><br>'\n                  'Abrupt cooling event with regional variations:<br>'\n                  '  * <b>Global</b>: ~1 degC cooling (averaged)<br>'\n                  '  * <b>Europe/N. America</b>: 2-6 degC cooling<br>'\n                  '  * <b>Greenland</b>: 8-10 degC cooling (ice cores)<br>'\n                  '<i>Brief event smoothed in 100-year resolution data</i><br>'\n                  'Meltwater disrupted Gulf Stream circulation<br>'\n                  'Led to megafauna extinctions & agricultural origins<br>'\n                  '<b>Three turquoise bands show regional cooling ranges</b>',                  \n        hoverlabel=dict(bgcolor='rgba(0,206,209,0.9)', font_size=11)\n    )\n    \n    # Add annotation for Holocene - positioned directly over the line\n    fig.add_annotation(\n#        x=0.0117,\n        x=np.log10(0.0117),  # Use log10 for log-scale x-axis\n        xref='x',        \n        y=1.5,  # Adjust this value to position vertically where you want\n        text=\"<b>Start of Holocene</b>\",\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='green',\n        ax=0,\n        ay=-42,\n        font=dict(size=9, color='green'),\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor='green',\n        borderwidth=1,\n        hovertext='<b>Holocene Begins (11,700 years ago)</b><br>'\n                  'End of last glacial period<br>'\n                  'Rapid warming of ~5 degC in centuries<br>'\n                  'Ice sheets retreat, sea level rises 120m<br>'\n                  'Stable, warm climate enables agriculture<br>'\n                  'Human civilization flourishes<br>'\n                  'Most stable climate in 800,000 years',\n        hoverlabel=dict(bgcolor='rgba(34,139,34,0.9)', font_size=11)\n    )\n\n    # Medieval Warm Period\n    # Add visual period marker (orange shaded region)\n    # MWP: 950-1250 CE = 1075-775 years ago\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"paper\",\n        x0=0.001075,  # 950 CE (1075 years ago)\n        x1=0.000775,  # 1250 CE (775 years ago)\n        y0=0,\n        y1=1,\n        fillcolor='rgba(255,140,0,0.12)',  # Light orange\n        line=dict(width=0),\n        layer=\"below\"\n    )\n    \n    fig.add_annotation(\n            x=np.log10(0.000925),  # ~1100 CE (middle of MWP) is 925 years ago\n            y=0.10,\n            text='Medieval Warm Period',\n            showarrow=True,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=1.5,\n            arrowcolor='#FF8C00',  # Dark orange\n            ax=-45,\n            ay=-55,\n            font=dict(size=9, color='#FF8C00'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='#FF8C00',\n            borderwidth=1,\n            hovertext='<b>Medieval Warm Period (950-1250 CE)</b><br>'\n                    'Regional warming in North Atlantic/Europe<br>'\n                    'Vikings settled Greenland, agricultural boom<br>'\n                    '<br>'\n                    '<b>Temperature Ranges (see horizontal bands):</b><br>'\n                    '* Regional (light orange): +0.3 to +0.5 degC<br>'\n                    '* Global average (dark orange): +0.1 to +0.2 degC<br>'\n                    '<br>'\n                    '<i>Note: Century-scale event smoothed in 100-yr data</i><br>'\n                    'Shows: Small global changes = large regional impacts<br>'\n                    '<b>[ZOOM] Zoom to 500-1500 CE to see temperature bands clearly!</b><br>'\n                    '<b>Orange vertical region shows event duration</b>',\n            hoverlabel=dict(bgcolor='rgba(255,140,0,0.9)', font_size=11)\n        )\n\n# Medieval Warm Period - Temperature Range Bands\n    # Showing BOTH regional and global ranges with nested opacity\n    \n    # Regional range (North Atlantic/Europe): ~+0.3 to +0.5 degC\n    # Lighter, wider band showing local impact\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"y\",\n        x0=0.001075,  # 950 CE\n        x1=0.000775,  # 1250 CE\n        y0=0.3,  # Regional range (wider)\n        y1=0.5,\n        fillcolor='rgba(255,140,0,0.15)',  # Light orange\n        line=dict(width=0),  # No border (cleaner)\n        layer=\"below\"\n    )\n    \n    # Global range: ~+0.1 to +0.2 degC\n    # Darker, narrower band showing planetary average\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"y\",\n        x0=0.001075,  # 950 CE\n        x1=0.000775,  # 1250 CE\n        y0=0.1,  # Global range (narrower)\n        y1=0.2,\n        fillcolor='rgba(255,140,0,0.35)',  # Darker orange\n        line=dict(width=0),\n        layer=\"below\"\n    )\n\n    # Little Ice Age\n    # Add visual period marker (blue shaded region)\n    # LIA: 1300-1850 CE = 725-175 years ago\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"paper\",\n        x0=0.000725,  # 1300 CE (725 years ago)\n        x1=0.000175,  # 1850 CE (175 years ago)\n        y0=0,\n        y1=1,\n        fillcolor='rgba(65,105,225,0.12)',  # Light royal blue\n        line=dict(width=0),\n        layer=\"below\"\n    )\n    \n    fig.add_annotation(\n        x=np.log10(0.000450),  # ~1575 CE (middle of LIA) is 450 years ago\n        y=-0.2,\n        text='Little Ice Age',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='#4169E1',  # Royal blue\n        ax=20,\n        ay=-55, \n        font=dict(size=9, color='#4169E1'),\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor='#4169E1',\n        borderwidth=1,\n        hovertext='<b>Little Ice Age (1300-1850 CE)</b><br>'\n                  'Regional cooling in North Atlantic/Europe<br>'\n                  'Viking Greenland abandoned, Thames froze, famines<br>'\n                  '<br>'\n                  '<b>Temperature Ranges (see horizontal bands):</b><br>'\n                  '* Regional (light blue): -0.5 to -1.0 degC<br>'\n                  '* Global average (dark blue): -0.2 to -0.3 degC<br>'\n                  '<br>'\n                  '<i>Note: Best visible in regional high-res proxies</i><br>'\n                  'Even small global changes affect civilizations<br>'\n                  '<b>[ZOOM] Zoom to 1200-1900 CE to see temperature bands clearly!</b><br>'\n                  '<b>Blue vertical region shows event duration</b>',\n        hoverlabel=dict(bgcolor='rgba(65,105,225,0.9)', font_size=11)\n    )\n\n# Little Ice Age - Temperature Range Bands\n    # Showing BOTH regional and global ranges with nested opacity\n    \n    # Regional range (North Atlantic/Europe): ~-0.5 to -1.0 degC\n    # Lighter, wider band showing local impact\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"y\",\n        x0=0.000725,  # 1300 CE\n        x1=0.000175,  # 1850 CE\n        y0=-1.0,  # Regional range (wider)\n        y1=-0.5,\n        fillcolor='rgba(65,105,225,0.15)',  # Light blue\n        line=dict(width=0),\n        layer=\"below\"\n    )\n    \n    # Global range: ~-0.2 to -0.3 degC\n    # Darker, narrower band showing planetary average\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"y\",\n        x0=0.000725,  # 1300 CE\n        x1=0.000175,  # 1850 CE\n        y0=-0.3,  # Global range (narrower)\n        y1=-0.2,\n        fillcolor='rgba(65,105,225,0.35)',  # Darker blue\n        line=dict(width=0),\n        layer=\"below\"\n    )    \n\n# K-Pg Extinction\n    fig.add_annotation(\n#        x=66.0, \n        x=np.log10(66.0),\n        y=-8,\n        text='K-Pg Extinction<br>(Dinosaurs)',\n        showarrow=False, arrowhead=2, arrowsize=1, arrowwidth=1.5, arrowcolor='#333',\n        ax=0, ay=-40,\n        font=dict(size=9, color='#333'),\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,\n        hovertext='<b>K-Pg Extinction (66 Million Years Ago)</b><br>'\n                  'Asteroid impact in Yucatan Peninsula<br>'\n                  'Chicxulub crater: 180 km diameter<br>'\n                  '~75% of species extinct (including dinosaurs)<br>'\n                  'Impact winter: years of darkness and cold<br>'\n                  'Ended Mesozoic Era, began Age of Mammals<br>'\n                  'Birds (avian dinosaurs) survived',\n        hoverlabel=dict(bgcolor='rgba(50,50,50,0.9)', font_size=11)\n    )\n    \n    # PETM\n    fig.add_annotation(\n        x=np.log10(56.0),\n        y=15.78,\n        text='PETM<br>(Thermal Maximum)',\n        showarrow=True, arrowhead=2, arrowsize=1, arrowwidth=1.5, arrowcolor='#333',\n        ax=0, \n        ay=-90,\n        font=dict(size=9, color='#333'),\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,\n        hovertext='<b>PETM - Paleocene-Eocene Thermal Maximum</b><br>'\n                  '~56 million years ago<br>'\n                  'Rapid warming of ~5-8 degC in <10,000 years<br>'\n                  'Massive carbon release (volcanic/methane)<br>'\n                  'Ocean acidification, deep-sea extinctions<br>'\n                  'Mammals diversified and spread globally<br>'\n                  'Closest ancient analog to modern warming',\n        hoverlabel=dict(bgcolor='rgba(50,50,50,0.9)', font_size=11)\n    )\n    \n    # Grande Coupure\n    fig.add_annotation(\n        x=np.log10(34.0),\n        y=8.44,\n        text='Grande Coupure<br>(Cooling begins)',\n        showarrow=True, arrowhead=2, arrowsize=1, arrowwidth=1.5, arrowcolor='#333',\n        ax=40, \n        ay=-40,\n        font=dict(size=9, color='#333'),\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,\n        hovertext='<b>Grande Coupure - The \"Great Cut\"</b><br>'\n                  '~34 million years ago (Eocene-Oligocene)<br>'\n                  'Abrupt cooling, ice sheets form on Antarctica<br>'\n                  'Drop of ~4 degC in less than 400,000 years<br>'\n                  'Opening of Drake Passage (Antarctica-S.America)<br>'\n                  'Circumpolar current isolates Antarctica<br>'\n                  'Major faunal turnover in Europe',\n        hoverlabel=dict(bgcolor='rgba(50,50,50,0.9)', font_size=11)\n    )\n    \n    # Ice Ages Begin - positioned to align with data\n    fig.add_annotation(\n        x=np.log10(2.58),  # Use log10 for log-scale x-axis\n        y=0.5,  # Adjusted y position to be closer to where data is\n        text='Ice Ages Begin',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='#333',\n        ax=0,\n        ay=-40,\n        font=dict(size=9, color='#333'),\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor='#333',\n        borderwidth=1,\n        hovertext='<b>Quaternary Ice Age Begins</b><br>'\n                  '~2.6 million years ago (Pleistocene)<br>'\n                  'Regular glacial-interglacial cycles begin<br>'\n                  '41,000-year cycles, then 100,000-year cycles<br>'\n                  'Ice sheets cover Northern Hemisphere<br>'\n                  'Human ancestors adapt to climate swings<br>'\n                  'Still in this ice age today (Holocene = warm phase)',\n        hoverlabel=dict(bgcolor='rgba(50,50,50,0.9)', font_size=11)\n    )\n    \n    # ===== DEEP TIME EVENTS (with ? hover for minimal clutter) =====\n    \n    # Cretaceous Thermal Maximum\n    fig.add_annotation(\n        x=np.log10(90),\n        y=20,\n        text='CTM',\n        showarrow=False,\n        font=dict(size=9, color='#333'),\n    #    font=dict(size=16, color='#7FC64E'),  # Cretaceous green\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,    \n    #    bgcolor='rgba(255,255,255,0.9)',\n    #    bordercolor='#7FC64E',\n    #    borderwidth=2,\n        borderpad=4,\n        hovertext='<b>Cretaceous Thermal Maximum (~90 Ma)</b><br>'\n                  'Peak Mesozoic greenhouse conditions<br>'\n                  'Global temp ~20 degC above pre-industrial<br>'\n                  'High CO2, no polar ice, warm oceans<br>'\n                  'Dinosaurs thrived in hot world',\n        hoverlabel=dict(bgcolor='rgba(127,198,78,0.9)', font_size=11)\n    )\n    \n    # Permian-Triassic Extinction\n    fig.add_annotation(\n        x=np.log10(252),\n        y=25.5,\n        text='P-T Ext.',\n        showarrow=False,\n        font=dict(size=9, color='#333'),        \n    #    font=dict(size=16, color='#F04028'),  # Permian red\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,    \n    #    bgcolor='rgba(255,255,255,0.9)',\n    #    bordercolor='#F04028',\n    #    borderwidth=2,\n        borderpad=4,\n        hovertext='<b>Permian-Triassic Extinction (~252 Ma)</b><br>'\n                  'The \"Great Dying\" - worst mass extinction<br>'\n                  '~96% of marine species extinct<br>'\n                  '~70% of terrestrial vertebrates extinct<br>'\n                  'Caused by Siberian Traps volcanism<br>'\n                  'Massive CO2 release, ocean anoxia<br>'\n                  'Global temp ~28 degC (peak hothouse)',\n        hoverlabel=dict(bgcolor='rgba(240,64,40,0.9)', font_size=11)\n    )\n    \n    # Carboniferous Icehouse\n    fig.add_annotation(\n        x=np.log10(300),\n        y=-3.5,\n        text='Icenhouse',\n        showarrow=False,\n        font=dict(size=9, color='#333'),        \n    #    font=dict(size=16, color='#67A599'),  # Carboniferous teal\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,    \n    #    bgcolor='rgba(255,255,255,0.9)',\n    #    bordercolor='#67A599',\n    #    borderwidth=2,\n        borderpad=4,\n        hovertext='<b>Carboniferous Icehouse (~300 Ma)</b><br>'\n                  'The \"Coal Age\" - vast tropical forests<br>'\n                  'Trees evolved lignin (hard to decompose)<br>'\n                  'Massive carbon burial [OK] coal deposits<br>'\n                  'Drew down atmospheric CO2<br>'\n                  'Triggered glaciation (~12 degC drop)<br>'\n                  'First forests changed the planet!',\n        hoverlabel=dict(bgcolor='rgba(103,165,153,0.9)', font_size=11)\n    )\n    \n    # Late Ordovician Glaciation\n    fig.add_annotation(\n        x=np.log10(445),\n        y=-8,\n        text='Glaciation',\n        showarrow=False,\n        font=dict(size=9, color='#333'),        \n    #    font=dict(size=16, color='#009270'),  # Ordovician green\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,    \n    #    bgcolor='rgba(255,255,255,0.9)',\n    #    bordercolor='#009270',\n    #    borderwidth=2,\n        borderpad=4,\n        hovertext='<b>Late Ordovician Glaciation (~445 Ma)</b><br>'\n                  'First major Phanerozoic icehouse<br>'\n                  'Rapid cooling to ~5 degC<br>'\n                  'Massive ice sheets on Gondwana<br>'\n                  'Sea level drop of ~100m<br>'\n                  'End-Ordovician mass extinction<br>'\n                  '~85% of marine species extinct',\n        hoverlabel=dict(bgcolor='rgba(0,146,112,0.9)', font_size=11)\n    )\n    \n    # End-Triassic Extinction (optional but you said \"all\"!)\n    fig.add_annotation(\n        x=np.log10(201),\n        y=18,\n        text='E-T Ext.',\n        showarrow=False,\n        font=dict(size=9, color='#333'),        \n    #    font=dict(size=16, color='#812B92'),  # Triassic purple\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,    \n    #    bgcolor='rgba(255,255,255,0.9)',\n    #    bordercolor='#812B92',\n    #    borderwidth=2,\n        borderpad=4,\n        hovertext='<b>End-Triassic Extinction (~201 Ma)</b><br>'\n                  'One of the \"Big Five\" mass extinctions<br>'\n                  '~75% of species extinct<br>'\n                  'Caused by CAMP volcanism<br>'\n                  '(Central Atlantic Magmatic Province)<br>'\n                  'CO2 spike, ocean acidification<br>'\n                  'Opened ecological space for dinosaurs',\n        hoverlabel=dict(bgcolor='rgba(129,43,146,0.9)', font_size=11)\n    )\n        \n\n    # Add 3.3 degC\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.0,\n        y0=3.3,\n        x1=0.94,\n        y1=3.3,\n        line=dict(\n            color=\"red\",\n            width=1,\n            dash=\"dot\"\n        )\n    )\n    \n    # Add 2.8 degC \n#    fig.add_shape(\n#        type=\"line\",\n#        xref=\"paper\",\n#        yref=\"y\",\n#        x0=0.0,\n#        y0=2.8,\n#        x1=0.94,\n#        y1=2.8,\n#        line=dict(\n#            color=\"red\",\n#            width=1,\n#            dash=\"dot\"\n#        )\n#    )\n\n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.80,\n        y=3.40,\n        text=\"Current Policies (UNEP): 2.6 degC - 3.3 degC\",\n        showarrow=False,\n        bgcolor=\"rgba(255,255,255,0)\",\n        font=dict(size=9, color='red'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n\n    # Add 2.6 degC \n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.0,\n        y0=2.6,\n        x1=0.94,\n        y1=2.6,\n        line=dict(\n            color=\"red\",\n            width=1,\n            dash=\"dot\"\n        )\n    )\n    \n#    fig.add_annotation(\n#        xref=\"paper\",\n#        yref=\"y\",\n#        x=0.82,\n#        y=3.10,\n#        text=\"2.5 degC to 2.9 degC Trajectory\",\n#        showarrow=False,\n#        bgcolor=\"rgba(255,255,255,0.8)\",\n#        font=dict(size=9, color='black'),\n#        xanchor='left',\n#        yanchor='bottom'\n#    )\n\n    # Add 1.28 degC current anomaly line - spans both plots\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.0,\n        y0=1.28,\n        x1=0.94,\n        y1=1.28,\n        line=dict(\n            color=\"green\",\n            width=1,\n            dash=\"dot\"\n        )\n    )\n    \n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.80,\n        y=1.40,\n        text=\"1.28 degC -- Current Anomaly\",\n        showarrow=False,\n        bgcolor=\"rgba(255,255,255,0)\",\n        font=dict(size=9, color='green'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n\n    # Add 0 degC baseline - spans both plots\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.0,\n        y0=0,\n        x1=0.94,\n        y1=0,\n        line=dict(\n            color=\"black\",\n            width=1,\n            dash=\"dot\"\n        )\n    )\n    \n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.80,\n        y=-1.0,\n        text=\"0 degC -- 1850 - 1900 Baseline\",\n        showarrow=False,\n        bgcolor=\"rgba(255,255,255,0)\",\n        font=dict(size=9, color='black'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n\n    info_text = (\n        \"<b>Earth's Climate History (Phanerozoic Eon, 540 Ma to Present)</b><br>\"\n        \"<br>\"\n        \"[EARTH] <b>Phanerozoic:</b> Scotese et al. 2021 (540 Ma); \"\n        \"   <i>Method: Lithologic indicators + delta^18O + models</i><br>\"\n        \"[CLOCK] <b>Paleoclimate:</b> LR04 Benthic Stack (5.3 Ma); \"\n        \"   <i>Method: Benthic foraminifera delta^18O</i><br>\"\n        \"[SNOW] <b>Younger Dryas:</b> Alley (GISP2 ice core, 2000); \"\n        \"   <i>Method: Greenland ice core delta^18O</i><br>\"\n        \"[TEMP] <b>Holocene:</b> Kaufman et al. 2020 (12 ka); \"\n        \"   <i>Method: Multi-proxy (pollen, sediments, biomarkers)</i><br>\"\n        \"[SUN] <b>Modern:</b> NASA GISS (1880-2025); \"\n        \"   <i>Method: Instrumental (thermometers, satellites)</i><br>\"\n        \"* Time Span: 540 Ma to 2100 CE<br>\"\n        \"[CHART] Baseline: Pre-industrial (1850-1900)<br>\"\n        \"<br>\"\n#        \"[INFO] <b>Overlapping curves show method differences</b> \"\n#        \"   Scientific uncertainty is normal and expected!<br>\"\n#        \"<br>\"\n        \"[*] <b>Proxy Handoffs:</b> Each dataset ends where higher-resolution methods begin<br>\"\n#        \"<br>\"\n\n#        \"* Phanerozoic 'double hump' (540 Ma)<br>\"\n#        \"* Mesozoic greenhouse (252-66 Ma)<br>\"\n#        \"* Ice age cycles (last 2.6 Ma)<br>\"\n#        \"* Holocene stability (last 12,000 years)<br>\"\n#        \"<br>\"\n        \"[*] <b>Key Insight:</b> The Holocene's stable climate \"\n        \"enabled human civilization to flourish.<br>\"\n        \"[ZOOM] <b>Use zoom to explore details!</b>\"\n    )    \n\n    fig.add_annotation(\n        text=info_text,\n        xref=\"paper\", yref=\"paper\",\n        x=0.50, y=0.95,\n        xanchor=\"left\", yanchor=\"top\",\n        bgcolor=\"rgba(255,255,255,0.9)\",\n        bordercolor=\"#2E86AB\",\n        borderwidth=2,\n        borderpad=10,\n        showarrow=False,\n        font=dict(size=10),\n        align=\"left\"\n    )\n    \n    fig.update_xaxes(\n        title_text=\"Millions of Years Before Present (Ma, logarithmic scale)\",\n        autorange=False,\n        range=[np.log10(540), np.log10(0.000001)],  # 540 Ma to ~present\n        type=\"log\",\n        showgrid=True,\n        gridwidth=1,\n        gridcolor='lightgray'\n    )   \n\n    fig.update_yaxes(\n        title_text=\"Temperature Anomaly ( degC, relative to present)\",\n        secondary_y=False,\n        showgrid=True,\n        gridwidth=1,\n        gridcolor='lightgray'\n    )\n    \n    # Layout\n    fig.update_layout(\n        title={\n            'text': \"Earth's Climate History: 540 Million Years to 2100 CE (Phanerozoic Eon)<br><sub>From Cambrian Explosion to Present</sub>\",\n            'x': 0.5,\n            'xanchor': 'center',\n            'font': {'size': 18}\n        },\n        hovermode='closest',\n        showlegend=True,\n        legend=dict(\n            x=0.94,\n            y=0.00,\n            xanchor='right',\n            yanchor='bottom',\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='#333',\n            borderwidth=1\n        ),\n        plot_bgcolor='white',\n        height=700,\n        margin=dict(t=100, b=80, l=80, r=80)\n    )\n    \n    # Add source citation\n    fig.add_annotation(\n        text=\"Data: Scotese et al. (2021) Phanerozoic | Lisiecki & Raymo (2005) LR04 | Kaufman et al. (2020) Holocene | Alley (2000) GISP2 Ice Core (YD) | NASA GISS | Paloma's Orrery\",\n        xref=\"paper\", yref=\"paper\",\n        x=0.5, y=-0.12,\n        xanchor=\"center\", yanchor=\"top\",\n        showarrow=False,\n        font=dict(size=9, color='#666')\n    )\n    \n    return fig",
    "start_line": 255,
    "end_line": 1611,
    "has_docstring": true,
    "docstring": "Create Phanerozoic paleoclimate visualization\n\nShows temperature over the past 540 million years with:\n- Geologic period shading\n- Multiple datasets: Scotese (540-5 Ma), LR04 (5-0.01 Ma), Holocene (12 ka), Modern (1880-present)\n- Zoomable to see detail from hundreds of millions of years down to millennia",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_paleoclimate_visualization",
    "component_id": "paleoclimate_visualization_full.create_paleoclimate_visualization"
  },
  "paleoclimate_visualization_full.main": {
    "id": "paleoclimate_visualization_full.main",
    "name": "main",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_visualization_full.py",
    "relative_path": "paleoclimate_visualization_full.py",
    "depends_on": [
      "paleoclimate_visualization_full.create_paleoclimate_visualization",
      "save_utils.save_plot"
    ],
    "source_code": "def main():\n    \"\"\"Test the visualization\"\"\"\n    if not PLOTLY_AVAILABLE:\n        print(\"Error: Plotly not available\")\n        return\n    \n    print(\"Creating paleoclimate visualization...\")\n    fig = create_paleoclimate_visualization()\n    \n    if fig:\n        print(\"[OK] Visualization created successfully\")\n        # Offer to save\n        save_plot(fig, \"paleoclimate_540Ma_to_present\")        \n        print(\"Opening in browser...\")\n        fig.show()\n    else:\n        print(\"[FAIL] Could not create visualization - check if data is cached\")\n        print(f\"Expected data file: {LR04_CACHE}\")",
    "start_line": 1613,
    "end_line": 1630,
    "has_docstring": true,
    "docstring": "Test the visualization",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "paleoclimate_visualization_full.main"
  },
  "paleoclimate_wet_bulb_full.date_to_age_ma": {
    "id": "paleoclimate_wet_bulb_full.date_to_age_ma",
    "name": "date_to_age_ma",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_wet_bulb_full.py",
    "relative_path": "paleoclimate_wet_bulb_full.py",
    "depends_on": [],
    "source_code": "def date_to_age_ma(date_str, reference_year=2026.0):\n    \"\"\"\n    Convert a date string (YYYY-MM-DD) to age in millions of years before present.\n    \n    Args:\n        date_str: Date in YYYY-MM-DD format\n        reference_year: Year to use as \"present\" (default 2026.0 = Jan 1, 2026)\n    \n    Returns:\n        Age in Ma (millions of years before present)\n    \"\"\"\n    from datetime import datetime\n    dt = datetime.strptime(date_str, '%Y-%m-%d')\n    # Calculate fractional year\n    year_fraction = dt.year + (dt.timetuple().tm_yday - 1) / 365.25\n    # Calculate age in years, then convert to Ma\n    age_years = reference_year - year_fraction\n    age_ma = age_years / 1_000_000\n    return max(age_ma, 0.0000001)  # Ensure positive for log scale",
    "start_line": 315,
    "end_line": 333,
    "has_docstring": true,
    "docstring": "Convert a date string (YYYY-MM-DD) to age in millions of years before present.\n\nArgs:\n    date_str: Date in YYYY-MM-DD format\n    reference_year: Year to use as \"present\" (default 2026.0 = Jan 1, 2026)\n\nReturns:\n    Age in Ma (millions of years before present)",
    "parameters": [
      "date_str",
      "reference_year"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function date_to_age_ma",
    "component_id": "paleoclimate_wet_bulb_full.date_to_age_ma"
  },
  "paleoclimate_wet_bulb_full.d18o_to_temperature_approx": {
    "id": "paleoclimate_wet_bulb_full.d18o_to_temperature_approx",
    "name": "d18o_to_temperature_approx",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_wet_bulb_full.py",
    "relative_path": "paleoclimate_wet_bulb_full.py",
    "depends_on": [],
    "source_code": "def d18o_to_temperature_approx(d18o_values):\n    \"\"\"\n    Convert benthic delta18O to approximate temperature anomaly\n    \n    This is a simplified conversion. Benthic delta18O reflects both \n    ice volume and deep ocean temperature. The relationship varies\n    over time, but rough approximation:\n    - Higher delta18O = More ice + Colder temperatures\n    - Lower delta18O = Less ice + Warmer temperatures\n    \n    Using simplified conversion: ~4-5 degC per 1 permil change\n    Normalized to show relative changes from present\n    \"\"\"\n    # Modern benthic delta18O is around 3.2 permil\n    modern_d18o = 3.23  # From LR04 data at 0 ka\n    \n    # Convert to temperature anomaly (inverted because higher delta18O = colder)\n    # Using ~4.5 degC per 1 permil as approximation\n    temp_anomaly = -(np.array(d18o_values) - modern_d18o) * 4.5\n    \n    return temp_anomaly",
    "start_line": 345,
    "end_line": 365,
    "has_docstring": true,
    "docstring": "Convert benthic delta18O to approximate temperature anomaly\n\nThis is a simplified conversion. Benthic delta18O reflects both \nice volume and deep ocean temperature. The relationship varies\nover time, but rough approximation:\n- Higher delta18O = More ice + Colder temperatures\n- Lower delta18O = Less ice + Warmer temperatures\n\nUsing simplified conversion: ~4-5 degC per 1 permil change\nNormalized to show relative changes from present",
    "parameters": [
      "d18o_values"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function d18o_to_temperature_approx",
    "component_id": "paleoclimate_wet_bulb_full.d18o_to_temperature_approx"
  },
  "paleoclimate_wet_bulb_full.load_lr04_data": {
    "id": "paleoclimate_wet_bulb_full.load_lr04_data",
    "name": "load_lr04_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_wet_bulb_full.py",
    "relative_path": "paleoclimate_wet_bulb_full.py",
    "depends_on": [],
    "source_code": "def load_lr04_data():\n    \"\"\"Load LR04 benthic stack from cache\"\"\"\n    try:\n        with open(LR04_CACHE, 'r') as f:\n            data = json.load(f)\n        return data\n    except FileNotFoundError:\n        return None\n    except json.JSONDecodeError:\n        return None",
    "start_line": 367,
    "end_line": 376,
    "has_docstring": true,
    "docstring": "Load LR04 benthic stack from cache",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_lr04_data",
    "component_id": "paleoclimate_wet_bulb_full.load_lr04_data"
  },
  "paleoclimate_wet_bulb_full.load_scotese_phanerozoic_data": {
    "id": "paleoclimate_wet_bulb_full.load_scotese_phanerozoic_data",
    "name": "load_scotese_phanerozoic_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_wet_bulb_full.py",
    "relative_path": "paleoclimate_wet_bulb_full.py",
    "depends_on": [],
    "source_code": "def load_scotese_phanerozoic_data():\n    \"\"\"\n    Load Scotese et al. (2021) Phanerozoic temperature data\n    \n    Returns global average temperatures from 540 Ma to 0 Ma\n    Based on pole-to-equator temperature reconstructions\n    \"\"\"\n    try:\n        import csv\n        \n        ages_ma = []\n        temps_global = []\n        \n        with open(SCOTESE_PHANEROZOIC, 'r', encoding='utf-8-sig') as f:\n            reader = csv.reader(f)\n            \n            # Read header row (ages)\n            header = next(reader)\n            # Remove the 'latitude/age' label and convert to float\n            age_values = [float(age) for age in header[1:]]\n            \n            # Read all latitude rows\n            temp_grid = []\n            for row in reader:\n                if row and row[0]:  # Skip empty rows\n                    try:\n                        # Skip the latitude label, convert temps to float\n                        temps = [float(t) for t in row[1:] if t]\n                        if temps:  # Only add non-empty rows\n                            temp_grid.append(temps)\n                    except (ValueError, IndexError):\n                        continue\n            \n            # Calculate global average by averaging across all latitudes for each age\n            if temp_grid:\n                # Convert to numpy for easier calculation\n                import numpy as np\n                temp_array = np.array(temp_grid)\n                \n                # Global average is mean across all latitudes (rows)\n                global_avg_temps = np.mean(temp_array, axis=0)\n                \n                ages_ma = age_values\n                temps_global = global_avg_temps.tolist()\n        \n        if ages_ma and temps_global:\n            return {\n                'ages_ma': ages_ma,\n                'temp_global': temps_global\n            }\n        return None\n        \n    except (FileNotFoundError, Exception) as e:\n        print(f\"Warning: Could not load Scotese Phanerozoic data: {e}\")\n        return None",
    "start_line": 378,
    "end_line": 432,
    "has_docstring": true,
    "docstring": "Load Scotese et al. (2021) Phanerozoic temperature data\n\nReturns global average temperatures from 540 Ma to 0 Ma\nBased on pole-to-equator temperature reconstructions",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_scotese_phanerozoic_data",
    "component_id": "paleoclimate_wet_bulb_full.load_scotese_phanerozoic_data"
  },
  "paleoclimate_wet_bulb_full.load_holocene_data": {
    "id": "paleoclimate_wet_bulb_full.load_holocene_data",
    "name": "load_holocene_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_wet_bulb_full.py",
    "relative_path": "paleoclimate_wet_bulb_full.py",
    "depends_on": [],
    "source_code": "def load_holocene_data():\n    \"\"\"Load Kaufman et al. (2020) Holocene temperature reconstruction\"\"\"\n    holocene_file = os.path.join(PALEO_DATA_DIR, 'temp12k_allmethods_percentiles.csv')\n    \n    try:\n\n        import csv\n        ages_years = []\n        temps_median = []\n        temps_5th = []\n        temps_95th = []\n        \n        with open(holocene_file, 'r') as f:\n            reader = csv.DictReader(f)\n            # Strip whitespace from fieldnames\n            reader.fieldnames = [name.strip() for name in reader.fieldnames]\n            \n            for row in reader:\n                ages_years.append(float(row['ages']))\n                temps_median.append(float(row['global_median']))\n                temps_5th.append(float(row['global_5']))\n                temps_95th.append(float(row['global_95']))\n        \n        # Convert years BP to Ma BP\n        ages_ma = [age / 1_000_000 for age in ages_years]\n        \n        return {\n            'ages_ma': ages_ma,\n            'temp_median': temps_median,\n            'temp_5th': temps_5th,\n            'temp_95th': temps_95th\n        }\n    except (FileNotFoundError, KeyError) as e:\n        print(f\"Warning: Could not load Holocene data: {e}\")\n        return None",
    "start_line": 435,
    "end_line": 469,
    "has_docstring": true,
    "docstring": "Load Kaufman et al. (2020) Holocene temperature reconstruction",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_holocene_data",
    "component_id": "paleoclimate_wet_bulb_full.load_holocene_data"
  },
  "paleoclimate_wet_bulb_full.calculate_preindustrial_offset": {
    "id": "paleoclimate_wet_bulb_full.calculate_preindustrial_offset",
    "name": "calculate_preindustrial_offset",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_wet_bulb_full.py",
    "relative_path": "paleoclimate_wet_bulb_full.py",
    "depends_on": [],
    "source_code": "def calculate_preindustrial_offset(holocene_data):\n    \"\"\"\n    Calculate offset to normalize to pre-industrial (1850-1900) baseline\n    \n    The Kaufman data is relative to 19th century. We need to find what\n    the temperature was during 1850-1900 period (roughly 75-125 years BP)\n    and use that as our zero point.\n    \"\"\"\n    if not holocene_data:\n        return 0.0\n    \n    ages_years = [age * 1_000_000 for age in holocene_data['ages_ma']]\n    temps = holocene_data['temp_median']\n    \n    # Find temperatures for 1850-1900 period (75-175 years BP to be safe)\n    preindustrial_temps = []\n    for age, temp in zip(ages_years, temps):\n        if 75 <= age <= 175:\n            preindustrial_temps.append(temp)\n    \n    if preindustrial_temps:\n        # Average of pre-industrial period\n        return np.mean(preindustrial_temps)\n    else:\n        # If we don't have data for that exact period, use closest point\n        # Find index closest to 100 years BP\n        closest_idx = min(range(len(ages_years)), \n                         key=lambda i: abs(ages_years[i] - 100))\n        return temps[closest_idx]",
    "start_line": 471,
    "end_line": 499,
    "has_docstring": true,
    "docstring": "Calculate offset to normalize to pre-industrial (1850-1900) baseline\n\nThe Kaufman data is relative to 19th century. We need to find what\nthe temperature was during 1850-1900 period (roughly 75-125 years BP)\nand use that as our zero point.",
    "parameters": [
      "holocene_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_preindustrial_offset",
    "component_id": "paleoclimate_wet_bulb_full.calculate_preindustrial_offset"
  },
  "paleoclimate_wet_bulb_full.load_modern_temperature_data": {
    "id": "paleoclimate_wet_bulb_full.load_modern_temperature_data",
    "name": "load_modern_temperature_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_wet_bulb_full.py",
    "relative_path": "paleoclimate_wet_bulb_full.py",
    "depends_on": [],
    "source_code": "def load_modern_temperature_data():\n    \"\"\"\n    Load modern instrumental temperature data to extend to present.\n    \n    Uses annual averages for 1880-2024, then monthly resolution for 2025+\n    This provides detail where the log scale has room to show it.\n    \n    Returns:\n        ages_ma: list of ages in Ma\n        temps: list of temperature anomalies\n        date_labels: list of date strings for hover display (e.g., \"2024\" or \"2025-03\")\n    \"\"\"\n    try:\n        with open('data/temperature_giss_monthly.json', 'r') as f:\n            data = json.load(f)\n        \n        records = data['data']\n        \n        # Reference year for age calculations\n        current_year = 2026\n        \n        # Threshold year: use monthly data from this year onward\n        monthly_threshold = 2025\n        \n        ages_ma = []\n        temps = []\n        date_labels = []\n        \n        # First pass: get annual averages for years before threshold\n        processed_years = set()\n        for record in records:\n            year = record['year']\n            \n            if year < monthly_threshold and year not in processed_years:\n                processed_years.add(year)\n                # Get all months for this year that have valid data\n                year_temps = [r['anomaly_c'] for r in records \n                             if r['year'] == year and r['anomaly_c'] is not None]\n                if year_temps:\n                    ages_ma.append((current_year - year) / 1_000_000)\n                    temps.append(np.mean(year_temps))\n                    date_labels.append(str(year))  # Just year for annual data\n        \n        # Second pass: add monthly data for threshold year and beyond\n        for record in records:\n            year = record['year']\n            month = record['month']\n            anomaly = record['anomaly_c']\n            \n            if year >= monthly_threshold and anomaly is not None:\n                # Calculate fractional year: year + (month - 0.5) / 12\n                # Using mid-month for positioning\n                fractional_year = year + (month - 0.5) / 12\n                age_ma = (current_year - fractional_year) / 1_000_000\n                ages_ma.append(age_ma)\n                temps.append(anomaly)\n                date_labels.append(f\"{year}-{month:02d}\")  # Year-Month for monthly data\n        \n        # Sort by age (oldest first) for proper line drawing\n        combined = sorted(zip(ages_ma, temps, date_labels), key=lambda x: -x[0])\n        ages_ma = [x[0] for x in combined]\n        temps = [x[1] for x in combined]\n        date_labels = [x[2] for x in combined]\n        \n        return ages_ma, temps, date_labels\n        \n    except (FileNotFoundError, json.JSONDecodeError) as e:\n        print(f\"Warning: Could not load modern temperature data: {e}\")\n        return None, None, None",
    "start_line": 501,
    "end_line": 569,
    "has_docstring": true,
    "docstring": "Load modern instrumental temperature data to extend to present.\n\nUses annual averages for 1880-2024, then monthly resolution for 2025+\nThis provides detail where the log scale has room to show it.\n\nReturns:\n    ages_ma: list of ages in Ma\n    temps: list of temperature anomalies\n    date_labels: list of date strings for hover display (e.g., \"2024\" or \"2025-03\")",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_modern_temperature_data",
    "component_id": "paleoclimate_wet_bulb_full.load_modern_temperature_data"
  },
  "paleoclimate_wet_bulb_full.calculate_trendline_points": {
    "id": "paleoclimate_wet_bulb_full.calculate_trendline_points",
    "name": "calculate_trendline_points",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_wet_bulb_full.py",
    "relative_path": "paleoclimate_wet_bulb_full.py",
    "depends_on": [],
    "source_code": "def calculate_trendline_points(events, num_points=50):\n    \"\"\"\n    Calculate linear regression in TIME (Years), then generate \n    many intermediate points so it plots correctly on Log-X axis.\n    \"\"\"\n    if not events: return None, None\n    \n    # 1. Extract Data\n    years = []\n    tws = []\n    for e in events:\n        dt = datetime.strptime(e['date'], '%Y-%m-%d')\n        # Use fractional year\n        yr = dt.year + (dt.timetuple().tm_yday - 1) / 365.25\n        years.append(yr)\n        tws.append(e['tw_celsius'])\n    \n    x = np.array(years)\n    y = np.array(tws)\n    \n    # 2. Linear Regression (y = mx + c)\n    A = np.vstack([x, np.ones(len(x))]).T\n    m, c = np.linalg.lstsq(A, y, rcond=None)[0]\n    \n    # 3. Generate dense range of years for smooth plotting\n    start_year = min(years)\n    end_year = 2026.0\n    year_range = np.linspace(start_year, end_year, num_points)\n    \n    # 4. Calculate Y values (Linear Trend)\n    y_trend = m * year_range + c\n    \n    # 5. Convert Years back to Age MA (for Log Plot)\n    age_ma_trend = (2026.0 - year_range) / 1_000_000\n    \n    # Ensure no zeros for log plot\n    age_ma_trend = np.maximum(age_ma_trend, 0.0000001)\n    \n    return age_ma_trend, y_trend",
    "start_line": 572,
    "end_line": 610,
    "has_docstring": true,
    "docstring": "Calculate linear regression in TIME (Years), then generate \nmany intermediate points so it plots correctly on Log-X axis.",
    "parameters": [
      "events",
      "num_points"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_trendline_points",
    "component_id": "paleoclimate_wet_bulb_full.calculate_trendline_points"
  },
  "paleoclimate_wet_bulb_full.create_paleoclimate_visualization": {
    "id": "paleoclimate_wet_bulb_full.create_paleoclimate_visualization",
    "name": "create_paleoclimate_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_wet_bulb_full.py",
    "relative_path": "paleoclimate_wet_bulb_full.py",
    "depends_on": [
      "paleoclimate_wet_bulb_full.calculate_trendline_points",
      "paleoclimate_wet_bulb_full.load_lr04_data",
      "paleoclimate_wet_bulb_full.load_modern_temperature_data",
      "paleoclimate_wet_bulb_full.d18o_to_temperature_approx",
      "paleoclimate_wet_bulb_full.load_holocene_data",
      "paleoclimate_wet_bulb_full.date_to_age_ma",
      "paleoclimate_wet_bulb_full.load_scotese_phanerozoic_data",
      "paleoclimate_wet_bulb_full.calculate_preindustrial_offset"
    ],
    "source_code": "def create_paleoclimate_visualization():\n    \"\"\"\n    Create Phanerozoic paleoclimate visualization\n    \n    Shows temperature over the past 540 million years with:\n    - Geologic period shading\n    - Multiple datasets: Scotese (540-5 Ma), LR04 (5-0.01 Ma), Holocene (12 ka), Modern (1880-present)\n    - Zoomable to see detail from hundreds of millions of years down to millennia\n    \"\"\"\n    \n    if not PLOTLY_AVAILABLE:\n        return None\n    \n    # Load all data sources\n    scotese_data = load_scotese_phanerozoic_data()\n    lr04_data = load_lr04_data()\n    holocene_data = load_holocene_data()\n    modern_ages_ma, modern_temps, modern_date_labels = load_modern_temperature_data()\n    \n    # Calculate pre-industrial baseline offset\n    preindustrial_offset = calculate_preindustrial_offset(holocene_data) if holocene_data else 0.0\n    \n    # --- Process LR04 Data ---\n    if not lr04_data:\n        return None\n    \n    records = lr04_data['data']\n    ages_ka = np.array([r['age_ka_bp'] for r in records])\n    d18o_values = np.array([r['d18o_permil'] for r in records])\n    ages_ma_lr04 = ages_ka / 1000.0\n    temp_anomaly_lr04 = d18o_to_temperature_approx(d18o_values)\n    temp_anomaly_lr04 = temp_anomaly_lr04 - preindustrial_offset\n    \n    # Filter to end at Holocene start (12 ka = 0.012 Ma)\n    # LR04 optimized for ice age cycles; Kaufman better for Holocene\n    holocene_start_ma = 0.012\n    mask_lr04 = ages_ma_lr04 >= holocene_start_ma\n    ages_ma_lr04 = ages_ma_lr04[mask_lr04]\n    temp_anomaly_lr04 = temp_anomaly_lr04[mask_lr04]\n\n    # --- Process Scotese Data ---\n    scotese_ages_ma = None\n    scotese_temps = None\n    \n    if scotese_data:\n        scotese_ages_ma = np.array(scotese_data['ages_ma'])\n        scotese_temps_raw = np.array(scotese_data['temp_global'])\n        \n        # Normalize Scotese data to match LR04 at the transition point (~5 Ma)\n        # Find Scotese value at 5 Ma\n        transition_age = 5.0\n        scotese_at_transition = np.interp(transition_age, scotese_ages_ma, scotese_temps_raw)\n        \n        # Find LR04 value at 5 Ma\n        lr04_at_transition = np.interp(transition_age, ages_ma_lr04, temp_anomaly_lr04)\n        \n        # Calculate offset to align them\n        scotese_offset = lr04_at_transition - scotese_at_transition\n        scotese_temps = scotese_temps_raw + scotese_offset\n        \n        # Filter to use Scotese data for deep time (>2 Ma)\n        # Scotese method: Lithologic indicators + Koppen belts (~5 Myr resolution)\n        # Optimized for deep time patterns, not high-resolution recent climate\n        # Use LR04/Holocene/Modern for <2 Ma (higher temporal resolution)\n        mask = scotese_ages_ma >= 2.0\n        scotese_ages_ma = scotese_ages_ma[mask]\n        scotese_temps = scotese_temps[mask]\n\n    # Create figure with secondary y-axis\n    fig = make_subplots(\n        rows=1, cols=1,\n        specs=[[{\"secondary_y\": True}]]\n    )\n    \n    # Add Scotese Phanerozoic temperature trace (540-5 Ma) - plotted first so it's behind\n    if scotese_ages_ma is not None and scotese_temps is not None:\n        fig.add_trace(\n            go.Scatter(\n                x=scotese_ages_ma,\n                y=scotese_temps,\n                mode='lines',\n                name='Phanerozoic Global Temperature (Scotese et al. 2021)',\n                line=dict(color='#003049', width=2),\n                showlegend=False,                \n                hovertemplate='Age: %{x:.1f} Ma<br>Temp Anomaly: %{y:.1f} degC<br><i>~5 Myr resolution (deep time method)</i><extra></extra>'\n            ),\n            secondary_y=False\n        )\n    \n    # Add LR04 temperature trace (5.3 Ma - 10 ka)\n    fig.add_trace(\n        go.Scatter(\n            x=ages_ma_lr04,\n            y=temp_anomaly_lr04,\n            mode='lines',\n            name='Paleoclimate Benthic Stack (Lisiecki & Raymo 2005)',\n            line=dict(color='#C1121F', width=1.5),\n            showlegend=False,            \n            hovertemplate='Age: %{x:.3f} Ma<br>Temp Anomaly: %{y:.1f} degC<extra></extra>'           \n        ),\n        secondary_y=False\n    )\n    \n    # Add Holocene reconstruction trace\n    if holocene_data:\n        # Normalize Holocene data to pre-industrial\n        holocene_temps_normalized = [t - preindustrial_offset for t in holocene_data['temp_median']]\n        \n        # Filter to end at 1880 CE (where instrumental record begins)\n        # 1880 CE = 145 years before 2025 = 0.000145 Ma\n        instrumental_start_ma = 0.000145\n        holocene_ages_filtered = []\n        holocene_temps_filtered = []\n        for age, temp in zip(holocene_data['ages_ma'], holocene_temps_normalized):\n            if age >= instrumental_start_ma:  # Older than 1880\n                holocene_ages_filtered.append(age)\n                holocene_temps_filtered.append(temp)\n\n        fig.add_trace(\n            go.Scatter(\n        #        x=holocene_data['ages_ma'],\n        #        y=holocene_temps_normalized,\n                x=holocene_ages_filtered,\n                y=holocene_temps_filtered,                \n                mode='lines',\n                name='Holocene Reconstruction (Kaufman 2020)',\n                line=dict(color=\"#2CC174\", width=2),\n                showlegend=False,                \n                hovertemplate='Age: %{x:.6f} Ma<br>Temp Anomaly: %{y:.2f} degC<extra></extra>'\n            ),\n            secondary_y=False\n        )\n\n    # ADD THIS: Add modern instrumental data\n    if modern_ages_ma and modern_temps:\n\n        # Normalize instrumental data to pre-industrial\n        # NASA GISS is relative to 1951-1980, need to shift to 1850-1900\n        # From literature: 1951-1980 was ~0.7 degC warmer than 1850-1900\n        giss_to_preindustrial_offset = 0.7\n        modern_temps_normalized = [t + giss_to_preindustrial_offset - preindustrial_offset \n                                   for t in modern_temps]\n        \n        fig.add_trace(\n            go.Scatter(\n                x=modern_ages_ma,\n                y=modern_temps,\n                mode='lines',\n                name='Instrumental Record 1880-2026 (NASA GISS)',\n                line=dict(color=\"#3586B5\", width=3),  # Bright orange-red\n                hovertemplate='Date: %{customdata}<br>Temp Anomaly: %{y:.2f} degC<extra></extra>',\n                customdata=modern_date_labels\n            ),\n            secondary_y=False\n        )\n        \n        # Add Younger Dryas regional temperature bands\n        # Shows spatial heterogeneity: different regions experienced different cooling\n        # Based on paleoclimate reconstructions and ice core data\n        \n        yd_start = 0.0129  # 12,900 years ago\n        yd_end = 0.0117    # 11,700 years ago\n        \n        # Band 1: Global average cooling (~0.5-1.5 degC)\n        # Subtle signal when averaged over entire planet\n        fig.add_trace(\n            go.Scatter(\n                x=[yd_start, yd_start, yd_end, yd_end, yd_start],\n                y=[0, -1.5, -1.5, 0, 0],\n                fill='toself',\n                fillcolor='rgba(0,206,209,0.1)',  # Very light turquoise\n                line=dict(width=0),\n                mode='lines',\n                name='YD Global (~1 degC)',\n                showlegend=False,\n                hovertemplate='Younger Dryas (Global)<br>Estimated: 0.5-1.5 degC cooling<br><i>Global average signal</i><extra></extra>'\n            ),\n            secondary_y=False\n        )\n        \n        # Band 2: Northern Hemisphere mid-latitudes (Europe & North America, ~2-6 degC)\n        # Regional cooling where most humans lived\n        fig.add_trace(\n            go.Scatter(\n                x=[yd_start, yd_start, yd_end, yd_end, yd_start],\n                y=[-2, -6, -6, -2, -2],\n                fill='toself',\n                fillcolor='rgba(0,206,209,0.4)',  # Medium turquoise\n                line=dict(width=0),\n                mode='lines',\n                name='YD Regional (~4 degC)',\n                showlegend=False,\n                hovertemplate='Younger Dryas (Regional)<br>Europe & North America: 2-6 degC cooling<br><i>Mid-latitude Northern Hemisphere</i><extra></extra>'\n            ),\n            secondary_y=False\n        )\n        \n        # Band 3: Greenland/North Atlantic extreme (~8-10 degC)\n        # Maximum regional impact from ice core records\n        fig.add_trace(\n            go.Scatter(\n                x=[yd_start, yd_start, yd_end, yd_end, yd_start],\n                y=[-8, -10, -10, -8, -8],\n                fill='toself',\n                fillcolor='rgba(0,206,209,0.9)',  # Darker turquoise\n                line=dict(width=0),\n                mode='lines',\n                name='YD Greenland (~9 degC)',\n                showlegend=False,\n                hovertemplate='Younger Dryas (Greenland)<br>GISP2 ice core: 8-10 degC cooling<br><i>Maximum regional impact</i><extra></extra>'\n            ),\n            secondary_y=False\n        )\n\n        # ============================================================\n        # MARINE ISOTOPE STAGES (MIS) - Pleistocene Climate Pulses\n        # Vertical bands showing glacial (cold/blue) and interglacial\n        # (warm/red) periods that controlled migration corridors\n        # ============================================================\n        \n        for mis in MIS_STAGES:\n            # Different colors for warm (interglacial) vs cold (glacial)\n            if mis['type'] == 'warm':\n                color = \"rgba(255, 99, 71, 0.12)\"  # Tomato, subtle\n            else:\n                color = \"rgba(100, 149, 237, 0.12)\"  # Cornflower blue, subtle\n            \n            fig.add_vrect(\n                x0=mis['start_ma'], x1=mis['end_ma'],\n                fillcolor=color,\n                layer=\"below\",\n                line_width=0,\n            )\n            \n            # Add hoverable annotation at top of each MIS band\n            mid_x = (mis['start_ma'] + mis['end_ma']) / 2\n            fig.add_trace(\n                go.Scatter(\n                    x=[mid_x],\n                    y=[8.5],  # Near top of chart\n                    mode='markers',\n                    marker=dict(\n                        symbol='diamond' if mis['type'] == 'warm' else 'square',\n                        size=8,\n                        color='rgba(255, 99, 71, 0.7)' if mis['type'] == 'warm' else 'rgba(100, 149, 237, 0.7)',\n                        line=dict(width=1, color='white')\n                    ),\n                    hovertemplate=(\n                        f\"<b>{mis['name']}</b><br>\"\n                        f\"<b>{mis['start_ma']*1000:.0f} - {mis['end_ma']*1000:.0f} ka</b><br>\"\n                        f\"{mis['note']}\"\n                        \"<extra></extra>\"\n                    ),\n                    showlegend=False\n                ),\n                secondary_y=False\n            )\n        \n        # Add special climate events (Toba, Green Sahara windows)\n        for event in CLIMATE_EVENTS:\n            # Different markers for different event types\n            if event['type'] == 'catastrophe':\n                symbol = 'triangle-down'\n                color = 'rgba(255, 0, 0, 0.8)'\n                size = 12\n            else:  # corridor\n                symbol = 'star'\n                color = 'rgba(34, 139, 34, 0.8)'\n                size = 10\n            \n            fig.add_trace(\n                go.Scatter(\n                    x=[event['age_ma']],\n                    y=[7.5],  # Slightly below MIS markers\n                    mode='markers',\n                    marker=dict(\n                        symbol=symbol,\n                        size=size,\n                        color=color,\n                        line=dict(width=1, color='white')\n                    ),\n                    hovertemplate=(\n                        f\"<b>{event['name']}</b><br>\"\n                        f\"<b>{event['age_ma']*1000:.0f} ka</b><br>\"\n                        f\"{event['note']}\"\n                        \"<extra></extra>\"\n                    ),\n                    showlegend=False\n                ),\n                secondary_y=False\n            )\n\n        # ============================================================\n        # HOMININ EVOLUTION MARKERS\n        # Small triangle markers at bottom of chart showing earliest\n        # evidence for key hominoid/hominin species\n        # \n        # Two marker types:\n        #   - Filled triangles: fossil-confirmed species\n        #   - Open triangles: ghost populations (DNA-only evidence)\n        #\n        # Markers use manual y_offset values defined in HOMININ_SPECIES\n        # for precise control over vertical positioning.\n        # ============================================================\n        \n        # Base y-position\n        base_y_position = -10.0\n        \n        # Build y-positions from manual offsets\n        species_y_positions = {\n            sp['name']: base_y_position + sp.get('y_offset', 0.0)\n            for sp in HOMININ_SPECIES\n        }\n        \n        # Separate fossil-confirmed from ghost populations\n        fossil_species = [sp for sp in HOMININ_SPECIES if sp.get('evidence', 'fossil') == 'fossil']\n        ghost_species = [sp for sp in HOMININ_SPECIES if sp.get('evidence') == 'dna_only']\n        \n        # Add faint vertical lines from each marker down to x-axis (all species)\n        for sp in HOMININ_SPECIES:\n            # Use slightly different line style for ghost populations\n            line_alpha = 0.2 if sp.get('evidence') == 'dna_only' else 0.3\n            marker_y = species_y_positions[sp['name']]\n            fig.add_shape(\n                type=\"line\",\n                x0=sp['age_ma'],\n                y0=marker_y,\n                x1=sp['age_ma'],\n                y1=9.5,  # Extend to top of chart area\n                line=dict(\n                    color=f\"rgba(128, 128, 128, {line_alpha})\",\n                    width=1,\n                    dash=\"dot\"\n                ),\n                xref=\"x\",\n                yref=\"y\"\n            )\n        \n        # Add FOSSIL-CONFIRMED species (filled triangles)\n        if fossil_species:\n            fossil_ages = [sp['age_ma'] for sp in fossil_species]\n            fossil_y = [species_y_positions[sp['name']] for sp in fossil_species]\n            fossil_names = [sp['name'] for sp in fossil_species]\n            fossil_notes = [sp['note'] for sp in fossil_species]\n            \n            fig.add_trace(\n                go.Scatter(\n                    x=fossil_ages,\n                    y=fossil_y,\n                    mode='markers',\n                    marker=dict(\n                        symbol='triangle-up',\n                        size=10,\n                        color='rgba(70, 70, 70, 0.7)',\n                        line=dict(width=1, color='#333')\n                    ),\n                    hovertemplate=(\n                        '<b>%{customdata[0]}</b><br>'\n                        '<b>%{customdata[1]:.2f} Ma</b><br>'\n                        '%{customdata[2]}'\n                        '<extra></extra>'\n                    ),\n                    customdata=[[name, age, note] for name, age, note in \n                               zip(fossil_names, fossil_ages, fossil_notes)],\n                    name='Hominin species earliest evidence (fossil)',\n                    showlegend=True\n                ),\n                secondary_y=False\n            )\n        \n        # Add GHOST POPULATIONS (open triangles)\n        if ghost_species:\n            ghost_ages = [sp['age_ma'] for sp in ghost_species]\n            ghost_y = [species_y_positions[sp['name']] for sp in ghost_species]\n            ghost_names = [sp['name'] for sp in ghost_species]\n            ghost_notes = [sp['note'] for sp in ghost_species]\n            \n            fig.add_trace(\n                go.Scatter(\n                    x=ghost_ages,\n                    y=ghost_y,\n                    mode='markers',\n                    marker=dict(\n                        symbol='triangle-up-open',  # Open triangle\n                        size=11,\n                        color='rgba(100, 100, 100, 0.9)',\n                        line=dict(width=2, color='#555')\n                    ),\n                    hovertemplate=(\n                        '<b>%{customdata[0]}</b><br>'\n                        '<b>Split time: ~%{customdata[1]:.1f} Ma</b><br>'\n                        '%{customdata[2]}'\n                        '<extra></extra>'\n                    ),\n                    customdata=[[name, age, note] for name, age, note in \n                               zip(ghost_names, ghost_ages, ghost_notes)],\n                    name='\"Ghost\" populations earliest evidence (DNA only)',\n                    showlegend=True\n                ),\n                secondary_y=False\n            )\n        \n        # Add legend entries for MIS stages\n        # Warm/Interglacial legend entry\n        fig.add_trace(\n            go.Scatter(\n                x=[None], y=[None],\n                mode='markers',\n                marker=dict(symbol='diamond', size=10, color='rgba(255, 99, 71, 0.7)'),\n                name='Marine Isotope Stages (MIS) - Warm',\n                showlegend=True\n            ),\n            secondary_y=False\n        )\n        # Cold/Glacial legend entry\n        fig.add_trace(\n            go.Scatter(\n                x=[None], y=[None],\n                mode='markers',\n                marker=dict(symbol='square', size=10, color='rgba(100, 149, 237, 0.7)'),\n                name='Marine Isotope Stages (MIS) - Cold',\n                showlegend=True\n            ),\n            secondary_y=False\n        )\n        # Climate events legend entry\n        fig.add_trace(\n            go.Scatter(\n                x=[None], y=[None],\n                mode='markers',\n                marker=dict(symbol='star', size=10, color='rgba(34, 139, 34, 0.8)'),\n                name='Climate Windows',\n                showlegend=True\n            ),\n            secondary_y=False\n        )\n\n    # --- INSERT THIS BLOCK BEFORE THE HEAT WAVE DOTS ARE PLOTTED ---\n        if HEAT_WAVE_EVENTS:\n            trend_ages, trend_tws = calculate_trendline_points(HEAT_WAVE_EVENTS)\n            if trend_ages is not None:\n                fig.add_trace(\n                    go.Scatter(\n                        x=trend_ages,\n                        y=trend_tws,\n                        mode='lines',\n                        name='Trend of Wet-Bulb Extremes',\n                        line=dict(color='rgba(255, 69, 0, 0.7)', width=4, dash='dot'), # Orange-red dashed\n                        hovertemplate='<b>Trend of Wet-Bulb Extremes</b><br>'\n                        'Linear fit (1948-2025), displayed on a logarithmic time axis.<br><br>' \n\n                        '<i>Indicative trend showing the rising upper envelope of<br>' \n                        'observed human-experienced wet-bulb heat events.</i><br><br>' \n\n                        'This line is not a climatological mean or a prediction.<br>' \n                        'It reflects where record wet-bulb stress has been measured<br>' \n                        'or inferred near major population centers, conditioned by<br>'\n                        'observation density, adaptation, and reporting.<br><br>'\n\n                        'This trend represents exposure-weighted records, not global<br>' \n                        'maxima, and should be interpreted as a qualitative signal<br>' \n                        'rather than a statistical model.<br><br>' \n\n                        'Early decades appear sparse due to limited humidity data,<br>' \n                        'weaker global monitoring, and mid-20th-century aerosol cooling.<br><br>' \n\n                        'The significance of the trend is directional: the physiological<br>' \n                        'ceiling of human exposure is rising and approaching known<br>' \n                        'biological limits.<extra></extra>',\n                        showlegend=True\n                    ),\n                    secondary_y=True\n                )\n                \n                # Add Annotation Label for the Line\n                fig.add_annotation(\n                    x=np.log10(0.00001), # Position near 2016\n                    y=trend_tws[-1],     # Height of the line end\n                    xref=\"x\", yref=\"y2\",\n                    text=\"<b>Trend of Record Extremes</b>\",\n                    showarrow=True,\n                    arrowhead=2,\n                    ax=-40, ay=-25,\n                    font=dict(size=9, color=\"#060200\"),\n                    bgcolor='rgba(255,255,255,0.0)'\n                )\n        # --- END INSERT ---\n\n        # =====================================================================\n        # EXTREME HEAT WAVE MARKERS\n        # Plot wet bulb temperature (Tw) events on the absolute temperature scale\n        # These show real human-experienced temperatures during extreme events\n        # =====================================================================\n        if HEAT_WAVE_EVENTS:\n            # Calculate age_ma for each event from its date\n            hw_ages = [date_to_age_ma(e['date']) for e in HEAT_WAVE_EVENTS]\n            # Use absolute Tw values since we're plotting on secondary (absolute) axis\n            hw_tws = [e['tw_celsius'] for e in HEAT_WAVE_EVENTS]\n            hw_names = [e['name'] for e in HEAT_WAVE_EVENTS]\n            hw_locations = [e['location'] for e in HEAT_WAVE_EVENTS]\n            hw_notes = [e['note'] for e in HEAT_WAVE_EVENTS]\n            hw_dates = [e['date'] for e in HEAT_WAVE_EVENTS]\n            \n            fig.add_trace(\n                go.Scatter(\n                    x=hw_ages,\n                    y=hw_tws,  # Absolute temperature for secondary axis\n                    mode='markers',\n                    marker=dict(\n                        symbol='circle',\n                        size=10,\n                        color='rgba(255, 0, 0, 0.8)',\n                        line=dict(width=1, color='darkred')\n                    ),\n                    hovertemplate=(\n                        '<b>%{customdata[0]}</b><br>'\n                        '<b>%{customdata[1]}</b><br>'\n                        'Date: %{customdata[5]}<br>'\n                        'Wet Bulb Temp: %{customdata[2]:.1f} degC<br>'\n                        '(Survivability range: 31-35 degC Tw)<br>'\n                        '%{customdata[3]}'\n                        '<extra></extra>'\n                    ),\n                    customdata=[[name, loc, tw, note, age, date] for name, loc, tw, note, age, date in \n                               zip(hw_names, hw_locations, hw_tws, hw_notes, hw_ages, hw_dates)],\n                    name='Extreme Heat Events (Wet Bulb Temp)',\n                    showlegend=True\n                ),\n                secondary_y=True  # Plot on absolute temperature axis (right side)\n            )\n        \n        # Add survivability threshold RANGE (31-35 degC) as shaded band\n        # 31 degC = biological limit (Vecellio et al., 2022)\n        # 35 degC = theoretical thermodynamic limit (Sherwood & Huber, 2010)\n        surv_bio_anomaly = TW_SURVIVABILITY_BIOLOGICAL - BASELINE_ABSOLUTE_TEMP  # 31 - 14 = 17\n        surv_theo_anomaly = TW_SURVIVABILITY_THEORETICAL - BASELINE_ABSOLUTE_TEMP  # 35 - 14 = 21\n        \n        # Shaded band for survivability range\n        fig.add_shape(\n            type=\"rect\",\n            xref=\"paper\",\n            yref=\"y\",\n            x0=0.0,\n            y0=surv_bio_anomaly,\n            x1=0.94,\n            y1=surv_theo_anomaly,\n            fillcolor=\"rgba(139, 0, 0, 0.15)\",  # Dark red, semi-transparent\n            line=dict(width=0),\n            layer=\"below\"\n        )\n        \n        # Lower boundary line (31 degC - biological limit)\n        fig.add_shape(\n            type=\"line\",\n            xref=\"paper\",\n            yref=\"y\",\n            x0=0.0,\n            y0=surv_bio_anomaly,\n            x1=0.94,\n            y1=surv_bio_anomaly,\n            line=dict(\n                color=\"darkred\",\n                width=2,\n                dash=\"dash\"\n            )\n        )\n        \n        # Upper boundary line (35 degC - theoretical limit)\n        fig.add_shape(\n            type=\"line\",\n            xref=\"paper\",\n            yref=\"y\",\n            x0=0.0,\n            y0=surv_theo_anomaly,\n            x1=0.94,\n            y1=surv_theo_anomaly,\n            line=dict(\n                color=\"black\",\n                width=2,\n                dash=\"dot\"\n            )\n        )\n        \n        # Annotation for the range\n        fig.add_annotation(\n            xref=\"paper\",\n            yref=\"y\",\n            x=0.60,\n            y=surv_theo_anomaly + 0.3,\n            text=\"35 degC Tw -- Fatal within hours, even in shade (Sherwood & Huber, 2010)\",\n            showarrow=False,\n            bgcolor=\"rgba(255,255,255,0.0)\",\n            font=dict(size=8, color='black'),\n            xanchor='left',\n            yanchor='bottom'\n        )\n        \n        fig.add_annotation(\n            xref=\"paper\",\n            yref=\"y\",\n            x=0.60,\n            y=surv_bio_anomaly + 0.3,\n            text=\"31 degC Tw -- Core body temp rises uncontrollably (Vecellio et al., 2022)\",\n            showarrow=False,\n            bgcolor=\"rgba(255,255,255,0.0)\",\n            font=dict(size=8, color='darkred'),\n            xanchor='left',\n            yanchor='bottom'\n        )\n\n        # Mark 2025 with a normal black vertical line (not bold red)\n    #    fig.add_vline(\n    #        x=0.000001,  # 1 year before 2026 = 2025\n    #        line_dash=\"solid\",\n    #        line_color=\"black\",\n    #        line_width=1\n    #    )\n        \n        # =====================================================================\n        # RECENT YEAR MARKERS - Minor ticks for recent years\n        # Styled consistently with major labels (2015, 1925, etc.)\n        # Using 2-digit format for minor ticks (24, 23, 22, etc.)\n        # Reference year is 2026, so age_ma = (2026 - year) / 1,000,000\n        # =====================================================================\n        minor_year_ticks = [\n            # Recent years (2-digit labels)\n    #        {'label': '26', 'age_ma': 0.0000001},   # 2026 - ~5 weeks\n    #        {'label': '25', 'age_ma': 0.000001},    # 2025 - 1 year\n            {'label': '24', 'age_ma': 0.000002},    # 2024 - 2 years\n            {'label': '23', 'age_ma': 0.000003},    # 2023 - 3 years\n            {'label': '22', 'age_ma': 0.000004},    # 2022 - 4 years\n            {'label': '21', 'age_ma': 0.000005},    # 2021 - 5 years\n            {'label': '20', 'age_ma': 0.000006},    # 2020 - 6 years\n            {'label': '10', 'age_ma': 0.000016},    # 2010 - 16 years\n            {'label': '05', 'age_ma': 0.000021},    # 2005 - 21 years\n            {'label': '00', 'age_ma': 0.000026},    # 2000 - 26 years\n            {'label': '90', 'age_ma': 0.000036},    # 1990 - 36 years\n        ]\n        \n        for tick in minor_year_ticks:\n            fig.add_annotation(\n                x=np.log10(tick['age_ma']),\n                xref='x',\n                y=1.0,  # Same level as 2015, 1925 labels\n                yref='paper',\n                text=tick['label'],\n                showarrow=False,\n                font=dict(size=8, color='gray'),\n                xanchor='center',\n                yanchor='bottom'\n            )\n\n        # =====================================================================\n        # RECENT HEAT EVENTS - Reference to Earth System Controller\n        # Add this after the existing annotations (around line 1765)\n        # =====================================================================\n\n        # Recent Heat Events marker (clusters all modern events)\n        fig.add_annotation(\n            x=np.log10(0.000005),  # visible near right edge\n            y=25.0,  \n            text='VIEW RECENT EXTREME WET-BULB HEAT EVENTS',\n            showarrow=False,\n            font=dict(size=9, color='#FF4500'),  # Orange-red\n            bgcolor='rgba(255,255,255,0.9)',\n            bordercolor='#FF4500',\n            borderwidth=2,\n            borderpad=4,\n            hovertext='<b>View Recent Wet-Bulb Heat Events in Google Earth</b><br>'\n                    '<br>'\n                #    '1995: Chicago Heat Wave (739 deaths)<br>'\n                #    '2003: Europe Heat Wave (70,000+ deaths)<br>'\n                #    '2021: Pacific NW Heat Dome (1,200+ deaths)<br>'\n                #    '2022: China Yangtze Basin (70-day event)<br>'\n                #    '2023: Amazon \"Boiling River\"<br>'\n                #    '2024: Mali/Sahel, Delhi Heat Belt, Persian Gulf<br>'\n                #    '2025: Pakistan Heat Wave<br>'\n                #    '<br>'\n                    '<b>KML layers available in data/ folder</b><br>'\n                    'Use KML Layer Controller in Earth System Visualization to open<br>'\n                    'Note: Google Earth Pro preinstalled required to open KML files<br>'\n                    'All the below events have KML layers except the 1936 Dust Bowl.',\n            hoverlabel=dict(bgcolor='rgba(255,69,0,0.9)', font_size=11, font_color='white')\n        )\n\n        # Add annotation for now (2026) - major label\n        fig.add_annotation(\n            x=np.log10(0.0000001),  # 1 years before 2026\n            xref='x',            \n            y=1.0,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"2026\",\n            showarrow=False,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>2026 CE</b><br>',\n            hoverlabel=dict(bgcolor='rgba(100,100,100,0.9)', font_size=11)\n        )\n\n        # Add annotation for 1 years ago (2025) - major label\n        fig.add_annotation(\n            x=np.log10(0.000001),  # 1 years before 2026\n            xref='x',            \n            y=1.0,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"2025\",\n            showarrow=False,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>2025 CE</b><br>'\n                      'Global temp: +1.2 degC above pre-industrial<br>'\n                      'Hottest year on record (at the time)<br>',\n            hoverlabel=dict(bgcolor='rgba(100,100,100,0.9)', font_size=11)\n        )\n\n        # Add annotation for 10 years ago (2015) - major label\n        fig.add_annotation(\n            x=np.log10(0.000011),  # 11 years before 2026\n            xref='x',            \n            y=1.0,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"2015\",\n            showarrow=False,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>2015 CE</b><br>'\n                      'Year of Paris Climate Agreement<br>'\n                      'Global temp: +1.0 degC above pre-industrial<br>'\n                      'Hottest year on record (at the time)<br>'\n                      '196 nations commit to climate action<br>'\n                      'Beginning of renewable energy surge',\n            hoverlabel=dict(bgcolor='rgba(100,100,100,0.9)', font_size=11)\n        )\n\n        # Add annotation for 100 years ago (1925) - positioned at far right\n        fig.add_annotation(\n            x=np.log10(0.0001),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.0,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"1925\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>1925 CE</b><br>'\n                      'The Roaring Twenties<br>'\n                      'Global temp: ~0.1 degC above pre-industrial<br>'\n                      'World population: 2 billion<br>'\n                      'Early automobile age begins<br>'\n                      'CO2 starting to rise from coal use<br>'\n                      'Beginning of modern warming signal',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )\n\n        # Add annotation for 1000 years ago (1025) - positioned at far right\n        fig.add_annotation(\n            x=np.log10(0.001),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"1025\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>1025 CE (Medieval Period)</b><br>'\n                      'Height of Medieval Warm Period<br>'\n                      'Vikings settled Greenland<br>'\n                      'Stable Holocene climate continues<br>'\n                      'Global temp within Holocene range<br>'\n                      'Agriculture thriving across Europe/Asia<br>'\n                      'Pre-industrial baseline conditions',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )  \n\n        # Add annotation for 10,000 years ago (10,000 bce) - positioned at far right\n        fig.add_annotation(\n            x=np.log10(0.01),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"10,000 BCE\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>10,000 BCE</b><br>'\n                      'End of last Ice Age<br>'\n                      'Beginning of Holocene interglacial<br>'\n                      'Agricultural Revolution begins<br>'\n                      'Humans start farming in Fertile Crescent<br>'\n                      'Climate stability enables civilization<br>'\n                      'World population: ~5 million',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )                       \n\n        # Add annotation for 100,000 years ago (100,000 bce) - positioned at far right\n        fig.add_annotation(\n            x=np.log10(0.1),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"100,000 BCE\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>100,000 BCE</b><br>'\n                      'Deep in Pleistocene Ice Age<br>'\n                      'Modern humans in Africa<br>'\n                      'Neanderthals in Europe<br>'\n                      'Sea levels ~100m lower than today<br>'\n                      'Massive ice sheets cover continents<br>'\n                      'Temp ~5-10 degC colder than present',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )  \n\n        # Add annotation for 1,000,000 years ago (1,000,000 bce) - positioned at far right\n        fig.add_annotation(\n            x=np.log10(1.0),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"1 million BCE (1 Ma)\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>1 Million Years Ago</b><br>'\n                      'Early Pleistocene Ice Age<br>'\n                      'Homo erectus using fire<br>'\n                      '100,000-year glacial cycles begin<br>'\n                      'Ice sheets grow and retreat<br>'\n                      'Human ancestors adapting to change<br>'\n                      'Stone tool technology advancing',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )  \n\n        # Add annotation for 10 Ma years ago - positioned at far right\n        fig.add_annotation(\n            x=np.log10(10),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"10 Ma\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>10 Million Years Ago</b><br>'\n                      'Late Miocene Epoch<br>'\n                      'Grasslands expanding worldwide<br>'\n                      'Great apes diversifying in Africa<br>'\n                      'Antarctica fully ice-covered<br>'\n                      'Global cooling trend underway<br>'\n                      'Modern ocean circulation patterns form',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        )\n\n        # Add annotation for 100 Ma years ago - positioned at far right\n        fig.add_annotation(\n            x=np.log10(100),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"100 Ma\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>100 Million Years Ago</b><br>'\n                      'Mid-Cretaceous greenhouse world<br>'\n                      'Dinosaurs at peak diversity<br>'\n                      'No polar ice caps<br>'\n                      'Sea levels 200m higher than today<br>'\n                      'CO2 ~4x higher than pre-industrial<br>'\n                      'Temp ~10 degC warmer than present',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        ) \n\n        # Add annotation for 540 Ma years ago - positioned at far right\n        fig.add_annotation(\n            x=np.log10(540),  # Use log10 for log-scale x-axis\n            xref='x',            \n            y=1.00,  # Use relative positioning (top of plot)\n            yref=\"paper\",\n            text=\"<540 Ma\",\n            showarrow=False,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=2,\n            arrowcolor='red',\n            ax=0,\n            ay=-40,\n            font=dict(size=10, color='red'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='red',\n            borderwidth=1,\n            hovertext='<b>Phanerozoic Eon (0.538 billion years)</b><br>'\n                      'Beginning of Cambrian Period 538.8 million years ago. Cambrian Explosion of life.<br>'\n                      'First animals with shells. Trilobites, early fish appear. Complex ecosystems emerge.<br><br>'\n                      '<b>Proterozoic Eon (2.0 billion years)</b><br>'\n                      '2.5 Billion Years Ago (Ga) to 538.8 Million Years Ago (Ma)<br>'\n                      'Great Oxidation Event. Complex (eukaryotic) cells. Assembly and breakup of supercontinents.<br>' \n                      'First large, soft-bodied multicellular animals (Ediacaran biota).<br><br>'\n                      '<b>Archean Eon (1.5 billion years)</b><br>'\n                      '4.0 Ga to 2.5 Ga<br>'\n                      'Formation of the first continental crust (cratons), the cooling of the planet, and the<br>' \n                      'origin of life (represented by microbial fossils like stromatolites).<br><br>'\n                      '<b>Hadean Eon (0.5 billion years)</b><br>'\n                      '4.54 Ga to 4.0 Ga<br>'\n                      'Earth\\'s formation (4.54 Ga). Intense meteorite bombardment.<br>' \n                      'Initial differentiation of the planet\\'s core, mantle, and crust.',\n            hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n        ) \n\n# Add geologic period shading - use actual Ma values, not log\n    for period in GEOLOGIC_PERIODS:\n        # Use the actual Ma values - the log axis will transform them\n        fig.add_shape(\n            type=\"rect\",\n            xref=\"x\",\n            yref=\"paper\",\n            x0=period['start'],  # Use actual value, not log!\n            y0=0,\n            x1=period['end'],     # Use actual value, not log!\n            y1=1,\n            fillcolor=period['color'],\n            opacity=0.2,\n            layer=\"below\",\n            line_width=0\n        )\n        \n        # Calculate midpoint and width in log space for label positioning\n        start_log = np.log10(period['start'])\n        end_log = np.log10(period['end'])\n        midpoint_log = (start_log + end_log) / 2\n        period_width = abs(start_log - end_log)\n        \n        # Adjust font size based on period width\n        if period_width > 0.3:\n            font_size = 10\n            opacity = 1.0\n        elif period_width > 0.15:\n            font_size = 8\n            opacity = 0.9\n        else:\n            font_size = 7\n            opacity = 0.8\n        \n        # But for annotations, we still need log space\n        fig.add_annotation(\n            x=midpoint_log,\n            xref=\"x\",\n            y=1.02,\n            yref=\"paper\",\n            text=period['name'],\n            showarrow=False,\n            font=dict(size=font_size, color='#333'),\n            textangle=-45,\n            xanchor='left',\n            yanchor='bottom',\n            opacity=opacity\n        )\n\n\n    # Add era labels (broader time divisions)\n    eras = [\n        {'name': 'Precambrian', 'start': 4500, 'end': 541, 'color': '#8B4789'},\n        {'name': 'Paleozoic', 'start': 541, 'end': 252.2, 'color': '#7FA056'},\n        {'name': 'Mesozoic', 'start': 252.2, 'end': 66.0, 'color': '#34B2C9'},\n        {'name': 'Cenozoic', 'start': 66.0, 'end': 0.0000001, 'color': '#FD9A52'}\n    ]\n    \n    \"\"\"\n    # Add Phanerozoic Eon label (spans Paleozoic + Mesozoic + Cenozoic)\n    # Calculate midpoint across all three Phanerozoic eras\n    phanerozoic_start = 541  # Beginning of Cambrian\n    phanerozoic_end = 0.0000001  # Present (2026)\n    phanerozoic_midpoint_log = (np.log10(phanerozoic_start) + np.log10(phanerozoic_end)) / 2\n    \n    fig.add_annotation(\n        x=phanerozoic_midpoint_log,\n        y=1.065,  # Position above era labels\n        yref=\"paper\",\n        text=\"<b>PHANEROZOIC EON (540 Ma - Present)</b>\",\n        showarrow=False,\n        font=dict(size=14, color='#2C5F2D'),  # Dark green\n        xanchor='center',\n        yanchor='bottom',\n        bgcolor='rgba(255,255,255,0.7)',\n        bordercolor='#2C5F2D',\n        borderwidth=2,\n        borderpad=4\n    )\n    \"\"\"\n    \n    for era in eras:\n        # Calculate midpoint in log space\n        midpoint_log = (np.log10(era['start']) + np.log10(era['end'])) / 2\n        \n        fig.add_annotation(\n            x=midpoint_log,\n            y=1.00,  # Position above the period labels\n            yref=\"paper\",\n            text=f\"<b>{era['name']}</b>\",\n            showarrow=False,\n            font=dict(size=12, color=era['color']),\n            xanchor='center',\n            yanchor='bottom'\n        )\n\n    # Mark the Holocene explicitly\n    fig.add_trace(\n        go.Scatter(\n            x=[0.0117, 0.0117],\n    #        y=[temp_anomaly_lr04.min(), temp_anomaly_lr04.max()],\n            y=[-13.0, 0.0],            \n            mode='lines',\n            name='Holocene Begins (11.7 ka)',\n            line=dict(color='green', width=2, dash='dash'),\n            showlegend=False,\n            hoverinfo='skip'\n        ),\n        secondary_y=False\n    )\n    \n    # ax=0, ay=-40 [OK] Straight down [DOWN]\n    # ax=40, ay=0 [OK] Straight right [RIGHT]\n    # ax=40, ay=-60 [OK] Diagonal up-right [UP-RIGHT]\n    # ax=-40, ay=40 [OK] Diagonal down-left [DOWN-LEFT]\n\n    # Anthropocene (recent, so use arrow like others)\n    fig.add_annotation(\n        x=np.log10(0.000075),  # 1950 CE is 75 years ago\n        y=0.0,\n        text='Proposed Anthropocene<br>(after 1950 CE)',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='red',\n        ax=28,\n        ay=-70,\n        font=dict(size=9, color='red'),\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor='red',\n        borderwidth=1,\n        hovertext='<b>Proposed Anthropocene Epoch</b><br>'\n                  'Proposed start: 1950 CE (Great Acceleration)<br>'\n                  'Human activity dominates Earth system<br>'\n                  'Nuclear testing, plastic, concrete markers<br>'\n                  'CO2 rising faster than any natural event<br>'\n                  'Sixth mass extinction underway<br>'\n                  'Geologists debate: new epoch or event?',\n        hoverlabel=dict(bgcolor='rgba(220,20,60,0.9)', font_size=11)\n    )\n\n    # Origin of Humanity - about 350 to 160,000 years ago\n    # Add visual period marker (blue shaded region showing event duration)\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"paper\",\n        x0=0.350,  # 350,000 ya\n        x1=0.160,  # 160,000 ya\n        y0=0,\n        y1=1,\n    #    fillcolor='#00D188,0.3', \n        fillcolor='rgba(0, 209, 136,0.1)',\n        line=dict(width=0),\n        layer=\"below\"\n    )\n    \n    fig.add_annotation(\n        x=np.log10(0.25),  \n        y=-12.0,\n        text='Origin of Humanity',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor=\"#00D188\",  \n        ax=0,\n        ay=0, \n        font=dict(size=9, color='#00D188'),\n        bgcolor='rgba(0, 209, 136,0)',\n        bordercolor='#00D188',\n        borderwidth=1,          \n        hovertext='<b>Origin of Humanity (350,000-160,000 years ago)</b><br>'\n        'The generally accepted range for the origin of Homo sapiens is between 300,000 and 200,000 years ago,<br>' \n        'although recent discoveries continually push the minimum date back. This range is based on the oldest<br>' \n        'widely recognized fossil evidence, all found in Africa.<br>' \n        '<b>Earliest Evidence (c. 300,000 years ago):</b> Fossils from the Jebel Irhoud site in Morocco, dated<br>' \n        'to approximately 300,000 years ago (with a range of 350,000 - 280,000 years ago), are currently the<br>' \n        'oldest known remains classified as early Homo sapiens. These specimens possess a mix of archaic and<br>' \n        'modern facial features.<br>' \n        '<b>Early Modern Humans (c. 233,000 - 160,000 years ago):</b><br>' \n        '- Omo I remains from Ethiopia, recently re-dated to at least 230,000 years ago.<br>' \n        '- Fossils from Herto, Ethiopia, dated to about 160,000 years ago.<br>' \n        '- The Florisbad Skull from South Africa, dated to about 260,000 years ago.<br>' \n        'The current scientific consensus suggests that Homo sapiens did not originate in a single \"cradle\"<br>' \n        'but rather emerged across the entire African continent from a widespread population of ancestral humans.<br>',                  \n        hoverlabel=dict(bgcolor='rgba(0, 209, 136,0.7)', font_size=11)\n    )\n\n    # Younger Dryas - the \"Big Freeze\" that interrupted deglaciation\n    # Add visual period marker (blue shaded region showing event duration)\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"paper\",\n        x0=0.0129,  # 12,900 years ago (start)\n        x1=0.0117,  # 11,700 years ago (end)\n        y0=0,\n        y1=1,\n        fillcolor='rgba(0,206,209,0)',  # Light turquoise\n        line=dict(width=0),\n        layer=\"below\"\n    )\n    \n    fig.add_annotation(\n        x=np.log10(0.0123),  # ~12,300 years ago (middle of YD)\n        y=-3.1,\n        text='Younger Dryas<br>(\"Big Freeze\")',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='#00CED1',  # Dark turquoise\n        ax=-95,\n        ay=-95, \n        font=dict(size=9, color='#00CED1'),\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor='#00CED1',\n        borderwidth=1,          \n        hovertext='<b>Younger Dryas (12,900-11,700 years ago)</b><br>'\n                  'Abrupt cooling event with regional variations:<br>'\n                  '  * <b>Global</b>: ~1 degC cooling (averaged)<br>'\n                  '  * <b>Europe/N. America</b>: 2-6 degC cooling<br>'\n                  '  * <b>Greenland</b>: 8-10 degC cooling (ice cores)<br>'\n                  '<i>Brief event smoothed in 100-year resolution data</i><br>'\n                  'Meltwater disrupted Gulf Stream circulation<br>'\n                  'Led to megafauna extinctions & agricultural origins<br>'\n                  '<b>Three turquoise bands show regional cooling ranges</b>',                  \n        hoverlabel=dict(bgcolor='rgba(0,206,209,0.9)', font_size=11)\n    )\n    \n    # Add annotation for Holocene - positioned directly over the line\n    fig.add_annotation(\n#        x=0.0117,\n        x=np.log10(0.0117),  # Use log10 for log-scale x-axis\n        xref='x',        \n        y=1.5,  # Adjust this value to position vertically where you want\n        text=\"<b>Start of Holocene</b>\",\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='green',\n        ax=0,\n        ay=-42,\n        font=dict(size=9, color='green'),\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor='green',\n        borderwidth=1,\n        hovertext='<b>Holocene Begins (11,700 years ago)</b><br>'\n                  'End of last glacial period<br>'\n                  'Rapid warming of ~5 degC in centuries<br>'\n                  'Ice sheets retreat, sea level rises 120m<br>'\n                  'Stable, warm climate enables agriculture<br>'\n                  'Human civilization flourishes<br>'\n                  'Most stable climate in 800,000 years',\n        hoverlabel=dict(bgcolor='rgba(34,139,34,0.9)', font_size=11)\n    )\n\n    # Medieval Warm Period\n    # Add visual period marker (orange shaded region)\n    # MWP: 950-1250 CE = 1075-775 years ago\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"paper\",\n        x0=0.001075,  # 950 CE (1075 years ago)\n        x1=0.000775,  # 1250 CE (775 years ago)\n        y0=0,\n        y1=1,\n        fillcolor='rgba(255,140,0,0.12)',  # Light orange\n        line=dict(width=0),\n        layer=\"below\"\n    )\n    \n    fig.add_annotation(\n            x=np.log10(0.000925),  # ~1100 CE (middle of MWP) is 925 years ago\n            y=0.10,\n            text='Medieval Warm Period',\n            showarrow=True,\n            arrowhead=2,\n            arrowsize=1,\n            arrowwidth=1.5,\n            arrowcolor='#FF8C00',  # Dark orange\n            ax=-45,\n            ay=-55,\n            font=dict(size=9, color='#FF8C00'),\n            bgcolor='rgba(255,255,255,0.8)',\n            bordercolor='#FF8C00',\n            borderwidth=1,\n            hovertext='<b>Medieval Warm Period (950-1250 CE)</b><br>'\n                    'Regional warming in North Atlantic/Europe<br>'\n                    'Vikings settled Greenland, agricultural boom<br>'\n                    '<br>'\n                    '<b>Temperature Ranges (see horizontal bands):</b><br>'\n                    '* Regional (light orange): +0.3 to +0.5 degC<br>'\n                    '* Global average (dark orange): +0.1 to +0.2 degC<br>'\n                    '<br>'\n                    '<i>Note: Century-scale event smoothed in 100-yr data</i><br>'\n                    'Shows: Small global changes = large regional impacts<br>'\n                    '<b>[ZOOM] Zoom to 500-1500 CE to see temperature bands clearly!</b><br>'\n                    '<b>Orange vertical region shows event duration</b>',\n            hoverlabel=dict(bgcolor='rgba(255,140,0,0.9)', font_size=11)\n        )\n\n# Medieval Warm Period - Temperature Range Bands\n    # Showing BOTH regional and global ranges with nested opacity\n    \n    # Regional range (North Atlantic/Europe): ~+0.3 to +0.5 degC\n    # Lighter, wider band showing local impact\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"y\",\n        x0=0.001075,  # 950 CE\n        x1=0.000775,  # 1250 CE\n        y0=0.3,  # Regional range (wider)\n        y1=0.5,\n        fillcolor='rgba(255,140,0,0.15)',  # Light orange\n        line=dict(width=0),  # No border (cleaner)\n        layer=\"below\"\n    )\n    \n    # Global range: ~+0.1 to +0.2 degC\n    # Darker, narrower band showing planetary average\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"y\",\n        x0=0.001075,  # 950 CE\n        x1=0.000775,  # 1250 CE\n        y0=0.1,  # Global range (narrower)\n        y1=0.2,\n        fillcolor='rgba(255,140,0,0.35)',  # Darker orange\n        line=dict(width=0),\n        layer=\"below\"\n    )\n\n    # Little Ice Age\n    # Add visual period marker (blue shaded region)\n    # LIA: 1300-1850 CE = 725-175 years ago\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"paper\",\n        x0=0.000725,  # 1300 CE (725 years ago)\n        x1=0.000175,  # 1850 CE (175 years ago)\n        y0=0,\n        y1=1,\n        fillcolor='rgba(65,105,225,0.12)',  # Light royal blue\n        line=dict(width=0),\n        layer=\"below\"\n    )\n    \n    fig.add_annotation(\n        x=np.log10(0.000450),  # ~1575 CE (middle of LIA) is 450 years ago\n        y=-0.2,\n        text='Little Ice Age',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='#4169E1',  # Royal blue\n        ax=20,\n        ay=-55, \n        font=dict(size=9, color='#4169E1'),\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor='#4169E1',\n        borderwidth=1,\n        hovertext='<b>Little Ice Age (1300-1850 CE)</b><br>'\n                  'Regional cooling in North Atlantic/Europe<br>'\n                  'Viking Greenland abandoned, Thames froze, famines<br>'\n                  '<br>'\n                  '<b>Temperature Ranges (see horizontal bands):</b><br>'\n                  '* Regional (light blue): -0.5 to -1.0 degC<br>'\n                  '* Global average (dark blue): -0.2 to -0.3 degC<br>'\n                  '<br>'\n                  '<i>Note: Best visible in regional high-res proxies</i><br>'\n                  'Even small global changes affect civilizations<br>'\n                  '<b>[ZOOM] Zoom to 1200-1900 CE to see temperature bands clearly!</b><br>'\n                  '<b>Blue vertical region shows event duration</b>',\n        hoverlabel=dict(bgcolor='rgba(65,105,225,0.9)', font_size=11)\n    )\n\n# Little Ice Age - Temperature Range Bands\n    # Showing BOTH regional and global ranges with nested opacity\n    \n    # Regional range (North Atlantic/Europe): ~-0.5 to -1.0 degC\n    # Lighter, wider band showing local impact\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"y\",\n        x0=0.000725,  # 1300 CE\n        x1=0.000175,  # 1850 CE\n        y0=-1.0,  # Regional range (wider)\n        y1=-0.5,\n        fillcolor='rgba(65,105,225,0.15)',  # Light blue\n        line=dict(width=0),\n        layer=\"below\"\n    )\n    \n    # Global range: ~-0.2 to -0.3 degC\n    # Darker, narrower band showing planetary average\n    fig.add_shape(\n        type=\"rect\",\n        xref=\"x\",\n        yref=\"y\",\n        x0=0.000725,  # 1300 CE\n        x1=0.000175,  # 1850 CE\n        y0=-0.3,  # Global range (narrower)\n        y1=-0.2,\n        fillcolor='rgba(65,105,225,0.35)',  # Darker blue\n        line=dict(width=0),\n        layer=\"below\"\n    )    \n\n# K-Pg Extinction\n    fig.add_annotation(\n#        x=66.0, \n        x=np.log10(66.0),\n        y=-8,\n        text='K-Pg Extinction<br>(Dinosaurs)',\n        showarrow=False, arrowhead=2, arrowsize=1, arrowwidth=1.5, arrowcolor='#333',\n        ax=0, ay=-40,\n        font=dict(size=9, color='#333'),\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,\n        hovertext='<b>K-Pg Extinction (66 Million Years Ago)</b><br>'\n                  'Asteroid impact in Yucatan Peninsula<br>'\n                  'Chicxulub crater: 180 km diameter<br>'\n                  '~75% of species extinct (including dinosaurs)<br>'\n                  'Impact winter: years of darkness and cold<br>'\n                  'Ended Mesozoic Era, began Age of Mammals<br>'\n                  'Birds (avian dinosaurs) survived',\n        hoverlabel=dict(bgcolor='rgba(50,50,50,0.9)', font_size=11)\n    )\n    \n    # PETM\n    fig.add_annotation(\n        x=np.log10(56.0),\n        y=15.78,\n        text='PETM<br>(Thermal Maximum)',\n        showarrow=True, arrowhead=2, arrowsize=1, arrowwidth=1.5, arrowcolor='#333',\n        ax=0, \n        ay=-90,\n        font=dict(size=9, color='#333'),\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,\n        hovertext='<b>PETM - Paleocene-Eocene Thermal Maximum</b><br>'\n                  '~56 million years ago<br>'\n                  'Rapid warming of ~5-8 degC in <10,000 years<br>'\n                  'Massive carbon release (volcanic/methane)<br>'\n                  'Ocean acidification, deep-sea extinctions<br>'\n                  'Mammals diversified and spread globally<br>'\n                  'Closest ancient analog to modern warming',\n        hoverlabel=dict(bgcolor='rgba(50,50,50,0.9)', font_size=11)\n    )\n    \n    # Grande Coupure\n    fig.add_annotation(\n        x=np.log10(34.0),\n        y=8.44,\n        text='Grande Coupure<br>(Cooling begins)',\n        showarrow=True, arrowhead=2, arrowsize=1, arrowwidth=1.5, arrowcolor='#333',\n        ax=40, \n        ay=-40,\n        font=dict(size=9, color='#333'),\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,\n        hovertext='<b>Grande Coupure - The \"Great Cut\"</b><br>'\n                  '~34 million years ago (Eocene-Oligocene)<br>'\n                  'Abrupt cooling, ice sheets form on Antarctica<br>'\n                  'Drop of ~4 degC in less than 400,000 years<br>'\n                  'Opening of Drake Passage (Antarctica-S.America)<br>'\n                  'Circumpolar current isolates Antarctica<br>'\n                  'Major faunal turnover in Europe',\n        hoverlabel=dict(bgcolor='rgba(50,50,50,0.9)', font_size=11)\n    )\n    \n    # Ice Ages Begin - positioned to align with data\n    fig.add_annotation(\n        x=np.log10(2.58),  # Use log10 for log-scale x-axis\n        y=0.5,  # Adjusted y position to be closer to where data is\n        text='Ice Ages Begin',\n        showarrow=True,\n        arrowhead=2,\n        arrowsize=1,\n        arrowwidth=1.5,\n        arrowcolor='#333',\n        ax=0,\n        ay=-40,\n        font=dict(size=9, color='#333'),\n        bgcolor='rgba(255,255,255,0.8)',\n        bordercolor='#333',\n        borderwidth=1,\n        hovertext='<b>Quaternary Ice Age Begins</b><br>'\n                  '~2.6 million years ago (Pleistocene)<br>'\n                  'Regular glacial-interglacial cycles begin<br>'\n                  '41,000-year cycles, then 100,000-year cycles<br>'\n                  'Ice sheets cover Northern Hemisphere<br>'\n                  'Human ancestors adapt to climate swings<br>'\n                  'Still in this ice age today (Holocene = warm phase)',\n        hoverlabel=dict(bgcolor='rgba(50,50,50,0.9)', font_size=11)\n    )\n    \n    # ===== DEEP TIME EVENTS (with ? hover for minimal clutter) =====\n    \n    # Cretaceous Thermal Maximum\n    fig.add_annotation(\n        x=np.log10(90),\n        y=20,\n        text='CTM',\n        showarrow=False,\n        font=dict(size=9, color='#333'),\n    #    font=dict(size=16, color='#7FC64E'),  # Cretaceous green\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,    \n    #    bgcolor='rgba(255,255,255,0.9)',\n    #    bordercolor='#7FC64E',\n    #    borderwidth=2,\n        borderpad=4,\n        hovertext='<b>Cretaceous Thermal Maximum (~90 Ma)</b><br>'\n                  'Peak Mesozoic greenhouse conditions<br>'\n                  'Global temp ~20 degC above pre-industrial<br>'\n                  'High CO2, no polar ice, warm oceans<br>'\n                  'Dinosaurs thrived in hot world',\n        hoverlabel=dict(bgcolor='rgba(127,198,78,0.9)', font_size=11)\n    )\n    \n    # Permian-Triassic Extinction\n    fig.add_annotation(\n        x=np.log10(252),\n        y=25.5,\n        text='P-T Ext.',\n        showarrow=False,\n        font=dict(size=9, color='#333'),        \n    #    font=dict(size=16, color='#F04028'),  # Permian red\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,    \n    #    bgcolor='rgba(255,255,255,0.9)',\n    #    bordercolor='#F04028',\n    #    borderwidth=2,\n        borderpad=4,\n        hovertext='<b>Permian-Triassic Extinction (~252 Ma)</b><br>'\n                  'The \"Great Dying\" - worst mass extinction<br>'\n                  '~96% of marine species extinct<br>'\n                  '~70% of terrestrial vertebrates extinct<br>'\n                  'Caused by Siberian Traps volcanism<br>'\n                  'Massive CO2 release, ocean anoxia<br>'\n                  'Global temp ~28 degC (peak hothouse)',\n        hoverlabel=dict(bgcolor='rgba(240,64,40,0.9)', font_size=11)\n    )\n    \n    # Carboniferous Icehouse\n    fig.add_annotation(\n        x=np.log10(300),\n        y=-3.5,\n        text='Icehouse',\n        showarrow=False,\n        font=dict(size=9, color='#333'),        \n    #    font=dict(size=16, color='#67A599'),  # Carboniferous teal\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,    \n    #    bgcolor='rgba(255,255,255,0.9)',\n    #    bordercolor='#67A599',\n    #    borderwidth=2,\n        borderpad=4,\n        hovertext='<b>Carboniferous Icehouse (~300 Ma)</b><br>'\n                  'The \"Coal Age\" - vast tropical forests<br>'\n                  'Trees evolved lignin (hard to decompose)<br>'\n                  'Massive carbon burial [OK] coal deposits<br>'\n                  'Drew down atmospheric CO2<br>'\n                  'Triggered glaciation (~12 degC drop)<br>'\n                  'First forests changed the planet!',\n        hoverlabel=dict(bgcolor='rgba(103,165,153,0.9)', font_size=11)\n    )\n    \n    # Late Ordovician Glaciation\n    fig.add_annotation(\n        x=np.log10(445),\n        y=-8,\n        text='Glaciation',\n        showarrow=False,\n        font=dict(size=9, color='#333'),        \n    #    font=dict(size=16, color='#009270'),  # Ordovician green\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,    \n    #    bgcolor='rgba(255,255,255,0.9)',\n    #    bordercolor='#009270',\n    #    borderwidth=2,\n        borderpad=4,\n        hovertext='<b>Late Ordovician Glaciation (~445 Ma)</b><br>'\n                  'First major Phanerozoic icehouse<br>'\n                  'Rapid cooling to ~5 degC<br>'\n                  'Massive ice sheets on Gondwana<br>'\n                  'Sea level drop of ~100m<br>'\n                  'End-Ordovician mass extinction<br>'\n                  '~85% of marine species extinct',\n        hoverlabel=dict(bgcolor='rgba(0,146,112,0.9)', font_size=11)\n    )\n    \n    # End-Triassic Extinction (optional but you said \"all\"!)\n    fig.add_annotation(\n        x=np.log10(201),\n        y=18,\n        text='E-T Ext.',\n        showarrow=False,\n        font=dict(size=9, color='#333'),        \n    #    font=dict(size=16, color='#812B92'),  # Triassic purple\n        bgcolor='rgba(255,255,255,0.8)', bordercolor='#333', borderwidth=1,    \n    #    bgcolor='rgba(255,255,255,0.9)',\n    #    bordercolor='#812B92',\n    #    borderwidth=2,\n        borderpad=4,\n        hovertext='<b>End-Triassic Extinction (~201 Ma)</b><br>'\n                  'One of the \"Big Five\" mass extinctions<br>'\n                  '~75% of species extinct<br>'\n                  'Caused by CAMP volcanism<br>'\n                  '(Central Atlantic Magmatic Province)<br>'\n                  'CO2 spike, ocean acidification<br>'\n                  'Opened ecological space for dinosaurs',\n        hoverlabel=dict(bgcolor='rgba(129,43,146,0.9)', font_size=11)\n    )\n        \n\n    # Add 3.3 degC\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.0,\n        y0=3.3,\n        x1=0.94,\n        y1=3.3,\n        line=dict(\n            color=\"red\",\n            width=1,\n            dash=\"dot\"\n        )\n    )\n    \n    # Add 2.8 degC \n#    fig.add_shape(\n#        type=\"line\",\n#        xref=\"paper\",\n#        yref=\"y\",\n#        x0=0.0,\n#        y0=2.8,\n#        x1=0.94,\n#        y1=2.8,\n#        line=dict(\n#            color=\"red\",\n#            width=1,\n#            dash=\"dot\"\n#        )\n#    )\n\n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.75,\n        y=3.40,\n        text=\"Current Policies (UNEP 2025): 2.6 degC - 3.3 degC\",\n        showarrow=False,\n        bgcolor=\"rgba(255,255,255,0)\",\n        font=dict(size=9, color='red'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n\n    # Add 2.6 degC \n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.0,\n        y0=2.6,\n        x1=0.94,\n        y1=2.6,\n        line=dict(\n            color=\"red\",\n            width=1,\n            dash=\"dot\"\n        )\n    )\n    \n#    fig.add_annotation(\n#        xref=\"paper\",\n#        yref=\"y\",\n#        x=0.82,\n#        y=3.10,\n#        text=\"2.5 degC to 2.9 degC Trajectory\",\n#        showarrow=False,\n#        bgcolor=\"rgba(255,255,255,0.8)\",\n#        font=dict(size=9, color='black'),\n#        xanchor='left',\n#        yanchor='bottom'\n#    )\n\n    # Add 1.28 degC current anomaly line - spans both plots\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.0,\n        y0=1.19,\n        x1=0.94,\n        y1=1.19,\n        line=dict(\n            color=\"green\",\n            width=1,\n            dash=\"dot\"\n        )\n    )\n    \n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.77,\n        y=1.40,\n        text=\"1.19 degC -- Current Anomaly (2025 Average)\",\n        showarrow=False,\n        bgcolor=\"rgba(255,255,255,0)\",\n        font=dict(size=9, color='green'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n\n    # Add 0 degC baseline - spans both plots\n    fig.add_shape(\n        type=\"line\",\n        xref=\"paper\",\n        yref=\"y\",\n        x0=0.0,\n        y0=0,\n        x1=0.94,\n        y1=0,\n        line=dict(\n            color=\"black\",\n            width=1,\n            dash=\"dot\"\n        )\n    )\n    \n    fig.add_annotation(\n        xref=\"paper\",\n        yref=\"y\",\n        x=0.80,\n        y=0.0,\n        text=\"0 degC Anomaly -- 1850-1900 Baseline\",\n        showarrow=False,\n        bgcolor=\"rgba(255,255,255,0)\",\n        font=dict(size=9, color='black'),\n        xanchor='left',\n        yanchor='bottom'\n    )\n\n    info_text = (\n        \"<b>Earth's Climate History and Extreme Heat Events</b><br>\"\n        \"<br>\"\n\n        \"* <b>Holocene:</b> Kaufman et al. 2020 (12 ka); \"\n        \"   <i>Method: Multi-proxy (pollen, sediments, biomarkers)</i><br>\"\n\n        \"* <b>Modern:</b> NASA GISS (1880-2025); \"\n        \"   <i>Method: Instrumental (thermometers, satellites)</i><br>\"\n\n        \"* Time Span: 540 Ma to 2100 CE<br>\"\n\n        \"* Baseline: Pre-industrial (1850-1900) ~14 degC +/-0.5 degC<br>\"\n        \"<br>\"\n\n        \"* <b>Right Axis:</b> Absolute temp scale shows wet bulb (Tw) heat events<br>\"\n\n        \"* <b>Wet Bulb Temperature:</b> Combines heat AND humidity.<br>\"\n        \"     At Tw >= 35 degC, sweating cannot cool the body.<br>\"\n\n        \"* <b>Survivability Range (shaded):</b><br>\"\n        \"     31 degC = Biological limit - core temp rises (Vecellio et al., 2022)<br>\"\n        \"     35 degC = Theoretical limit - death within hours (Sherwood & Huber, 2010)<br>\"\n        \"* <b>Use zoom to explore details!</b>\"\n\n    )    \n\n    fig.add_annotation(\n        text=info_text,\n        xref=\"paper\", yref=\"paper\",\n        x=0.20, y=0.95,\n        xanchor=\"left\", yanchor=\"top\",\n        bgcolor=\"rgba(255,255,255,0.9)\",\n        bordercolor=\"#2E86AB\",\n        borderwidth=2,\n        borderpad=10,\n        showarrow=False,\n        font=dict(size=10),\n        align=\"left\"\n    )\n    \n    fig.update_xaxes(\n        title_text=\"Millions of Years Before Present (Ma, logarithmic scale)\",\n        autorange=False,\n        range=[np.log10(540), np.log10(0.0000001)],  # 540 Ma to 2026 (~5 weeks before Jan 1)\n        type=\"log\",\n        showgrid=True,\n        gridwidth=1,\n        gridcolor='lightgray'\n    )   \n\n    fig.update_yaxes(\n        title_text=\"Temperature Anomaly (degC, relative to 1850-1900)\",\n        secondary_y=False,\n        showgrid=True,\n        gridwidth=1,\n        gridcolor='lightgray',\n        range=Y_AXIS_RANGE_ANOMALY  # Fixed range to prevent shifting\n    )\n    \n    # Secondary Y-axis: Absolute temperature scale\n    # Converts anomaly to approximate absolute temperature using 14 degC baseline\n    fig.update_yaxes(\n        title_text=\"Absolute Temperature (degC)\",\n        secondary_y=True,\n        showgrid=False,  # Don't duplicate gridlines\n        range=[Y_AXIS_RANGE_ANOMALY[0] + BASELINE_ABSOLUTE_TEMP, \n               Y_AXIS_RANGE_ANOMALY[1] + BASELINE_ABSOLUTE_TEMP],  # Shifted by baseline\n        tickmode='array',\n        tickvals=[0, 10, 14, 20, 30, 31, 35, 40],  # Key reference points including survivability range\n        ticktext=['0', '10', '14', '20', '30', '31', '35', '40']\n    )\n    \n    # Layout\n    fig.update_layout(\n        title={\n            'text': \"Earth's Climate History: 540 Million Years to 2100 CE<br><sub>Wet Bulb Temperature and Human Survivability</sub>\",\n            'x': 0.5,\n            'xanchor': 'center',\n            'font': {'size': 18}\n        },\n        hovermode='closest',\n        showlegend=True,\n        legend=dict(\n            x=0.94,\n            y=0.00,\n            xanchor='right',\n            yanchor='bottom',\n            bgcolor='rgba(255,255,255,0.9)',\n            bordercolor='#2E86AB',\n            borderwidth=2,\n            font=dict(size=10)\n        ),\n        plot_bgcolor='white',\n        height=700,\n        margin=dict(t=80, b=80, l=80, r=80)\n    )\n    \n    # Add source citation\n    fig.add_annotation(\n        text=\"Data: Scotese et al. (2021) Phanerozoic | Lisiecki & Raymo (2005) LR04 | Kaufman et al. (2020) Holocene | Alley (2000) GISP2 Ice Core (YD) | NASA GISS | Paloma's Orrery\",\n        xref=\"paper\", yref=\"paper\",\n        x=0.5, y=-0.10,\n        xanchor=\"center\", yanchor=\"top\",\n        showarrow=False,\n        font=dict(size=9, color='#666')\n    )\n    \n    return fig",
    "start_line": 613,
    "end_line": 2445,
    "has_docstring": true,
    "docstring": "Create Phanerozoic paleoclimate visualization\n\nShows temperature over the past 540 million years with:\n- Geologic period shading\n- Multiple datasets: Scotese (540-5 Ma), LR04 (5-0.01 Ma), Holocene (12 ka), Modern (1880-present)\n- Zoomable to see detail from hundreds of millions of years down to millennia",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_paleoclimate_visualization",
    "component_id": "paleoclimate_wet_bulb_full.create_paleoclimate_visualization"
  },
  "paleoclimate_wet_bulb_full.main": {
    "id": "paleoclimate_wet_bulb_full.main",
    "name": "main",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\paleoclimate_wet_bulb_full.py",
    "relative_path": "paleoclimate_wet_bulb_full.py",
    "depends_on": [
      "save_utils.save_plot",
      "paleoclimate_wet_bulb_full.create_paleoclimate_visualization"
    ],
    "source_code": "def main():\n    \"\"\"Test the visualization\"\"\"\n    if not PLOTLY_AVAILABLE:\n        print(\"Error: Plotly not available\")\n        return\n    \n    print(\"Creating paleoclimate visualization...\")\n    fig = create_paleoclimate_visualization()\n    \n    if fig:\n        print(\"[OK] Visualization created successfully\")\n        # Offer to save\n        save_plot(fig, \"paleoclimate_540Ma_to_present\")        \n        print(\"Opening in browser...\")\n        fig.show()\n    else:\n        print(\"[FAIL] Could not create visualization - check if data is cached\")\n        print(f\"Expected data file: {LR04_CACHE}\")",
    "start_line": 2447,
    "end_line": 2464,
    "has_docstring": true,
    "docstring": "Test the visualization",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "paleoclimate_wet_bulb_full.main"
  },
  "palomas_orrery.get_fetch_interval_for_type": {
    "id": "palomas_orrery.get_fetch_interval_for_type",
    "name": "get_fetch_interval_for_type",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def get_fetch_interval_for_type(obj_type, obj_name, trajectory_interval, \n                                default_interval,                                   # removed eccentric_interval,\n                                satellite_interval, planetary_params):\n    \"\"\"\n    Get the appropriate fetch interval based on object type.\n    Returns None for fixed objects that don't need trajectories.\n    \"\"\"\n    if obj_type == 'trajectory':\n        return trajectory_interval\n    elif obj_type == 'satellite':\n        return satellite_interval\n    elif obj_type == 'orbital':\n        return default_interval\n    elif obj_type == 'lagrange_point':\n        return default_interval\n    elif obj_type == 'fixed':\n        return None  # No trajectory needed\n    else:\n        print(f\"Unknown object type '{obj_type}' for {obj_name}, using default\", flush=True)\n        return default_interval",
    "start_line": 281,
    "end_line": 300,
    "has_docstring": true,
    "docstring": "Get the appropriate fetch interval based on object type.\nReturns None for fixed objects that don't need trajectories.",
    "parameters": [
      "obj_type",
      "obj_name",
      "trajectory_interval",
      "default_interval",
      "satellite_interval",
      "planetary_params"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_fetch_interval_for_type",
    "component_id": "palomas_orrery.get_fetch_interval_for_type"
  },
  "palomas_orrery.create_dates_list_for_object": {
    "id": "palomas_orrery.create_dates_list_for_object",
    "name": "create_dates_list_for_object",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def create_dates_list_for_object(obj, obj_type, date_obj, \n                                trajectory_points, orbital_points,\n                                satellite_days, satellite_points,\n                                start_date, end_date,\n                                planetary_params, parent_planets,\n                                center_object_name, max_date, settings):\n    \"\"\"\n    Create a list of dates for plotting based on object type.\n    \"\"\"\n        \n    if obj_type == 'trajectory':\n        # Time-bounded paths\n        # Check if object has specific start/end dates, otherwise use GUI settings\n        if 'start_date' in obj and 'end_date' in obj:\n            # Use object-specific dates\n            start_date = obj.get('start_date', date_obj)\n            end_date = obj.get('end_date', date_obj)\n        else:\n            # Use GUI-provided date range for objects without specific dates\n            start_date = settings['start_date']\n            end_date = settings['end_date']\n            \n    #    total_days = (end_date - start_date).days\n        # Use total_seconds() to preserve fractional days\n        total_days = (end_date - start_date).total_seconds() / 86400\n        \n        if total_days <= 0:\n            # If no valid range, use the requested days from GUI\n            requested_days = settings['days_to_plot']\n            end_date = start_date + timedelta(days=requested_days)\n            total_days = requested_days\n        \n        num_points = int(trajectory_points) + 1\n        return [start_date + timedelta(days=float(d)) \n                for d in np.linspace(0, total_days, num=num_points)]\n                         \n    elif obj_type == 'satellite' and obj['name'] in parent_planets.get(center_object_name, []):\n        # Moons of the center object\n        num_points = int(satellite_points) + 1\n        return [date_obj + timedelta(days=float(d)) \n                for d in np.linspace(0, satellite_days, num=num_points)]\n                \n    elif obj_type == 'orbital' and obj['name'] in planetary_params:\n        # Planets, dwarf planets, TNOs\n        a = planetary_params[obj['name']]['a']\n        \n        if a > 0:  # Only for elliptical orbits\n            orbital_period_years = np.sqrt(a ** 3)\n            orbital_period_days = orbital_period_years * 365.25\n        else:\n            # Hyperbolic orbit - use a reasonable default span\n            orbital_period_days = 365.25  # 1 year default for trajectories\n\n        requested_days = settings['days_to_plot']  # Use the actual days to plot from GUI\n    #    requested_days = requested_days_timedelta.days  # Convert timedelta to days (int)        \n        plot_days = min(orbital_period_days, requested_days)\n        \n        # Apply system limits\n        days_until_horizons = (max_date - date_obj).days\n        capped_days = min(plot_days, days_until_horizons)\n        \n        num_points = int(orbital_points) + 1\n        return [date_obj + timedelta(days=float(d)) \n                for d in np.linspace(0, capped_days, num=num_points)]\n                \n    elif obj_type == 'lagrange_point':\n        # Co-orbital motion\n    #    requested_days_timedelta = end_date - start_date\n        requested_days = settings['days_to_plot']  # Use the actual days to plot from GUI\n    #    requested_days = requested_days_timedelta.days  # Convert to integer days\n        num_points = int(orbital_points) + 1\n        return [date_obj + timedelta(days=float(d)) \n                for d in np.linspace(0, requested_days, num=num_points)]\n                \n    elif obj_type == 'fixed':\n        # Single position only\n        return [date_obj]\n        \n    else:\n        print(f\"WARNING: Unknown object type '{obj_type}' for {obj['name']}\", flush=True)\n        return [date_obj]",
    "start_line": 302,
    "end_line": 382,
    "has_docstring": true,
    "docstring": "Create a list of dates for plotting based on object type.",
    "parameters": [
      "obj",
      "obj_type",
      "date_obj",
      "trajectory_points",
      "orbital_points",
      "satellite_days",
      "satellite_points",
      "start_date",
      "end_date",
      "planetary_params",
      "parent_planets",
      "center_object_name",
      "max_date",
      "settings"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_dates_list_for_object",
    "component_id": "palomas_orrery.create_dates_list_for_object"
  },
  "palomas_orrery.handle_update_dialog": {
    "id": "palomas_orrery.handle_update_dialog",
    "name": "handle_update_dialog",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def handle_update_dialog(num_objects):\n    \"\"\"\n    Handle the update dialog for cache updates.\n    Returns True if user wants to update, False otherwise.\n    \"\"\"\n    global remember_update_choice, update_choice_remembered\n    \n    if update_choice_remembered:\n        return remember_update_choice\n        \n    # Show dialog\n    dialog = tk.Toplevel(root)\n    dialog.title(\"Update Orbit Data?\")\n    dialog.geometry(\"400x200\")\n    \n    message = tk.Label(dialog, \n        text=f\"New orbit data is needed for {num_objects} selected objects.\\n\\n\"\n             f\"Would you like to fetch updated data from JPL Horizons?\",\n        wraplength=350)\n    message.pack(pady=20)\n    \n    remember_var = tk.IntVar(value=0)\n    remember_check = tk.Checkbutton(dialog,\n        text=\"Remember my choice for this session\",\n        variable=remember_var)\n    remember_check.pack(pady=10)\n    \n    user_choice = {'update': None}\n    \n    def on_yes():\n        user_choice['update'] = True\n        if remember_var.get() == 1:\n            global remember_update_choice, update_choice_remembered\n            remember_update_choice = True\n            update_choice_remembered = True\n        dialog.destroy()\n    \n    def on_no():\n        user_choice['update'] = False\n        if remember_var.get() == 1:\n            global remember_update_choice, update_choice_remembered\n            remember_update_choice = False\n            update_choice_remembered = True\n        dialog.destroy()\n    \n    button_frame = tk.Frame(dialog)\n    button_frame.pack()\n    \n    tk.Button(button_frame, text=\"Yes - Update Cache\", \n             command=on_yes, bg='light green').pack(side='left', padx=5)\n    tk.Button(button_frame, text=\"No - Use Existing\", \n             command=on_no, bg='light coral').pack(side='left', padx=5)\n    \n    dialog.wait_window()\n    \n    return user_choice.get('update', False)",
    "start_line": 384,
    "end_line": 439,
    "has_docstring": true,
    "docstring": "Handle the update dialog for cache updates.\nReturns True if user wants to update, False otherwise.",
    "parameters": [
      "num_objects"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_update_dialog",
    "component_id": "palomas_orrery.handle_update_dialog"
  },
  "palomas_orrery.on_yes": {
    "id": "palomas_orrery.on_yes",
    "name": "on_yes",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "                    def on_yes():\n                        user_choice['update'] = True\n                        if remember_var.get() == 1:\n                            global remember_update_choice, update_choice_remembered\n                            remember_update_choice = True\n                            update_choice_remembered = True\n                        dialog.destroy()",
    "start_line": 3814,
    "end_line": 3820,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function on_yes",
    "component_id": "palomas_orrery.on_yes"
  },
  "palomas_orrery.on_no": {
    "id": "palomas_orrery.on_no",
    "name": "on_no",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "                    def on_no():\n                        user_choice['update'] = False\n                        if remember_var.get() == 1:\n                            global remember_update_choice, update_choice_remembered\n                            remember_update_choice = False\n                            update_choice_remembered = True\n                        dialog.destroy()",
    "start_line": 3822,
    "end_line": 3828,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function on_no",
    "component_id": "palomas_orrery.on_no"
  },
  "palomas_orrery.get_interval_settings": {
    "id": "palomas_orrery.get_interval_settings",
    "name": "get_interval_settings",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.get_date_from_gui",
      "palomas_orrery.get_end_date_from_gui"
    ],
    "source_code": "def get_interval_settings():\n    \"\"\"\n    Get all interval settings from the GUI entries.\n    Returns a dictionary with validated interval values.\n    \n    NOTE: This function reads DISPLAY settings (points to show).\n    Fetch intervals (1d, 6h, etc.) are read separately.\n    \"\"\"\n    try:\n        # Force update of GUI to ensure we get current values\n        root.update_idletasks()\n        \n        # Get values from GUI based on object types\n        settings = {\n            'trajectory_points': float(trajectory_points_entry.get()),\n            'orbital_points': float(orbital_points_entry.get()),\n            'satellite_days': int(satellite_days_entry.get()),\n            'satellite_points': float(satellite_points_entry.get()),\n            'start_date': get_date_from_gui(),\n            'end_date': get_end_date_from_gui(),\n            'days_to_plot': int(days_to_plot_entry.get())\n        }\n        \n        # Debug output to verify\n        print(f\"[get_interval_settings] Read days_to_plot: {settings['days_to_plot']}\", flush=True)\n        \n        # Validate and apply defaults\n        if settings['trajectory_points'] <= 0: \n            settings['trajectory_points'] = 50\n        if settings['orbital_points'] <= 0: \n            settings['orbital_points'] = 50\n        if settings['satellite_days'] <= 0: \n            settings['satellite_days'] = 50\n        if settings['satellite_points'] <= 0: \n            settings['satellite_points'] = 50\n        if settings['days_to_plot'] <= 0: \n            settings['days_to_plot'] = 365\n            \n        # Validate date order\n        if settings['end_date'] <= settings['start_date']:\n            # Auto-correct by adding default days to start date\n            settings['end_date'] = settings['start_date'] + timedelta(days=365)\n            settings['days_to_plot'] = 365\n            \n        # Ensure dates are within Horizons limits\n        if settings['start_date'] < datetime(1900, 1, 1):\n            settings['start_date'] = datetime(1900, 1, 1)\n        if settings['end_date'] > HORIZONS_MAX_DATE:\n            settings['end_date'] = HORIZONS_MAX_DATE\n\n        #    settings['days_to_plot'] = (settings['end_date'] - settings['start_date']).days\n            # Use total_seconds() to preserve fractional days (e.g., 28 hours = 1.167 days, not 1 day)\n        #    settings['days_to_plot'] = (settings['end_date'] - settings['start_date']).total_seconds() / 86400\n        \n        # Always recalculate days_to_plot from actual date range\n        # Use total_seconds() to preserve fractional days (e.g., 28 hours = 1.167 days, not 1 day)\n        settings['days_to_plot'] = (settings['end_date'] - settings['start_date']).total_seconds() / 86400\n\n        return settings, None  # No error\n        \n    except (ValueError, TypeError) as e:\n        # Return defaults with error message\n        now = datetime.now()\n        defaults = {\n            'trajectory_points': 50,\n            'orbital_points': 50,\n            'satellite_days': 50,\n            'satellite_points': 50,\n            'start_date': now,\n            'end_date': now + timedelta(days=365),\n            'days_to_plot': 365\n        }\n        return defaults, f\"Invalid interval values, using defaults. Error: {str(e)}\"",
    "start_line": 446,
    "end_line": 518,
    "has_docstring": true,
    "docstring": "Get all interval settings from the GUI entries.\nReturns a dictionary with validated interval values.\n\nNOTE: This function reads DISPLAY settings (points to show).\nFetch intervals (1d, 6h, etc.) are read separately.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_interval_settings",
    "component_id": "palomas_orrery.get_interval_settings"
  },
  "palomas_orrery.get_date_from_gui": {
    "id": "palomas_orrery.get_date_from_gui",
    "name": "get_date_from_gui",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def get_date_from_gui():\n    \"\"\"\n    Get the date from GUI entry fields.\n    Returns a datetime object.\n    \"\"\"\n    return datetime(\n        int(entry_year.get()),\n        int(entry_month.get()),\n        int(entry_day.get()),\n        int(entry_hour.get()),\n        int(entry_minute.get())\n    )",
    "start_line": 520,
    "end_line": 531,
    "has_docstring": true,
    "docstring": "Get the date from GUI entry fields.\nReturns a datetime object.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_date_from_gui",
    "component_id": "palomas_orrery.get_date_from_gui"
  },
  "palomas_orrery.create_animation_dates": {
    "id": "palomas_orrery.create_animation_dates",
    "name": "create_animation_dates",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def create_animation_dates(current_date, step, N):\n    \"\"\"\n    Create dates list specifically for animations.\n    Handles special cases for month and year steps.\n    \"\"\"\n    dates_list = []\n    \n    if step == 'month':\n        # For months, properly handle month lengths\n        for i in range(N):\n            month_offset = current_date.month - 1 + i\n            year = current_date.year + month_offset // 12\n            month = month_offset % 12 + 1\n            # Handle case where the day might not exist in the month\n            day = min(current_date.day, calendar.monthrange(year, month)[1])\n            date = datetime(year, month, day, current_date.hour, current_date.minute)\n            dates_list.append(date)\n    elif step == 'year':\n        # For years, handle leap year issues\n        for i in range(N):\n            try:\n                date = current_date.replace(year=current_date.year + i)\n            except ValueError:\n                # Handle Feb 29 in non-leap years\n                date = current_date.replace(year=current_date.year + i, month=2, day=28)\n            dates_list.append(date)\n    else:\n        # For days, hours, minutes, etc.\n        for i in range(N):\n            date = current_date + step * i\n            dates_list.append(date)\n    \n    return dates_list",
    "start_line": 533,
    "end_line": 565,
    "has_docstring": true,
    "docstring": "Create dates list specifically for animations.\nHandles special cases for month and year steps.",
    "parameters": [
      "current_date",
      "step",
      "N"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_animation_dates",
    "component_id": "palomas_orrery.create_animation_dates"
  },
  "palomas_orrery.calculate_axis_range_from_orbits": {
    "id": "palomas_orrery.calculate_axis_range_from_orbits",
    "name": "calculate_axis_range_from_orbits",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def calculate_axis_range_from_orbits(selected_objects, positions, planetary_params, \n                                    parent_planets, center_object_name):\n    \"\"\"\n    Calculate appropriate axis range based on orbital parameters.\n    Uses semi-major axis data when available, falls back to position data.\n    \n    Parameters:\n        selected_objects: List of selected object dictionaries\n        positions: Dictionary of current object positions  \n        planetary_params: Dictionary from idealized_orbits.py containing orbital parameters\n        parent_planets: Dictionary mapping planets to their moons\n        center_object_name: Name of the center object\n    \n    Returns:\n        list: [min_range, max_range] for axis scaling\n    \"\"\"\n\n    # Special case: Pluto-Charon Barycenter centered view\n    # Use fixed range appropriate for the binary planet system (~0.0005 AU scale)\n#    if center_object_name == 'Pluto-Charon Barycenter':\n        # Hydra (most distant) orbits at ~0.000436 AU\n        # Add buffer for comfortable viewing\n#        max_range = 0.00065  # ~1.5x Hydra's orbit\n#        print(f\"[SCALING] Pluto-Charon Barycenter mode: using fixed range +/-{max_range:.6f} AU\", flush=True)\n#        return [-max_range, max_range]\n\n    # Special case: Orcus-Vanth Barycenter centered view\n    # Use fixed range appropriate for the binary dwarf planet system (~0.00015 AU scale)\n#    if center_object_name == 'Orcus-Vanth Barycenter':\n        # Vanth orbits at ~0.0000601 AU from barycenter (~7,770 km from barycenter)\n        # Add buffer for comfortable viewing - scale to see both orbits clearly\n#        max_range = 0.00015  # ~2.5x Vanth's orbital radius from barycenter\n#        print(f\"[SCALING] Orcus-Vanth Barycenter mode: using fixed range +/-{max_range:.6f} AU\", flush=True)\n#        return [-max_range, max_range]\n\n    # Special case: Patroclus-Menoetius Barycenter centered view\n    # Binary Trojan asteroid system (Lucy target, March 2033)\n#    if center_object_name == 'Patroclus-Menoetius Barycenter':\n        # Binary separation ~692.5 km = 0.00000463 AU\n        # Add buffer for comfortable viewing - scale to see both objects clearly\n#        max_range = 0.000012  # ~2.5x binary separation\n#        print(f\"[SCALING] Patroclus-Menoetius Barycenter mode: using fixed range +/-{max_range:.6f} AU\", flush=True)\n#        return [-max_range, max_range]\n\n    # Generic barycenter handling: if center is a barycenter in parent_planets,\n    # use the children's orbital elements (which are barycentric, not heliocentric)\n    if center_object_name in parent_planets:\n        children = parent_planets[center_object_name]\n        child_distances = []\n        for child_name in children:\n            if child_name in planetary_params:\n                child_params = planetary_params[child_name]\n                child_a = child_params.get('a', 0)\n                child_e = child_params.get('e', 0)\n                if child_a > 0:\n                    child_apoapsis = child_a * (1 + child_e)\n                    child_distances.append(child_apoapsis)\n                    print(f\"[SCALING] {center_object_name} child '{child_name}': a={child_a:.6f} AU, apoapsis={child_apoapsis:.6f} AU\", flush=True)\n        \n        if child_distances:\n            max_range = max(child_distances) * 1.5  # 1.5x buffer for comfortable viewing\n            print(f\"[SCALING] {center_object_name} mode: using range +/-{max_range:.6f} AU (based on children's orbits)\", flush=True)\n            return [-max_range, max_range]\n\n    max_distances = []\n    \n    # Get orbital distances for selected objects\n    for obj in selected_objects:\n        obj_name = obj['name']\n        \n        # Skip the center object itself\n        if obj_name == center_object_name:\n            continue\n            \n        # Check if we have orbital parameters for this object in idealized_orbits.py\n        if obj_name in planetary_params:\n            params = planetary_params[obj_name]      \n            a = params.get('a', 0)  # Semi-major axis in AU\n            e = params.get('e', 0)  # Eccentricity\n            \n            # Handle different orbit types\n            if e >= 0.99 and e <= 1.01:  # Near-parabolic orbit (within 1% of parabolic)\n                # For parabolic/near-parabolic orbits, use perihelion distance\n                # q = a(1-e) for elliptical, but for near-parabolic with negative a:\n                # Use the actual perihelion distance from the formula\n                if a < 0:  # Hyperbolic with negative semi-major axis\n                    q = abs(a) * (e - 1)  # Perihelion for hyperbolic orbit\n                else:\n                    q = a * (1 - e)  # Standard perihelion formula\n                \n                # For C/2025_K1, we know perihelion is ~0.33 AU\n                # Use a reasonable multiple of perihelion distance for viewing\n                if obj_name == 'C/2025_K1':\n                    q = 0.33  # Known perihelion distance\n                \n                # Show enough to see the interesting part of the orbit\n        #        max_distance = q * 15  # Show 15x perihelion distance\n        #        max_distances.append(max_distance)\n                \n        #        print(f\"{obj_name}: Near-parabolic orbit - e={e:.6f}, perihelion={q:.6f} AU, view range={max_distance:.6f} AU\", flush=True)\n                \n                # Show enough to see the interesting part of the orbit\n                max_distance = q * 15  # Show 15x perihelion distance\n                \n                # Also check current position - comet might be much farther out right now\n                obj_data = positions.get(obj_name)\n                if obj_data and obj_data.get('x') is not None:\n                    current_distance = (obj_data['x']**2 + obj_data['y']**2 + obj_data['z']**2)**0.5\n                    if current_distance > max_distance:\n                        max_distance = current_distance * 1.3  # Use current position with buffer\n                        print(f\"{obj_name}: Near-parabolic orbit - using current position {current_distance:.6f} AU (> perihelion-based range)\", flush=True)\n                \n                max_distances.append(max_distance)\n                \n                print(f\"{obj_name}: Near-parabolic orbit - e={e:.6f}, perihelion={q:.6f} AU, view range={max_distance:.6f} AU\", flush=True)\n\n            elif e > 1.01:  # Clearly hyperbolic\n                # For hyperbolic orbits with e > 1\n                q = abs(a) * (e - 1)  # Perihelion distance\n                max_distance = q * 10  # Show 10x perihelion distance\n                max_distances.append(max_distance)\n                \n                print(f\"{obj_name}: Hyperbolic orbit - a={a:.6f} AU, e={e:.4f}, perihelion={q:.6f} AU, view range={max_distance:.6f} AU\", flush=True)\n                \n            else:  # Elliptical orbit (e < 0.99)\n                # Standard calculation for elliptical orbits\n                aphelion = a * (1 + e)\n                max_distances.append(abs(aphelion))  # Use abs to handle any edge cases\n                \n                print(f\"{obj_name}: Elliptical orbit - a={a:.6f} AU, e={e:.4f}, aphelion={aphelion:.6f} AU\", flush=True)\n            \n        else:\n            # Fall back to current position data for objects without orbital parameters\n            obj_data = positions.get(obj_name)\n            if obj_data and obj_data.get('x') is not None:\n                distance = (obj_data['x']**2 + obj_data['y']**2 + obj_data['z']**2)**0.5\n                max_distances.append(distance)\n                print(f\"{obj_name}: Using position data - distance={distance:.6f} AU\", flush=True)\n    \n    # Handle satellite systems when centered on a planet\n    for obj in selected_objects:\n        obj_name = obj['name']\n        for parent_name, satellites in parent_planets.items():\n            if obj_name in satellites and parent_name in planetary_params:\n                # This is a satellite\n                sat_params = planetary_params.get(obj_name, {})\n                sat_a = sat_params.get('a', 0)\n                sat_e = sat_params.get('e', 0)\n                \n                # Skip if no valid orbital data\n                if sat_a == 0:\n                    continue\n                    \n                sat_aphelion = sat_a * (1 + sat_e)\n                \n                if center_object_name == 'Sun':\n                    # If viewing from Sun, add parent planet's distance\n                    parent_params = planetary_params[parent_name]\n                    parent_a = parent_params.get('a', 0)\n                    parent_e = parent_params.get('e', 0)\n                    parent_aphelion = parent_a * (1 + parent_e)\n                    \n                    total_distance = parent_aphelion + sat_aphelion\n                    max_distances.append(total_distance)\n                    print(f\"{obj_name} around {parent_name}: parent={parent_aphelion:.6f} AU, satellite={sat_aphelion:.6f} AU, total={total_distance:.3f} AU\", flush=True)\n                \n                elif center_object_name == parent_name:\n                    # If viewing from the parent planet, just use satellite orbit\n                    max_distances.append(sat_aphelion)\n                    print(f\"{obj_name} around {parent_name}: orbit={sat_aphelion:.6f} AU\", flush=True)\n    \n    if max_distances:\n        max_range = max(max_distances)\n        \n        # Add appropriate buffer based on the scale\n        if max_range < 0.1:  # Very small systems (satellite systems)\n            buffer_factor = 1.5\n        elif max_range < 10:  # Inner solar system\n            buffer_factor = 1.3\n        elif max_range < 100:  # Outer solar system\n            buffer_factor = 1.2\n        else:  # Very distant objects\n            buffer_factor = 1.1\n            \n        max_range_with_buffer = max_range * buffer_factor\n        axis_range = [-max_range_with_buffer, max_range_with_buffer]\n        \n        print(f\"\\nAutomatic scaling calculation:\", flush=True)\n        print(f\"  Maximum orbital distance: {max_range:.6f} AU\", flush=True)\n        print(f\"  Buffer factor: {buffer_factor}\", flush=True)\n        print(f\"  Final axis range: +/-{max_range_with_buffer:.6f} AU\", flush=True)\n        \n        return axis_range\n    else:\n        # Fallback to default range if no orbital data available\n        print(\"No orbital data available, using default range\", flush=True)\n        return [-1, 1]",
    "start_line": 583,
    "end_line": 779,
    "has_docstring": true,
    "docstring": "Calculate appropriate axis range based on orbital parameters.\nUses semi-major axis data when available, falls back to position data.\n\nParameters:\n    selected_objects: List of selected object dictionaries\n    positions: Dictionary of current object positions  \n    planetary_params: Dictionary from idealized_orbits.py containing orbital parameters\n    parent_planets: Dictionary mapping planets to their moons\n    center_object_name: Name of the center object\n\nReturns:\n    list: [min_range, max_range] for axis scaling",
    "parameters": [
      "selected_objects",
      "positions",
      "planetary_params",
      "parent_planets",
      "center_object_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_axis_range_from_orbits",
    "component_id": "palomas_orrery.calculate_axis_range_from_orbits"
  },
  "palomas_orrery.get_improved_axis_range": {
    "id": "palomas_orrery.get_improved_axis_range",
    "name": "get_improved_axis_range",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.calculate_axis_range_from_orbits"
    ],
    "source_code": "def get_improved_axis_range(scale_var, custom_scale_entry, selected_objects, positions, \n                          planetary_params, parent_planets, center_object_name):\n    \"\"\"\n    Get axis range using improved scaling logic.\n    \"\"\"\n    if scale_var.get() == 'Auto':\n        return calculate_axis_range_from_orbits(\n            selected_objects, positions, planetary_params, \n            parent_planets, center_object_name\n        )\n    else:\n        try:\n            custom_scale = float(custom_scale_entry.get())\n            return [-custom_scale, custom_scale]\n        except ValueError:\n            print(\"Invalid custom scale value, using default\", flush=True)\n            return [-1, 1]",
    "start_line": 783,
    "end_line": 799,
    "has_docstring": true,
    "docstring": "Get axis range using improved scaling logic.",
    "parameters": [
      "scale_var",
      "custom_scale_entry",
      "selected_objects",
      "positions",
      "planetary_params",
      "parent_planets",
      "center_object_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_improved_axis_range",
    "component_id": "palomas_orrery.get_improved_axis_range"
  },
  "palomas_orrery.get_animation_axis_range": {
    "id": "palomas_orrery.get_animation_axis_range",
    "name": "get_animation_axis_range",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.calculate_axis_range_from_orbits"
    ],
    "source_code": "def get_animation_axis_range(scale_var, custom_scale_entry, objects, planetary_params, parent_planets, center_object_name):\n    \"\"\"\n    Get axis range for animations using the same logic as static plots.\n    This ensures consistency between plot_objects() and animate_objects().\n    \"\"\"\n    if scale_var.get() == 'Auto':\n        # Use the same orbital-based scaling as plot_objects()\n        selected_objects = [obj for obj in objects if obj['var'].get() == 1]\n        \n        return calculate_axis_range_from_orbits(\n            selected_objects, {}, planetary_params, \n            parent_planets, center_object_name\n        )\n    else:\n        try:\n            custom_scale = float(custom_scale_entry.get())\n            return [-custom_scale, custom_scale]\n        except ValueError:\n            print(\"Invalid custom scale value, using default\", flush=True)\n            return [-1, 1]",
    "start_line": 801,
    "end_line": 820,
    "has_docstring": true,
    "docstring": "Get axis range for animations using the same logic as static plots.\nThis ensures consistency between plot_objects() and animate_objects().",
    "parameters": [
      "scale_var",
      "custom_scale_entry",
      "objects",
      "planetary_params",
      "parent_planets",
      "center_object_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_animation_axis_range",
    "component_id": "palomas_orrery.get_animation_axis_range"
  },
  "palomas_orrery.calculate_satellite_precession_info": {
    "id": "palomas_orrery.calculate_satellite_precession_info",
    "name": "calculate_satellite_precession_info",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def calculate_satellite_precession_info(selected_objects, start_date, end_date, center_object_name):\n    \"\"\"\n    Calculate precession information for selected satellites based on date range.\n    \n    Returns:\n        list: Information messages about precession for each satellite\n    \"\"\"\n    info_messages = []\n    \n    # Precession rates in degrees per year for various satellites\n    # Based on J2 perturbations and orbital mechanics\n    satellite_precession_rates = {\n        # Mars satellites (Mars has high J2 = 1.96e-3)\n        'Phobos': 158.0,      # Very close, rapid precession\n        'Deimos': 2.7,        # Further out, slower precession\n        \n        # Jupiter satellites (Jupiter J2 = 1.47e-2)\n        'Metis': 28.0,        # Ring moon\n        'Adrastea': 24.0,     # Ring moon\n        'Amalthea': 7.0,      # Inner moon\n        'Thebe': 2.5,         # Inner moon\n        'Io': 0.7,            # Galilean\n        'Europa': 0.04,       # Galilean\n        'Ganymede': 0.002,    # Galilean\n        'Callisto': 0.0001,   # Galilean\n        \n        # Saturn satellites (Saturn J2 = 1.63e-2)\n        'Pan': 52.0,          # Ring moon\n        'Daphnis': 48.0,      # Ring moon\n        'Atlas': 44.0,        # Ring moon\n        'Prometheus': 36.0,   # Ring moon\n        'Pandora': 32.0,      # Ring moon\n        'Mimas': 5.3,         # Inner major moon\n        'Enceladus': 0.6,     # Major moon\n        'Tethys': 0.05,       # Major moon\n        'Dione': 0.009,       # Major moon\n        'Rhea': 0.001,        # Major moon\n        'Titan': 0.0001,      # Major moon\n        \n        # Uranus satellites (Uranus J2 = 3.34e-3)\n        'Cordelia': 16.0,     # Inner moon\n        'Ophelia': 12.0,      # Inner moon\n        'Bianca': 8.0,        # Inner moon\n        'Cressida': 4.0,      # Inner moon\n        'Portia': 15.0,       # Inner moon\n        'Mab': 8.0,           # Ring moon\n        'Miranda': 0.8,       # Major moon\n        'Ariel': 0.03,        # Major moon\n        'Umbriel': 0.01,      # Major moon\n        'Titania': 0.002,     # Major moon\n        'Oberon': 0.001,      # Major moon\n        \n        # Neptune satellites (Neptune J2 = 3.41e-3)\n        'Naiad': 24.0,        # Inner moon\n        'Thalassa': 18.0,     # Inner moon\n        'Despina': 14.0,      # Inner moon\n        'Galatea': 8.0,       # Inner moon\n        'Larissa': 2.0,       # Inner moon\n        'Proteus': 0.5,       # Inner moon\n        'Triton': 0.2,        # Major moon (retrograde)\n        \n        # Earth satellite\n        'Moon': 0.004,        # Very minimal precession\n        \n        # Pluto satellites (minimal J2 effects)\n        'Charon': 0.001,\n        'Styx': 0.001,\n        'Nix': 0.001,\n        'Kerberos': 0.001,\n        'Hydra': 0.001,\n    }\n    \n    # Maximum acceptable precession (degrees)\n    MAX_PRECESSION = 10.0  # Adjust this threshold as needed\n    \n    # Calculate days in the selected range\n#    days_to_plot = (end_date - start_date).days\n    # Use total_seconds() to preserve fractional days\n    days_to_plot = (end_date - start_date).total_seconds() / 86400\n    years_to_plot = days_to_plot / 365.25\n    \n    # Check each selected object\n    for obj in selected_objects:\n        obj_name = obj['name']\n        \n        # Skip if not a satellite of the center object\n        if center_object_name not in parent_planets or obj_name not in parent_planets.get(center_object_name, []):\n            continue\n            \n        # Check if we have precession data for this satellite\n        if obj_name in satellite_precession_rates:\n            precession_rate = satellite_precession_rates[obj_name]\n            total_precession = precession_rate * years_to_plot\n            \n            # Calculate recommended maximum days for 10 deg precession\n            max_years = MAX_PRECESSION / precession_rate\n            max_days = int(max_years * 365.25)\n            \n            # Get orbital period for additional context\n            orbital_period_days = KNOWN_ORBITAL_PERIODS.get(obj_name, 1.0)\n            orbits_in_range = days_to_plot / orbital_period_days\n            recommended_orbits = max_days / orbital_period_days\n            \n            # Create info message with all details\n            if total_precession > MAX_PRECESSION:\n                # Warning format (exceeds recommended)\n                info_msg = (\n                    f\"WARNING: {obj_name}:\\n\"\n                    f\"  - Selected range: {days_to_plot} days = {orbits_in_range:.0f} orbits\\n\"\n                    f\"  - Precession: {total_precession:.1f} deg (EXCEEDS recommended {MAX_PRECESSION} deg)\\n\"\n                    f\"  - Recommended: <={max_days} days = {recommended_orbits:.0f} orbits for {MAX_PRECESSION} deg precession\"\n                )\n            else:\n                # Info format (within recommended)\n                info_msg = (\n                    f\"WARNING: {obj_name}:\\n\"\n                    f\"  - Selected range: {days_to_plot} days = {orbits_in_range:.0f} orbits\\n\"\n                    f\"  - Precession: {total_precession:.1f} deg (within recommended {MAX_PRECESSION} deg)\\n\"\n                    f\"  - Maximum recommended: {max_days} days = {recommended_orbits:.0f} orbits for {MAX_PRECESSION} deg precession\"\n                )\n            \n            info_messages.append(info_msg)\n    \n    return info_messages",
    "start_line": 822,
    "end_line": 945,
    "has_docstring": true,
    "docstring": "Calculate precession information for selected satellites based on date range.\n\nReturns:\n    list: Information messages about precession for each satellite",
    "parameters": [
      "selected_objects",
      "start_date",
      "end_date",
      "center_object_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_satellite_precession_info",
    "component_id": "palomas_orrery.calculate_satellite_precession_info"
  },
  "palomas_orrery.get_best_orbit": {
    "id": "palomas_orrery.get_best_orbit",
    "name": "get_best_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def get_best_orbit(object_name, primary=None, idealized_func=None):\n    \"\"\"\n    Get the best available orbit function for an object.\n    Returns the orbit function (refined if available, otherwise idealized).\n    \"\"\"\n    # Try refined orbit first\n    if REFINED_AVAILABLE:\n        try:\n            # Map of convenience functions\n            refined_funcs = {\n                'phobos': refined_orbits.create_refined_phobos_orbit,\n                'deimos': refined_orbits.create_refined_deimos_orbit,\n                'moon': refined_orbits.create_refined_moon_orbit,\n                'io': refined_orbits.create_refined_io_orbit,\n                'europa': refined_orbits.create_refined_europa_orbit,\n                'ganymede': refined_orbits.create_refined_ganymede_orbit,\n                'callisto': refined_orbits.create_refined_callisto_orbit,\n            }\n            \n            obj_lower = object_name.lower()\n            if obj_lower in refined_funcs:\n                print(f\"Using refined orbit for {object_name}\", flush=True)\n                return refined_funcs[obj_lower]()\n        except Exception as e:\n            print(f\"Could not load refined orbit for {object_name}: {e}\", flush=True)\n    \n    # Fall back to idealized orbit\n    if idealized_func:\n        print(f\"Using Keplerian orbit for {object_name}\", flush=True)\n        return idealized_func()\n    \n    # No orbit available\n    print(f\"Warning: No orbit available for {object_name}\", flush=True)\n    return None",
    "start_line": 948,
    "end_line": 981,
    "has_docstring": true,
    "docstring": "Get the best available orbit function for an object.\nReturns the orbit function (refined if available, otherwise idealized).",
    "parameters": [
      "object_name",
      "primary",
      "idealized_func"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_best_orbit",
    "component_id": "palomas_orrery.get_best_orbit"
  },
  "palomas_orrery.plot_refined_orbits_for_moons": {
    "id": "palomas_orrery.plot_refined_orbits_for_moons",
    "name": "plot_refined_orbits_for_moons",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "refined_orbits.get_refined_system",
      "palomas_orrery.create_refined_orbit_with_actual_data",
      "refined_orbits.create_refined_orbit",
      "palomas_orrery.refined_orbit",
      "constants_new.color_map"
    ],
    "source_code": "def plot_refined_orbits_for_moons(fig, moon_names, center_id, color_map, orbit_data=None,\n                                  date_obj=None, date_range=None):\n    \"\"\"\n    Add refined orbit traces for moons using refined_orbits module.\n    \n    Parameters:\n        orbit_data: Dict of actual orbit data to use for corrections\n    \"\"\"\n    if not REFINED_AVAILABLE:\n        print(\"Refined orbits module not available\", flush=True)\n        return fig\n        \n    import numpy as np\n    import plotly.graph_objects as go\n    \n    for moon_name in moon_names:\n        try:\n            # Get refined orbit function\n            print(f\"\\n{'='*60}\", flush=True)\n            print(f\"Creating refined orbit for {moon_name}...\", flush=True)\n            \n            # Create refined orbit with actual data if available\n            orbit_key = f\"{moon_name}_{center_id}\"\n            actual_data = orbit_data.get(orbit_key) if orbit_data else None\n            \n            if actual_data:\n                print(f\"Found actual orbit data for {moon_name}\", flush=True)\n                # Create a custom refined orbit using the actual data\n                refined_orbit = create_refined_orbit_with_actual_data(\n                    moon_name, center_id, actual_data, refined_orbits\n                )\n            else:\n                print(f\"No actual orbit data for {moon_name}, using Keplerian only\", flush=True)\n                refined_orbit = refined_orbits.create_refined_orbit(moon_name, center_id)\n            \n            # Also get the idealized orbit for comparison\n            system = refined_orbits.get_refined_system()\n            idealized_orbit = system._get_idealized_orbit(moon_name, center_id)\n            \n            # Generate orbit points\n            t = np.linspace(0, 2*np.pi, 50)\n            \n            # Generate positions for both refined and ideal\n            refined_positions = []\n            ideal_positions = []\n            \n            for t_val in t:\n                try:\n                    # Get refined position\n                    pos_refined = refined_orbit(t_val)\n                    refined_positions.append(pos_refined)\n                    \n                    # Get ideal position for comparison\n                    if idealized_orbit:\n                        pos_ideal = idealized_orbit(t_val)\n                        ideal_positions.append(pos_ideal)\n                except Exception as e:\n                    print(f\"  Error at t={t_val:.3f}: {e}\", flush=True)\n                    refined_positions.append([0, 0, 0])\n                    ideal_positions.append([0, 0, 0])\n            \n            refined_positions = np.array(refined_positions)\n            ideal_positions = np.array(ideal_positions) if ideal_positions else None\n            \n            # Debug: Check the scale of positions\n            mean_radius = np.mean(np.linalg.norm(refined_positions, axis=1))\n            print(f\"\\nRefined orbit mean radius before conversion: {mean_radius:.6f}\", flush=True)\n            \n            # Determine if we need to convert from km to AU\n            if mean_radius > 1:\n                refined_positions_au = refined_positions / 149597870.7\n                print(f\"Converting from km to AU (mean radius now: {np.mean(np.linalg.norm(refined_positions_au, axis=1)):.6f} AU)\", flush=True)\n            else:\n                refined_positions_au = refined_positions\n                print(f\"Already in AU, no conversion needed\", flush=True)\n            \n            # Do the same for ideal positions\n            if ideal_positions is not None and len(ideal_positions) > 0:\n                ideal_mean_radius = np.mean(np.linalg.norm(ideal_positions, axis=1))\n                if ideal_mean_radius > 1:\n                    ideal_positions_au = ideal_positions / 149597870.7\n                else:\n                    ideal_positions_au = ideal_positions\n                \n                # Compare refined vs ideal\n                differences = []\n                for i in range(len(refined_positions_au)):\n                    diff = np.linalg.norm(refined_positions_au[i] - ideal_positions_au[i])\n                    differences.append(diff)\n                \n                max_diff = np.max(differences)\n                mean_diff = np.mean(differences)\n                print(f\"\\nOrbit comparison:\", flush=True)\n                print(f\"  Maximum difference: {max_diff * 149597870.7:.1f} km ({max_diff:.6f} AU)\", flush=True)\n                print(f\"  Mean difference: {mean_diff * 149597870.7:.1f} km ({mean_diff:.6f} AU)\", flush=True)\n                \n                if max_diff < 1e-10:\n                    print(\"  - WARNING: Refined orbit is identical to Keplerian orbit!\", flush=True)\n                else:\n                    print(\"  -> Refined orbit differs from Keplerian orbit\", flush=True)\n            \n            # Add trace with distinctive style\n            fig.add_trace(\n                go.Scatter3d(\n                    x=refined_positions_au[:, 0],\n                    y=refined_positions_au[:, 1],\n                    z=refined_positions_au[:, 2],\n            #        mode='lines+markers',  # Add markers for visibility\n                    mode='lines',  \n                    line=dict(\n            #            color='moon_color', \n                        color=color_map(moon_name),     \n                        width=1,           # Thicker\n                        dash='dashdot'     # Different pattern\n            #            dash='dot'     # Different pattern\n                    ),\n            #        marker=dict(\n            #            size=1,\n            #            color='gold'\n            #        ),\n                    name=f\"{moon_name} Refined Keplerian\",\n                    text=[f\"{moon_name} Refined Keplerian\"] * len(refined_positions_au),\n                    customdata=[f\"{moon_name} Refined Keplerian\"] * len(refined_positions_au),\n                    hovertemplate='%{text}<extra></extra>',\n                    showlegend=True,\n                    opacity=0.9\n                )\n            )\n            print(f\"\\n-> Added refined orbit trace for {moon_name}\", flush=True)\n            print(f\"{'='*60}\", flush=True)\n            \n        except Exception as e:\n            print(f\"\\n-> Could not add refined orbit for {moon_name}: {e}\", flush=True)\n            import traceback\n            traceback.print_exc()\n            print(f\"{'='*60}\", flush=True)\n    \n    return fig",
    "start_line": 983,
    "end_line": 1120,
    "has_docstring": true,
    "docstring": "Add refined orbit traces for moons using refined_orbits module.\n\nParameters:\n    orbit_data: Dict of actual orbit data to use for corrections",
    "parameters": [
      "fig",
      "moon_names",
      "center_id",
      "color_map",
      "orbit_data",
      "date_obj",
      "date_range"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_refined_orbits_for_moons",
    "component_id": "palomas_orrery.plot_refined_orbits_for_moons"
  },
  "palomas_orrery.create_refined_orbit_with_actual_data": {
    "id": "palomas_orrery.create_refined_orbit_with_actual_data",
    "name": "create_refined_orbit_with_actual_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "refined_orbits.get_refined_system"
    ],
    "source_code": "def create_refined_orbit_with_actual_data(satellite, primary, actual_orbit_data, refined_orbits_module):\n    \"\"\"Create a refined orbit using provided actual orbit data.\"\"\"\n    import numpy as np\n    from scipy.spatial.transform import Rotation\n    \n    # Get the refined orbit system\n    system = refined_orbits_module.get_refined_system()\n    \n    # Get the idealized orbit\n    idealized = system._get_idealized_orbit(satellite, primary)\n    if not idealized:\n        print(f\"No Keplerian orbit for {satellite}\", flush=True)\n        return system._create_default_orbit(satellite, primary)\n    \n    # Calculate correction using the provided actual data\n    correction = None\n    try:\n        # Debug: Print structure of actual_orbit_data\n        print(f\"\\nActual orbit data keys: {list(actual_orbit_data.keys())}\", flush=True)\n        \n        # Handle the nested data structure\n        if 'data_points' in actual_orbit_data:\n            # Data is nested under 'data_points' with date keys\n            data_points = actual_orbit_data['data_points']\n            print(f\"Found data_points with {len(data_points)} entries\", flush=True)\n            \n            # Extract x, y, z from date-keyed entries\n            if isinstance(data_points, dict) and len(data_points) > 0:\n                # Sort dates to ensure consistent ordering\n                sorted_dates = sorted(data_points.keys())\n                \n                # Extract coordinates\n                actual_x = []\n                actual_y = []\n                actual_z = []\n                \n                for date_key in sorted_dates:\n                    point = data_points[date_key]\n                    if isinstance(point, dict) and 'x' in point and 'y' in point and 'z' in point:\n                        actual_x.append(point['x'])\n                        actual_y.append(point['y'])\n                        actual_z.append(point['z'])\n                \n                actual_x = np.array(actual_x)\n                actual_y = np.array(actual_y)\n                actual_z = np.array(actual_z)\n                \n                print(f\"Extracted {len(actual_x)} points from data_points\", flush=True)\n            else:\n                print(f\"Unexpected data_points structure\", flush=True)\n                return idealized\n                \n        elif 'x' in actual_orbit_data and 'y' in actual_orbit_data and 'z' in actual_orbit_data:\n            # Direct x, y, z arrays (original expected format - temp cache uses this)\n            actual_x = np.array(actual_orbit_data['x'])\n            actual_y = np.array(actual_orbit_data['y'])\n            actual_z = np.array(actual_orbit_data['z'])\n            print(f\"Using direct x,y,z arrays format (temp cache)\", flush=True)\n        else:\n            print(f\"Could not find x,y,z data in orbit structure\", flush=True)\n            return idealized\n        \n        print(f\"Actual orbit data length: x={len(actual_x)}, y={len(actual_y)}, z={len(actual_z)}\", flush=True)\n        \n        # Check if actual data is in AU (should be since it comes from JPL)\n        actual_mean_radius = np.mean(np.sqrt(actual_x**2 + actual_y**2 + actual_z**2))\n        print(f\"Actual orbit mean radius: {actual_mean_radius:.6f} AU ({actual_mean_radius * 149597870.7:.1f} km)\", flush=True)\n        \n        # Ensure we have enough points\n        if len(actual_x) < 3:\n            print(\"Not enough actual orbit points to calculate correction\", flush=True)\n            return idealized\n        \n        # Use SVD to find the best-fit plane through all actual orbit points\n        print(\"\\nCalculating actual orbit normal using SVD...\", flush=True)\n        actual_positions = np.column_stack((actual_x, actual_y, actual_z))\n        \n        # Center the points\n        actual_centroid = np.mean(actual_positions, axis=0)\n        actual_centered = actual_positions - actual_centroid\n        \n        # Use SVD to find the principal components\n        U_actual, S_actual, Vt_actual = np.linalg.svd(actual_centered)\n        \n        # The normal to the best-fit plane is the third principal component\n        n_actual = Vt_actual[2]\n        \n        # Ensure consistent orientation (pointing \"up\" in z)\n        if n_actual[2] < 0:\n            n_actual = -n_actual\n        \n        print(f\"Actual orbit normal (SVD): [{n_actual[0]:.4f}, {n_actual[1]:.4f}, {n_actual[2]:.4f}]\", flush=True)\n        print(f\"SVD singular values: [{S_actual[0]:.6e}, {S_actual[1]:.6e}, {S_actual[2]:.6e}]\", flush=True)\n        \n        # Check planarity - if the third singular value is very small, the orbit is planar\n        planarity_ratio = S_actual[2] / S_actual[0] if S_actual[0] > 0 else 0\n        print(f\"Planarity ratio: {planarity_ratio:.6e} (smaller = more planar)\", flush=True)\n        \n        # Calculate idealized orbit normal using SVD as well\n        print(\"\\nCalculating Keplerian orbit normal using SVD...\", flush=True)\n        t_sample = np.linspace(0, 2*np.pi, 50)\n        ideal_positions = []\n        \n        for t in t_sample:\n            pos = idealized(t)\n            ideal_positions.append(pos)\n        \n        ideal_positions = np.array(ideal_positions)\n        \n        # Check if idealized positions are in km or AU\n        ideal_mean_radius = np.mean(np.linalg.norm(ideal_positions, axis=1))\n        print(f\"Keplerian orbit mean radius before any conversion: {ideal_mean_radius:.6f}\", flush=True)\n        \n        # Convert to AU if needed\n        if ideal_mean_radius > 10:  # Likely in km\n            print(f\"Converting Keplerian positions from km to AU\", flush=True)\n            ideal_positions = ideal_positions / 149597870.7\n            ideal_mean_radius = np.mean(np.linalg.norm(ideal_positions, axis=1))\n            print(f\"Keplerian orbit mean radius after conversion: {ideal_mean_radius:.6f} AU\", flush=True)\n        \n        # Center the ideal points\n        ideal_centroid = np.mean(ideal_positions, axis=0)\n        ideal_centered = ideal_positions - ideal_centroid\n        \n        # Use SVD for ideal orbit\n        U_ideal, S_ideal, Vt_ideal = np.linalg.svd(ideal_centered)\n        n_ideal = Vt_ideal[2]\n        \n        # Ensure consistent orientation\n        if n_ideal[2] < 0:\n            n_ideal = -n_ideal\n        \n        print(f\"Keplerian orbit normal (SVD): [{n_ideal[0]:.4f}, {n_ideal[1]:.4f}, {n_ideal[2]:.4f}]\", flush=True)\n        \n        # Calculate rotation correction\n        dot_product = np.dot(n_ideal, n_actual)\n        print(f\"\\nDot product of normals: {dot_product:.6f}\", flush=True)\n        \n        # Check if normals are already very close\n        if abs(dot_product) > 0.9999:  # Normals are essentially the same\n            print(\"Normals are already aligned (angle < 0.01 deg), no correction needed\", flush=True)\n            return idealized\n        \n        # Calculate the rotation axis\n        axis = np.cross(n_ideal, n_actual)\n        axis_mag = np.linalg.norm(axis)\n        \n        if axis_mag > 1e-10:\n            axis = axis / axis_mag\n            angle = np.arccos(np.clip(dot_product, -1, 1))\n            \n            print(f\"Rotation axis: [{axis[0]:.4f}, {axis[1]:.4f}, {axis[2]:.4f}]\", flush=True)\n            print(f\"Rotation angle: {np.degrees(angle):.2f} deg ({angle:.6f} radians)\", flush=True)\n            \n            # Create the rotation correction\n            correction = Rotation.from_rotvec(angle * axis)\n            print(f\"Created rotation correction of {np.degrees(angle):.2f} deg\", flush=True)\n            \n            # Test the correction\n            test_ideal = ideal_positions[0] - ideal_centroid\n            test_corrected = correction.apply(test_ideal)\n        else:\n            print(\"Rotation axis has zero magnitude, normals are parallel\", flush=True)\n            \n    except Exception as e:\n        print(f\"Error calculating correction: {e}\", flush=True)\n        import traceback\n        traceback.print_exc()\n    \n    # Create the refined orbit function\n    def refined_orbit(t):\n        \"\"\"Refined orbit function that applies correction to Keplerian orbit.\"\"\"\n        # Get position from idealized orbit\n        pos = idealized(t)\n        \n        # Apply correction if available\n        if correction is not None:\n            # Handle both single position and array of positions\n            if isinstance(pos, np.ndarray):\n                if pos.ndim == 1:\n                    # Single position\n                    # Center, rotate, then uncenter\n                    pos_centered = pos - ideal_centroid\n                    pos_corrected = correction.apply(pos_centered) + ideal_centroid\n                else:\n                    # Multiple positions\n                    pos_corrected = np.array([\n                        correction.apply(p - ideal_centroid) + ideal_centroid \n                        for p in pos\n                    ])\n            else:\n                # Convert to numpy array if needed\n                pos_array = np.array(pos)\n                pos_centered = pos_array - ideal_centroid\n                pos_corrected = correction.apply(pos_centered) + ideal_centroid\n            \n            return pos_corrected\n        else:\n            return pos\n    \n    # Verify the refined orbit\n    if correction is not None:\n        print(\"\\n-> Refined orbit function created WITH correction\", flush=True)\n        \n        # Test comparison\n        test_t = np.linspace(0, 2*np.pi, 8)\n        for t in test_t[:3]:  # Just show first 3\n            ideal_pos = idealized(t)\n            refined_pos = refined_orbit(t)\n            diff = np.linalg.norm(ideal_pos - refined_pos) * 149597870.7  # km\n            print(f\"  t={t:.2f}: difference = {diff:.1f} km\", flush=True)\n    else:\n        print(\"\\n-> Refined orbit function created WITHOUT correction (identical to Keplerian)\", flush=True)\n    \n    return refined_orbit",
    "start_line": 1122,
    "end_line": 1336,
    "has_docstring": true,
    "docstring": "Create a refined orbit using provided actual orbit data.",
    "parameters": [
      "satellite",
      "primary",
      "actual_orbit_data",
      "refined_orbits_module"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_refined_orbit_with_actual_data",
    "component_id": "palomas_orrery.create_refined_orbit_with_actual_data"
  },
  "palomas_orrery.refined_orbit": {
    "id": "palomas_orrery.refined_orbit",
    "name": "refined_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "    def refined_orbit(t):\n        \"\"\"Refined orbit function that applies correction to Keplerian orbit.\"\"\"\n        # Get position from idealized orbit\n        pos = idealized(t)\n        \n        # Apply correction if available\n        if correction is not None:\n            # Handle both single position and array of positions\n            if isinstance(pos, np.ndarray):\n                if pos.ndim == 1:\n                    # Single position\n                    # Center, rotate, then uncenter\n                    pos_centered = pos - ideal_centroid\n                    pos_corrected = correction.apply(pos_centered) + ideal_centroid\n                else:\n                    # Multiple positions\n                    pos_corrected = np.array([\n                        correction.apply(p - ideal_centroid) + ideal_centroid \n                        for p in pos\n                    ])\n            else:\n                # Convert to numpy array if needed\n                pos_array = np.array(pos)\n                pos_centered = pos_array - ideal_centroid\n                pos_corrected = correction.apply(pos_centered) + ideal_centroid\n            \n            return pos_corrected\n        else:\n            return pos",
    "start_line": 1292,
    "end_line": 1320,
    "has_docstring": true,
    "docstring": "Refined orbit function that applies correction to Keplerian orbit.",
    "parameters": [
      "t"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function refined_orbit",
    "component_id": "palomas_orrery.refined_orbit"
  },
  "palomas_orrery.load_window_config": {
    "id": "palomas_orrery.load_window_config",
    "name": "load_window_config",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def load_window_config():\n    \"\"\"Load saved window geometry and sash positions from config file.\"\"\"\n    try:\n        if os.path.exists(CONFIG_FILE):\n            with open(CONFIG_FILE, 'r') as f:\n                return json.load(f)\n    except Exception as e:\n        print(f\"Note: Could not load window config: {e}\", flush=True)\n    return None",
    "start_line": 1374,
    "end_line": 1382,
    "has_docstring": true,
    "docstring": "Load saved window geometry and sash positions from config file.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_window_config",
    "component_id": "palomas_orrery.load_window_config"
  },
  "palomas_orrery.save_window_config": {
    "id": "palomas_orrery.save_window_config",
    "name": "save_window_config",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def save_window_config():\n    \"\"\"Save current window geometry and sash positions to config file.\"\"\"\n    try:\n        sash_positions = []\n        try:\n            for i in range(2):\n                sash_positions.append(main_paned.sash_coord(i)[0])\n        except:\n            pass\n        config = {\n            'geometry': root.geometry(),\n            'state': root.state(),\n            'platform': platform.system(),\n            'sash_positions': sash_positions\n        }\n        with open(CONFIG_FILE, 'w') as f:\n            json.dump(config, f, indent=2)\n        print(f\"Window config saved to {CONFIG_FILE}\", flush=True)\n    except Exception as e:\n        print(f\"Note: Could not save window config: {e}\", flush=True)",
    "start_line": 1384,
    "end_line": 1403,
    "has_docstring": true,
    "docstring": "Save current window geometry and sash positions to config file.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function save_window_config",
    "component_id": "palomas_orrery.save_window_config"
  },
  "palomas_orrery.fetch_position": {
    "id": "palomas_orrery.fetch_position",
    "name": "fetch_position",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery_helpers.calculate_planet9_position_on_orbit"
    ],
    "source_code": "def fetch_position(object_id, date_obj, center_id='Sun', id_type=None, override_location=None, mission_url=None, mission_info=None):  \n \n    # Skip fetching for Planet 9 and use accurate position on orbit\n    if object_id == 'planet9_placeholder':\n        # Calculate position directly on the theoretical orbit\n        x, y, z, range_val = calculate_planet9_position_on_orbit()\n        \n        # Return a complete position object with all necessary fields\n        return {\n            'x': x,\n            'y': y,\n            'z': z,\n            'range': range_val,   # Distance based on IRAS/AKARI study estimate\n            'vx': 0,\n            'vy': 0,\n            'vz': 0,\n            'velocity': 0,\n            'distance_km': range_val * KM_PER_AU,\n            'distance_lm': range_val * LIGHT_MINUTES_PER_AU,\n            'distance_lh': (range_val * LIGHT_MINUTES_PER_AU) / 60,\n            'mission_info': \"Planet 9 candidate identified in 2025 IRAS/AKARI infrared data analysis.\"\n        }\n        \n    try:\n        # Convert date to Julian Date\n        times = Time([date_obj])\n        epochs = times.jd.tolist()\n\n        # Set location\n        if override_location is not None:\n            location = override_location\n        else:\n            location = '@' + str(center_id)\n\n        # Query the Horizons system with coordinates relative to location\n        obj = Horizons(id=object_id, id_type=id_type, location=location, epochs=epochs)\n        vectors = obj.vectors()\n\n        if len(vectors) == 0:\n            print(f\"No data returned for object {object_id} on {date_obj}\", flush=True)\n            return None\n\n        # Extract desired fields with error handling\n        x = float(vectors['x'][0]) if 'x' in vectors.colnames else None\n        y = float(vectors['y'][0]) if 'y' in vectors.colnames else None\n        z = float(vectors['z'][0]) if 'z' in vectors.colnames else None\n        range_ = float(vectors['range'][0]) if 'range' in vectors.colnames else None  # Distance in AU from the Sun\n        range_rate = float(vectors['range_rate'][0]) if 'range_rate' in vectors.colnames else None  # AU/day\n        vx = float(vectors['vx'][0]) if 'vx' in vectors.colnames else None  # AU/day\n        vy = float(vectors['vy'][0]) if 'vy' in vectors.colnames else None\n        vz = float(vectors['vz'][0]) if 'vz' in vectors.colnames else None\n        velocity = np.sqrt(vx**2 + vy**2 + vz**2) if vx is not None and vy is not None and vz is not None else 'N/A'\n\n        # Calculate distance in light-minutes and light-hours\n        distance_km = range_ * KM_PER_AU if range_ is not None else 'N/A'\n        distance_lm = range_ * LIGHT_MINUTES_PER_AU if range_ is not None else 'N/A'\n        distance_lh = (distance_lm / 60) if isinstance(distance_lm, float) else 'N/A'\n\n        # Find object name from id\n        obj_name = next((obj['name'] for obj in objects if obj['id'] == object_id), None)\n        \n        # Initialize orbital period values\n        calculated_orbital_period = 'N/A'\n        known_orbital_period = 'N/A'\n        orbital_period = 'N/A'  # Keep the original variable for backward compatibility\n        \n        # Find object name from id\n        obj_name = next((obj['name'] for obj in objects if obj['id'] == object_id), None)\n        \n        # Check if it's a planetary satellite\n        is_satellite = False\n        for planet, satellites in parent_planets.items():\n            if obj_name in satellites:\n                is_satellite = True\n                break\n\n        # Get the known orbital period if available\n        if obj_name in KNOWN_ORBITAL_PERIODS:\n            known_value = KNOWN_ORBITAL_PERIODS[obj_name]\n\n            # Check if the value is None (hyperbolic objects)\n            if known_value is None:\n                # For hyperbolic objects, period is undefined\n                known_orbital_period = {\n                    'years': None,\n                    'days': None,\n                    'description': 'N/A (hyperbolic orbit)'\n                }\n                orbital_period = 'N/A (hyperbolic)'\n\n            else:\n                # ALL values are standardized as days\n                known_orbital_period = {\n                    'days': known_value,\n                    'years': known_value / 365.25\n                }\n                orbital_period = known_value / 365.25       # Convert to years for display\n                \n        # Only calculate the orbital period for non-satellites\n        if not is_satellite and obj_name and obj_name in planetary_params:\n            a = planetary_params[obj_name]['a']  # Semi-major axis in AU\n            if a > 0:  # Only for elliptical orbits (hyperbolic orbits have a < 0)\n                orbital_period_years = np.sqrt(a ** 3)  # Period in Earth years\n                calculated_orbital_period = {\n                    'years': orbital_period_years,\n                    'days': orbital_period_years * 365.25\n                }\n                # If no known period, use the calculated one\n                if orbital_period == 'N/A':\n                    orbital_period = orbital_period_years\n\n        return {\n            'x': x,\n            'y': y,\n            'z': z,\n            'range': range_,\n            'range_rate': range_rate,\n            'vx': vx,\n            'vy': vy,\n            'vz': vz,\n            'velocity': velocity,\\\n            'distance_km': distance_km,\n            'distance_lm': distance_lm,\n            'distance_lh': distance_lh,\n            'mission_info': mission_info,  # Include mission info if available\n            'calculated_orbital_period': calculated_orbital_period,  # New: separated calculated period\n            'known_orbital_period': known_orbital_period,  # New: added known period from reference data\n            'orbital_period': orbital_period  # Original variable preserved for backward compatibility\n        }\n    except Exception as e:\n        print(f\"Error fetching data for object {object_id} on {date_obj}: {e}\", flush=True)\n        return None",
    "start_line": 1500,
    "end_line": 1631,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "object_id",
      "date_obj",
      "center_id",
      "id_type",
      "override_location",
      "mission_url",
      "mission_info"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_position",
    "component_id": "palomas_orrery.fetch_position"
  },
  "palomas_orrery.calculate_analytical_position": {
    "id": "palomas_orrery.calculate_analytical_position",
    "name": "calculate_analytical_position",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "apsidal_markers.calculate_keplerian_position"
    ],
    "source_code": "def calculate_analytical_position(obj_name, date_obj, center_id='Sun'):\n    \"\"\"\n    Calculate position from analytical orbital elements when Horizons is unavailable.\n    \n    Uses the mean anomaly (MA) at epoch to propagate the position to any date.\n    This is the fallback for newly discovered objects not yet in JPL Horizons.\n    \n    Parameters:\n        obj_name: Name of the object (must be in planetary_params with 'MA')\n        date_obj: datetime object for the desired position\n        center_id: Center body (only 'Sun' supported for heliocentric objects)\n        \n    Returns:\n        dict with x, y, z, range, velocity fields, or None if calculation fails\n    \"\"\"\n    from apsidal_markers import calculate_keplerian_position\n    from idealized_orbits import rotate_points\n    \n    if obj_name not in planetary_params:\n        print(f\"[ANALYTICAL POS] {obj_name} not in planetary_params\", flush=True)\n        return None\n    \n    params = planetary_params[obj_name]\n    \n    # Check for required elements including MA\n    if 'MA' not in params:\n        print(f\"[ANALYTICAL POS] {obj_name} missing MA (mean anomaly) - cannot calculate position\", flush=True)\n        return None\n    \n    if 'epoch' not in params:\n        print(f\"[ANALYTICAL POS] {obj_name} missing epoch - cannot calculate position\", flush=True)\n        return None\n    \n    try:\n        # Use the Keplerian position calculator from apsidal_markers\n        position = calculate_keplerian_position(params, date_obj, rotate_points)\n        \n        if position is None:\n            return None\n        \n        # Build return dict matching fetch_position() format\n        x, y, z = position['x'], position['y'], position['z']\n        distance = position['distance']\n        \n        # Calculate approximate velocity from orbital elements\n        # v = sqrt(GM * (2/r - 1/a)) for vis-viva equation\n        # Using GM_sun in AU^3/day^2 units\n        a = params.get('a', 1.0)\n        GM_sun_au3_day2 = 2.959122e-4  # GM in AU^3/day^2\n        if a > 0 and distance > 0:\n            v_au_day = np.sqrt(GM_sun_au3_day2 * (2/distance - 1/a))\n            v_km_s = v_au_day * KM_PER_AU / 86400.0\n        else:\n            v_km_s = 0\n        \n        result = {\n            'x': x,\n            'y': y,\n            'z': z,\n            'range': distance,\n            'range_rate': None,  # Not calculated\n            'vx': None,  # Direction unknown without more computation\n            'vy': None,\n            'vz': None,\n            'velocity': v_km_s,\n            'distance_km': distance * KM_PER_AU,\n            'distance_lm': distance * LIGHT_MINUTES_PER_AU,\n            'distance_lh': (distance * LIGHT_MINUTES_PER_AU) / 60,\n            'mission_info': f\"Position calculated from analytical elements (Epoch: {params.get('epoch')})\",\n            'calculated_orbital_period': {'years': np.sqrt(a**3), 'days': np.sqrt(a**3) * 365.25} if a > 0 else None,\n            'analytical_position': True,  # Flag this as analytical\n            'calculation_details': position.get('calculation_details', '')\n        }\n        \n        print(f\"[ANALYTICAL POS] {obj_name}: x={x:.6f}, y={y:.6f}, z={z:.6f} AU (r={distance:.3f} AU)\", flush=True)\n        return result\n        \n    except Exception as e:\n        print(f\"[ANALYTICAL POS] Error calculating position for {obj_name}: {e}\", flush=True)\n        import traceback\n        traceback.print_exc()\n        return None",
    "start_line": 1633,
    "end_line": 1714,
    "has_docstring": true,
    "docstring": "Calculate position from analytical orbital elements when Horizons is unavailable.\n\nUses the mean anomaly (MA) at epoch to propagate the position to any date.\nThis is the fallback for newly discovered objects not yet in JPL Horizons.\n\nParameters:\n    obj_name: Name of the object (must be in planetary_params with 'MA')\n    date_obj: datetime object for the desired position\n    center_id: Center body (only 'Sun' supported for heliocentric objects)\n    \nReturns:\n    dict with x, y, z, range, velocity fields, or None if calculation fails",
    "parameters": [
      "obj_name",
      "date_obj",
      "center_id"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_analytical_position",
    "component_id": "palomas_orrery.calculate_analytical_position"
  },
  "palomas_orrery.fetch_radec_for_hover": {
    "id": "palomas_orrery.fetch_radec_for_hover",
    "name": "fetch_radec_for_hover",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def fetch_radec_for_hover(object_id, date_obj, id_type=None):\n    \"\"\"\n    Fetch RA/Dec and uncertainties for hover text\n    \n    Returns:\n        tuple: (ra_deg, dec_deg, ra_3sigma, dec_3sigma)\n    \"\"\"\n    try:\n        if object_id == '399':  # Earth doesn't have Earth-centered coordinates\n            return None, None, None, None\n            \n        times = Time([date_obj])\n        epochs = times.jd.tolist()\n        \n        # Get Earth-centered ephemerides for apparent RA/Dec\n        earth_obj = Horizons(id=object_id, id_type=id_type, location='@399', epochs=epochs)\n        \n        # Request ephemerides with extra precision columns\n        # The quantities parameter requests specific columns including uncertainties\n        try:\n            ephemerides = earth_obj.ephemerides(quantities='1,2,36,37')\n            # 1=RA, 2=DEC, 36=RA_3sigma, 37=DEC_3sigma (check JPL docs for exact numbers)\n        except:\n            # Fallback to basic ephemerides if enhanced request fails\n            ephemerides = earth_obj.ephemerides()\n        \n        if len(ephemerides) == 0:\n            return None, None, None, None\n            \n        # Look for apparent coordinates\n        ra_deg = None\n        dec_deg = None\n        ra_3sigma = None\n        dec_3sigma = None\n        \n        if 'RA_app' in ephemerides.colnames:\n            ra_deg = float(ephemerides['RA_app'][0])\n        elif 'RA' in ephemerides.colnames:\n            ra_deg = float(ephemerides['RA'][0])\n            \n        if 'DEC_app' in ephemerides.colnames:\n            dec_deg = float(ephemerides['DEC_app'][0])\n        elif 'DEC' in ephemerides.colnames:\n            dec_deg = float(ephemerides['DEC'][0])\n        \n        # Extract uncertainties if available\n        if 'RA_3sigma' in ephemerides.colnames:\n            try:\n                val = ephemerides['RA_3sigma'][0]\n                # Check if it's 'n.a.' or similar non-numeric value\n                if val != 'n.a.' and val is not None:\n                    ra_3sigma = float(val)\n            except:\n                ra_3sigma = None\n        \n        if 'DEC_3sigma' in ephemerides.colnames:\n            try:\n                val = ephemerides['DEC_3sigma'][0]\n                if val != 'n.a.' and val is not None:\n                    dec_3sigma = float(val)\n            except:\n                dec_3sigma = None\n            \n        return ra_deg, dec_deg, ra_3sigma, dec_3sigma\n        \n    except Exception as e:\n        print(f\"Could not fetch RA/Dec for {object_id}: {e}\", flush=True)\n        return None, None, None, None",
    "start_line": 1716,
    "end_line": 1783,
    "has_docstring": true,
    "docstring": "Fetch RA/Dec and uncertainties for hover text\n\nReturns:\n    tuple: (ra_deg, dec_deg, ra_3sigma, dec_3sigma)",
    "parameters": [
      "object_id",
      "date_obj",
      "id_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_radec_for_hover",
    "component_id": "palomas_orrery.fetch_radec_for_hover"
  },
  "palomas_orrery.add_celestial_object": {
    "id": "palomas_orrery.add_celestial_object",
    "name": "add_celestial_object",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.fetch_radec_for_hover",
      "palomas_orrery.get_date_from_gui",
      "visualization_utils.format_detailed_hover_text"
    ],
    "source_code": "def add_celestial_object(fig, obj_data, name, color, symbol='circle', marker_size=DEFAULT_MARKER_SIZE, \n                         hover_data=\"Full Object Info\", center_object_name=None):\n    \n    # Skip if there's no data\n    if obj_data is None or obj_data['x'] is None:\n        return\n\n    # Get the object's ID for RA/Dec fetching\n    obj_info = next((obj for obj in objects if obj['name'] == name), None)\n\n    if obj_info:\n        # IMPORTANT: Add object_type to obj_data so it's available for precision calculation\n        if 'object_type' not in obj_data:\n            obj_data['object_type'] = obj_info.get('object_type', 'unknown')\n        \n        if hover_data == \"Full Object Info\":\n\n            # Fetch RA/Dec and uncertainties - NOW RECEIVING 4 VALUES\n            ra_deg, dec_deg, ra_3sigma, dec_3sigma = fetch_radec_for_hover(\n                obj_info['id'], \n                get_date_from_gui(), \n                obj_info.get('id_type')\n            )\n            \n            if ra_deg is not None and dec_deg is not None:\n                # Add RA/Dec and uncertainties to obj_data for hover text formatting\n                obj_data['ra'] = ra_deg\n                obj_data['dec'] = dec_deg\n                obj_data['ra_3sigma'] = ra_3sigma  # Add uncertainties\n                obj_data['dec_3sigma'] = dec_3sigma\n\n    # Use the consolidated function for hover text\n    full_hover_text, minimal_hover_text, satellite_note = format_detailed_hover_text(\n        obj_data, \n        name, \n        center_object_name,\n        objects,\n        planetary_params,\n        parent_planets,\n        CENTER_BODY_RADII,\n        KM_PER_AU,\n        LIGHT_MINUTES_PER_AU,\n        KNOWN_ORBITAL_PERIODS\n    )\n    \n    # Add satellite note if present\n    if satellite_note:\n        full_hover_text += satellite_note\n    \n    print(f\"Full hover text: {full_hover_text}\", flush=True)\n    print(f\"Minimal hover text: {minimal_hover_text}\", flush=True)\n\n    fig.add_trace(\n        go.Scatter3d(\n            x=[obj_data['x']],\n            y=[obj_data['y']],\n            z=[obj_data['z']],\n            mode='markers',\n            marker=dict(\n                symbol=symbol,\n                color=color,\n                size=marker_size\n            ),\n            name=name,\n            text=[full_hover_text],  # Important: Wrap in list\n            customdata=[minimal_hover_text],  # Important: Wrap in list\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    )",
    "start_line": 1786,
    "end_line": 1855,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "fig",
      "obj_data",
      "name",
      "color",
      "symbol",
      "marker_size",
      "hover_data",
      "center_object_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_celestial_object",
    "component_id": "palomas_orrery.add_celestial_object"
  },
  "palomas_orrery.update_status_display": {
    "id": "palomas_orrery.update_status_display",
    "name": "update_status_display",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def update_status_display(message, status_type='info'):\n    \"\"\"Update status display with color coding and history\"\"\"\n    global status_history\n    \n    # Color mapping\n    color_map = {\n        'info': 'black',\n        'success': 'green',\n        'warning': 'orange',\n        'error': 'red',\n        'special': 'blue'\n    }\n    \n    # Add timestamp\n    timestamp = datetime.now().strftime(\"%H:%M:%S\")\n    status_entry = {\n        'time': timestamp,\n        'message': message,\n        'color': color_map.get(status_type, 'black')\n    }\n    \n    # Add to history (keep last 3)\n    status_history.append(status_entry)\n    if len(status_history) > 3:\n        status_history.pop(0)\n    \n    # Update display if status_display exists\n    if 'status_display' in globals() and status_display:\n        display_text = \"\"\n        for entry in status_history:\n            display_text += f\"[{entry['time']}] {entry['message']}\\n\"\n        display_text += \"Refer to terminal for more details\"\n        \n        status_display.config(text=display_text)\n        \n        # Color the most recent line\n        if status_history:\n            status_display.config(fg=status_history[-1]['color'])",
    "start_line": 1859,
    "end_line": 1896,
    "has_docstring": true,
    "docstring": "Update status display with color coding and history",
    "parameters": [
      "message",
      "status_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function update_status_display",
    "component_id": "palomas_orrery.update_status_display"
  },
  "palomas_orrery.configure_controls_canvas": {
    "id": "palomas_orrery.configure_controls_canvas",
    "name": "configure_controls_canvas",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def configure_controls_canvas(event):\n    # Update the scrollregion to encompass the inner frame\n    controls_canvas.configure(scrollregion=controls_canvas.bbox(\"all\"))\n    \n    # Set the canvas window width to match the canvas width\n    controls_canvas.itemconfig(controls_window, width=controls_canvas.winfo_width())\n    \n    # Force a redraw of the canvas\n    controls_canvas.update_idletasks()",
    "start_line": 1898,
    "end_line": 1906,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "event"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function configure_controls_canvas",
    "component_id": "palomas_orrery.configure_controls_canvas"
  },
  "palomas_orrery._on_mousewheel": {
    "id": "palomas_orrery._on_mousewheel",
    "name": "_on_mousewheel",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def _on_mousewheel(event):\n    # macOS returns delta of 1/-1, Windows returns 120/-120\n    if platform.system() == 'Darwin':  # macOS\n        controls_canvas.yview_scroll(int(-1 * event.delta), \"units\")\n    elif event.num == 4:  # Linux scroll up\n        controls_canvas.yview_scroll(-1, \"units\")\n    elif event.num == 5:  # Linux scroll down\n        controls_canvas.yview_scroll(1, \"units\")\n    else:  # Windows\n        controls_canvas.yview_scroll(int(-1 * (event.delta / 120)), \"units\")",
    "start_line": 1927,
    "end_line": 1936,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "event"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _on_mousewheel",
    "component_id": "palomas_orrery._on_mousewheel"
  },
  "palomas_orrery._unbound_mousewheel": {
    "id": "palomas_orrery._unbound_mousewheel",
    "name": "_unbound_mousewheel",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def _unbound_mousewheel(event):\n    controls_canvas.unbind_all(\"<MouseWheel>\")\n    controls_canvas.unbind_all(\"<Button-4>\")\n    controls_canvas.unbind_all(\"<Button-5>\")",
    "start_line": 1939,
    "end_line": 1942,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "event"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _unbound_mousewheel",
    "component_id": "palomas_orrery._unbound_mousewheel"
  },
  "palomas_orrery._bound_mousewheel": {
    "id": "palomas_orrery._bound_mousewheel",
    "name": "_bound_mousewheel",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def _bound_mousewheel(event):\n    controls_canvas.bind_all(\"<MouseWheel>\", _on_mousewheel)\n    controls_canvas.bind_all(\"<Button-4>\", _on_mousewheel)  # Linux scroll up\n    controls_canvas.bind_all(\"<Button-5>\", _on_mousewheel)  # Linux scroll down",
    "start_line": 1944,
    "end_line": 1947,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "event"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _bound_mousewheel",
    "component_id": "palomas_orrery._bound_mousewheel"
  },
  "palomas_orrery.ScrollableFrame": {
    "id": "palomas_orrery.ScrollableFrame",
    "name": "ScrollableFrame",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "class ScrollableFrame(tk.Frame):\n    \"\"\"\n    A scrollable frame that can contain multiple widgets with a vertical scrollbar.\n    \"\"\"\n    def __init__(self, container, *args, **kwargs):\n        super().__init__(container, *args, **kwargs)\n\n        # Canvas and Scrollbar\n        self.canvas = tk.Canvas(self, bg='gray90')\n        self.scrollbar = ttk.Scrollbar(self, orient=\"vertical\", command=self.canvas.yview)\n        self.canvas.configure(yscrollcommand=self.scrollbar.set) \n\n        # Layout\n        self.canvas.pack(side=\"left\", fill=\"both\", expand=True)\n        self.scrollbar.pack(side=\"right\", fill=\"y\")\n\n        # Scrollable Frame\n        self.scrollable_frame = tk.Frame(self.canvas, bg='gray90')\n        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor=\"nw\")\n\n        # Bind mousewheel to the canvas\n        self.canvas.bind(\"<Enter>\", self._on_enter)\n        self.canvas.bind(\"<Leave>\", self._on_leave)\n\n        # Update scroll region when the canvas size changes\n        self.canvas.bind(\n            \"<Configure>\",\n            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox(\"all\"))\n        )\n\n#    def _on_mousewheel(self, event):\n#        if event.delta:\n#            self.canvas.yview_scroll(int(-1 * (event.delta / 120)), \"units\")\n#        elif event.num == 4:\n#            self.canvas.yview_scroll(-1, \"units\")\n#        elif event.num == 5:\n#            self.canvas.yview_scroll(1, \"units\")\n\n    def _on_mousewheel(self, event):\n        # Cross-platform mousewheel handling\n        # macOS returns delta of 1/-1, Windows returns 120/-120\n        if platform.system() == 'Darwin':  # macOS\n            self.canvas.yview_scroll(int(-1 * event.delta), \"units\")\n        elif event.num == 4:  # Linux scroll up\n            self.canvas.yview_scroll(-1, \"units\")\n        elif event.num == 5:  # Linux scroll down\n            self.canvas.yview_scroll(1, \"units\")\n        elif event.delta:  # Windows\n            self.canvas.yview_scroll(int(-1 * (event.delta / 120)), \"units\")\n\n    def _on_enter(self, event):\n        # Bind the mousewheel events\n        self.canvas.bind_all(\"<MouseWheel>\", self._on_mousewheel)\n        self.canvas.bind_all(\"<Button-4>\", self._on_mousewheel)  # Linux\n        self.canvas.bind_all(\"<Button-5>\", self._on_mousewheel)  # Linux\n\n    def _on_leave(self, event):\n        # Unbind mousewheel events\n        self.canvas.unbind_all(\"<MouseWheel>\")\n        self.canvas.unbind_all(\"<Button-4>\")\n        self.canvas.unbind_all(\"<Button-5>\")   \n\n    def _on_enter(self, event):\n        # Bind the mouse wheel events when the cursor enters a widget\n        event.widget.bind_all(\"<MouseWheel>\", self._on_mousewheel)\n        event.widget.bind_all(\"<Button-4>\", self._on_mousewheel)\n        event.widget.bind_all(\"<Button-5>\", self._on_mousewheel)\n\n    def _on_leave(self, event):\n        # Unbind the mouse wheel events when the cursor leaves a widget\n        event.widget.unbind_all(\"<MouseWheel>\")\n        event.widget.unbind_all(\"<Button-4>\")\n        event.widget.unbind_all(\"<Button-5>\")",
    "start_line": 2649,
    "end_line": 2721,
    "has_docstring": true,
    "docstring": "A scrollable frame that can contain multiple widgets with a vertical scrollbar.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "tk.Frame"
    ],
    "class_name": null,
    "display_name": "class ScrollableFrame",
    "component_id": "palomas_orrery.ScrollableFrame"
  },
  "palomas_orrery.CreateToolTip": {
    "id": "palomas_orrery.CreateToolTip",
    "name": "CreateToolTip",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "class CreateToolTip(object):\n    \"\"\"\n    Create a tooltip for a given widget with intelligent positioning to prevent clipping.\n    \"\"\"\n\n    def __init__(self, widget, text='widget info'):\n        self.waittime = 500     # milliseconds\n        self.wraplength = 1000   # Reduced wraplength\n        self.widget = widget\n        self.text = text\n        self.widget.bind(\"<Enter>\", self.enter)\n        self.widget.bind(\"<Leave>\", self.leave)\n        self.id = None\n        self.tw = None\n\n    def enter(self, event=None):\n        self.schedule()\n\n    def leave(self, event=None):\n        self.unschedule()\n        self.hidetip()\n\n    def schedule(self):\n        self.unschedule()\n        self.id = self.widget.after(self.waittime, self.showtip)\n\n    def unschedule(self):\n        id_ = self.id\n        self.id = None\n        if id_:\n            self.widget.after_cancel(id_)\n\n    def showtip(self, event=None):\n        try:\n            # Get screen dimensions and taskbar height (estimated)\n            screen_width = self.widget.winfo_screenwidth()\n            screen_height = self.widget.winfo_screenheight()\n            taskbar_height = 40  # Estimated Windows taskbar height\n\n            # Create the tooltip window\n            self.tw = tk.Toplevel(self.widget)\n            self.tw.wm_overrideredirect(True)\n            \n            # Calculate usable screen height\n            usable_height = screen_height - taskbar_height\n\n            # Create the tooltip label\n            label = tk.Label(\n                self.tw,\n                text=self.text,\n                justify='left',\n                background='yellow',\n                relief='solid',\n                borderwidth=1,\n                wraplength=min(self.wraplength, screen_width - 100),\n                font=(\"Arial\", 10, \"normal\")\n            )\n            label.pack(ipadx=1, ipady=1)\n\n            # Update the window to calculate its size\n            self.tw.update_idletasks()\n            tooltip_width = self.tw.winfo_width()\n            tooltip_height = self.tw.winfo_height()\n\n            # Initial x position - try positioning to the right of the widget first\n            x = self.widget.winfo_rootx() + self.widget.winfo_width() + 5\n\n            # If tooltip would extend beyond right edge, try positioning to the left of the widget\n            if x + tooltip_width > screen_width:\n                x = self.widget.winfo_rootx() - tooltip_width - 5\n\n            # If that would push it off the left edge, position at left screen edge with padding\n            if x < 0:\n                x = 5\n\n            # Calculate vertical position\n            y = self.widget.winfo_rooty()\n\n            # If tooltip is taller than available space, position at top of screen\n            if tooltip_height > usable_height:\n                y = 5  # Small padding from top\n            else:\n                # Center vertically relative to widget if space allows\n                widget_center = y + (self.widget.winfo_height() / 2)\n                y = widget_center - (tooltip_height / 2)\n                \n                # Ensure tooltip doesn't go below usable screen area\n                if y + tooltip_height > usable_height:\n                    y = usable_height - tooltip_height - 5\n\n                # Ensure tooltip doesn't go above top of screen\n                if y < 5:\n                    y = 5\n\n            # Position the tooltip\n            self.tw.wm_geometry(f\"+{int(x)}+{int(y)}\")\n\n        except Exception as e:\n            print(f\"Error showing tooltip: {e}\", flush=True)\n            traceback.print_exc()\n\n    def hidetip(self):\n        if self.tw:\n            self.tw.destroy()\n        self.tw = None",
    "start_line": 2750,
    "end_line": 2854,
    "has_docstring": true,
    "docstring": "Create a tooltip for a given widget with intelligent positioning to prevent clipping.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "object"
    ],
    "class_name": null,
    "display_name": "class CreateToolTip",
    "component_id": "palomas_orrery.CreateToolTip"
  },
  "palomas_orrery.pulse_progress_bar": {
    "id": "palomas_orrery.pulse_progress_bar",
    "name": "pulse_progress_bar",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def pulse_progress_bar():\n    \"\"\"Create a pulsating effect for the progress bar\"\"\"\n    progress_bar.step(2)  # Increase by 2%\n    root.after(100, pulse_progress_bar)  # Call again after 100ms",
    "start_line": 2907,
    "end_line": 2910,
    "has_docstring": true,
    "docstring": "Create a pulsating effect for the progress bar",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function pulse_progress_bar",
    "component_id": "palomas_orrery.pulse_progress_bar"
  },
  "palomas_orrery.update_orbit_paths": {
    "id": "palomas_orrery.update_orbit_paths",
    "name": "update_orbit_paths",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "orrery_integration.update",
      "palomas_orrery_helpers.fetch_orbit_path",
      "orbit_data_manager.save_orbit_paths"
    ],
    "source_code": "def update_orbit_paths(center_object_name='Sun'):\n    \"\"\"\n    For each object in the global 'objects' list that has an 'id', check if its orbit path is\n    stored in orbit_paths_over_time. If not (or if refresh_all is True), fetch its orbit path\n    from JPL Horizons and update the global dictionary.\n    \n    Parameters:\n        center_object_name (str): Name of the central body (default: 'Sun')\n    \"\"\"\n# def update_orbit_paths():\n\n    import datetime\n    global orbit_paths_over_time\n    \n    # Get center object info\n    center_object_info = next((obj for obj in objects if obj['name'] == center_object_name), None)\n    if center_object_info:\n#        center_id = center_object_info['id']\n        center_id = center_object_info.get('center_id', center_object_info['id'])\n        center_id_type = center_object_info.get('id_type')\n    else:\n        center_id = 'Sun'\n        center_id_type = None\n\n    updated_count = 0\n    total_objects = 0\n\n    now = STATIC_TODAY\n    start_date = now - datetime.timedelta(days=0)    # default start at now\n    end_date = now + datetime.timedelta(days=365)      # default 1 year or 365 days\n    \n    # Iterate over all objects in the 'objects' list\n    for obj in objects:\n        if 'id' not in obj or obj['name'] == center_object_name:\n#        if 'id' not in obj:\n            continue\n        total_objects += 1\n\n        # Check if this is a satellite of the center object\n        is_satellite_of_center = False\n        if center_object_name in parent_planets and obj['name'] in parent_planets.get(center_object_name, []):\n            is_satellite_of_center = True\n            print(f\"Identified {obj['name']} as a satellite of {center_object_name}\", flush=True)\n\n        # Generate a unique key for this object-center pair\n        orbit_key = f\"{obj['name']}_{center_object_name}\"\n\n        # If refresh_all is True or the object's orbit path is missing, fetch new data.\n#        if refresh_all or (obj['name'] not in orbit_paths_over_time):\n        if orbit_key not in orbit_paths_over_time:\n            # Determine a suitable interval.\n            # Use adaptive step sizing if available -- for example, for high eccentricity objects use \"12h\" instead of \"1d\".\n            interval = \"1d\"  # default interval\n\n            if obj['name'] in planetary_params:\n                e = planetary_params[obj['name']].get('e', 0)\n                if e > 0.5:  # example threshold for a highly elliptical orbit\n                    interval = \"12h\"\n            else:\n                # For spacecraft, comets, and moons, use a finer interval\n                # For comet Ikeya-Seki using 6h, then 2h for +/- 3 days, and 1h for +/- 1 day from perihelion 1965-10-21\n                interval = \"6h\"\n            \n            # For satellites of the center object, use a much finer resolution\n            if is_satellite_of_center:\n                interval = \"1h\"  # Higher resolution for moons orbiting the center\n\n            # Update the status in the GUI\n            status_display.config(text=f\"Fetching orbit path for {obj['name']} relative to {center_object_name}...\")\n    #        status_label.config(text=f\"Fetching orbit path for {obj['name']}...\")\n            root.update()  # Force GUI to refresh the status\n            \n            path_data = fetch_orbit_path(\n                obj, \n                start_date, \n                end_date, \n                interval, \n                center_id=center_id,\n                id_type=obj.get('id_type')\n            )           \n\n            if path_data is not None:\n                # Store with the unique key\n                orbit_paths_over_time[orbit_key] = path_data\n                updated_count += 1\n                print(f\"Updated orbit path for {obj['name']} relative to {center_object_name}\", flush=True)\n    \n    status_display.config(text=f\"Orbit paths updated for {updated_count}/{total_objects} objects relative to {center_object_name}.\")\n    # Save the updated orbit paths to the JSON file\n    orbit_data_manager.save_orbit_paths(orbit_paths_over_time)",
    "start_line": 2913,
    "end_line": 3002,
    "has_docstring": true,
    "docstring": "For each object in the global 'objects' list that has an 'id', check if its orbit path is\nstored in orbit_paths_over_time. If not (or if refresh_all is True), fetch its orbit path\nfrom JPL Horizons and update the global dictionary.\n\nParameters:\n    center_object_name (str): Name of the central body (default: 'Sun')",
    "parameters": [
      "center_object_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function update_orbit_paths",
    "component_id": "palomas_orrery.update_orbit_paths"
  },
  "palomas_orrery.plot_orbit_paths": {
    "id": "palomas_orrery.plot_orbit_paths",
    "name": "plot_orbit_paths",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "orbit_data_manager.get_orbit_data_for_plotting",
      "constants_new.color_map"
    ],
    "source_code": "def plot_orbit_paths(fig, objects_to_plot, center_object_name='Sun'):\n    \"\"\"Plot orbit paths using data from orbit_data_manager or temp cache.\"\"\"\n    # Check if we're in special fetch mode\n    if special_fetch_var.get() == 1 and temp_cache:\n        # Use temp cache data\n        plot_data = {}\n        print(f\"[PLOT ORBIT PATHS] Using temp cache with {len(temp_cache)} orbits\", flush=True)\n        for obj in objects_to_plot:\n            orbit_key = f\"{obj['name']}_{center_object_name}\"\n            if orbit_key in temp_cache:\n                plot_data[obj['name']] = temp_cache[orbit_key]\n                print(f\"[PLOT ORBIT PATHS] Found {obj['name']} in temp cache with {len(temp_cache[orbit_key]['x'])} points\", flush=True)\n    else:\n        # Get orbit data in plot-ready format from main cache\n        plot_data = orbit_data_manager.get_orbit_data_for_plotting(objects_to_plot, center_object_name)\n        print(f\"[PLOT ORBIT PATHS] Using main cache\", flush=True)\n    \n    for name, path_data in plot_data.items():\n        # Skip objects that are the center\n        if name == center_object_name:\n            continue\n            \n        # Check if this is a satellite of the center object\n        is_satellite_of_center = center_object_name in parent_planets and name in parent_planets.get(center_object_name, [])\n        \n        # Create the hover text arrays\n        if is_satellite_of_center:\n            hover_text = [f\"{name} Orbit around {center_object_name}\"] * len(path_data['x'])\n            orbit_name = f\"{name} Orbit around {center_object_name}\"\n        else:\n            hover_text = [f\"{name} Orbit\"] * len(path_data['x'])\n            orbit_name = f\"{name} Orbit\"\n\n        print(f\"Plotting orbit for {name} relative to {center_object_name} ({len(path_data['x'])} points)\", flush=True)\n      \n        fig.add_trace(\n            go.Scatter3d(\n                x=path_data['x'],\n                y=path_data['y'],\n                z=path_data['z'],\n                mode='lines',\n                line=dict(width=1, color=color_map(name)),\n                name=orbit_name,\n                text=hover_text,\n                customdata=hover_text,\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            )\n        )",
    "start_line": 3011,
    "end_line": 3059,
    "has_docstring": true,
    "docstring": "Plot orbit paths using data from orbit_data_manager or temp cache.",
    "parameters": [
      "fig",
      "objects_to_plot",
      "center_object_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_orbit_paths",
    "component_id": "palomas_orrery.plot_orbit_paths"
  },
  "palomas_orrery.plot_actual_orbits": {
    "id": "palomas_orrery.plot_actual_orbits",
    "name": "plot_actual_orbits",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery_helpers.fetch_trajectory",
      "apsidal_markers.add_closest_approach_marker",
      "constants_new.color_map"
    ],
    "source_code": "def plot_actual_orbits(fig, planets_to_plot, dates_lists, center_id='Sun', show_lines=True, center_object_name='Sun', show_closest_approach=False, trajectory_marker_color=None):\n\n    \"\"\"\n    Plot actual orbit positions for selected objects.\n    \n    Parameters:\n        fig: plotly figure object\n        planets_to_plot: list of planet names to plot\n        dates_lists: dictionary mapping planet names to lists of dates\n        center_id: ID of central body (default: 'Sun')\n        show_lines: whether to show lines connecting points (default: False)\n        center_object_name: Name of the center object (default: 'Sun')\n    \"\"\"\n    # Check if we're in special fetch mode and should use temp cache\n    if special_fetch_var.get() == 1 and temp_cache:\n        # For special fetch mode, use the temp cache data directly\n        print(\"[SPECIAL FETCH MODE] Using temp cache for plot_actual_orbits\", flush=True)\n        \n        for planet in planets_to_plot:\n            orbit_key = f\"{planet}_{center_object_name}\"\n\n            if orbit_key in temp_cache:\n                path_data = temp_cache[orbit_key]\n                x = path_data['x']\n                y = path_data['y'] \n                z = path_data['z']\n                \n                if show_lines:\n                    mode = 'lines'\n                    line = dict(color=color_map(planet), width=2)\n                    marker = None\n                else:\n                    mode = 'markers'\n                    line = None\n                    marker = dict(color=color_map(planet), size=2)\n\n                # Create the hover text for the actual orbit\n                hover_text = f\"{planet} Orbit\"\n\n                fig.add_trace(\n                    go.Scatter3d(\n                        x=x,\n                        y=y,\n                        z=z,\n                        mode=mode,\n                        line=line,\n                        marker=marker,\n                        name=f\"{planet} Actual Orbit\",\n                        text=[hover_text] * len(x),\n                        customdata=[hover_text] * len(x),\n                        hovertemplate='%{text}<extra></extra>',\n                        showlegend=True\n                    )\n                )\n            else:\n\n# Add closest approach marker if enabled\n                if show_closest_approach:\n                    from apsidal_markers import add_closest_approach_marker\n            #        from datetime import datetime\n                    \n                    # For special fetch, build positions_dict from temp cache data\n                    # Note: temp_cache may not have dates, so we'll use indices\n                    positions_dict = {}\n                    for i in range(len(x)):\n                        # Create synthetic date strings if needed\n                        date_str = f\"2025-01-01T00:00:00+{i:05d}\"  # Placeholder\n                        positions_dict[date_str] = {\n                            'x': x[i],\n                            'y': y[i],\n                            'z': z[i]\n                        }\n                    \n                    add_closest_approach_marker(\n                        fig=fig,\n                        positions_dict=positions_dict,\n                        obj_name=planet,\n                        center_body=center_object_name,\n                        color_map=color_map\n                    )\n\n    else:\n        # Normal mode - use dates_lists and fetch_trajectory\n        print(\"[NORMAL MODE] Using dates_lists for plot_actual_orbits\", flush=True)\n        for planet in planets_to_plot:\n            dates_list = dates_lists.get(planet, [])\n            if not dates_list:\n                print(f\"No dates available for {planet}, skipping.\", flush=True)\n                continue\n            print(f\"[NORMAL MODE] {planet}: {len(dates_list)} dates from {dates_list[0]} to {dates_list[-1]}\", flush=True)\n            \n            obj_info = next((obj for obj in objects if obj['name'] == planet), None)\n            if not obj_info:\n                continue\n\n            # Skip exoplanet objects - they don't use JPL Horizons\n            if obj_info.get('object_type') in ['exoplanet', 'exo_host_star', 'exo_binary_star', 'exo_barycenter']:    \n                continue\n\n            # Use helio_id for Sun-centered plots if available (longer ephemeris coverage)\n            # System barycenter IDs (e.g., 20136108) only have data to ~2030\n            # Heliocentric IDs (e.g., 2003 EL61) have data to ~2500\n            fetch_id = obj_info['id']\n            fetch_id_type = obj_info.get('id_type')\n            if center_object_name == 'Sun' and 'helio_id' in obj_info:\n                fetch_id = obj_info['helio_id']\n                fetch_id_type = 'smallbody'  # helio_ids are smallbody designations\n            \n            trajectory = fetch_trajectory(fetch_id, dates_list, center_id=center_id, id_type=fetch_id_type)\n            \n            # ORCUS TRAJECTORY DERIVATION: JPL doesn't support 920090482 as query target\n            # Derive Orcus trajectory from Vanth using mass ratio\n            if planet == 'Orcus' and center_object_name == 'Orcus-Vanth Barycenter':\n                traj_all_zeros = trajectory and all(\n                    (pos is None or (pos.get('x', 0) == 0 and pos.get('y', 0) == 0 and pos.get('z', 0) == 0))\n                    for pos in trajectory\n                )\n                if not trajectory or traj_all_zeros:\n                    print(f\"  - Deriving Orcus trajectory from Vanth (mass ratio method)...\", flush=True)\n                    vanth_trajectory = fetch_trajectory('120090482', dates_list, center_id=center_id, id_type=None)\n                    if vanth_trajectory:\n                        mass_ratio = 0.16\n                        trajectory = []\n                        for vanth_pos in vanth_trajectory:\n                            if vanth_pos and vanth_pos.get('x') != 0:\n                                trajectory.append({\n                                    'x': -vanth_pos['x'] * mass_ratio,\n                                    'y': -vanth_pos['y'] * mass_ratio,\n                                    'z': -vanth_pos['z'] * mass_ratio\n                                })\n                            else:\n                                trajectory.append({'x': 0, 'y': 0, 'z': 0})\n                        print(f\"  -> Derived {len(trajectory)} Orcus positions from Vanth\", flush=True)\n\n            # Now trajectory is a list of positions - extract valid positions\n\n            # Now trajectory is a list of positions - extract valid positions\n            x, y, z = [], [], []\n            if trajectory:\n                x = [pos['x'] for pos in trajectory if pos is not None]\n                y = [pos['y'] for pos in trajectory if pos is not None]\n                z = [pos['z'] for pos in trajectory if pos is not None]\n\n            # Determine object type (needed for both JPL and analytical paths)\n            obj_type = obj_info.get('object_type', 'orbital')\n            \n            # Only create trace if we have actual positions from JPL\n            if x:\n                # Determine trace color - use trajectory_marker_color for trajectory objects if set\n\n                trace_color = trajectory_marker_color if (obj_type == 'trajectory' and trajectory_marker_color) else color_map(planet)\n                \n                if show_lines:                                                 # this code adds lines betwen the markers\n                    mode = 'lines'\n                    line = dict(color=trace_color, width=2)\n                    marker = None\n                else:\n                    mode = 'markers'\n                    line = None\n                    marker = dict(color=trace_color, size=2)\n\n                # Create the hover text and legend name for the actual orbit\n                # For trajectory objects: \"Plotted Period\" if trajectory_marker_color is set (animate), \"Full Mission\" otherwise (static)\n                if obj_type == 'trajectory':\n                    if trajectory_marker_color:\n                        hover_text = f\"{planet} Plotted Period\"\n                        legend_name = f\"{planet} Plotted Period\"\n                    else:\n                        hover_text = f\"{planet} Full Mission\"\n                        legend_name = f\"{planet} Full Mission\"\n                \n                else:\n                    # Orcus-Vanth barycenter mode: explain derivation method\n                    if planet == 'Orcus' and center_object_name == 'Orcus-Vanth Barycenter':\n                        hover_text = (\n                            f\"<b>{planet} Orbit (Derived from Vanth)</b><br>\"\n                            f\"<br>JPL Horizons cannot query Orcus (920090482) at barycenter.<br>\"\n                            f\"Orbit derived from Vanth (120090482) positions:<br>\"\n                            f\"Orcus position = -Vanth position x mass ratio (0.16)<br>\"\n                            f\"<br>Assumes tidal lock: Orcus always 180 deg opposite Vanth.<br>\"\n                            f\"Mass ratio: M_Vanth/M_Orcus = 0.16 +/- 0.02<br>\"\n                            f\"(Highest known ratio - even higher than Charon/Pluto!)<br>\"\n                            f\"<br>Data: JPL Horizons satellite solution\"\n                        )\n                    elif planet == 'Vanth' and center_object_name == 'Orcus-Vanth Barycenter':\n                        hover_text = (\n                            f\"<b>{planet} Orbit (JPL Horizons)</b><br>\"\n                            f\"<br>Direct from JPL satellite solution (ID 120090482)<br>\"\n                            f\"centered on Orcus-Vanth Barycenter (20090482).<br>\"\n                            f\"<br>Vanth: 443 +/- 10 km diameter (nearly half of Orcus!)<br>\"\n                            f\"Likely a largely-intact impactor from giant collision.<br>\"\n                            f\"<br>Data: JPL Horizons satellite solution\"\n                        )\n                    else:\n                        hover_text = f\"{planet} Orbit\"\n                    legend_name = f\"{planet} Actual Orbit\"\n\n                fig.add_trace(\n                    go.Scatter3d(\n                        x=x,\n                        y=y,\n                        z=z,\n                        mode=mode,\n                        line=line,\n                        marker=marker,\n                        name=legend_name,\n                        text=[hover_text] * len(x),           # Add proper hover text\n                        customdata=[hover_text] * len(x),     # Same for customdata\n                        hovertemplate='%{text}<extra></extra>',\n                        showlegend=True\n                    )\n\n            )\n                print(f\"[NORMAL MODE] Plotted {planet} orbit with {len(x)} points\", flush=True)\n\n                # Add closest approach marker if enabled\n                if show_closest_approach:\n                    from apsidal_markers import add_closest_approach_marker\n                    \n                    # Build positions_dict from trajectory data\n                    positions_dict = {}\n                    for i in range(len(x)):\n                        if i < len(dates_list):\n                            positions_dict[dates_list[i].isoformat()] = {\n                                'x': x[i],\n                                'y': y[i],\n                                'z': z[i]\n                            }\n                    \n                    # Add the marker - use trajectory_marker_color for trajectory objects\n                    marker_color = trajectory_marker_color if obj_type == 'trajectory' else None\n                    add_closest_approach_marker(\n                        fig=fig,\n                        positions_dict=positions_dict,\n                        obj_name=planet,\n                        center_body=center_object_name,\n                        color_map=color_map,\n                        date_range=(dates_list[0], dates_list[-1]) if dates_list else None,\n                        marker_color=marker_color\n                    )                     \n\n            # ===================================================================\n            # ANALYTICAL FALLBACK: For objects without JPL ephemeris\n            # Creates \"Analytical Orbit\" trace from orbital elements\n            # ===================================================================\n            if not x:\n\n            #    ANALYTICAL_POSITION_FALLBACK = ['MK2', 'Xiangliu', 'Vanth', 'Weywot', '6AC4721']\n                ANALYTICAL_POSITION_FALLBACK = ['MK2', 'Xiangliu', 'Vanth', 'Gonggong', '6AC4721']  # Weywot removed - JPL data works at Quaoar\n                if planet in ANALYTICAL_POSITION_FALLBACK:\n                    from orbital_elements import planetary_params\n                    if planet in planetary_params:\n                        print(f\"[ANALYTICAL ORBIT] Calculating analytical positions for {planet}...\", flush=True)\n                        elements = planetary_params[planet]\n                        a = elements.get('a', 0)\n                        e = elements.get('e', 0)\n                        i_deg = elements.get('i', 0)\n                        omega_deg = elements.get('omega', 0)\n                        Omega_deg = elements.get('Omega', 0)\n                        \n                        # Get orbital period\n                        if 'orbital_period_days' in elements:\n                            orbital_period = elements['orbital_period_days']\n                        elif a > 0:\n                            orbital_period = np.sqrt(a**3) * 365.25\n                        else:\n                            orbital_period = 365.25\n                        \n                        # Reference epoch and mean anomaly\n                        if 'MA' in elements and 'epoch' in elements:\n                            MA_epoch = elements['MA']\n                            epoch_str = str(elements['epoch']).replace(' osc.', '').strip()\n                            try:\n                                ref_epoch = datetime.strptime(epoch_str, '%Y-%m-%d')\n                            except ValueError:\n                                ref_epoch = datetime(2000, 1, 1, 12, 0, 0)\n                        else:\n                            MA_epoch = 0.0\n                            ref_epoch = datetime(2000, 1, 1, 12, 0, 0)\n                        \n                        # Pre-calculate rotation angles\n                        i_rad = np.radians(i_deg)\n                        omega_rad = np.radians(omega_deg)\n                        Omega_rad = np.radians(Omega_deg)\n                        n = 360.0 / orbital_period  # Mean motion\n                        \n                        # Calculate positions for all dates\n                        x, y, z = [], [], []\n                        for date_obj in dates_list:\n                            delta_days = (date_obj - ref_epoch).total_seconds() / 86400.0\n                            M_deg = (MA_epoch + n * delta_days) % 360.0\n                            M_rad = np.radians(M_deg)\n                            \n                            # Solve Kepler's equation\n                            if e > 0.01:\n                                E = M_rad if e < 0.8 else np.pi\n                                for _ in range(50):\n                                    f = E - e * np.sin(E) - M_rad\n                                    f_prime = 1 - e * np.cos(E)\n                                    if abs(f_prime) < 1e-12:\n                                        break\n                                    E = E - f / f_prime\n                                    if abs(f / f_prime) < 1e-10:\n                                        break\n                                true_anomaly = 2 * np.arctan2(\n                                    np.sqrt(1 + e) * np.sin(E / 2),\n                                    np.sqrt(1 - e) * np.cos(E / 2)\n                                )\n                            else:\n                                true_anomaly = M_rad\n                            \n                            # Position in orbital plane\n                            r = a * (1 - e**2) / (1 + e * np.cos(true_anomaly)) if e > 0 else a\n                            x_orb = r * np.cos(true_anomaly)\n                            y_orb = r * np.sin(true_anomaly)\n                            \n                            # Apply 3D rotations\n                            x1 = x_orb * np.cos(omega_rad) - y_orb * np.sin(omega_rad)\n                            y1 = x_orb * np.sin(omega_rad) + y_orb * np.cos(omega_rad)\n                            x2 = x1\n                            y2 = y1 * np.cos(i_rad)\n                            z2 = y1 * np.sin(i_rad)\n                            x_final = x2 * np.cos(Omega_rad) - y2 * np.sin(Omega_rad)\n                            y_final = x2 * np.sin(Omega_rad) + y2 * np.cos(Omega_rad)\n                            \n                            x.append(x_final)\n                            y.append(y_final)\n                            z.append(z2)\n                                                \n                        # Skip orbit trace if satellite's orbit is already drawn by plot_tno_satellite_orbit\n                        # (avoids duplicate \"Analytical Orbit\" in legend)\n                        is_satellite_of_center = planet in parent_planets.get(center_object_name, [])\n                        if not is_satellite_of_center:\n\n                            # Create trace with same styling as Actual Orbit\n                            obj_type = obj_info.get('object_type', 'orbital')\n                            trace_color = trajectory_marker_color if (obj_type == 'trajectory' and trajectory_marker_color) else color_map(planet)\n                            \n                            if show_lines:\n                                mode = 'lines'\n                                line = dict(color=trace_color, width=2)\n                                marker = None\n                            else:\n                                mode = 'markers'\n                                line = None\n                                marker = dict(color=trace_color, size=2)\n                            \n                            hover_text = f\"{planet} Analytical Orbit\"\n                            legend_name = f\"{planet} Analytical Orbit\"\n                            \n                            fig.add_trace(\n                                go.Scatter3d(\n                                    x=x,\n                                    y=y,\n                                    z=z,\n                                    mode=mode,\n                                    line=line,\n                                    marker=marker,\n                                    name=legend_name,\n                                    text=[hover_text] * len(x),\n                                    customdata=[hover_text] * len(x),\n                                    hovertemplate='%{text}<extra></extra>',\n                                    showlegend=True\n                                )\n                            )\n\n                            print(f\"[ANALYTICAL ORBIT] Plotted {planet} analytical orbit with {len(x)} points\", flush=True)\n                        else:\n                            print(f\"[ANALYTICAL ORBIT] Skipped orbit trace for {planet} (drawn by plot_tno_satellite_orbit)\", flush=True)                            ",
    "start_line": 3065,
    "end_line": 3433,
    "has_docstring": true,
    "docstring": "Plot actual orbit positions for selected objects.\n\nParameters:\n    fig: plotly figure object\n    planets_to_plot: list of planet names to plot\n    dates_lists: dictionary mapping planet names to lists of dates\n    center_id: ID of central body (default: 'Sun')\n    show_lines: whether to show lines connecting points (default: False)\n    center_object_name: Name of the center object (default: 'Sun')",
    "parameters": [
      "fig",
      "planets_to_plot",
      "dates_lists",
      "center_id",
      "show_lines",
      "center_object_name",
      "show_closest_approach",
      "trajectory_marker_color"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_actual_orbits",
    "component_id": "palomas_orrery.plot_actual_orbits"
  },
  "palomas_orrery.export_social_view": {
    "id": "palomas_orrery.export_social_view",
    "name": "export_social_view",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "social_media_export.show_trace_selection_dialog",
      "social_media_export.export_social_html"
    ],
    "source_code": "def export_social_view():\n    \"\"\"Export the last plotted figure as a social media view.\"\"\"\n    if _last_plotted_fig[0] is None:\n        import tkinter.messagebox as messagebox\n        messagebox.showinfo(\"Social Media View\",\n            \"No figure available.\\n\\n\"\n            \"Plot or animate first, then export.\")\n        return\n\n    from social_media_export import show_trace_selection_dialog, export_social_html\n\n    # Show trace selection dialog\n    selected = show_trace_selection_dialog(_last_plotted_fig[0], parent=root)\n    if selected is None:\n        print(\"[SOCIAL MEDIA] Export cancelled.\", flush=True)\n        return\n\n    # Generate output path from last plot name\n    output_name = _last_plot_name[0] + '_social.html' if _last_plot_name[0] else 'orrery_social_view.html'\n\n    export_social_html(\n        _last_plotted_fig[0],\n    #    output_path=output_name,\n        trace_names=selected\n    )",
    "start_line": 3460,
    "end_line": 3484,
    "has_docstring": true,
    "docstring": "Export the last plotted figure as a social media view.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function export_social_view",
    "component_id": "palomas_orrery.export_social_view"
  },
  "palomas_orrery.plot_objects": {
    "id": "palomas_orrery.plot_objects",
    "name": "plot_objects",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "osculating_cache_manager.get_elements_with_prompt",
      "palomas_orrery.get_date_from_gui"
    ],
    "source_code": "def plot_objects():\n    # DEBUG: Heartbeat check - confirms button click works\n    \n    # =========================================================================\n    # PRE-FETCH OSCULATING ELEMENTS ON MAIN THREAD\n    # =========================================================================\n    \n    # Create working copy of planetary_params\n    active_planetary_params = planetary_params.copy()\n    \n    # Get selected objects\n    selected_objects_for_prefetch = [obj for obj in objects if obj['var'].get() == 1]\n    center_object_name = center_object_var.get()\n    \n    # Determine center_body for osculating elements based on view\n    # This affects which reference frame the elements use\n    if center_object_name == 'Pluto-Charon Barycenter':\n        osculating_center_body = '@9'  # Barycentric elements\n    elif center_object_name == 'Pluto':\n        osculating_center_body = '@999'  # Pluto-centered elements\n\n    elif center_object_name == 'Orcus-Vanth Barycenter':\n        osculating_center_body = '@20090482'  # Orcus-Vanth satellite solution barycenter\n    elif center_object_name == 'Orcus':\n        osculating_center_body = '@920090482'  # Orcus PRIMARY body (not small body)\n\n    elif center_object_name == 'Patroclus-Menoetius Barycenter':\n        osculating_center_body = '@20000617'  # Patroclus-Menoetius satellite solution barycenter\n\n    elif center_object_name == 'Earth-Moon Barycenter':\n        osculating_center_body = '@3'  # Earth-Moon system barycenter\n    elif center_object_name == 'Earth':\n        osculating_center_body = '@399'  # Earth body center (for Moon's osculating elements)\n\n    else:\n        osculating_center_body = None  # Default (heliocentric or auto-detect)\n\n    # Get the plot date for osculating elements\n    try:\n        plot_date = get_date_from_gui()\n    except Exception as e:\n        print(f\"[WARNING] Could not get plot date from GUI: {e}, using today\", flush=True)\n        plot_date = datetime.now()\n\n    # These TNO moons have no usable JPL parent-centered ephemeris\n#    SKIP_HORIZONS_PREFETCH = ['MK2', 'Xiangliu', 'Vanth', 'Weywot']\n    SKIP_HORIZONS_PREFETCH = ['MK2', 'Xiangliu', 'Vanth', 'Gonggong']  # Weywot removed - JPL data works at Quaoar\n\n    # Filter objects that need osculating elements\n    pre_fetch_objects = [\n        obj['name'] for obj in selected_objects_for_prefetch \n        if obj['name'] not in SKIP_HORIZONS_PREFETCH  # Add this filter\n        if obj.get('object_type') in ['orbital', 'satellite', 'trajectory', 'lagrange_point']\n        and obj['name'] != center_object_name\n        and obj.get('object_type') not in ['exoplanet', 'exo_host_star', 'exo_binary_star', 'exo_barycenter']\n        and not obj.get('is_mission', False)\n    ]\n    \n    # Debug: Print the state of variables to console\n    is_normal_mode = (special_fetch_var.get() == 0)\n\n    if is_normal_mode and pre_fetch_objects:\n        print(f\"[PRE-FETCH] Checking osculating elements for {len(pre_fetch_objects)} objects...\", flush=True)\n                        \n        for obj_name in pre_fetch_objects:\n            try:\n                # Find the object dictionary to get its Horizons ID\n                obj_dict = next((obj for obj in selected_objects_for_prefetch \n                                if obj['name'] == obj_name), None)\n                \n                if obj_dict:\n                    horizons_id = obj_dict.get('id', obj_name)\n                    id_type = obj_dict.get('id_type', 'smallbody')\n                    \n                    # Determine if this object needs barycentric elements\n                    # Pluto system objects need center_body when viewing from barycenter\n                    obj_center_body = None\n\n                    if center_object_name in ['Pluto-Charon Barycenter', 'Pluto']:\n                        pluto_system_ids = ['999', '901', '902', '903', '904', '905']   # Pluto, Charon, Styx, Nix, Kerberos, Hydra\n                        if str(horizons_id) in pluto_system_ids:\n                            obj_center_body = osculating_center_body\n                    elif center_object_name in ['Orcus-Vanth Barycenter', 'Orcus']:\n                        # Check if this is an Orcus system object (Orcus or Vanth)\n                        orcus_system_ids = ['920090482', '120090482', '2004 DW']  # Orcus primary, Vanth, Orcus small body\n                        if str(horizons_id) in orcus_system_ids:\n                            obj_center_body = osculating_center_body\n                    elif center_object_name == 'Patroclus-Menoetius Barycenter':\n                        # Check if this is a Patroclus system object (Patroclus or Menoetius)\n                        patroclus_system_ids = ['920000617', '120000617', 'A906 UL']  # Patroclus primary, Menoetius, smallbody\n                        if str(horizons_id) in patroclus_system_ids:\n                            obj_center_body = osculating_center_body       \n                    elif center_object_name in ['Earth-Moon Barycenter', 'Earth']:\n                        earth_moon_system_ids = ['399', '301']  # Earth, Moon\n                        if str(horizons_id) in earth_moon_system_ids:\n                            obj_center_body = osculating_center_body                            \n\n                    # Trigger the GUI prompt with proper Horizons ID and center\n\n                    fresh_elements = get_elements_with_prompt(\n                        obj_name, \n                        horizons_id=horizons_id,\n                        id_type=id_type,\n                        plot_date=plot_date,\n                        parent_window=root,\n                        center_body=obj_center_body\n                    )\n\n                else:\n                    # Fallback to old behavior if object not found\n                    print(f\"[WARNING] Object dictionary not found for {obj_name}, using name as ID\", flush=True)\n            #        fresh_elements = get_elements_with_prompt(obj_name, plot_date=plot_date, parent_window=root)\n                    fresh_elements = get_elements_with_prompt(obj_name, plot_date=plot_date, parent_window=root, center_body=osculating_center_body)\n                \n                # Update working copy\n                active_planetary_params[obj_name] = fresh_elements\n                \n                # DEBUG: Validation\n                if obj_name == 'Mercury':\n                    ecc = fresh_elements.get('e', 0)\n                    if ecc >= 0.7:\n                        print(f\"[WARNING] Mercury is using MANUAL FALLBACK data (e={ecc})\", flush=True)\n                        messagebox.showwarning(\"Fetch Failed\", f\"Could not fetch fresh data for {obj_name}.\\nSystem is using manual fallback (e={ecc}).\\nCheck internet connection or Horizons availability.\")\n                    else:\n                        print(f\"[SUCCESS] Mercury fetched fresh data (e={ecc})\", flush=True)\n                \n                print(f\"[PRE-FETCH] OK: {obj_name}: Updated\", flush=True)\n                    \n            except Exception as e:\n                print(f\"[PRE-FETCH] ERROR: {obj_name}: {e}\", flush=True)\n                traceback.print_exc()\n    # =========================================================================\n        \n    def worker():\n        try:\n\n            # Add explicit reference to avoid issues with nested scopes\n            global orbit_paths_over_time\n            nonlocal active_planetary_params  # Access the pre-fetched orbital params\n\n            exo_objects = [obj for obj in objects \n                        if obj['var'].get() == 1 and obj.get('object_type') == 'exoplanet']\n\n            exo_host_stars = [obj for obj in objects\n                    #   if obj['var'].get() == 1 and obj.get('object_type') == 'exo_host_star'] \n                        if obj['var'].get() == 1 and obj.get('object_type') in ['exo_host_star', 'exo_binary_star', 'exo_barycenter']]            \n\n            # Detect if we're in exoplanet mode (for coordinate system legend)\n            is_exoplanet_mode = bool(exo_objects or exo_host_stars)\n\n            # Reset the global today or use a local today variable\n            today = datetime.today()\n\n            # Create figure object at the start\n            fig = go.Figure()\n\n            # Add global sun direction indicator to the plot\n    #        fig = add_global_sun_direction_indicator(fig)\n\n            # Generate default name with timestamp\n            current_date = STATIC_TODAY\n            default_name = f\"solar_system_{current_date.strftime('%Y%m%d_%H%M')}\"\n                       \n            output_label.config(text=\"Fetching data, please wait...\")\n            progress_bar['mode'] = 'indeterminate'\n            progress_bar.start(10)  # Start the progress bar with a slight delay\n            root.update_idletasks()  # Force GUI to update\n\n            # REPLACE the interval handling section with:\n            settings, error_msg = get_interval_settings()\n            if error_msg:\n                output_label.config(text=error_msg)\n            \n            # CRITICAL FIX: Ensure we have the correct days_to_plot\n            # Double-check by reading directly from GUI\n        #    gui_days = int(days_to_plot_entry.get())\n        #    if settings['days_to_plot'] != gui_days:\n        #        print(f\"[WARNING] Settings mismatch: settings={settings['days_to_plot']}, GUI={gui_days}\", flush=True)\n        #        settings['days_to_plot'] = gui_days\n\n            # Debug check - don't override the precise calculated value from date range\n            gui_days = int(days_to_plot_entry.get()) if days_to_plot_entry.get() else 0\n            if int(settings['days_to_plot']) != gui_days:\n                print(f\"[INFO] days_to_plot: calculated={settings['days_to_plot']:.6f} days ({settings['days_to_plot']*24*60:.1f} min), GUI shows={gui_days} days\", flush=True)\n            # Note: Don't override - calculated value preserves sub-day precision for flybys     \n\n            # Extract the values\n            trajectory_points = settings['trajectory_points']\n            orbital_points = settings['orbital_points']\n            satellite_days = settings['satellite_days']\n            satellite_points = settings['satellite_points']\n            start_date = settings['start_date']\n            end_date = settings['end_date']\n            \n            # Get the date\n            date_obj = get_date_from_gui()\n\n            # Define hover_data with a default value\n            hover_data = \"Full Object Info\"  # Or \"Object Names Only\"\n\n            # Determine center object\n            center_object_name = center_object_var.get()\n            center_object_info = next((obj for obj in objects if obj['name'] == center_object_name), None)\n\n            # Capture center's system ID\n            center_system_id = (center_object_info or {}).get('system_id', 'solar')\n            print(f\"[SYSTEM SCOPE] Center: {center_object_name}, System: {center_system_id}\", flush=True)\n\n            if center_object_info:\n                if center_object_name == 'Sun':\n                    center_id = 'Sun'\n                    center_id_type = None\n                else:\n            #        center_id = center_object_info['id']\n                    center_id = center_object_info.get('center_id', center_object_info['id'])\n                    center_id_type = center_object_info.get('id_type')\n            else:\n                center_id = 'Sun'\n                center_id_type = None\n\n# Get selected objects\n            selected_objects = [obj for obj in objects if obj['var'].get() == 1]\n            \n            if not selected_objects:\n                output_label.config(text=\"No objects selected for plotting\")\n                progress_bar.stop()\n                return\n\n            # Check if we're in special fetch mode or normal mode\n            if special_fetch_var.get() == 0:  # Normal mode\n\n                # Check if any selected object needs updating\n                need_update = False\n                fetch_requests = []  # Store what needs to be fetched\n\n                # Calculate the date range we need\n                cache_start_date = settings['start_date']  # Or get_date_from_gui()\n                cache_end_date = settings['end_date']      # Or get_end_date_from_gui()\n\n                # These TNO moons have no usable JPL parent-centered ephemeris\n        #        SKIP_HORIZONS_TRAJECTORY = ['MK2', 'Xiangliu', 'Vanth', 'Weywot']\n                SKIP_HORIZONS_TRAJECTORY = ['MK2', 'Xiangliu', 'Vanth', 'Gonggong']  # Weywot removed - JPL data works at Quaoar\n                \n                for obj in selected_objects:\n                    # Skip exoplanet objects - they don't use JPL Horizons\n                    if obj.get('object_type') in ['exoplanet', 'exo_host_star', 'exo_binary_star', 'exo_barycenter']:    \n                        continue\n                    # Skip TNO moons that use analytical orbits only\n                    if obj['name'] in SKIP_HORIZONS_TRAJECTORY:\n                        continue\n\n                    orbit_key = f\"{obj['name']}_{center_object_name}\"\n                    \n                    # Check if orbit exists in cache\n                    if orbit_key not in orbit_paths_over_time:\n                        need_update = True\n                        fetch_requests.append({\n                            'object': obj,\n                            'fetch_start': cache_start_date,\n                            'fetch_end': cache_end_date,\n                            'reason': 'not in cache'\n                        })\n                        print(f\"{obj['name']}: Not in cache, need full range\", flush=True)\n                    else:\n                        # Check if cached date range covers what we need\n                        cached_data = orbit_paths_over_time[orbit_key]\n                        \n                        if 'metadata' in cached_data:\n                #            cache_meta_start = cached_data['metadata'].get('start_date')\n                #            cache_meta_end = cached_data['metadata'].get('end_date')\n                            cache_meta_start = cached_data['metadata'].get('start_date') or cached_data['metadata'].get('earliest_date')\n                            cache_meta_end = cached_data['metadata'].get('end_date') or cached_data['metadata'].get('latest_date')\n                            \n                            if cache_meta_start and cache_meta_end:\n                                existing_start = datetime.strptime(cache_meta_start, '%Y-%m-%d')\n                                existing_end = datetime.strptime(cache_meta_end, '%Y-%m-%d')\n                                \n                                # Determine what gaps need filling\n                                fetch_gaps = []\n                                \n                                # Gap at the beginning?\n                                if cache_start_date < existing_start:\n                                    fetch_gaps.append((cache_start_date, existing_start - timedelta(days=1)))\n                                \n                                # Gap at the end?\n                                if cache_end_date > existing_end:\n                                    fetch_gaps.append((existing_end + timedelta(days=1), cache_end_date))\n                                \n                                if fetch_gaps:\n                                    need_update = True\n                                    for gap_start, gap_end in fetch_gaps:\n                                        fetch_requests.append({\n                                            'object': obj,\n                                            'fetch_start': gap_start,\n                                            'fetch_end': gap_end,\n                                            'reason': 'gap in cache'\n                                        })\n                                        days_to_fetch = (gap_end - gap_start).days + 1\n                                        print(f\"{obj['name']}: Need {days_to_fetch} days from {gap_start} to {gap_end}\", flush=True)\n                \n                # Handle updates based on user preference\n                should_update = False\n                \n                if need_update and not update_choice_remembered:\n                    # Show dialog\n                    dialog = tk.Toplevel(root)\n                    dialog.title(\"Update Orbit Data?\")\n                    dialog.geometry(\"400x200\")\n                    \n                    message = tk.Label(dialog, \n                        text=f\"New orbit data is needed for {len(selected_objects)} selected objects.\\n\\n\"\n                             f\"Would you like to fetch updated data from JPL Horizons?\",\n                        wraplength=350)\n                    message.pack(pady=20)\n                    \n                    remember_var = tk.IntVar(value=0)\n                    remember_check = tk.Checkbutton(dialog,\n                        text=\"Remember my choice for this session\\n\"\n                             \"(Warning: This applies globally to all plots)\",\n                        variable=remember_var)\n                    remember_check.pack(pady=10)\n                    \n                    button_frame = tk.Frame(dialog)\n                    button_frame.pack()\n                    \n                    user_choice = {'update': None}\n                    \n                    def on_yes():\n                        user_choice['update'] = True\n                        if remember_var.get() == 1:\n                            global remember_update_choice, update_choice_remembered\n                            remember_update_choice = True\n                            update_choice_remembered = True\n                        dialog.destroy()\n                    \n                    def on_no():\n                        user_choice['update'] = False\n                        if remember_var.get() == 1:\n                            global remember_update_choice, update_choice_remembered\n                            remember_update_choice = False\n                            update_choice_remembered = True\n                        dialog.destroy()\n                    \n                    tk.Button(button_frame, text=\"Yes - Update Cache\", \n                             command=on_yes, bg='light green').pack(side='left', padx=5)\n                    tk.Button(button_frame, text=\"No - Use Existing\", \n                             command=on_no, bg='light coral').pack(side='left', padx=5)\n                    \n                    dialog.wait_window()\n                    \n                    should_update = user_choice.get('update', False)\n                \n                elif need_update and update_choice_remembered:\n                    # Use remembered choice\n                    should_update = remember_update_choice\n                \n                # Perform update if needed\n                if should_update:\n                    update_status_display(\"Updating orbit cache for selected objects...\", 'info')\n                    progress_bar.step(10)\n                    root.update_idletasks()\n                    \n                    updated, current, total, time_saved = orbit_data_manager.update_orbit_paths_incrementally(\n                        object_list=selected_objects,\n                        center_object_name=center_object_name,\n                #        days_ahead=int(get_end_date_from_gui()),\n                        days_ahead=int(days_to_plot_entry.get()),\n                        planetary_params=active_planetary_params,\n                        parent_planets=parent_planets,\n                        root_widget=root\n                    )\n                    \n                    update_status_display(f\"Cache updated: {updated} new, {current} current\", 'success')\n                else:\n                    update_status_display(\"Using existing cache without updates\", 'info')\n                    \n            else:  # Special fetch mode\n                update_status_display(\"Special fetch mode: Fetching data (not cached)...\", 'special')\n                \n                # In special fetch mode, determine interval based on object type\n                for obj in selected_objects:\n                    if obj['name'] != center_object_name:\n                        orbit_key = f\"{obj['name']}_{center_object_name}\"\n                        \n                        # Get object type\n                        obj_type = obj.get('object_type', 'unknown')\n                        \n                        # Determine interval based on object type\n                        if obj_type == 'trajectory':\n                            # Missions, interstellar objects, comets - use fine intervals\n                            interval = trajectory_interval_entry.get()\n                        elif obj_type == 'satellite':\n                            # Moons need very fine resolution\n                            interval = satellite_interval_entry.get()\n                        elif obj_type == 'orbital':\n                            # Planets, asteroids, TNOs - can use coarser intervals\n                    #        if obj.get('e', 0) > 0.5:  # High eccentricity needs finer intervals\n                    #            interval = eccentric_interval_entry.get()\n                    #        else:\n                            interval = default_interval_entry.get()\n                        elif obj_type == 'lagrange_point':\n                            # L-points move smoothly, medium resolution is fine\n                            interval = default_interval_entry.get()\n                        elif obj_type == 'fixed':\n                            # Fixed objects don't need trajectories\n                            continue  # Skip fetching - NOW INSIDE THE LOOP\n                        else:\n                            # Fallback\n                            interval = default_interval_entry.get()\n                            \n                        # Calculate date range\n                        start_date = get_date_from_gui()\n                        end_date = get_end_date_from_gui()\n                        \n                        # Fetch without caching to main file\n                        orbit_data = fetch_orbit_path(obj, start_date, end_date, interval,\n                                                    center_id=center_id, id_type=obj.get('id_type'))\n                        if orbit_data:\n                            temp_cache[orbit_key] = orbit_data\n                \n                # Save temp cache\n                with open(TEMP_CACHE_FILE, 'w') as f:\n                    json.dump(temp_cache, f)\n                \n                update_status_display(f\"Special fetch complete: {len(temp_cache)} orbits in temp cache\", 'special')\n            \n            progress_bar.step(10)\n            root.update_idletasks()\n\n            # Define planets with shell visualizations\n            planets_with_shells = {\n                'Mercury': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': mercury_shell_vars\n                },\n                'Venus': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': venus_shell_vars\n                },\n                'Earth': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': earth_shell_vars\n                },\n                'Moon': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': moon_shell_vars\n                },\n                'Mars': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': mars_shell_vars\n                },\n                'Jupiter': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': jupiter_shell_vars\n                },\n                'Saturn': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': saturn_shell_vars\n                },\n                'Uranus': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': uranus_shell_vars\n                },\n                'Neptune': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': neptune_shell_vars\n                },\n                'Pluto': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': pluto_shell_vars\n                },\n                'Eris': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': eris_shell_vars\n                },\n                'Planet 9': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': planet9_shell_vars\n                }\n            }\n\n            # Create date lists for each selected object\n            dates_lists = {}\n            for obj in objects:\n\n                # For satellites specifically, even if they have orbital parameters, \n                # we should always fetch their actual position data\n                if obj['var'].get() == 1 and obj['name'] != center_object_name:\n\n                    # Check if this is a satellite of a planet\n                    is_satellite = False\n                    parent_planet = None\n                    for planet, moons in parent_planets.items():\n                        if obj['name'] in moons:\n                            is_satellite = True\n                            parent_planet = planet  # Use 'planet' to match the loop variable\n                            break\n\n                    is_parent = obj['name'] in parent_planets    \n                    \n                                        # Get object type (with fallback for backward compatibility)\n                    obj_type = obj.get('object_type', None)\n                            \n                    if obj_type == 'trajectory':\n                        # Time-bounded paths\n                        # Check if object has specific start/end dates\n                        if 'start_date' in obj and 'end_date' in obj:\n                            # Use object-specific dates\n                            start_date = obj.get('start_date', date_obj)\n                            end_date = obj.get('end_date', date_obj)\n                        else:\n                            # Use GUI settings for objects without specific dates (like 3I/ATLAS)\n                            start_date = settings['start_date']\n                            end_date = settings['end_date']\n                            \n                    #    total_days = (end_date - start_date).days\n                        # Use total_seconds() to preserve fractional days\n                        total_days = (end_date - start_date).total_seconds() / 86400\n                        \n                        if total_days <= 0:\n                            # Use requested days from GUI\n                            requested_days = settings['days_to_plot']\n                            end_date = start_date + timedelta(days=requested_days)\n                            total_days = requested_days\n                            \n                        num_points = int(trajectory_points) + 1\n                        dates_list = [start_date + timedelta(days=float(d)) \n                                    for d in np.linspace(0, total_days, num=num_points)]\n                        \n                    # Check if this object is a satellite of the current center              \n                    # (regardless of object_type - e.g., Pluto is 'orbital' but orbits the barycenter)\n                    elif obj['name'] in parent_planets.get(center_object_name, []):\n                        # Moons/orbiters of the center object - use satellite settings\n                        num_points = int(satellite_points) + 1\n                        actual_days_to_plot = settings['days_to_plot'] \n                        dates_list = [date_obj + timedelta(days=float(d)) \n                                    for d in np.linspace(0, actual_days_to_plot, num=num_points)]\n\n            #        elif obj_type == 'orbital' and obj['name'] in planetary_params:\n                    elif obj_type == 'orbital' and obj['name'] in active_planetary_params:      # uses osculating elements\n\n                        # Get the raw days_to_plot value\n                        raw_days = int(days_to_plot_entry.get())\n                        settings_days = settings['days_to_plot']\n                        \n                        print(f\"  Raw days_to_plot from entry: {raw_days}\", flush=True)\n                        print(f\"  Settings days_to_plot: {settings_days}\", flush=True)\n                        # ==========================================\n                        \n                        # Planets, dwarf planets, TNOs\n            #            a = planetary_params[obj['name']]['a']\n                        a = active_planetary_params[obj['name']]['a']\n                        \n                        if a > 0:  # Only for elliptical orbits\n                            orbital_period_years = np.sqrt(a ** 3)\n                            orbital_period_days = orbital_period_years * 365.25\n                        else:\n                            # Hyperbolic orbit - use a reasonable default span\n                            orbital_period_days = 365.25  # 1 year default for trajectories\n\n                        # FIX: Use the actual requested days, don't limit by orbital period\n                        requested_days = settings['days_to_plot']\n                        # Remove the limitation - let user plot multiple orbits if desired\n                        plot_days = requested_days  # NOT min(orbital_period_days, requested_days)\n                        \n                        # ============ MORE DEBUG #3 ============\n                        print(f\"  Orbital period: {orbital_period_days:.1f} days\", flush=True)\n                        print(f\"  Requested days: {requested_days}\", flush=True)\n                        print(f\"  Plot days (NO LIMIT): {plot_days}\", flush=True)\n                        # =======================================\n                        \n                        # Apply system limits\n                        days_until_horizons = (HORIZONS_MAX_DATE - date_obj).days\n                        capped_days = min(plot_days, days_until_horizons)\n                        \n                        # ============ MORE DEBUG #3 ============\n                        print(f\"  Final days for dates_list: {capped_days}\", flush=True)\n                        # =======================================\n                        \n                        num_points = int(settings['orbital_points']) + 1\n\n                        dates_list = [date_obj + timedelta(days=float(d)) \n                                    for d in np.linspace(0, capped_days, num=num_points)]\n                        \n                        # ============ FINAL DEBUG #3 ============\n                        print(f\"  Dates list spans: {(dates_list[-1] - dates_list[0]).days} days\", flush=True)\n                        print(f\"  First date: {dates_list[0]}\", flush=True)\n                        print(f\"  Last date: {dates_list[-1]}\", flush=True)\n                        # ========================================\n\n                    elif obj_type == 'fixed':\n                        if obj['name'] == 'Sun':\n\n                            if is_exoplanet_mode:\n                                print(f\"Skipping Sun in exoplanet animation mode\", flush=True)\n                                continue\n\n                            if center_object_name != 'Sun':\n                                # Sun needs trajectory when viewed from another center (e.g., Earth)\n                                requested_days = settings['days_to_plot']\n                                num_points = int(orbital_points) + 1\n                                dates_list = [date_obj + timedelta(days=float(d)) \n                                            for d in np.linspace(0, requested_days, num=num_points)]\n                                print(f\"Sun needs trajectory relative to {center_object_name}\", flush=True)\n                            else:\n                                # Sun at origin doesn't need trajectory\n                                dates_list = [date_obj]\n                        else:\n                            # Other fixed objects only need single date\n                            dates_list = [date_obj]\n                            print(f\"Fixed object {obj['name']}: single date point\", flush=True)\n\n                    elif obj_type == 'lagrange_point':\n                        # Lagrange points need dates to show their co-orbital motion\n                #        requested_days = int(get_end_date_from_gui()) - int(get_date_from_gui())\n                        requested_days = settings['days_to_plot']  # Use settings instead of bad calculation\n                        num_points = int(settings['orbital_points']) + 1  # Use settings\n                        num_points = int(orbital_points) + 1  # Changed from planet_interval_divisor\n                        dates_list = [date_obj + timedelta(days=float(d)) for d in np.linspace(0, requested_days, num=num_points)]\n\n                    else:\n                        print(f\"ERROR: No handler for object type '{obj_type}' for {obj['name']}\", flush=True)\n                        dates_list = [date_obj]\n\n                    # Store the dates list\n                    dates_lists[obj['name']] = dates_list\n\n                    # Debug output\n                    if dates_list and len(dates_list) > 1:\n                        print(f\"{obj['name']} ({obj_type}): {len(dates_list)} dates from {dates_list[0]} to {dates_list[-1]} ({(dates_list[-1] - dates_list[0]).days} days)\", flush=True)\n\n            # Fetch positions for selected objects on the chosen date\n            positions = {}\n            for obj in objects:\n        #        if obj['var'].get() == 1:\n\n                if not obj['var'].get():\n                    continue\n                # System-scope: only same-system objects\n                if obj['name'] != center_object_name and obj.get('system_id', 'solar') != center_system_id:\n                    continue\n\n                if obj['name'] == 'Planet 9' or obj['id'] == 'planet9_placeholder':\n                        # Calculate Planet 9 position directly on its theoretical orbit\n                        x, y, z, range_val = calculate_planet9_position_on_orbit()\n                        # Create a complete position object\n                        obj_data = {\n                            'x': x,\n                            'y': y,\n                            'z': z,\n                            'range': range_val,\n                            'distance_km': range_val * KM_PER_AU,\n                            'distance_lm': range_val * LIGHT_MINUTES_PER_AU,\n                            'distance_lh': (range_val * LIGHT_MINUTES_PER_AU) / 60,\n                            'vx': 0,\n                            'vy': 0,\n                            'vz': 0,\n                            'velocity': 0,\n                            'calculated_orbital_period': {\n                                'years': np.sqrt(600**3),  # Semi-major axis^1.5\n                                'days': np.sqrt(600**3) * 365.25\n                            },\n                            'known_orbital_period': {\n                                'years': np.sqrt(600**3),\n                                'days': np.sqrt(600**3) * 365.25\n                            },\n                            'orbital_period': np.sqrt(600**3)  # Orbital period in years\n                        }\n                elif obj['name'] == center_object_name:\n\n                        obj_data = {'x': 0, 'y': 0, 'z': 0}\n            #    else:\n            #            obj_data = fetch_position(obj['id'], date_obj, center_id=center_id, id_type=obj.get('id_type', None))\n\n                else:\n                        # Use helio_id for Sun-centered plots if available\n                        fetch_id = obj['id']\n                        fetch_id_type = obj.get('id_type', None)\n                        if center_object_name == 'Sun' and 'helio_id' in obj:\n                            fetch_id = obj['helio_id']\n                            fetch_id_type = 'smallbody'\n                        obj_data = fetch_position(fetch_id, date_obj, center_id=center_id, id_type=fetch_id_type)\n                        \n                        # Special case: Orcus at Orcus-Vanth Barycenter - derive from Vanth's position\n                        # JPL doesn't have 920090482 as a valid target, but 120090482 (Vanth) works\n                        # Orcus is on opposite side of barycenter at 1/mass_ratio of Vanth's distance\n\n                        orcus_needs_derivation = (\n                            obj['name'] == 'Orcus' and \n                            center_object_name == 'Orcus-Vanth Barycenter' and\n                            (obj_data is None or (obj_data.get('x') == 0 and obj_data.get('y') == 0 and obj_data.get('z') == 0))\n                        )\n                        if orcus_needs_derivation:\n\n                            print(f\"  - Deriving Orcus position from Vanth (mass ratio method)...\", flush=True)\n                            # Fetch Vanth's position\n                            vanth_data = fetch_position('120090482', date_obj, center_id=center_id, id_type=None)\n                            if vanth_data and vanth_data.get('x') != 0:\n                                # Mass ratio: M_Vanth/M_Orcus = 0.16\n                                # Orcus is at -1/mass_ratio * Vanth's position relative to barycenter\n                                mass_ratio = 0.16\n                                x_orcus = -vanth_data['x'] * mass_ratio\n                                y_orcus = -vanth_data['y'] * mass_ratio\n                                z_orcus = -vanth_data['z'] * mass_ratio\n                                r_orcus = np.sqrt(x_orcus**2 + y_orcus**2 + z_orcus**2)\n                                # Velocity: same ratio, opposite direction\n                                vx_orcus = -vanth_data.get('vx', 0) * mass_ratio\n                                vy_orcus = -vanth_data.get('vy', 0) * mass_ratio\n                                vz_orcus = -vanth_data.get('vz', 0) * mass_ratio\n                                v_orcus = np.sqrt(vx_orcus**2 + vy_orcus**2 + vz_orcus**2)\n                                \n                                obj_data = {\n                                    'x': x_orcus, 'y': y_orcus, 'z': z_orcus,\n                                    'range': r_orcus,\n                                    'vx': vx_orcus, 'vy': vy_orcus, 'vz': vz_orcus,\n                                    'velocity': v_orcus,\n                                    'distance_km': r_orcus * KM_PER_AU,\n                                    'distance_lm': r_orcus * LIGHT_MINUTES_PER_AU,\n                                    'distance_lh': (r_orcus * LIGHT_MINUTES_PER_AU) / 60,\n                                    'derived_from_vanth': True\n                                }\n                                print(f\"  -> Orcus position: ({x_orcus:.7f}, {y_orcus:.7f}, {z_orcus:.7f}) AU, r={r_orcus:.7f} AU (~{r_orcus * 149597870.7:.0f} km)\", flush=True)\n\n                            else:\n                                print(f\"  -> Could not fetch Vanth position to derive Orcus\", flush=True)\n\n                        # Fallback to analytical position for objects not in Horizons (e.g., 6AC4721)\n                        if obj_data is None and obj['name'] in active_planetary_params and 'MA' in active_planetary_params[obj['name']]:\n                            print(f\"  - No JPL data for {obj['name']}, calculating analytical position from MA...\", flush=True)\n                            elements = active_planetary_params[obj['name']]\n                            a = elements.get('a', 0)\n                            e = elements.get('e', 0)\n                            i_deg = elements.get('i', 0)\n                            omega_deg = elements.get('omega', 0)\n                            Omega_deg = elements.get('Omega', 0)\n                            MA_epoch = elements.get('MA', 0)\n                            \n                            # Get orbital period\n                            if 'orbital_period_days' in elements:\n                                orbital_period = elements['orbital_period_days']\n                            elif a > 0:\n                                orbital_period = np.sqrt(a**3) * 365.25\n                            else:\n                                orbital_period = 365.25\n                            \n                            # Get reference epoch\n                            if 'epoch' in elements:\n                                epoch_str = str(elements['epoch']).replace(' osc.', '').strip()\n                                try:\n                                    ref_epoch = datetime.strptime(epoch_str, '%Y-%m-%d')\n                                except ValueError:\n                                    ref_epoch = datetime(2000, 1, 1, 12, 0, 0)\n                            else:\n                                ref_epoch = datetime(2000, 1, 1, 12, 0, 0)\n                            \n                            # Calculate position\n                            delta_days = (date_obj - ref_epoch).total_seconds() / 86400.0\n                            n = 360.0 / orbital_period\n                            M_deg = (MA_epoch + n * delta_days) % 360.0\n                            M_rad = np.radians(M_deg)\n                            \n                            # Solve Kepler's equation\n                            if e > 0.01:\n                                E = M_rad if e < 0.8 else np.pi\n                                for _ in range(50):\n                                    f = E - e * np.sin(E) - M_rad\n                                    f_prime = 1 - e * np.cos(E)\n                                    if abs(f_prime) < 1e-12:\n                                        break\n                                    E = E - f / f_prime\n                                    if abs(f / f_prime) < 1e-10:\n                                        break\n                                true_anomaly = 2 * np.arctan2(\n                                    np.sqrt(1 + e) * np.sin(E / 2),\n                                    np.sqrt(1 - e) * np.cos(E / 2)\n                                )\n                            else:\n                                true_anomaly = M_rad\n                            \n                            # Position in orbital plane\n                            r = a * (1 - e**2) / (1 + e * np.cos(true_anomaly)) if e > 0 else a\n                            x_orb = r * np.cos(true_anomaly)\n                            y_orb = r * np.sin(true_anomaly)\n                            \n                            # Rotation angles\n                            i_rad = np.radians(i_deg)\n                            omega_rad = np.radians(omega_deg)\n                            Omega_rad = np.radians(Omega_deg)\n                            \n                            # Apply rotations\n                            x1 = x_orb * np.cos(omega_rad) - y_orb * np.sin(omega_rad)\n                            y1 = x_orb * np.sin(omega_rad) + y_orb * np.cos(omega_rad)\n                            x2 = x1\n                            y2 = y1 * np.cos(i_rad)\n                            z2 = y1 * np.sin(i_rad)\n                            x_final = x2 * np.cos(Omega_rad) - y2 * np.sin(Omega_rad)\n                            y_final = x2 * np.sin(Omega_rad) + y2 * np.cos(Omega_rad)\n                            z_final = z2\n                            \n                            # Velocity (vis-viva)\n                            GM_sun = 2.959122e-4\n                            v_au_day = np.sqrt(GM_sun * (2/r - 1/a)) if a > 0 else 0\n                            \n                            obj_data = {\n                                'x': x_final, 'y': y_final, 'z': z_final,\n                                'range': r,\n                                'velocity': v_au_day,\n                                'distance_km': r * KM_PER_AU,\n                                'distance_lm': r * LIGHT_MINUTES_PER_AU,\n                                'distance_lh': (r * LIGHT_MINUTES_PER_AU) / 60,\n                                'analytical_position': True\n                            }\n                            print(f\"  -> Analytical position: x={x_final:.4f}, y={y_final:.4f}, z={z_final:.4f} AU (r={r:.3f} AU)\", flush=True)                        \n\n                        # DEBUG: Check what obj_data contains before assignment\n                        if obj['name'] == 'Orcus':\n                            print(f\"  [DEBUG] About to assign Orcus position: {obj_data}\", flush=True)\n\n                positions[obj['name']] = obj_data\n\n                    # Store positions for planets with shells\n                if obj['name'] in planets_with_shells and obj_data and 'x' in obj_data:\n                        planets_with_shells[obj['name']]['position'] = (obj_data['x'], obj_data['y'], obj_data['z'])\n\n            # Print planet positions in the console\n            print_planet_positions(positions)\n\n            if scale_var.get() == 'Auto':\n                selected_objects = [obj for obj in objects if obj['var'].get() == 1]\n\n                axis_range = calculate_axis_range_from_orbits(\n            #        selected_objects, positions, planetary_params, \n                    selected_objects, positions, active_planetary_params,\n\n                    parent_planets, center_object_name\n    )\n\n            else:\n                try:\n                    custom_scale = float(custom_scale_entry.get())\n                    axis_range = [-custom_scale, custom_scale]\n                except ValueError:\n                    output_label.config(text=\"Invalid custom scale value.\")\n                    progress_bar.stop()\n                    return\n\n            # Create Plotly figure\n            fig = go.Figure()\n\n            # Add hover toggle buttons\n            fig = add_hover_toggle_buttons(fig)\n\n            # Define dictionary mapping planets to their shell variable dictionaries\n            planet_shells_config = {\n                'Mercury': mercury_shell_vars,\n                'Venus': venus_shell_vars,\n                'Earth': earth_shell_vars,\n                'Moon': moon_shell_vars,\n                'Mars': mars_shell_vars,\n                'Jupiter': jupiter_shell_vars,\n                'Saturn': saturn_shell_vars,\n                'Uranus': uranus_shell_vars,\n                'Neptune': neptune_shell_vars,\n                'Pluto': pluto_shell_vars,\n                'Eris': eris_shell_vars,\n                'Planet 9': planet9_shell_vars               \n                # Add more planets here as shell systems are developed\n            }\n\n            # Flag to track if shells have been added for center object\n            center_shells_added = False\n\n            # First add Sun visualization if needed\n            if center_object_name == 'Sun' and any(var.get() == 1 for var in sun_shell_vars.values()):\n                fig = create_sun_visualization(fig, sun_shell_vars)\n                center_shells_added = True\n                \n            # Now add planet visualization if the center is a planet with shells\n            elif center_object_name in planet_shells_config:\n                shell_vars = planet_shells_config[center_object_name]\n                if any(var.get() == 1 for var in shell_vars.values()):\n                    fig = create_planet_visualization(fig, center_object_name, shell_vars)\n                    center_shells_added = True\n\n            # Add center marker only if shells haven't been added\n            if not center_shells_added:\n                if center_object_name == 'Sun':\n                    # Just add the central Sun marker if shells not selected\n                    fig.add_trace(\n                        go.Scatter3d(\n                            x=[0],\n                            y=[0],\n                            z=[0],\n                            mode='markers',\n                            marker=dict(\n                                color='rgb(102, 187, 106)',\n                                size=12,\n                                symbol=center_object_info['symbol']\n                            ),\n                            name=\"Sun\",\n                            text=[hover_text_sun],\n                            customdata=[\"Sun\"],\n                            hovertemplate='%{text}<extra></extra>',\n                            showlegend=True\n                        )\n                    )\n\n                else:\n                    # For other central bodies (planets), add the center marker trace\n                    # Check if color is transparent to hide legend\n                    is_transparent = 'rgba(0,0,0,0)' in str(center_object_info['color']).replace(' ', '')\n                    \n                    fig.add_trace(\n                        go.Scatter3d(\n                            x=[0],\n                            y=[0],\n                            z=[0],\n                            mode='markers',\n                            marker=dict(\n                                color=center_object_info['color'],\n                                size=12,\n                                symbol=center_object_info['symbol']\n                            ),\n                            name=f\"{center_object_name}\",\n                            text=[center_object_name],\n                            hoverinfo='skip',\n                            showlegend=not is_transparent  # Hide legend if transparent\n                        )\n                    )\n\n\n            # Create dictionary of shell variables for each planet\n            planet_shell_vars = {\n                'Mercury': mercury_shell_vars,\n                'Venus': venus_shell_vars,\n                'Earth': earth_shell_vars,\n                'Moon': moon_shell_vars,\n                'Mars': mars_shell_vars,\n                'Jupiter': jupiter_shell_vars,\n                'Saturn': saturn_shell_vars,\n                'Uranus': uranus_shell_vars,\n                'Neptune': neptune_shell_vars,\n                'Pluto': pluto_shell_vars,\n                'Eris': eris_shell_vars,\n                'Planet 9': planet9_shell_vars               \n            }\n\n            # Add Sun direction indicator for non-center planets with shells\n            for planet_name, planet_data in planets_with_shells.items():\n                is_center = (center_object_name == planet_name)\n                \n                # Modified condition: allow shells for any planet, not just the center\n                if planet_name in planet_shell_vars:\n                    # For center planet, position at (0,0,0)\n                    if is_center and not center_shells_added:\n                        print(f\"\\nAdding shells for center planet {planet_name}\", flush=True)\n                        fig = create_planet_visualization(\n                            fig,                            # First parameter should be fig\n                            planet_name,                    # Second parameter should be planet_name\n                            planet_shell_vars[planet_name], # Third parameter should be shell_vars\n                            center_position=(0, 0, 0)       # Named parameter can stay as is\n                        )\n                    # For non-center planets, use their actual positions\n                    elif not is_center and 'position' in planet_data and planet_data['position'] is not None:\n                        # Check if any shell for this planet is selected\n                        if any(var.get() == 1 for var in planet_shell_vars[planet_name].values()):\n                            print(f\"\\nAdding shells for non-center planet {planet_name}\", flush=True)\n                            \n                            # Always add the planet shells\n                            fig = create_planet_visualization(\n                                fig,                            \n                                planet_name,                    \n                                planet_shell_vars[planet_name], \n                                center_position=planet_data['position']  # Use planet's position\n                            )\n\n                            # Only add sun direction indicator when Sun is not the center\n                            if center_object_name != 'Sun':\n                                print(f\"Adding Sun direction indicator for {planet_name}\", flush=True)\n                                sun_direction_traces = create_sun_direction_indicator(\n                                    center_position=planet_data['position'],\n                                    axis_range=axis_range,  # Pass the axis_range parameter\n                                    object_type=planet_name,\n                                    center_object=center_object_name\n                                )\n\n                                for trace in sun_direction_traces:\n                                    fig.add_trace(trace)\n                            \n            # NEW: Add Sun corona when viewing from non-Sun center\n            if center_object_name != 'Sun':\n                if sun_shell_vars.get('corona_from_distance') and sun_shell_vars['corona_from_distance'].get() == 1:\n                    # Get Sun's position relative to current center\n                    if 'Sun' in positions and positions['Sun'] is not None:\n                        sun_pos_dict = positions['Sun']\n                        # Extract x, y, z from dictionary\n                        sun_position = (sun_pos_dict['x'], sun_pos_dict['y'], sun_pos_dict['z'])\n                        print(f\"\\nAdding Sun corona layers at position {sun_position}\", flush=True)\n                        fig = create_sun_corona_from_distance(fig, sun_shell_vars, sun_position)\n\n            selected_planets = [\n                obj['name'] for obj in objects\n                if obj['var'].get() == 1\n                and obj['name'] != center_object_name\n                and obj.get('system_id', 'solar') == center_system_id\n            ]\n\n            # Pass center_object_name to plot_actual_orbits\n\n            plot_actual_orbits(fig, selected_planets, dates_lists, center_id=center_id, show_lines=True, center_object_name=center_object_name, show_closest_approach=show_closest_approach_var.get())\n\n            # ADD PLOTTED PERIOD OVERLAY FOR TRAJECTORY OBJECTS (yellow highlight)\n            # This shows the GUI-selected date range overlaid on the full mission\n            trajectory_objects = [obj for obj in selected_objects \n                                 if obj.get('object_type') == 'trajectory' \n                                 and obj['name'] != center_object_name]\n            \n            if trajectory_objects:\n                print(f\"\\n[PLOTTED PERIOD] Adding yellow overlay for {len(trajectory_objects)} trajectory objects...\", flush=True)\n                \n                for obj in trajectory_objects:\n                    obj_name = obj['name']\n                    \n                    # Get mission bounds\n                    mission_start = obj.get('start_date', settings['start_date'])\n                    mission_end = obj.get('end_date', settings['end_date'])\n                    \n                    # Calculate plotted period (GUI dates clipped to mission bounds)\n                    plot_start = max(settings['start_date'], mission_start)\n                    plot_end = min(settings['end_date'], mission_end)\n                    \n                    # Skip if plotted period doesn't overlap with mission\n                    if plot_start >= plot_end:\n                        print(f\"[PLOTTED PERIOD] {obj_name}: No overlap with mission dates, skipping\", flush=True)\n                        continue\n                    \n                    # Calculate dates for plotted period\n                    plot_days = (plot_end - plot_start).total_seconds() / 86400\n                    num_points = int(trajectory_points) + 1\n                    plotted_dates = [plot_start + timedelta(days=float(d)) \n                                    for d in np.linspace(0, plot_days, num=num_points)]\n                    \n                    # Use helio_id for Sun-centered plots if available\n                    fetch_id = obj['id']\n                    fetch_id_type = obj.get('id_type')\n                    if center_object_name == 'Sun' and 'helio_id' in obj:\n                        fetch_id = obj['helio_id']\n                        fetch_id_type = 'smallbody'\n                                        \n                    # Fetch trajectory for plotted period\n                    trajectory = fetch_trajectory(fetch_id, plotted_dates, center_id=center_id, id_type=fetch_id_type)\n                    \n                    # ORCUS TRAJECTORY DERIVATION: JPL doesn't support 920090482 as query target\n                    # Derive Orcus trajectory from Vanth using mass ratio\n                    if obj_name == 'Orcus' and center_object_name == 'Orcus-Vanth Barycenter':\n                        # Check if trajectory is all zeros (JPL returns zeros for invalid target)\n                        traj_all_zeros = trajectory and all(\n                            (pos is None or (pos.get('x', 0) == 0 and pos.get('y', 0) == 0 and pos.get('z', 0) == 0))\n                            for pos in trajectory\n                        )\n                        if not trajectory or traj_all_zeros:\n                            print(f\"  - Deriving Orcus trajectory from Vanth (mass ratio method)...\", flush=True)\n                            # Fetch Vanth trajectory - ID 120090482 works correctly\n                            vanth_trajectory = fetch_trajectory('120090482', plotted_dates, center_id=center_id, id_type=None)\n                            if vanth_trajectory:\n                                mass_ratio = 0.16  # Vanth/Orcus mass ratio\n                                trajectory = []\n                                for vanth_pos in vanth_trajectory:\n                                    if vanth_pos and vanth_pos.get('x') != 0:\n                                        # Orcus is opposite Vanth relative to barycenter, scaled by mass ratio\n                                        trajectory.append({\n                                            'x': -vanth_pos['x'] * mass_ratio,\n                                            'y': -vanth_pos['y'] * mass_ratio,\n                                            'z': -vanth_pos['z'] * mass_ratio\n                                        })\n                                    else:\n                                        trajectory.append({'x': 0, 'y': 0, 'z': 0})\n                                print(f\"  -> Derived {len(trajectory)} Orcus positions from Vanth\", flush=True)\n\n                    if trajectory:\n                        x = [pos['x'] for pos in trajectory if pos is not None]\n                        y = [pos['y'] for pos in trajectory if pos is not None]\n                        z = [pos['z'] for pos in trajectory if pos is not None]\n                        \n                        if x:\n                            fig.add_trace(\n                                go.Scatter3d(\n                                    x=x,\n                                    y=y,\n                                    z=z,\n                                    mode='lines',\n                                    line=dict(color='yellow', width=2),\n                                    opacity=1.0,\n                                    name=f\"{obj_name} Plotted Period\",\n                                    text=[f\"{obj_name} Plotted Period\"] * len(x),\n                                    hovertemplate='%{text}<extra></extra>',\n                                    showlegend=True\n                                )\n                            )\n                            print(f\"[PLOTTED PERIOD] {obj_name}: {len(x)} points from {plot_start.strftime('%Y-%m-%d')} to {plot_end.strftime('%Y-%m-%d')}\", flush=True)\n                            \n                            # Add yellow closest approach marker for Plotted Period\n                            if show_closest_approach_var.get():\n                                from apsidal_markers import add_closest_approach_marker\n                                \n                                # Build positions_dict from trajectory data\n                                positions_dict = {}\n                                for i in range(len(x)):\n                                    if i < len(plotted_dates):\n                                        positions_dict[plotted_dates[i].isoformat()] = {\n                                            'x': x[i],\n                                            'y': y[i],\n                                            'z': z[i]\n                                        }\n                                \n                                add_closest_approach_marker(\n                                    fig=fig,\n                                    positions_dict=positions_dict,\n                                    obj_name=obj_name,\n                                    center_body=center_object_name,\n                                    color_map=color_map,\n                                    date_range=(plotted_dates[0], plotted_dates[-1]) if plotted_dates else None,\n                                    marker_color='yellow'  # Yellow for Plotted Period\n                                )\n\n            positions = {}\n\n            for obj in objects:\n                if not obj['var'].get():\n                    continue\n                # Only fetch positions for same-system objects\n                if obj['name'] != center_object_name and obj.get('system_id', 'solar') != center_system_id:\n                    continue\n                \n                if obj['name'] == center_object_name:\n                    obj_data = {'x': 0, 'y': 0, 'z': 0}\n\n        #        else:\n        #            obj_data = fetch_position(obj['id'], date_obj, center_id=center_id, id_type=obj.get('id_type', None))\n                \n                else:\n                    # Use helio_id for Sun-centered plots if available\n                    fetch_id = obj['id']\n                    fetch_id_type = obj.get('id_type', None)\n                    if center_object_name == 'Sun' and 'helio_id' in obj:\n                        fetch_id = obj['helio_id']\n                        fetch_id_type = 'smallbody'\n                    obj_data = fetch_position(fetch_id, date_obj, center_id=center_id, id_type=fetch_id_type)\n\n                    # Special case: Orcus at Orcus-Vanth Barycenter - derive from Vanth's position\n                    orcus_needs_derivation = (\n                        obj['name'] == 'Orcus' and \n                        center_object_name == 'Orcus-Vanth Barycenter' and\n                        (obj_data is None or (obj_data.get('x') == 0 and obj_data.get('y') == 0 and obj_data.get('z') == 0))\n                    )\n                    if orcus_needs_derivation:\n                        print(f\"  - Deriving Orcus position from Vanth (mass ratio method)...\", flush=True)\n                        vanth_data = fetch_position('120090482', date_obj, center_id=center_id, id_type=None)\n                        if vanth_data and vanth_data.get('x') != 0:\n                            mass_ratio = 0.16\n                            x_orcus = -vanth_data['x'] * mass_ratio\n                            y_orcus = -vanth_data['y'] * mass_ratio\n                            z_orcus = -vanth_data['z'] * mass_ratio\n                            r_orcus = np.sqrt(x_orcus**2 + y_orcus**2 + z_orcus**2)\n                            vx_orcus = -vanth_data.get('vx', 0) * mass_ratio\n                            vy_orcus = -vanth_data.get('vy', 0) * mass_ratio\n                            vz_orcus = -vanth_data.get('vz', 0) * mass_ratio\n                            v_orcus = np.sqrt(vx_orcus**2 + vy_orcus**2 + vz_orcus**2)\n                            obj_data = {\n                                'x': x_orcus, 'y': y_orcus, 'z': z_orcus,\n                                'range': r_orcus,\n                                'vx': vx_orcus, 'vy': vy_orcus, 'vz': vz_orcus,\n                                'velocity': v_orcus,\n                                'distance_km': r_orcus * KM_PER_AU,\n                                'distance_lm': r_orcus * LIGHT_MINUTES_PER_AU,\n                                'distance_lh': (r_orcus * LIGHT_MINUTES_PER_AU) / 60,\n                                'derived_from_vanth': True\n                            }\n                            print(f\"  -> Orcus: r={r_orcus:.7f} AU (~{r_orcus * 149597870.7:.0f} km)\", flush=True)\n\n                # Fallback for objects without JPL ephemeris (e.g., MK2, 6AC4721)\n            #    ANALYTICAL_POSITION_FALLBACK = ['MK2', 'Xiangliu', 'Vanth', 'Weywot', '6AC4721']\n                ANALYTICAL_POSITION_FALLBACK = ['MK2', 'Xiangliu', 'Vanth', 'Gonggong', '6AC4721']  # Weywot removed - JPL data works at Quaoar\n                if obj_data is None and obj['name'] in ANALYTICAL_POSITION_FALLBACK:\n                    from orbital_elements import planetary_params\n                    if obj['name'] in planetary_params:\n                        elements = planetary_params[obj['name']]\n                        a = elements.get('a', 0)\n                        e = elements.get('e', 0)\n                        i_deg = elements.get('i', 0)\n                        omega_deg = elements.get('omega', 0)\n                        Omega_deg = elements.get('Omega', 0)\n                        \n                        # Get orbital period - calculate from a if not provided\n                        if 'orbital_period_days' in elements:\n                            orbital_period = elements['orbital_period_days']\n                        elif a > 0:\n                            orbital_period = np.sqrt(a**3) * 365.25\n                        else:\n                            orbital_period = 12.4  # Default fallback\n                        \n                        # Reference epoch and mean anomaly\n                        # Use object's values if available, else J2000 with MA=0\n                        if 'MA' in elements and 'epoch' in elements:\n                            MA_epoch = elements['MA']\n                            epoch_str = str(elements['epoch']).replace(' osc.', '').strip()\n                            try:\n                                ref_epoch = datetime.strptime(epoch_str, '%Y-%m-%d')\n                            except ValueError:\n                                ref_epoch = datetime(2000, 1, 1, 12, 0, 0)\n                        else:\n                            MA_epoch = 0.0\n                            ref_epoch = datetime(2000, 1, 1, 12, 0, 0)\n                        \n                        delta_days = (date_obj - ref_epoch).total_seconds() / 86400.0\n                        \n                        # Mean motion and current mean anomaly\n                        n = 360.0 / orbital_period\n                        M_deg = (MA_epoch + n * delta_days) % 360.0\n                        M_rad = np.radians(M_deg)\n                        \n                        # Solve Kepler's equation if e > 0.01\n                        if e > 0.01:\n                            E = M_rad if e < 0.8 else np.pi\n                            for _ in range(50):\n                                f = E - e * np.sin(E) - M_rad\n                                f_prime = 1 - e * np.cos(E)\n                                if abs(f_prime) < 1e-12:\n                                    break\n                                E = E - f / f_prime\n                                if abs(f / f_prime) < 1e-10:\n                                    break\n                            true_anomaly = 2 * np.arctan2(\n                                np.sqrt(1 + e) * np.sin(E / 2),\n                                np.sqrt(1 - e) * np.cos(E / 2)\n                            )\n                        else:\n                            true_anomaly = M_rad\n                        \n                        # Position in orbital plane\n                        r = a if e == 0 else a * (1 - e**2) / (1 + e * np.cos(true_anomaly))\n                        x_orb = r * np.cos(true_anomaly)\n                        y_orb = r * np.sin(true_anomaly)\n                        \n                        # Apply 3D rotations\n                        i_rad = np.radians(i_deg)\n                        omega_rad = np.radians(omega_deg)\n                        Omega_rad = np.radians(Omega_deg)\n                        \n                        x1 = x_orb * np.cos(omega_rad) - y_orb * np.sin(omega_rad)\n                        y1 = x_orb * np.sin(omega_rad) + y_orb * np.cos(omega_rad)\n                        x2 = x1\n                        y2 = y1 * np.cos(i_rad)\n                        z2 = y1 * np.sin(i_rad)\n                        x_final = x2 * np.cos(Omega_rad) - y2 * np.sin(Omega_rad)\n                        y_final = x2 * np.sin(Omega_rad) + y2 * np.cos(Omega_rad)\n                        \n                        obj_data = {'x': x_final, 'y': y_final, 'z': z2}\n                        print(f\"  [ANALYTICAL] Calculated position for {obj['name']}: ({x_final:.6f}, {y_final:.6f}, {z2:.6f}) AU\", flush=True)\n                \n                positions[obj['name']] = obj_data\n\n            # ADD THIS: Convert positions to the format needed by idealized_orbits\n            current_positions = {}\n            for obj_name, pos_data in positions.items():\n                if pos_data and 'x' in pos_data:\n                    current_positions[obj_name] = {\n                        'x': pos_data['x'],\n                        'y': pos_data['y'],\n                        'z': pos_data['z']\n                    }\n\n            for obj in objects:\n                # Check system membership\n                same_system = obj.get('system_id', 'solar') == center_system_id\n                \n                # Only plot center or same-system checked objects\n                # Skip exoplanet objects - they're handled in dedicated exoplanet block\n                if obj.get('object_type') in ['exoplanet', 'exo_host_star', 'exo_binary_star', 'exo_barycenter']:\n                    continue\n\n                if obj['name'] == center_object_name or (obj['var'].get() == 1 and same_system):\n\n                    obj_data = positions.get(obj['name'])\n                    if not obj_data:\n                        continue\n\n                    obj_data = positions.get(obj['name'])\n                    if obj_data:\n                        marker_size = DEFAULT_MARKER_SIZE\n                        if obj['name'] == center_object_name:\n                            marker_size = CENTER_MARKER_SIZE\n                        elif obj['name'] == 'Moon' and center_object_name == 'Earth':\n                            marker_size = DEFAULT_MARKER_SIZE\n                        add_celestial_object(fig, \n                                             obj_data, \n                                             obj['name'], \n                                             obj['color'], \n                                             obj['symbol'], \n                                             marker_size=marker_size, \n                                             hover_data=hover_data,\n                                             center_object_name=center_object_name\n                                             )  \n\n            # Rearrange traces to ensure the center marker is on top\n            center_trace_name = center_object_name  # This should match the 'name' parameter of your center marker trace\n\n            # Extract center traces\n            center_traces = [trace for trace in fig.data if trace.name == center_trace_name]\n\n            # Extract all other traces\n            other_traces = [trace for trace in fig.data if trace.name != center_trace_name]\n\n            # Reassign fig.data with center traces at the end\n            fig.data = tuple(other_traces + center_traces)\n\n            # Find the section in plot_objects() where the figure layout is updated\n            # Replace the existing title line with this enhanced version:\n\n            # Calculate the end date for the title based on orbit data range\n            try:\n                # Get the dates directly\n                start_date = get_date_from_gui()\n                end_date = get_end_date_from_gui()\n                days_to_plot = int(days_to_plot_entry.get())\n                \n                # Format the title with date range\n                if days_to_plot == 0:\n                    # If no days to plot, just show the single date\n                    title_text = f\"Paloma's Orrery for {start_date.strftime('%B %d, %Y %H:%M')} UTC\"\n                else:\n                    # Show date range for orbit data\n                    title_text = f\"Paloma's Orrery for {start_date.strftime('%B %d, %Y %H:%M')} through {end_date.strftime('%B %d, %Y %H:%M')} UTC\"\n            except ValueError:\n                # Fallback to original format if end_date is invalid\n                title_text = f\"Paloma's Orrery for {date_obj.strftime('%B %d, %Y %H:%M')} UTC\"\n\n            # Update the figure layout section to use the new title:\n            fig.update_layout(\n                scene=dict(\n                    xaxis=dict(\n                        title='X (AU)',\n                        range=axis_range,\n                        backgroundcolor='black',\n                        gridcolor='gray',\n                        showbackground=True,\n                        showgrid=True\n                    ),\n                    yaxis=dict(\n                        title='Y (AU)',\n                        range=axis_range,\n                        backgroundcolor='black',\n                        gridcolor='gray',\n                        showbackground=True,\n                        showgrid=True\n                    ),\n                    zaxis=dict(\n                        title='Z (AU)',\n                        range=axis_range,\n                        backgroundcolor='black',\n                        gridcolor='gray',\n                        showbackground=True,\n                        showgrid=True\n                    ),\n                    aspectmode='cube',\n                    camera=get_default_camera(),\n                    domain=dict(x=[0.2, 1.0], y=[0.0, 1.0])\n                ),\n                paper_bgcolor='black',\n                plot_bgcolor='black',\n                title_font_color='white',\n                font_color='white',\n                title=title_text,  # Use the calculated title with date range\n                showlegend=True,\n                legend=dict(\n                    font=dict(color='white'),\n                    x=1,\n                    y=1,\n                    xanchor='left',\n                    yanchor='top'\n                ),\n\n                margin=dict(l=75, r=50, t=80, b=50),\n\n                annotations=[\n\n                    # NEW: Coordinate System explanation box\n                    dict(\n\n                        text=(\n                            \"<b>Coordinate System (J2000 Ecliptic):</b><br><br>\"\n\n                            \"<b>+X:</b> Toward RA=0 deg (&#9800;) - same for all objects<br><br>\"\n\n                            + \"<b>+Z:</b> Ecliptic North perpendicular to Earth's orbit<br>\"\n                            + (\"<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(For exoplanets: line of sight from star to Earth)</i><br><br>\" \n                            if is_exoplanet_mode else \"<br>\")\n\n                            + \"<b>XY plane:</b> Ecliptic, Earth's orbital plane<br>\"\n                            + (\"<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(For exoplanets: sky plane, perpendicular to line of sight)</i><br><br><br>\" \n                            if is_exoplanet_mode else \"<br><br>\")\n\n                            + \"<i>See Orbital Parameter Visualization for detailed explanation of ecliptic coordinates</i>\"\n                        ),                        \n\n                        xref='paper',\n                        yref='paper',\n                        x=-0.04,\n                        y=0.80,  \n                        showarrow=False,\n                        font=dict(size=11, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top',\n                        bgcolor='rgba(0, 0, 0, 0.3)',\n                        bordercolor='white',\n                        borderwidth=1,\n                        borderpad=4\n                    ),\n\n                    dict(\n                        text=\"<a href='https://tonylquintanilla.github.io/palomas_orrery/'>Paloma's Orrery GitHub Page</a>\",\n                        xref='paper',\n                        yref='paper',\n                        x=0,\n                        y=0.4,\n                        showarrow=False,\n                        font=dict(size=12, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top'\n                    ),                    \n                    dict(\n                        text=\"<a href='https://sites.google.com/view/tony-quintanilla/home'>Paloma's Orrery Web Site</a>\",\n                        xref='paper',\n                        yref='paper',\n                        x=0,\n                        y=0.45,\n                        showarrow=False,\n                        font=dict(size=12, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top'\n                    ),                    \n                    dict(\n                        text=\"<a href='https://ssd.jpl.nasa.gov/horizons/app.html#/' target='_blank'>JPL Horizons</a>\",\n                        xref='paper',\n                        yref='paper',\n                        x=0,\n                        y=0.35,\n                        showarrow=False,\n                        font=dict(size=12, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top'\n                    ),\n                    dict(\n                        text=\"<a href='https://www.nasa.gov/' target='_blank'>NASA</a>\",\n                        xref='paper',\n                        yref='paper',\n                        x=0,\n                        y=0.3,\n                        showarrow=False,\n                        font=dict(size=12, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top'\n                    ),\n                    dict(\n                        text=\"Click on the legend items to<br>\"\n                            \"toggle them off and back on.\",\n                        xref='paper',\n                        yref='paper',\n                        x=0.95,\n                        y=1.08,\n                        showarrow=False,\n                        font=dict(size=12, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top'\n                    ),\n                ]\n            )\n\n            # 5. Collect user-checked objects for orbits\n            selected_objects = [obj['name'] for obj in objects if obj['var'].get() == 1]\n            \n            # 6. Plot idealized orbits using your new logic\n            plot_idealized_orbits(fig, selected_objects, center_id=center_object_name, \n                                    objects=objects, \n                                    planetary_params=active_planetary_params,  # <--- Use the updated params\n                                    parent_planets=parent_planets, color_map=color_map, \n                                    date=date_obj, days_to_plot=settings['days_to_plot'],\n                                    current_positions=current_positions, \n                                    fetch_position=fetch_position,\n                                    show_apsidal_markers=show_apsidal_markers_var.get(),\n                                    parent_window=root\n                                    )\n\n                    # Add refined orbits if we're centered on a planet with moons\n            if center_object_name != 'Sun' and REFINED_AVAILABLE:\n                # Get the moons for this center\n                moons_to_plot = []\n                for obj in selected_objects:\n                    if obj in parent_planets.get(center_object_name, []):\n                        moons_to_plot.append(obj)\n                \n                if moons_to_plot:\n        #            print(f\"\\nAdding refined orbits for {center_object_name}'s moons...\", flush=True)  # deprecated   \n\n                    # Pass the orbit data directly if in special fetch mode\n            #        orbit_data_to_pass = None\n                    # Collect actual orbit data to pass directly\n                    orbit_data_to_pass = {}\n\n                    # Check special fetch mode first\n                    if special_fetch_var.get() == 1 and temp_cache:\n            #            orbit_data_to_pass = temp_cache\n                        orbit_data_to_pass = temp_cache.copy()     \n                    else:\n                        # Try to get from the main cache\n                        for moon in moons_to_plot:\n                            orbit_key = f\"{moon}_{center_object_name}\"\n                            if orbit_key in orbit_paths_over_time:\n                                orbit_data_to_pass[orbit_key] = orbit_paths_over_time[orbit_key]  \n\n                    # Determine the date range based on object type (for satellites)\n                #    sat_plot_orbit_days = int(satellite_days_entry.get())  # Get the satellite days setting\n                    sat_plot_orbit_days = settings['days_to_plot']  # Use the actual days_to_plot value\n                    start_date = date_obj\n                    end_date = date_obj + timedelta(days=sat_plot_orbit_days)\n\n                    # DISABLED: Refined orbits system - osculating elements already include all perturbations\n                    # The refined_orbits.py module was an excellent exploration of orbital mechanics and\n                    # perturbation theory, but JPL Horizons osculating elements already incorporate\n                    # all physical effects (precession, J2, n-body perturbations, etc.)\n                    # Keeping this code for historical reference and potential future educational use.\n                    \n                    # fig = plot_refined_orbits_for_moons(\n                    #     fig, moons_to_plot, center_object_name, color_map, \n                    #     orbit_data=orbit_data_to_pass,\n                    #     date_obj=date_obj,\n                    #     date_range=(start_date, end_date)\n                    # )\n\n        # ============ EXOPLANET ORBITS ============\n            # Plot exoplanet systems if any exoplanet objects are selected           \n            \n            if exo_objects or exo_host_stars:\n                # Override center object for exoplanet systems\n                exo_systems = set()\n                for obj in exo_objects + exo_host_stars:\n                    system_id = obj.get('system_id')\n                    if system_id:\n                        exo_systems.add(system_id)\n                \n                # Override center to host star -- using explict star as center object selection instead\n            #    if exo_systems:\n            #        first_system_id = list(exo_systems)[0]\n            #        system = get_system(first_system_id)\n            #        if system:\n            #            center_object_name = system['host_star']['name']\n            #            print(f\"\\n[EXOPLANET MODE] Center: {center_object_name}\")\n                \n                try:\n                    # Determine which system(s) are selected\n                    exo_systems = set()\n\n                    for obj in exo_objects + exo_host_stars:\n                        system_id = obj.get('system_id')\n                        if system_id:\n                            exo_systems.add(system_id)\n                    \n                    # Plot each system\n                    for system_id in exo_systems:\n                        system = get_system(system_id)\n                        if not system:\n                            continue\n                        \n                        # Get objects for this system\n                #        system_planets = [obj for obj in exo_objects \n                #                        if obj.get('system_id') == system_id]\n                        \n                        # Get objects for this system - use full catalog data\n                        system_planets = []\n                        for obj in exo_objects:\n                            if obj.get('system_id') == system_id:\n                                # Get the full planet data from the catalog\n                                planet_id = obj.get('id')\n                                if planet_id:\n                                    # Find this planet in the system's planets list\n                                    for catalog_planet in system['planets']:\n                                        if catalog_planet.get('planet_id') == planet_id:\n                                            # Add the GUI metadata to the catalog data\n                                            full_planet = catalog_planet.copy()\n                                            full_planet['var'] = obj['var']\n                                            full_planet['name'] = obj['name']\n                                            full_planet['color'] = obj.get('color', 'lightblue')\n                                            system_planets.append(full_planet)\n                                            break\n\n\n                        system_stars = [obj for obj in exo_host_stars \n                                    if obj.get('system_id') == system_id]\n                        \n                        # Plot host star(s)\n                        # Check if barycenter is selected\n                        barycenter_obj = next((obj for obj in exo_host_stars \n                                             if obj.get('id_type') == 'barycenter' \n                                             and obj.get('system_id') == system_id \n                                             and obj['var'].get() == 1), None)\n                        \n\n                        # Plot host star(s) - works for both binary and single star systems\n                        if system_stars or barycenter_obj or not system['host_star'].get('is_binary'):\n                            # Call plot_binary_host_stars - it handles both binary AND single stars\n\n                            fig = plot_binary_host_stars(fig, system['host_star'], date_obj, show_orbits=True, system_data=system)\n\n                        # Plot planets\n                        if system_planets:\n                            fig = plot_exoplanet_orbits(\n                                fig, system_planets, system, date_obj,\n                                show_orbits=True, show_markers=True\n                            )\n\n\n                        # Set axis range for exoplanet system\n                        if system_planets:\n                            exo_axis_range = calculate_exoplanet_axis_range(system_planets)\n                            fig.update_layout(\n                                scene=dict(\n                                    xaxis=dict(range=[-exo_axis_range, exo_axis_range], title='X (AU)'),\n                                    yaxis=dict(range=[-exo_axis_range, exo_axis_range], title='Y (AU)'),\n                                    zaxis=dict(range=[-exo_axis_range, exo_axis_range], title='Z (AU)'),\n                                    aspectmode='cube'\n                                )\n                            )\n                            \n                            # Add note about coordinate system\n                            print(f\"\\nExoplanet system '{system['system_name']}' uses independent local frame:\", flush=True)\n                            print(f\"  Origin: Host star at (0, 0, 0)\", flush=True)\n                            print(f\"  XY plane: Sky plane (perpendicular to Earth)\", flush=True)\n                            print(f\"  Z axis: Toward Earth\", flush=True)\n                            print(f\"  Axis range: +/-{exo_axis_range:.4f} AU\\n\", flush=True)\n                \n                except Exception as e:\n                    print(f\"Error plotting exoplanet systems: {e}\", flush=True)\n            #        import traceback\n                    traceback.print_exc()\n\n\n            # Add URL buttons before showing/saving\n            fig = add_url_buttons(fig, objects, selected_objects)\n\n            # Add camera view buttons with dropdown for different target objects\n            fig = add_look_at_object_buttons(fig, positions, center_object_name)            \n           \n            fig = add_fly_to_object_buttons(fig, positions, center_object_name)  # NEW\n\n            # ============ ADD COMET TAILS INTEGRATION ============\n            # Conservative comet tail integration\n            for obj in objects:\n                if obj['var'].get() == 1:\n                    # Check if this is a comet by its properties\n                    \n                    is_comet = (\n                        obj.get('object_type') in ['orbital', 'trajectory'] and  # Allow both types\n                        obj.get('id_type') == 'smallbody' and\n                        obj.get('symbol') == 'diamond'\n                    )\n\n                    if is_comet and obj['name'] in positions:\n                        print(f\"Processing comet tails for {obj['name']}...\", flush=True)\n                        fig = add_comet_tails_to_figure(\n                            fig,\n                            obj['name'],\n                            positions[obj['name']],\n                            center_object_name\n                        )\n            # ============ END COMET TAILS INTEGRATION ============\n\n            # Generate default name with timestamp\n#            current_date = datetime.now()\n            current_date = STATIC_TODAY\n            default_name = f\"solar_system_{date_obj.strftime('%Y%m%d_%H%M')}\"\n\n            # Use show_figure_safely to handle both display and save options\n            show_figure_safely(fig, default_name)\n\n            # Store fig for social media export\n            _last_plotted_fig[0] = fig\n            _last_plot_name[0] = default_name\n\n            # Schedule GUI updates on main thread (required for macOS)\n            root.after(0, lambda: output_label.config(text=\"Plotting complete.\"))\n            root.after(0, lambda: progress_bar.stop())\n\n        except Exception as e:\n            # Schedule GUI updates on main thread (required for macOS)\n            root.after(0, lambda msg=str(e): output_label.config(text=f\"Error during plotting: {msg}\"))\n            print(f\"Error during plotting: {e}\", flush=True)\n            traceback.print_exc()\n            root.after(0, lambda: progress_bar.stop())\n            \n    # Instead of threading.Thread(...).start(), use create_monitored_thread\n    plot_thread = create_monitored_thread(shutdown_handler, worker)\n    plot_thread.start()",
    "start_line": 3487,
    "end_line": 5194,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function plot_objects",
    "component_id": "palomas_orrery.plot_objects"
  },
  "palomas_orrery.worker": {
    "id": "palomas_orrery.worker",
    "name": "worker",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.get_interval_settings",
      "palomas_orrery.get_date_from_gui"
    ],
    "source_code": "    def worker():\n        try:\n\n            # Add explicit reference to avoid issues with nested scopes\n            global orbit_paths_over_time\n            nonlocal active_planetary_params  # Access the pre-fetched orbital params\n\n            exo_objects = [obj for obj in objects \n                        if obj['var'].get() == 1 and obj.get('object_type') == 'exoplanet']\n\n            exo_host_stars = [obj for obj in objects\n                    #   if obj['var'].get() == 1 and obj.get('object_type') == 'exo_host_star'] \n                        if obj['var'].get() == 1 and obj.get('object_type') in ['exo_host_star', 'exo_binary_star', 'exo_barycenter']]            \n\n            # Detect if we're in exoplanet mode (for coordinate system legend)\n            is_exoplanet_mode = bool(exo_objects or exo_host_stars)\n\n            # Reset the global today or use a local today variable\n            today = datetime.today()\n\n            # Create figure object at the start\n            fig = go.Figure()\n\n            # Add global sun direction indicator to the plot\n    #        fig = add_global_sun_direction_indicator(fig)\n\n            # Generate default name with timestamp\n            current_date = STATIC_TODAY\n            default_name = f\"solar_system_{current_date.strftime('%Y%m%d_%H%M')}\"\n                       \n            output_label.config(text=\"Fetching data, please wait...\")\n            progress_bar['mode'] = 'indeterminate'\n            progress_bar.start(10)  # Start the progress bar with a slight delay\n            root.update_idletasks()  # Force GUI to update\n\n            # REPLACE the interval handling section with:\n            settings, error_msg = get_interval_settings()\n            if error_msg:\n                output_label.config(text=error_msg)\n            \n            # CRITICAL FIX: Ensure we have the correct days_to_plot\n            # Double-check by reading directly from GUI\n        #    gui_days = int(days_to_plot_entry.get())\n        #    if settings['days_to_plot'] != gui_days:\n        #        print(f\"[WARNING] Settings mismatch: settings={settings['days_to_plot']}, GUI={gui_days}\", flush=True)\n        #        settings['days_to_plot'] = gui_days\n\n            # Debug check - don't override the precise calculated value from date range\n            gui_days = int(days_to_plot_entry.get()) if days_to_plot_entry.get() else 0\n            if int(settings['days_to_plot']) != gui_days:\n                print(f\"[INFO] days_to_plot: calculated={settings['days_to_plot']:.6f} days ({settings['days_to_plot']*24*60:.1f} min), GUI shows={gui_days} days\", flush=True)\n            # Note: Don't override - calculated value preserves sub-day precision for flybys     \n\n            # Extract the values\n            trajectory_points = settings['trajectory_points']\n            orbital_points = settings['orbital_points']\n            satellite_days = settings['satellite_days']\n            satellite_points = settings['satellite_points']\n            start_date = settings['start_date']\n            end_date = settings['end_date']\n            \n            # Get the date\n            date_obj = get_date_from_gui()\n\n            # Define hover_data with a default value\n            hover_data = \"Full Object Info\"  # Or \"Object Names Only\"\n\n            # Determine center object\n            center_object_name = center_object_var.get()\n            center_object_info = next((obj for obj in objects if obj['name'] == center_object_name), None)\n\n            # Capture center's system ID\n            center_system_id = (center_object_info or {}).get('system_id', 'solar')\n            print(f\"[SYSTEM SCOPE] Center: {center_object_name}, System: {center_system_id}\", flush=True)\n\n            if center_object_info:\n                if center_object_name == 'Sun':\n                    center_id = 'Sun'\n                    center_id_type = None\n                else:\n            #        center_id = center_object_info['id']\n                    center_id = center_object_info.get('center_id', center_object_info['id'])\n                    center_id_type = center_object_info.get('id_type')\n            else:\n                center_id = 'Sun'\n                center_id_type = None\n\n# Get selected objects\n            selected_objects = [obj for obj in objects if obj['var'].get() == 1]\n            \n            if not selected_objects:\n                output_label.config(text=\"No objects selected for plotting\")\n                progress_bar.stop()\n                return\n\n            # Check if we're in special fetch mode or normal mode\n            if special_fetch_var.get() == 0:  # Normal mode\n\n                # Check if any selected object needs updating\n                need_update = False\n                fetch_requests = []  # Store what needs to be fetched\n\n                # Calculate the date range we need\n                cache_start_date = settings['start_date']  # Or get_date_from_gui()\n                cache_end_date = settings['end_date']      # Or get_end_date_from_gui()\n\n                # These TNO moons have no usable JPL parent-centered ephemeris\n        #        SKIP_HORIZONS_TRAJECTORY = ['MK2', 'Xiangliu', 'Vanth', 'Weywot']\n                SKIP_HORIZONS_TRAJECTORY = ['MK2', 'Xiangliu', 'Vanth', 'Gonggong']  # Weywot removed - JPL data works at Quaoar\n                \n                for obj in selected_objects:\n                    # Skip exoplanet objects - they don't use JPL Horizons\n                    if obj.get('object_type') in ['exoplanet', 'exo_host_star', 'exo_binary_star', 'exo_barycenter']:    \n                        continue\n                    # Skip TNO moons that use analytical orbits only\n                    if obj['name'] in SKIP_HORIZONS_TRAJECTORY:\n                        continue\n\n                    orbit_key = f\"{obj['name']}_{center_object_name}\"\n                    \n                    # Check if orbit exists in cache\n                    if orbit_key not in orbit_paths_over_time:\n                        need_update = True\n                        fetch_requests.append({\n                            'object': obj,\n                            'fetch_start': cache_start_date,\n                            'fetch_end': cache_end_date,\n                            'reason': 'not in cache'\n                        })\n                        print(f\"{obj['name']}: Not in cache, need full range\", flush=True)\n                    else:\n                        # Check if cached date range covers what we need\n                        cached_data = orbit_paths_over_time[orbit_key]\n                        \n                        if 'metadata' in cached_data:\n                #            cache_meta_start = cached_data['metadata'].get('start_date')\n                #            cache_meta_end = cached_data['metadata'].get('end_date')\n                            cache_meta_start = cached_data['metadata'].get('start_date') or cached_data['metadata'].get('earliest_date')\n                            cache_meta_end = cached_data['metadata'].get('end_date') or cached_data['metadata'].get('latest_date')\n                            \n                            if cache_meta_start and cache_meta_end:\n                                existing_start = datetime.strptime(cache_meta_start, '%Y-%m-%d')\n                                existing_end = datetime.strptime(cache_meta_end, '%Y-%m-%d')\n                                \n                                # Determine what gaps need filling\n                                fetch_gaps = []\n                                \n                                # Gap at the beginning?\n                                if cache_start_date < existing_start:\n                                    fetch_gaps.append((cache_start_date, existing_start - timedelta(days=1)))\n                                \n                                # Gap at the end?\n                                if cache_end_date > existing_end:\n                                    fetch_gaps.append((existing_end + timedelta(days=1), cache_end_date))\n                                \n                                if fetch_gaps:\n                                    need_update = True\n                                    for gap_start, gap_end in fetch_gaps:\n                                        fetch_requests.append({\n                                            'object': obj,\n                                            'fetch_start': gap_start,\n                                            'fetch_end': gap_end,\n                                            'reason': 'gap in cache'\n                                        })\n                                        days_to_fetch = (gap_end - gap_start).days + 1\n                                        print(f\"{obj['name']}: Need {days_to_fetch} days from {gap_start} to {gap_end}\", flush=True)\n                \n                # Handle updates based on user preference\n                should_update = False\n                \n                if need_update and not update_choice_remembered:\n                    # Show dialog\n                    dialog = tk.Toplevel(root)\n                    dialog.title(\"Update Orbit Data?\")\n                    dialog.geometry(\"400x200\")\n                    \n                    message = tk.Label(dialog, \n                        text=f\"New orbit data is needed for {len(selected_objects)} selected objects.\\n\\n\"\n                             f\"Would you like to fetch updated data from JPL Horizons?\",\n                        wraplength=350)\n                    message.pack(pady=20)\n                    \n                    remember_var = tk.IntVar(value=0)\n                    remember_check = tk.Checkbutton(dialog,\n                        text=\"Remember my choice for this session\\n\"\n                             \"(Warning: This applies globally to all plots)\",\n                        variable=remember_var)\n                    remember_check.pack(pady=10)\n                    \n                    button_frame = tk.Frame(dialog)\n                    button_frame.pack()\n                    \n                    user_choice = {'update': None}\n                    \n                    def on_yes():\n                        user_choice['update'] = True\n                        if remember_var.get() == 1:\n                            global remember_update_choice, update_choice_remembered\n                            remember_update_choice = True\n                            update_choice_remembered = True\n                        dialog.destroy()\n                    \n                    def on_no():\n                        user_choice['update'] = False\n                        if remember_var.get() == 1:\n                            global remember_update_choice, update_choice_remembered\n                            remember_update_choice = False\n                            update_choice_remembered = True\n                        dialog.destroy()\n                    \n                    tk.Button(button_frame, text=\"Yes - Update Cache\", \n                             command=on_yes, bg='light green').pack(side='left', padx=5)\n                    tk.Button(button_frame, text=\"No - Use Existing\", \n                             command=on_no, bg='light coral').pack(side='left', padx=5)\n                    \n                    dialog.wait_window()\n                    \n                    should_update = user_choice.get('update', False)\n                \n                elif need_update and update_choice_remembered:\n                    # Use remembered choice\n                    should_update = remember_update_choice\n                \n                # Perform update if needed\n                if should_update:\n                    update_status_display(\"Updating orbit cache for selected objects...\", 'info')\n                    progress_bar.step(10)\n                    root.update_idletasks()\n                    \n                    updated, current, total, time_saved = orbit_data_manager.update_orbit_paths_incrementally(\n                        object_list=selected_objects,\n                        center_object_name=center_object_name,\n                #        days_ahead=int(get_end_date_from_gui()),\n                        days_ahead=int(days_to_plot_entry.get()),\n                        planetary_params=active_planetary_params,\n                        parent_planets=parent_planets,\n                        root_widget=root\n                    )\n                    \n                    update_status_display(f\"Cache updated: {updated} new, {current} current\", 'success')\n                else:\n                    update_status_display(\"Using existing cache without updates\", 'info')\n                    \n            else:  # Special fetch mode\n                update_status_display(\"Special fetch mode: Fetching data (not cached)...\", 'special')\n                \n                # In special fetch mode, determine interval based on object type\n                for obj in selected_objects:\n                    if obj['name'] != center_object_name:\n                        orbit_key = f\"{obj['name']}_{center_object_name}\"\n                        \n                        # Get object type\n                        obj_type = obj.get('object_type', 'unknown')\n                        \n                        # Determine interval based on object type\n                        if obj_type == 'trajectory':\n                            # Missions, interstellar objects, comets - use fine intervals\n                            interval = trajectory_interval_entry.get()\n                        elif obj_type == 'satellite':\n                            # Moons need very fine resolution\n                            interval = satellite_interval_entry.get()\n                        elif obj_type == 'orbital':\n                            # Planets, asteroids, TNOs - can use coarser intervals\n                    #        if obj.get('e', 0) > 0.5:  # High eccentricity needs finer intervals\n                    #            interval = eccentric_interval_entry.get()\n                    #        else:\n                            interval = default_interval_entry.get()\n                        elif obj_type == 'lagrange_point':\n                            # L-points move smoothly, medium resolution is fine\n                            interval = default_interval_entry.get()\n                        elif obj_type == 'fixed':\n                            # Fixed objects don't need trajectories\n                            continue  # Skip fetching - NOW INSIDE THE LOOP\n                        else:\n                            # Fallback\n                            interval = default_interval_entry.get()\n                            \n                        # Calculate date range\n                        start_date = get_date_from_gui()\n                        end_date = get_end_date_from_gui()\n                        \n                        # Fetch without caching to main file\n                        orbit_data = fetch_orbit_path(obj, start_date, end_date, interval,\n                                                    center_id=center_id, id_type=obj.get('id_type'))\n                        if orbit_data:\n                            temp_cache[orbit_key] = orbit_data\n                \n                # Save temp cache\n                with open(TEMP_CACHE_FILE, 'w') as f:\n                    json.dump(temp_cache, f)\n                \n                update_status_display(f\"Special fetch complete: {len(temp_cache)} orbits in temp cache\", 'special')\n            \n            progress_bar.step(10)\n            root.update_idletasks()\n\n            # Define planets with shell visualizations\n            planets_with_shells = {\n                'Mercury': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': mercury_shell_vars\n                },\n                'Venus': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': venus_shell_vars\n                },\n                'Earth': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': earth_shell_vars\n                },\n                'Moon': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': moon_shell_vars\n                },\n                'Mars': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': mars_shell_vars\n                },\n                'Jupiter': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': jupiter_shell_vars\n                },\n                'Saturn': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': saturn_shell_vars\n                },\n                'Uranus': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': uranus_shell_vars\n                },\n                'Neptune': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': neptune_shell_vars\n                },\n                'Pluto': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': pluto_shell_vars\n                },\n                'Eris': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': eris_shell_vars\n                },\n                'Planet 9': {\n                    'position': None,  # Will be populated during animation\n                    'shell_vars': planet9_shell_vars\n                }\n            }\n\n            # Create date lists for each selected object\n            dates_lists = {}\n            for obj in objects:\n\n                # For satellites specifically, even if they have orbital parameters, \n                # we should always fetch their actual position data\n                if obj['var'].get() == 1 and obj['name'] != center_object_name:\n\n                    # Check if this is a satellite of a planet\n                    is_satellite = False\n                    parent_planet = None\n                    for planet, moons in parent_planets.items():\n                        if obj['name'] in moons:\n                            is_satellite = True\n                            parent_planet = planet  # Use 'planet' to match the loop variable\n                            break\n\n                    is_parent = obj['name'] in parent_planets    \n                    \n                                        # Get object type (with fallback for backward compatibility)\n                    obj_type = obj.get('object_type', None)\n                            \n                    if obj_type == 'trajectory':\n                        # Time-bounded paths\n                        # Check if object has specific start/end dates\n                        if 'start_date' in obj and 'end_date' in obj:\n                            # Use object-specific dates\n                            start_date = obj.get('start_date', date_obj)\n                            end_date = obj.get('end_date', date_obj)\n                        else:\n                            # Use GUI settings for objects without specific dates (like 3I/ATLAS)\n                            start_date = settings['start_date']\n                            end_date = settings['end_date']\n                            \n                    #    total_days = (end_date - start_date).days\n                        # Use total_seconds() to preserve fractional days\n                        total_days = (end_date - start_date).total_seconds() / 86400\n                        \n                        if total_days <= 0:\n                            # Use requested days from GUI\n                            requested_days = settings['days_to_plot']\n                            end_date = start_date + timedelta(days=requested_days)\n                            total_days = requested_days\n                            \n                        num_points = int(trajectory_points) + 1\n                        dates_list = [start_date + timedelta(days=float(d)) \n                                    for d in np.linspace(0, total_days, num=num_points)]\n                        \n                    # Check if this object is a satellite of the current center              \n                    # (regardless of object_type - e.g., Pluto is 'orbital' but orbits the barycenter)\n                    elif obj['name'] in parent_planets.get(center_object_name, []):\n                        # Moons/orbiters of the center object - use satellite settings\n                        num_points = int(satellite_points) + 1\n                        actual_days_to_plot = settings['days_to_plot'] \n                        dates_list = [date_obj + timedelta(days=float(d)) \n                                    for d in np.linspace(0, actual_days_to_plot, num=num_points)]\n\n            #        elif obj_type == 'orbital' and obj['name'] in planetary_params:\n                    elif obj_type == 'orbital' and obj['name'] in active_planetary_params:      # uses osculating elements\n\n                        # Get the raw days_to_plot value\n                        raw_days = int(days_to_plot_entry.get())\n                        settings_days = settings['days_to_plot']\n                        \n                        print(f\"  Raw days_to_plot from entry: {raw_days}\", flush=True)\n                        print(f\"  Settings days_to_plot: {settings_days}\", flush=True)\n                        # ==========================================\n                        \n                        # Planets, dwarf planets, TNOs\n            #            a = planetary_params[obj['name']]['a']\n                        a = active_planetary_params[obj['name']]['a']\n                        \n                        if a > 0:  # Only for elliptical orbits\n                            orbital_period_years = np.sqrt(a ** 3)\n                            orbital_period_days = orbital_period_years * 365.25\n                        else:\n                            # Hyperbolic orbit - use a reasonable default span\n                            orbital_period_days = 365.25  # 1 year default for trajectories\n\n                        # FIX: Use the actual requested days, don't limit by orbital period\n                        requested_days = settings['days_to_plot']\n                        # Remove the limitation - let user plot multiple orbits if desired\n                        plot_days = requested_days  # NOT min(orbital_period_days, requested_days)\n                        \n                        # ============ MORE DEBUG #3 ============\n                        print(f\"  Orbital period: {orbital_period_days:.1f} days\", flush=True)\n                        print(f\"  Requested days: {requested_days}\", flush=True)\n                        print(f\"  Plot days (NO LIMIT): {plot_days}\", flush=True)\n                        # =======================================\n                        \n                        # Apply system limits\n                        days_until_horizons = (HORIZONS_MAX_DATE - date_obj).days\n                        capped_days = min(plot_days, days_until_horizons)\n                        \n                        # ============ MORE DEBUG #3 ============\n                        print(f\"  Final days for dates_list: {capped_days}\", flush=True)\n                        # =======================================\n                        \n                        num_points = int(settings['orbital_points']) + 1\n\n                        dates_list = [date_obj + timedelta(days=float(d)) \n                                    for d in np.linspace(0, capped_days, num=num_points)]\n                        \n                        # ============ FINAL DEBUG #3 ============\n                        print(f\"  Dates list spans: {(dates_list[-1] - dates_list[0]).days} days\", flush=True)\n                        print(f\"  First date: {dates_list[0]}\", flush=True)\n                        print(f\"  Last date: {dates_list[-1]}\", flush=True)\n                        # ========================================\n\n                    elif obj_type == 'fixed':\n                        if obj['name'] == 'Sun':\n\n                            if is_exoplanet_mode:\n                                print(f\"Skipping Sun in exoplanet animation mode\", flush=True)\n                                continue\n\n                            if center_object_name != 'Sun':\n                                # Sun needs trajectory when viewed from another center (e.g., Earth)\n                                requested_days = settings['days_to_plot']\n                                num_points = int(orbital_points) + 1\n                                dates_list = [date_obj + timedelta(days=float(d)) \n                                            for d in np.linspace(0, requested_days, num=num_points)]\n                                print(f\"Sun needs trajectory relative to {center_object_name}\", flush=True)\n                            else:\n                                # Sun at origin doesn't need trajectory\n                                dates_list = [date_obj]\n                        else:\n                            # Other fixed objects only need single date\n                            dates_list = [date_obj]\n                            print(f\"Fixed object {obj['name']}: single date point\", flush=True)\n\n                    elif obj_type == 'lagrange_point':\n                        # Lagrange points need dates to show their co-orbital motion\n                #        requested_days = int(get_end_date_from_gui()) - int(get_date_from_gui())\n                        requested_days = settings['days_to_plot']  # Use settings instead of bad calculation\n                        num_points = int(settings['orbital_points']) + 1  # Use settings\n                        num_points = int(orbital_points) + 1  # Changed from planet_interval_divisor\n                        dates_list = [date_obj + timedelta(days=float(d)) for d in np.linspace(0, requested_days, num=num_points)]\n\n                    else:\n                        print(f\"ERROR: No handler for object type '{obj_type}' for {obj['name']}\", flush=True)\n                        dates_list = [date_obj]\n\n                    # Store the dates list\n                    dates_lists[obj['name']] = dates_list\n\n                    # Debug output\n                    if dates_list and len(dates_list) > 1:\n                        print(f\"{obj['name']} ({obj_type}): {len(dates_list)} dates from {dates_list[0]} to {dates_list[-1]} ({(dates_list[-1] - dates_list[0]).days} days)\", flush=True)\n\n            # Fetch positions for selected objects on the chosen date\n            positions = {}\n            for obj in objects:\n        #        if obj['var'].get() == 1:\n\n                if not obj['var'].get():\n                    continue\n                # System-scope: only same-system objects\n                if obj['name'] != center_object_name and obj.get('system_id', 'solar') != center_system_id:\n                    continue\n\n                if obj['name'] == 'Planet 9' or obj['id'] == 'planet9_placeholder':\n                        # Calculate Planet 9 position directly on its theoretical orbit\n                        x, y, z, range_val = calculate_planet9_position_on_orbit()\n                        # Create a complete position object\n                        obj_data = {\n                            'x': x,\n                            'y': y,\n                            'z': z,\n                            'range': range_val,\n                            'distance_km': range_val * KM_PER_AU,\n                            'distance_lm': range_val * LIGHT_MINUTES_PER_AU,\n                            'distance_lh': (range_val * LIGHT_MINUTES_PER_AU) / 60,\n                            'vx': 0,\n                            'vy': 0,\n                            'vz': 0,\n                            'velocity': 0,\n                            'calculated_orbital_period': {\n                                'years': np.sqrt(600**3),  # Semi-major axis^1.5\n                                'days': np.sqrt(600**3) * 365.25\n                            },\n                            'known_orbital_period': {\n                                'years': np.sqrt(600**3),\n                                'days': np.sqrt(600**3) * 365.25\n                            },\n                            'orbital_period': np.sqrt(600**3)  # Orbital period in years\n                        }\n                elif obj['name'] == center_object_name:\n\n                        obj_data = {'x': 0, 'y': 0, 'z': 0}\n            #    else:\n            #            obj_data = fetch_position(obj['id'], date_obj, center_id=center_id, id_type=obj.get('id_type', None))\n\n                else:\n                        # Use helio_id for Sun-centered plots if available\n                        fetch_id = obj['id']\n                        fetch_id_type = obj.get('id_type', None)\n                        if center_object_name == 'Sun' and 'helio_id' in obj:\n                            fetch_id = obj['helio_id']\n                            fetch_id_type = 'smallbody'\n                        obj_data = fetch_position(fetch_id, date_obj, center_id=center_id, id_type=fetch_id_type)\n                        \n                        # Special case: Orcus at Orcus-Vanth Barycenter - derive from Vanth's position\n                        # JPL doesn't have 920090482 as a valid target, but 120090482 (Vanth) works\n                        # Orcus is on opposite side of barycenter at 1/mass_ratio of Vanth's distance\n\n                        orcus_needs_derivation = (\n                            obj['name'] == 'Orcus' and \n                            center_object_name == 'Orcus-Vanth Barycenter' and\n                            (obj_data is None or (obj_data.get('x') == 0 and obj_data.get('y') == 0 and obj_data.get('z') == 0))\n                        )\n                        if orcus_needs_derivation:\n\n                            print(f\"  - Deriving Orcus position from Vanth (mass ratio method)...\", flush=True)\n                            # Fetch Vanth's position\n                            vanth_data = fetch_position('120090482', date_obj, center_id=center_id, id_type=None)\n                            if vanth_data and vanth_data.get('x') != 0:\n                                # Mass ratio: M_Vanth/M_Orcus = 0.16\n                                # Orcus is at -1/mass_ratio * Vanth's position relative to barycenter\n                                mass_ratio = 0.16\n                                x_orcus = -vanth_data['x'] * mass_ratio\n                                y_orcus = -vanth_data['y'] * mass_ratio\n                                z_orcus = -vanth_data['z'] * mass_ratio\n                                r_orcus = np.sqrt(x_orcus**2 + y_orcus**2 + z_orcus**2)\n                                # Velocity: same ratio, opposite direction\n                                vx_orcus = -vanth_data.get('vx', 0) * mass_ratio\n                                vy_orcus = -vanth_data.get('vy', 0) * mass_ratio\n                                vz_orcus = -vanth_data.get('vz', 0) * mass_ratio\n                                v_orcus = np.sqrt(vx_orcus**2 + vy_orcus**2 + vz_orcus**2)\n                                \n                                obj_data = {\n                                    'x': x_orcus, 'y': y_orcus, 'z': z_orcus,\n                                    'range': r_orcus,\n                                    'vx': vx_orcus, 'vy': vy_orcus, 'vz': vz_orcus,\n                                    'velocity': v_orcus,\n                                    'distance_km': r_orcus * KM_PER_AU,\n                                    'distance_lm': r_orcus * LIGHT_MINUTES_PER_AU,\n                                    'distance_lh': (r_orcus * LIGHT_MINUTES_PER_AU) / 60,\n                                    'derived_from_vanth': True\n                                }\n                                print(f\"  -> Orcus position: ({x_orcus:.7f}, {y_orcus:.7f}, {z_orcus:.7f}) AU, r={r_orcus:.7f} AU (~{r_orcus * 149597870.7:.0f} km)\", flush=True)\n\n                            else:\n                                print(f\"  -> Could not fetch Vanth position to derive Orcus\", flush=True)\n\n                        # Fallback to analytical position for objects not in Horizons (e.g., 6AC4721)\n                        if obj_data is None and obj['name'] in active_planetary_params and 'MA' in active_planetary_params[obj['name']]:\n                            print(f\"  - No JPL data for {obj['name']}, calculating analytical position from MA...\", flush=True)\n                            elements = active_planetary_params[obj['name']]\n                            a = elements.get('a', 0)\n                            e = elements.get('e', 0)\n                            i_deg = elements.get('i', 0)\n                            omega_deg = elements.get('omega', 0)\n                            Omega_deg = elements.get('Omega', 0)\n                            MA_epoch = elements.get('MA', 0)\n                            \n                            # Get orbital period\n                            if 'orbital_period_days' in elements:\n                                orbital_period = elements['orbital_period_days']\n                            elif a > 0:\n                                orbital_period = np.sqrt(a**3) * 365.25\n                            else:\n                                orbital_period = 365.25\n                            \n                            # Get reference epoch\n                            if 'epoch' in elements:\n                                epoch_str = str(elements['epoch']).replace(' osc.', '').strip()\n                                try:\n                                    ref_epoch = datetime.strptime(epoch_str, '%Y-%m-%d')\n                                except ValueError:\n                                    ref_epoch = datetime(2000, 1, 1, 12, 0, 0)\n                            else:\n                                ref_epoch = datetime(2000, 1, 1, 12, 0, 0)\n                            \n                            # Calculate position\n                            delta_days = (date_obj - ref_epoch).total_seconds() / 86400.0\n                            n = 360.0 / orbital_period\n                            M_deg = (MA_epoch + n * delta_days) % 360.0\n                            M_rad = np.radians(M_deg)\n                            \n                            # Solve Kepler's equation\n                            if e > 0.01:\n                                E = M_rad if e < 0.8 else np.pi\n                                for _ in range(50):\n                                    f = E - e * np.sin(E) - M_rad\n                                    f_prime = 1 - e * np.cos(E)\n                                    if abs(f_prime) < 1e-12:\n                                        break\n                                    E = E - f / f_prime\n                                    if abs(f / f_prime) < 1e-10:\n                                        break\n                                true_anomaly = 2 * np.arctan2(\n                                    np.sqrt(1 + e) * np.sin(E / 2),\n                                    np.sqrt(1 - e) * np.cos(E / 2)\n                                )\n                            else:\n                                true_anomaly = M_rad\n                            \n                            # Position in orbital plane\n                            r = a * (1 - e**2) / (1 + e * np.cos(true_anomaly)) if e > 0 else a\n                            x_orb = r * np.cos(true_anomaly)\n                            y_orb = r * np.sin(true_anomaly)\n                            \n                            # Rotation angles\n                            i_rad = np.radians(i_deg)\n                            omega_rad = np.radians(omega_deg)\n                            Omega_rad = np.radians(Omega_deg)\n                            \n                            # Apply rotations\n                            x1 = x_orb * np.cos(omega_rad) - y_orb * np.sin(omega_rad)\n                            y1 = x_orb * np.sin(omega_rad) + y_orb * np.cos(omega_rad)\n                            x2 = x1\n                            y2 = y1 * np.cos(i_rad)\n                            z2 = y1 * np.sin(i_rad)\n                            x_final = x2 * np.cos(Omega_rad) - y2 * np.sin(Omega_rad)\n                            y_final = x2 * np.sin(Omega_rad) + y2 * np.cos(Omega_rad)\n                            z_final = z2\n                            \n                            # Velocity (vis-viva)\n                            GM_sun = 2.959122e-4\n                            v_au_day = np.sqrt(GM_sun * (2/r - 1/a)) if a > 0 else 0\n                            \n                            obj_data = {\n                                'x': x_final, 'y': y_final, 'z': z_final,\n                                'range': r,\n                                'velocity': v_au_day,\n                                'distance_km': r * KM_PER_AU,\n                                'distance_lm': r * LIGHT_MINUTES_PER_AU,\n                                'distance_lh': (r * LIGHT_MINUTES_PER_AU) / 60,\n                                'analytical_position': True\n                            }\n                            print(f\"  -> Analytical position: x={x_final:.4f}, y={y_final:.4f}, z={z_final:.4f} AU (r={r:.3f} AU)\", flush=True)                        \n\n                        # DEBUG: Check what obj_data contains before assignment\n                        if obj['name'] == 'Orcus':\n                            print(f\"  [DEBUG] About to assign Orcus position: {obj_data}\", flush=True)\n\n                positions[obj['name']] = obj_data\n\n                    # Store positions for planets with shells\n                if obj['name'] in planets_with_shells and obj_data and 'x' in obj_data:\n                        planets_with_shells[obj['name']]['position'] = (obj_data['x'], obj_data['y'], obj_data['z'])\n\n            # Print planet positions in the console\n            print_planet_positions(positions)\n\n            if scale_var.get() == 'Auto':\n                selected_objects = [obj for obj in objects if obj['var'].get() == 1]\n\n                axis_range = calculate_axis_range_from_orbits(\n            #        selected_objects, positions, planetary_params, \n                    selected_objects, positions, active_planetary_params,\n\n                    parent_planets, center_object_name\n    )\n\n            else:\n                try:\n                    custom_scale = float(custom_scale_entry.get())\n                    axis_range = [-custom_scale, custom_scale]\n                except ValueError:\n                    output_label.config(text=\"Invalid custom scale value.\")\n                    progress_bar.stop()\n                    return\n\n            # Create Plotly figure\n            fig = go.Figure()\n\n            # Add hover toggle buttons\n            fig = add_hover_toggle_buttons(fig)\n\n            # Define dictionary mapping planets to their shell variable dictionaries\n            planet_shells_config = {\n                'Mercury': mercury_shell_vars,\n                'Venus': venus_shell_vars,\n                'Earth': earth_shell_vars,\n                'Moon': moon_shell_vars,\n                'Mars': mars_shell_vars,\n                'Jupiter': jupiter_shell_vars,\n                'Saturn': saturn_shell_vars,\n                'Uranus': uranus_shell_vars,\n                'Neptune': neptune_shell_vars,\n                'Pluto': pluto_shell_vars,\n                'Eris': eris_shell_vars,\n                'Planet 9': planet9_shell_vars               \n                # Add more planets here as shell systems are developed\n            }\n\n            # Flag to track if shells have been added for center object\n            center_shells_added = False\n\n            # First add Sun visualization if needed\n            if center_object_name == 'Sun' and any(var.get() == 1 for var in sun_shell_vars.values()):\n                fig = create_sun_visualization(fig, sun_shell_vars)\n                center_shells_added = True\n                \n            # Now add planet visualization if the center is a planet with shells\n            elif center_object_name in planet_shells_config:\n                shell_vars = planet_shells_config[center_object_name]\n                if any(var.get() == 1 for var in shell_vars.values()):\n                    fig = create_planet_visualization(fig, center_object_name, shell_vars)\n                    center_shells_added = True\n\n            # Add center marker only if shells haven't been added\n            if not center_shells_added:\n                if center_object_name == 'Sun':\n                    # Just add the central Sun marker if shells not selected\n                    fig.add_trace(\n                        go.Scatter3d(\n                            x=[0],\n                            y=[0],\n                            z=[0],\n                            mode='markers',\n                            marker=dict(\n                                color='rgb(102, 187, 106)',\n                                size=12,\n                                symbol=center_object_info['symbol']\n                            ),\n                            name=\"Sun\",\n                            text=[hover_text_sun],\n                            customdata=[\"Sun\"],\n                            hovertemplate='%{text}<extra></extra>',\n                            showlegend=True\n                        )\n                    )\n\n                else:\n                    # For other central bodies (planets), add the center marker trace\n                    # Check if color is transparent to hide legend\n                    is_transparent = 'rgba(0,0,0,0)' in str(center_object_info['color']).replace(' ', '')\n                    \n                    fig.add_trace(\n                        go.Scatter3d(\n                            x=[0],\n                            y=[0],\n                            z=[0],\n                            mode='markers',\n                            marker=dict(\n                                color=center_object_info['color'],\n                                size=12,\n                                symbol=center_object_info['symbol']\n                            ),\n                            name=f\"{center_object_name}\",\n                            text=[center_object_name],\n                            hoverinfo='skip',\n                            showlegend=not is_transparent  # Hide legend if transparent\n                        )\n                    )\n\n\n            # Create dictionary of shell variables for each planet\n            planet_shell_vars = {\n                'Mercury': mercury_shell_vars,\n                'Venus': venus_shell_vars,\n                'Earth': earth_shell_vars,\n                'Moon': moon_shell_vars,\n                'Mars': mars_shell_vars,\n                'Jupiter': jupiter_shell_vars,\n                'Saturn': saturn_shell_vars,\n                'Uranus': uranus_shell_vars,\n                'Neptune': neptune_shell_vars,\n                'Pluto': pluto_shell_vars,\n                'Eris': eris_shell_vars,\n                'Planet 9': planet9_shell_vars               \n            }\n\n            # Add Sun direction indicator for non-center planets with shells\n            for planet_name, planet_data in planets_with_shells.items():\n                is_center = (center_object_name == planet_name)\n                \n                # Modified condition: allow shells for any planet, not just the center\n                if planet_name in planet_shell_vars:\n                    # For center planet, position at (0,0,0)\n                    if is_center and not center_shells_added:\n                        print(f\"\\nAdding shells for center planet {planet_name}\", flush=True)\n                        fig = create_planet_visualization(\n                            fig,                            # First parameter should be fig\n                            planet_name,                    # Second parameter should be planet_name\n                            planet_shell_vars[planet_name], # Third parameter should be shell_vars\n                            center_position=(0, 0, 0)       # Named parameter can stay as is\n                        )\n                    # For non-center planets, use their actual positions\n                    elif not is_center and 'position' in planet_data and planet_data['position'] is not None:\n                        # Check if any shell for this planet is selected\n                        if any(var.get() == 1 for var in planet_shell_vars[planet_name].values()):\n                            print(f\"\\nAdding shells for non-center planet {planet_name}\", flush=True)\n                            \n                            # Always add the planet shells\n                            fig = create_planet_visualization(\n                                fig,                            \n                                planet_name,                    \n                                planet_shell_vars[planet_name], \n                                center_position=planet_data['position']  # Use planet's position\n                            )\n\n                            # Only add sun direction indicator when Sun is not the center\n                            if center_object_name != 'Sun':\n                                print(f\"Adding Sun direction indicator for {planet_name}\", flush=True)\n                                sun_direction_traces = create_sun_direction_indicator(\n                                    center_position=planet_data['position'],\n                                    axis_range=axis_range,  # Pass the axis_range parameter\n                                    object_type=planet_name,\n                                    center_object=center_object_name\n                                )\n\n                                for trace in sun_direction_traces:\n                                    fig.add_trace(trace)\n                            \n            # NEW: Add Sun corona when viewing from non-Sun center\n            if center_object_name != 'Sun':\n                if sun_shell_vars.get('corona_from_distance') and sun_shell_vars['corona_from_distance'].get() == 1:\n                    # Get Sun's position relative to current center\n                    if 'Sun' in positions and positions['Sun'] is not None:\n                        sun_pos_dict = positions['Sun']\n                        # Extract x, y, z from dictionary\n                        sun_position = (sun_pos_dict['x'], sun_pos_dict['y'], sun_pos_dict['z'])\n                        print(f\"\\nAdding Sun corona layers at position {sun_position}\", flush=True)\n                        fig = create_sun_corona_from_distance(fig, sun_shell_vars, sun_position)\n\n            selected_planets = [\n                obj['name'] for obj in objects\n                if obj['var'].get() == 1\n                and obj['name'] != center_object_name\n                and obj.get('system_id', 'solar') == center_system_id\n            ]\n\n            # Pass center_object_name to plot_actual_orbits\n\n            plot_actual_orbits(fig, selected_planets, dates_lists, center_id=center_id, show_lines=True, center_object_name=center_object_name, show_closest_approach=show_closest_approach_var.get())\n\n            # ADD PLOTTED PERIOD OVERLAY FOR TRAJECTORY OBJECTS (yellow highlight)\n            # This shows the GUI-selected date range overlaid on the full mission\n            trajectory_objects = [obj for obj in selected_objects \n                                 if obj.get('object_type') == 'trajectory' \n                                 and obj['name'] != center_object_name]\n            \n            if trajectory_objects:\n                print(f\"\\n[PLOTTED PERIOD] Adding yellow overlay for {len(trajectory_objects)} trajectory objects...\", flush=True)\n                \n                for obj in trajectory_objects:\n                    obj_name = obj['name']\n                    \n                    # Get mission bounds\n                    mission_start = obj.get('start_date', settings['start_date'])\n                    mission_end = obj.get('end_date', settings['end_date'])\n                    \n                    # Calculate plotted period (GUI dates clipped to mission bounds)\n                    plot_start = max(settings['start_date'], mission_start)\n                    plot_end = min(settings['end_date'], mission_end)\n                    \n                    # Skip if plotted period doesn't overlap with mission\n                    if plot_start >= plot_end:\n                        print(f\"[PLOTTED PERIOD] {obj_name}: No overlap with mission dates, skipping\", flush=True)\n                        continue\n                    \n                    # Calculate dates for plotted period\n                    plot_days = (plot_end - plot_start).total_seconds() / 86400\n                    num_points = int(trajectory_points) + 1\n                    plotted_dates = [plot_start + timedelta(days=float(d)) \n                                    for d in np.linspace(0, plot_days, num=num_points)]\n                    \n                    # Use helio_id for Sun-centered plots if available\n                    fetch_id = obj['id']\n                    fetch_id_type = obj.get('id_type')\n                    if center_object_name == 'Sun' and 'helio_id' in obj:\n                        fetch_id = obj['helio_id']\n                        fetch_id_type = 'smallbody'\n                                        \n                    # Fetch trajectory for plotted period\n                    trajectory = fetch_trajectory(fetch_id, plotted_dates, center_id=center_id, id_type=fetch_id_type)\n                    \n                    # ORCUS TRAJECTORY DERIVATION: JPL doesn't support 920090482 as query target\n                    # Derive Orcus trajectory from Vanth using mass ratio\n                    if obj_name == 'Orcus' and center_object_name == 'Orcus-Vanth Barycenter':\n                        # Check if trajectory is all zeros (JPL returns zeros for invalid target)\n                        traj_all_zeros = trajectory and all(\n                            (pos is None or (pos.get('x', 0) == 0 and pos.get('y', 0) == 0 and pos.get('z', 0) == 0))\n                            for pos in trajectory\n                        )\n                        if not trajectory or traj_all_zeros:\n                            print(f\"  - Deriving Orcus trajectory from Vanth (mass ratio method)...\", flush=True)\n                            # Fetch Vanth trajectory - ID 120090482 works correctly\n                            vanth_trajectory = fetch_trajectory('120090482', plotted_dates, center_id=center_id, id_type=None)\n                            if vanth_trajectory:\n                                mass_ratio = 0.16  # Vanth/Orcus mass ratio\n                                trajectory = []\n                                for vanth_pos in vanth_trajectory:\n                                    if vanth_pos and vanth_pos.get('x') != 0:\n                                        # Orcus is opposite Vanth relative to barycenter, scaled by mass ratio\n                                        trajectory.append({\n                                            'x': -vanth_pos['x'] * mass_ratio,\n                                            'y': -vanth_pos['y'] * mass_ratio,\n                                            'z': -vanth_pos['z'] * mass_ratio\n                                        })\n                                    else:\n                                        trajectory.append({'x': 0, 'y': 0, 'z': 0})\n                                print(f\"  -> Derived {len(trajectory)} Orcus positions from Vanth\", flush=True)\n\n                    if trajectory:\n                        x = [pos['x'] for pos in trajectory if pos is not None]\n                        y = [pos['y'] for pos in trajectory if pos is not None]\n                        z = [pos['z'] for pos in trajectory if pos is not None]\n                        \n                        if x:\n                            fig.add_trace(\n                                go.Scatter3d(\n                                    x=x,\n                                    y=y,\n                                    z=z,\n                                    mode='lines',\n                                    line=dict(color='yellow', width=2),\n                                    opacity=1.0,\n                                    name=f\"{obj_name} Plotted Period\",\n                                    text=[f\"{obj_name} Plotted Period\"] * len(x),\n                                    hovertemplate='%{text}<extra></extra>',\n                                    showlegend=True\n                                )\n                            )\n                            print(f\"[PLOTTED PERIOD] {obj_name}: {len(x)} points from {plot_start.strftime('%Y-%m-%d')} to {plot_end.strftime('%Y-%m-%d')}\", flush=True)\n                            \n                            # Add yellow closest approach marker for Plotted Period\n                            if show_closest_approach_var.get():\n                                from apsidal_markers import add_closest_approach_marker\n                                \n                                # Build positions_dict from trajectory data\n                                positions_dict = {}\n                                for i in range(len(x)):\n                                    if i < len(plotted_dates):\n                                        positions_dict[plotted_dates[i].isoformat()] = {\n                                            'x': x[i],\n                                            'y': y[i],\n                                            'z': z[i]\n                                        }\n                                \n                                add_closest_approach_marker(\n                                    fig=fig,\n                                    positions_dict=positions_dict,\n                                    obj_name=obj_name,\n                                    center_body=center_object_name,\n                                    color_map=color_map,\n                                    date_range=(plotted_dates[0], plotted_dates[-1]) if plotted_dates else None,\n                                    marker_color='yellow'  # Yellow for Plotted Period\n                                )\n\n            positions = {}\n\n            for obj in objects:\n                if not obj['var'].get():\n                    continue\n                # Only fetch positions for same-system objects\n                if obj['name'] != center_object_name and obj.get('system_id', 'solar') != center_system_id:\n                    continue\n                \n                if obj['name'] == center_object_name:\n                    obj_data = {'x': 0, 'y': 0, 'z': 0}\n\n        #        else:\n        #            obj_data = fetch_position(obj['id'], date_obj, center_id=center_id, id_type=obj.get('id_type', None))\n                \n                else:\n                    # Use helio_id for Sun-centered plots if available\n                    fetch_id = obj['id']\n                    fetch_id_type = obj.get('id_type', None)\n                    if center_object_name == 'Sun' and 'helio_id' in obj:\n                        fetch_id = obj['helio_id']\n                        fetch_id_type = 'smallbody'\n                    obj_data = fetch_position(fetch_id, date_obj, center_id=center_id, id_type=fetch_id_type)\n\n                    # Special case: Orcus at Orcus-Vanth Barycenter - derive from Vanth's position\n                    orcus_needs_derivation = (\n                        obj['name'] == 'Orcus' and \n                        center_object_name == 'Orcus-Vanth Barycenter' and\n                        (obj_data is None or (obj_data.get('x') == 0 and obj_data.get('y') == 0 and obj_data.get('z') == 0))\n                    )\n                    if orcus_needs_derivation:\n                        print(f\"  - Deriving Orcus position from Vanth (mass ratio method)...\", flush=True)\n                        vanth_data = fetch_position('120090482', date_obj, center_id=center_id, id_type=None)\n                        if vanth_data and vanth_data.get('x') != 0:\n                            mass_ratio = 0.16\n                            x_orcus = -vanth_data['x'] * mass_ratio\n                            y_orcus = -vanth_data['y'] * mass_ratio\n                            z_orcus = -vanth_data['z'] * mass_ratio\n                            r_orcus = np.sqrt(x_orcus**2 + y_orcus**2 + z_orcus**2)\n                            vx_orcus = -vanth_data.get('vx', 0) * mass_ratio\n                            vy_orcus = -vanth_data.get('vy', 0) * mass_ratio\n                            vz_orcus = -vanth_data.get('vz', 0) * mass_ratio\n                            v_orcus = np.sqrt(vx_orcus**2 + vy_orcus**2 + vz_orcus**2)\n                            obj_data = {\n                                'x': x_orcus, 'y': y_orcus, 'z': z_orcus,\n                                'range': r_orcus,\n                                'vx': vx_orcus, 'vy': vy_orcus, 'vz': vz_orcus,\n                                'velocity': v_orcus,\n                                'distance_km': r_orcus * KM_PER_AU,\n                                'distance_lm': r_orcus * LIGHT_MINUTES_PER_AU,\n                                'distance_lh': (r_orcus * LIGHT_MINUTES_PER_AU) / 60,\n                                'derived_from_vanth': True\n                            }\n                            print(f\"  -> Orcus: r={r_orcus:.7f} AU (~{r_orcus * 149597870.7:.0f} km)\", flush=True)\n\n                # Fallback for objects without JPL ephemeris (e.g., MK2, 6AC4721)\n            #    ANALYTICAL_POSITION_FALLBACK = ['MK2', 'Xiangliu', 'Vanth', 'Weywot', '6AC4721']\n                ANALYTICAL_POSITION_FALLBACK = ['MK2', 'Xiangliu', 'Vanth', 'Gonggong', '6AC4721']  # Weywot removed - JPL data works at Quaoar\n                if obj_data is None and obj['name'] in ANALYTICAL_POSITION_FALLBACK:\n                    from orbital_elements import planetary_params\n                    if obj['name'] in planetary_params:\n                        elements = planetary_params[obj['name']]\n                        a = elements.get('a', 0)\n                        e = elements.get('e', 0)\n                        i_deg = elements.get('i', 0)\n                        omega_deg = elements.get('omega', 0)\n                        Omega_deg = elements.get('Omega', 0)\n                        \n                        # Get orbital period - calculate from a if not provided\n                        if 'orbital_period_days' in elements:\n                            orbital_period = elements['orbital_period_days']\n                        elif a > 0:\n                            orbital_period = np.sqrt(a**3) * 365.25\n                        else:\n                            orbital_period = 12.4  # Default fallback\n                        \n                        # Reference epoch and mean anomaly\n                        # Use object's values if available, else J2000 with MA=0\n                        if 'MA' in elements and 'epoch' in elements:\n                            MA_epoch = elements['MA']\n                            epoch_str = str(elements['epoch']).replace(' osc.', '').strip()\n                            try:\n                                ref_epoch = datetime.strptime(epoch_str, '%Y-%m-%d')\n                            except ValueError:\n                                ref_epoch = datetime(2000, 1, 1, 12, 0, 0)\n                        else:\n                            MA_epoch = 0.0\n                            ref_epoch = datetime(2000, 1, 1, 12, 0, 0)\n                        \n                        delta_days = (date_obj - ref_epoch).total_seconds() / 86400.0\n                        \n                        # Mean motion and current mean anomaly\n                        n = 360.0 / orbital_period\n                        M_deg = (MA_epoch + n * delta_days) % 360.0\n                        M_rad = np.radians(M_deg)\n                        \n                        # Solve Kepler's equation if e > 0.01\n                        if e > 0.01:\n                            E = M_rad if e < 0.8 else np.pi\n                            for _ in range(50):\n                                f = E - e * np.sin(E) - M_rad\n                                f_prime = 1 - e * np.cos(E)\n                                if abs(f_prime) < 1e-12:\n                                    break\n                                E = E - f / f_prime\n                                if abs(f / f_prime) < 1e-10:\n                                    break\n                            true_anomaly = 2 * np.arctan2(\n                                np.sqrt(1 + e) * np.sin(E / 2),\n                                np.sqrt(1 - e) * np.cos(E / 2)\n                            )\n                        else:\n                            true_anomaly = M_rad\n                        \n                        # Position in orbital plane\n                        r = a if e == 0 else a * (1 - e**2) / (1 + e * np.cos(true_anomaly))\n                        x_orb = r * np.cos(true_anomaly)\n                        y_orb = r * np.sin(true_anomaly)\n                        \n                        # Apply 3D rotations\n                        i_rad = np.radians(i_deg)\n                        omega_rad = np.radians(omega_deg)\n                        Omega_rad = np.radians(Omega_deg)\n                        \n                        x1 = x_orb * np.cos(omega_rad) - y_orb * np.sin(omega_rad)\n                        y1 = x_orb * np.sin(omega_rad) + y_orb * np.cos(omega_rad)\n                        x2 = x1\n                        y2 = y1 * np.cos(i_rad)\n                        z2 = y1 * np.sin(i_rad)\n                        x_final = x2 * np.cos(Omega_rad) - y2 * np.sin(Omega_rad)\n                        y_final = x2 * np.sin(Omega_rad) + y2 * np.cos(Omega_rad)\n                        \n                        obj_data = {'x': x_final, 'y': y_final, 'z': z2}\n                        print(f\"  [ANALYTICAL] Calculated position for {obj['name']}: ({x_final:.6f}, {y_final:.6f}, {z2:.6f}) AU\", flush=True)\n                \n                positions[obj['name']] = obj_data\n\n            # ADD THIS: Convert positions to the format needed by idealized_orbits\n            current_positions = {}\n            for obj_name, pos_data in positions.items():\n                if pos_data and 'x' in pos_data:\n                    current_positions[obj_name] = {\n                        'x': pos_data['x'],\n                        'y': pos_data['y'],\n                        'z': pos_data['z']\n                    }\n\n            for obj in objects:\n                # Check system membership\n                same_system = obj.get('system_id', 'solar') == center_system_id\n                \n                # Only plot center or same-system checked objects\n                # Skip exoplanet objects - they're handled in dedicated exoplanet block\n                if obj.get('object_type') in ['exoplanet', 'exo_host_star', 'exo_binary_star', 'exo_barycenter']:\n                    continue\n\n                if obj['name'] == center_object_name or (obj['var'].get() == 1 and same_system):\n\n                    obj_data = positions.get(obj['name'])\n                    if not obj_data:\n                        continue\n\n                    obj_data = positions.get(obj['name'])\n                    if obj_data:\n                        marker_size = DEFAULT_MARKER_SIZE\n                        if obj['name'] == center_object_name:\n                            marker_size = CENTER_MARKER_SIZE\n                        elif obj['name'] == 'Moon' and center_object_name == 'Earth':\n                            marker_size = DEFAULT_MARKER_SIZE\n                        add_celestial_object(fig, \n                                             obj_data, \n                                             obj['name'], \n                                             obj['color'], \n                                             obj['symbol'], \n                                             marker_size=marker_size, \n                                             hover_data=hover_data,\n                                             center_object_name=center_object_name\n                                             )  \n\n            # Rearrange traces to ensure the center marker is on top\n            center_trace_name = center_object_name  # This should match the 'name' parameter of your center marker trace\n\n            # Extract center traces\n            center_traces = [trace for trace in fig.data if trace.name == center_trace_name]\n\n            # Extract all other traces\n            other_traces = [trace for trace in fig.data if trace.name != center_trace_name]\n\n            # Reassign fig.data with center traces at the end\n            fig.data = tuple(other_traces + center_traces)\n\n            # Find the section in plot_objects() where the figure layout is updated\n            # Replace the existing title line with this enhanced version:\n\n            # Calculate the end date for the title based on orbit data range\n            try:\n                # Get the dates directly\n                start_date = get_date_from_gui()\n                end_date = get_end_date_from_gui()\n                days_to_plot = int(days_to_plot_entry.get())\n                \n                # Format the title with date range\n                if days_to_plot == 0:\n                    # If no days to plot, just show the single date\n                    title_text = f\"Paloma's Orrery for {start_date.strftime('%B %d, %Y %H:%M')} UTC\"\n                else:\n                    # Show date range for orbit data\n                    title_text = f\"Paloma's Orrery for {start_date.strftime('%B %d, %Y %H:%M')} through {end_date.strftime('%B %d, %Y %H:%M')} UTC\"\n            except ValueError:\n                # Fallback to original format if end_date is invalid\n                title_text = f\"Paloma's Orrery for {date_obj.strftime('%B %d, %Y %H:%M')} UTC\"\n\n            # Update the figure layout section to use the new title:\n            fig.update_layout(\n                scene=dict(\n                    xaxis=dict(\n                        title='X (AU)',\n                        range=axis_range,\n                        backgroundcolor='black',\n                        gridcolor='gray',\n                        showbackground=True,\n                        showgrid=True\n                    ),\n                    yaxis=dict(\n                        title='Y (AU)',\n                        range=axis_range,\n                        backgroundcolor='black',\n                        gridcolor='gray',\n                        showbackground=True,\n                        showgrid=True\n                    ),\n                    zaxis=dict(\n                        title='Z (AU)',\n                        range=axis_range,\n                        backgroundcolor='black',\n                        gridcolor='gray',\n                        showbackground=True,\n                        showgrid=True\n                    ),\n                    aspectmode='cube',\n                    camera=get_default_camera(),\n                    domain=dict(x=[0.2, 1.0], y=[0.0, 1.0])\n                ),\n                paper_bgcolor='black',\n                plot_bgcolor='black',\n                title_font_color='white',\n                font_color='white',\n                title=title_text,  # Use the calculated title with date range\n                showlegend=True,\n                legend=dict(\n                    font=dict(color='white'),\n                    x=1,\n                    y=1,\n                    xanchor='left',\n                    yanchor='top'\n                ),\n\n                margin=dict(l=75, r=50, t=80, b=50),\n\n                annotations=[\n\n                    # NEW: Coordinate System explanation box\n                    dict(\n\n                        text=(\n                            \"<b>Coordinate System (J2000 Ecliptic):</b><br><br>\"\n\n                            \"<b>+X:</b> Toward RA=0 deg (&#9800;) - same for all objects<br><br>\"\n\n                            + \"<b>+Z:</b> Ecliptic North perpendicular to Earth's orbit<br>\"\n                            + (\"<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(For exoplanets: line of sight from star to Earth)</i><br><br>\" \n                            if is_exoplanet_mode else \"<br>\")\n\n                            + \"<b>XY plane:</b> Ecliptic, Earth's orbital plane<br>\"\n                            + (\"<i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(For exoplanets: sky plane, perpendicular to line of sight)</i><br><br><br>\" \n                            if is_exoplanet_mode else \"<br><br>\")\n\n                            + \"<i>See Orbital Parameter Visualization for detailed explanation of ecliptic coordinates</i>\"\n                        ),                        \n\n                        xref='paper',\n                        yref='paper',\n                        x=-0.04,\n                        y=0.80,  \n                        showarrow=False,\n                        font=dict(size=11, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top',\n                        bgcolor='rgba(0, 0, 0, 0.3)',\n                        bordercolor='white',\n                        borderwidth=1,\n                        borderpad=4\n                    ),\n\n                    dict(\n                        text=\"<a href='https://tonylquintanilla.github.io/palomas_orrery/'>Paloma's Orrery GitHub Page</a>\",\n                        xref='paper',\n                        yref='paper',\n                        x=0,\n                        y=0.4,\n                        showarrow=False,\n                        font=dict(size=12, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top'\n                    ),                    \n                    dict(\n                        text=\"<a href='https://sites.google.com/view/tony-quintanilla/home'>Paloma's Orrery Web Site</a>\",\n                        xref='paper',\n                        yref='paper',\n                        x=0,\n                        y=0.45,\n                        showarrow=False,\n                        font=dict(size=12, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top'\n                    ),                    \n                    dict(\n                        text=\"<a href='https://ssd.jpl.nasa.gov/horizons/app.html#/' target='_blank'>JPL Horizons</a>\",\n                        xref='paper',\n                        yref='paper',\n                        x=0,\n                        y=0.35,\n                        showarrow=False,\n                        font=dict(size=12, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top'\n                    ),\n                    dict(\n                        text=\"<a href='https://www.nasa.gov/' target='_blank'>NASA</a>\",\n                        xref='paper',\n                        yref='paper',\n                        x=0,\n                        y=0.3,\n                        showarrow=False,\n                        font=dict(size=12, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top'\n                    ),\n                    dict(\n                        text=\"Click on the legend items to<br>\"\n                            \"toggle them off and back on.\",\n                        xref='paper',\n                        yref='paper',\n                        x=0.95,\n                        y=1.08,\n                        showarrow=False,\n                        font=dict(size=12, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top'\n                    ),\n                ]\n            )\n\n            # 5. Collect user-checked objects for orbits\n            selected_objects = [obj['name'] for obj in objects if obj['var'].get() == 1]\n            \n            # 6. Plot idealized orbits using your new logic\n            plot_idealized_orbits(fig, selected_objects, center_id=center_object_name, \n                                    objects=objects, \n                                    planetary_params=active_planetary_params,  # <--- Use the updated params\n                                    parent_planets=parent_planets, color_map=color_map, \n                                    date=date_obj, days_to_plot=settings['days_to_plot'],\n                                    current_positions=current_positions, \n                                    fetch_position=fetch_position,\n                                    show_apsidal_markers=show_apsidal_markers_var.get(),\n                                    parent_window=root\n                                    )\n\n                    # Add refined orbits if we're centered on a planet with moons\n            if center_object_name != 'Sun' and REFINED_AVAILABLE:\n                # Get the moons for this center\n                moons_to_plot = []\n                for obj in selected_objects:\n                    if obj in parent_planets.get(center_object_name, []):\n                        moons_to_plot.append(obj)\n                \n                if moons_to_plot:\n        #            print(f\"\\nAdding refined orbits for {center_object_name}'s moons...\", flush=True)  # deprecated   \n\n                    # Pass the orbit data directly if in special fetch mode\n            #        orbit_data_to_pass = None\n                    # Collect actual orbit data to pass directly\n                    orbit_data_to_pass = {}\n\n                    # Check special fetch mode first\n                    if special_fetch_var.get() == 1 and temp_cache:\n            #            orbit_data_to_pass = temp_cache\n                        orbit_data_to_pass = temp_cache.copy()     \n                    else:\n                        # Try to get from the main cache\n                        for moon in moons_to_plot:\n                            orbit_key = f\"{moon}_{center_object_name}\"\n                            if orbit_key in orbit_paths_over_time:\n                                orbit_data_to_pass[orbit_key] = orbit_paths_over_time[orbit_key]  \n\n                    # Determine the date range based on object type (for satellites)\n                #    sat_plot_orbit_days = int(satellite_days_entry.get())  # Get the satellite days setting\n                    sat_plot_orbit_days = settings['days_to_plot']  # Use the actual days_to_plot value\n                    start_date = date_obj\n                    end_date = date_obj + timedelta(days=sat_plot_orbit_days)\n\n                    # DISABLED: Refined orbits system - osculating elements already include all perturbations\n                    # The refined_orbits.py module was an excellent exploration of orbital mechanics and\n                    # perturbation theory, but JPL Horizons osculating elements already incorporate\n                    # all physical effects (precession, J2, n-body perturbations, etc.)\n                    # Keeping this code for historical reference and potential future educational use.\n                    \n                    # fig = plot_refined_orbits_for_moons(\n                    #     fig, moons_to_plot, center_object_name, color_map, \n                    #     orbit_data=orbit_data_to_pass,\n                    #     date_obj=date_obj,\n                    #     date_range=(start_date, end_date)\n                    # )\n\n        # ============ EXOPLANET ORBITS ============\n            # Plot exoplanet systems if any exoplanet objects are selected           \n            \n            if exo_objects or exo_host_stars:\n                # Override center object for exoplanet systems\n                exo_systems = set()\n                for obj in exo_objects + exo_host_stars:\n                    system_id = obj.get('system_id')\n                    if system_id:\n                        exo_systems.add(system_id)\n                \n                # Override center to host star -- using explict star as center object selection instead\n            #    if exo_systems:\n            #        first_system_id = list(exo_systems)[0]\n            #        system = get_system(first_system_id)\n            #        if system:\n            #            center_object_name = system['host_star']['name']\n            #            print(f\"\\n[EXOPLANET MODE] Center: {center_object_name}\")\n                \n                try:\n                    # Determine which system(s) are selected\n                    exo_systems = set()\n\n                    for obj in exo_objects + exo_host_stars:\n                        system_id = obj.get('system_id')\n                        if system_id:\n                            exo_systems.add(system_id)\n                    \n                    # Plot each system\n                    for system_id in exo_systems:\n                        system = get_system(system_id)\n                        if not system:\n                            continue\n                        \n                        # Get objects for this system\n                #        system_planets = [obj for obj in exo_objects \n                #                        if obj.get('system_id') == system_id]\n                        \n                        # Get objects for this system - use full catalog data\n                        system_planets = []\n                        for obj in exo_objects:\n                            if obj.get('system_id') == system_id:\n                                # Get the full planet data from the catalog\n                                planet_id = obj.get('id')\n                                if planet_id:\n                                    # Find this planet in the system's planets list\n                                    for catalog_planet in system['planets']:\n                                        if catalog_planet.get('planet_id') == planet_id:\n                                            # Add the GUI metadata to the catalog data\n                                            full_planet = catalog_planet.copy()\n                                            full_planet['var'] = obj['var']\n                                            full_planet['name'] = obj['name']\n                                            full_planet['color'] = obj.get('color', 'lightblue')\n                                            system_planets.append(full_planet)\n                                            break\n\n\n                        system_stars = [obj for obj in exo_host_stars \n                                    if obj.get('system_id') == system_id]\n                        \n                        # Plot host star(s)\n                        # Check if barycenter is selected\n                        barycenter_obj = next((obj for obj in exo_host_stars \n                                             if obj.get('id_type') == 'barycenter' \n                                             and obj.get('system_id') == system_id \n                                             and obj['var'].get() == 1), None)\n                        \n\n                        # Plot host star(s) - works for both binary and single star systems\n                        if system_stars or barycenter_obj or not system['host_star'].get('is_binary'):\n                            # Call plot_binary_host_stars - it handles both binary AND single stars\n\n                            fig = plot_binary_host_stars(fig, system['host_star'], date_obj, show_orbits=True, system_data=system)\n\n                        # Plot planets\n                        if system_planets:\n                            fig = plot_exoplanet_orbits(\n                                fig, system_planets, system, date_obj,\n                                show_orbits=True, show_markers=True\n                            )\n\n\n                        # Set axis range for exoplanet system\n                        if system_planets:\n                            exo_axis_range = calculate_exoplanet_axis_range(system_planets)\n                            fig.update_layout(\n                                scene=dict(\n                                    xaxis=dict(range=[-exo_axis_range, exo_axis_range], title='X (AU)'),\n                                    yaxis=dict(range=[-exo_axis_range, exo_axis_range], title='Y (AU)'),\n                                    zaxis=dict(range=[-exo_axis_range, exo_axis_range], title='Z (AU)'),\n                                    aspectmode='cube'\n                                )\n                            )\n                            \n                            # Add note about coordinate system\n                            print(f\"\\nExoplanet system '{system['system_name']}' uses independent local frame:\", flush=True)\n                            print(f\"  Origin: Host star at (0, 0, 0)\", flush=True)\n                            print(f\"  XY plane: Sky plane (perpendicular to Earth)\", flush=True)\n                            print(f\"  Z axis: Toward Earth\", flush=True)\n                            print(f\"  Axis range: +/-{exo_axis_range:.4f} AU\\n\", flush=True)\n                \n                except Exception as e:\n                    print(f\"Error plotting exoplanet systems: {e}\", flush=True)\n            #        import traceback\n                    traceback.print_exc()\n\n\n            # Add URL buttons before showing/saving\n            fig = add_url_buttons(fig, objects, selected_objects)\n\n            # Add camera view buttons with dropdown for different target objects\n            fig = add_look_at_object_buttons(fig, positions, center_object_name)            \n           \n            fig = add_fly_to_object_buttons(fig, positions, center_object_name)  # NEW\n\n            # ============ ADD COMET TAILS INTEGRATION ============\n            # Conservative comet tail integration\n            for obj in objects:\n                if obj['var'].get() == 1:\n                    # Check if this is a comet by its properties\n                    \n                    is_comet = (\n                        obj.get('object_type') in ['orbital', 'trajectory'] and  # Allow both types\n                        obj.get('id_type') == 'smallbody' and\n                        obj.get('symbol') == 'diamond'\n                    )\n\n                    if is_comet and obj['name'] in positions:\n                        print(f\"Processing comet tails for {obj['name']}...\", flush=True)\n                        fig = add_comet_tails_to_figure(\n                            fig,\n                            obj['name'],\n                            positions[obj['name']],\n                            center_object_name\n                        )\n            # ============ END COMET TAILS INTEGRATION ============\n\n            # Generate default name with timestamp\n#            current_date = datetime.now()\n            current_date = STATIC_TODAY\n            default_name = f\"solar_system_{date_obj.strftime('%Y%m%d_%H%M')}\"\n\n            # Use show_figure_safely to handle both display and save options\n            show_figure_safely(fig, default_name)\n\n            # Store fig for social media export\n            _last_plotted_fig[0] = fig\n            _last_plot_name[0] = default_name\n\n            # Schedule GUI updates on main thread (required for macOS)\n            root.after(0, lambda: output_label.config(text=\"Plotting complete.\"))\n            root.after(0, lambda: progress_bar.stop())\n\n        except Exception as e:\n            # Schedule GUI updates on main thread (required for macOS)\n            root.after(0, lambda msg=str(e): output_label.config(text=f\"Error during plotting: {msg}\"))\n            print(f\"Error during plotting: {e}\", flush=True)\n            traceback.print_exc()\n            root.after(0, lambda: progress_bar.stop())",
    "start_line": 3620,
    "end_line": 5190,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function worker",
    "component_id": "palomas_orrery.worker"
  },
  "palomas_orrery.animate_objects": {
    "id": "palomas_orrery.animate_objects",
    "name": "animate_objects",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "osculating_cache_manager.get_elements_with_prompt",
      "palomas_orrery.get_date_from_gui"
    ],
    "source_code": "def animate_objects(step, label):\n    # =========================================================================\n    # PRE-FETCH OSCULATING ELEMENTS ON MAIN THREAD (Threading Fix)\n    # =========================================================================\n    # Create working copy of planetary_params with fresh data (same as plot_objects)\n    active_planetary_params = planetary_params.copy()\n    \n    # Get selected objects that need orbital elements\n    selected_objects_for_prefetch = [obj for obj in objects if obj['var'].get() == 1]\n    center_object_name = center_object_var.get()\n    \n    # Determine center_body for osculating elements based on view\n    # This affects which reference frame the elements use\n    if center_object_name == 'Pluto-Charon Barycenter':\n        osculating_center_body = '@9'  # Barycentric elements\n    elif center_object_name == 'Pluto':\n        osculating_center_body = '@999'  # Pluto-centered elements\n    elif center_object_name == 'Orcus-Vanth Barycenter':\n        osculating_center_body = '@20090482'  # Orcus-Vanth satellite solution barycenter\n    elif center_object_name == 'Patroclus-Menoetius Barycenter':\n        osculating_center_body = '@20000617'  # Patroclus-Menoetius satellite solution barycenter        \n    elif center_object_name == 'Earth-Moon Barycenter':\n        osculating_center_body = '@3'  # Earth-Moon system barycenter\n    elif center_object_name == 'Earth':\n        osculating_center_body = '@399'  # Earth body center (for Moon's osculating elements)\n    else:\n        osculating_center_body = None  # Default (heliocentric or auto-detect)\n\n    # Get the animation start date for osculating elements\n    try:\n        plot_date = get_date_from_gui()\n    except Exception as e:\n        print(f\"[ANIMATION PRE-FETCH] Could not get start date: {e}, using today\", flush=True)\n        plot_date = datetime.now()\n\n    # These TNO moons have no usable JPL parent-centered ephemeris\n#    SKIP_HORIZONS_PREFETCH = ['MK2', 'Xiangliu', 'Vanth', 'Weywot']\n    SKIP_HORIZONS_PREFETCH = ['MK2', 'Xiangliu', 'Vanth', 'Gonggong']  \n\n    pre_fetch_objects = [\n        obj['name'] for obj in selected_objects_for_prefetch \n        if obj['name'] not in SKIP_HORIZONS_PREFETCH\n        if obj.get('object_type') in ['orbital', 'satellite', 'trajectory', 'lagrange_point']\n        and obj['name'] != center_object_name\n        and obj.get('object_type') not in ['exoplanet', 'exo_host_star', 'exo_binary_star', 'exo_barycenter']\n        and not obj.get('is_mission', False)\n    ]\n    \n    # Only pre-fetch in normal mode (not special fetch mode)\n    if special_fetch_var.get() == 0 and pre_fetch_objects:\n        print(f\"\\n[ANIMATION PRE-FETCH] Checking osculating elements for {len(pre_fetch_objects)} objects...\", flush=True)\n        for obj_name in pre_fetch_objects:\n            try:\n                # Find the object dictionary to get its Horizons ID\n                obj_dict = next((obj for obj in selected_objects_for_prefetch \n                                if obj['name'] == obj_name), None)\n                \n                if obj_dict:\n                    horizons_id = obj_dict.get('id', obj_name)\n                    id_type = obj_dict.get('id_type', 'smallbody')\n                    \n                    print(f\"[ANIMATION PRE-FETCH] Using Horizons ID: {horizons_id} (type: {id_type})\", flush=True)\n                    \n                    # Determine if this object needs barycentric elements\n                    # Pluto system objects need center_body when viewing from barycenter\n                    obj_center_body = None\n                    if center_object_name in ['Pluto-Charon Barycenter', 'Pluto']:\n                        # Check if this is a Pluto system object (Pluto, Charon, or outer moons)\n                        pluto_system_ids = ['999', '901', '902', '903', '904', '905']  # Pluto, Charon, Nix, Hydra, Kerberos, Styx\n                        if str(horizons_id) in pluto_system_ids:\n                            obj_center_body = osculating_center_body\n                    elif center_object_name == 'Orcus-Vanth Barycenter':\n                        orcus_system_ids = ['920090482', '120090482', '2004 DW']\n                        if str(horizons_id) in orcus_system_ids:\n                            obj_center_body = osculating_center_body\n                    elif center_object_name == 'Patroclus-Menoetius Barycenter':\n                        patroclus_system_ids = ['920000617', '120000617', 'A906 UL']\n                        if str(horizons_id) in patroclus_system_ids:\n                            obj_center_body = osculating_center_body                    \n                    elif center_object_name in ['Earth-Moon Barycenter', 'Earth']:\n                        # Check if this is an Earth-Moon system object (Earth or Moon)\n                        earth_moon_system_ids = ['399', '301']  # Earth, Moon\n                        if str(horizons_id) in earth_moon_system_ids:\n                            obj_center_body = osculating_center_body\n\n                    # Get elements with proper Horizons ID and center body\n                    fresh_elements = get_elements_with_prompt(\n                        obj_name, \n                        horizons_id=horizons_id,\n                        id_type=id_type,\n                        plot_date=plot_date,\n                        parent_window=root,\n                        center_body=obj_center_body\n                    )\n\n                else:\n                    # Fallback to old behavior\n                    print(f\"[ANIMATION PRE-FETCH] ? Object dictionary not found for {obj_name}, using name as ID\", flush=True)\n            #        fresh_elements = get_elements_with_prompt(obj_name, plot_date=plot_date, parent_window=root)\n                    fresh_elements = get_elements_with_prompt(obj_name, plot_date=plot_date, parent_window=root, center_body=osculating_center_body)\n                \n                active_planetary_params[obj_name] = fresh_elements\n                print(f\"[ANIMATION PRE-FETCH] OK: {obj_name}: Updated\", flush=True)\n            except Exception as e:\n                print(f\"[ANIMATION PRE-FETCH] ERROR: {obj_name}: {e}\", flush=True)\n\n    # =========================================================================\n    \n    def animation_worker():\n        try:\n            # Global references\n            global orbit_paths_over_time\n            nonlocal active_planetary_params  # Access the pre-fetched orbital params\n\n            # Initialize frames list at the beginning\n            frames = []\n\n            # Display status message at the beginning of animation\n            output_label.config(text=f\"Creating {label} animation. Please be patient as data is being fetched...\")\n            progress_bar['mode'] = 'indeterminate'\n            progress_bar.start(10)  # Start the progress bar\n            root.update_idletasks()  # Force GUI to update\n\n            # Detect exoplanet objects (same as in plot_objects)\n            exo_objects = [obj for obj in objects \n                        if obj['var'].get() == 1 and obj.get('object_type') == 'exoplanet']\n\n            exo_host_stars = [obj for obj in objects\n                        if obj['var'].get() == 1 and obj.get('object_type') in ['exo_host_star', 'exo_binary_star', 'exo_barycenter']]\n\n            # Detect if we're in exoplanet mode\n            is_exoplanet_mode = bool(exo_objects or exo_host_stars)\n\n            if is_exoplanet_mode:\n                print(f\"\\n[EXOPLANET ANIMATION MODE] Detected {len(exo_objects)} exoplanets and {len(exo_host_stars)} host stars\", flush=True)            \n\n            # Original setup code remains unchanged\n            center_object_name = center_object_var.get()\n            center_object_info = next((obj for obj in objects if obj['name'] == center_object_name), None)\n            if center_object_info:\n                if center_object_name == 'Sun':\n                    center_id = 'Sun'\n                    center_id_type = None\n                else:\n            #        center_id = center_object_info['id']\n                    center_id = center_object_info.get('center_id', center_object_info['id'])\n                    center_id_type = center_object_info.get('id_type')\n            else:\n                center_id = 'Sun'\n                center_id_type = None\n\n            # Get frames number and validate\n            N_str = num_frames_entry.get()\n            if not N_str.strip():\n                output_label.config(text=\"Please enter a valid number of frames.\")\n                return\n            N = int(N_str)\n            if N <= 0:\n                output_label.config(text=\"Number of frames must be positive.\")\n                return\n\n            # Get interval settings\n            settings, error_msg = get_interval_settings()\n            if error_msg:\n                output_label.config(text=error_msg)\n                return\n            \n            # Apply fix for days_to_plot\n        #    gui_days = int(days_to_plot_entry.get())\n        #    if settings['days_to_plot'] != gui_days:\n        #        print(f\"[ANIMATION WARNING] Settings mismatch: settings={settings['days_to_plot']}, GUI={gui_days}\", flush=True)\n        #        settings['days_to_plot'] = gui_days\n\n            # Debug check - don't override the precise calculated value from date range\n            gui_days = int(days_to_plot_entry.get()) if days_to_plot_entry.get() else 0\n            if int(settings['days_to_plot']) != gui_days:\n                print(f\"[INFO] Animation days_to_plot: calculated={settings['days_to_plot']:.6f} days ({settings['days_to_plot']*24*60:.1f} min), GUI shows={gui_days} days\", flush=True)\n            # Note: Don't override - calculated value preserves sub-day precision for flybys       \n\n            # Debug output\n            print(f\"Days to Plot: {settings['days_to_plot']}\", flush=True)\n            print(f\"Number of Frames: {N}\", flush=True)\n            print(f\"Animation Step: {label}\", flush=True)\n            print(\"=\" * 50, flush=True)\n\n            # Extract the values needed for animation\n            trajectory_points = settings['trajectory_points']\n            orbital_points = settings['orbital_points']\n            satellite_days = settings['satellite_days']\n            satellite_points = settings['satellite_points']\n            end_date = settings['end_date']\n            start_date = settings['start_date']\n            \n            # Get the current date\n            current_date = get_date_from_gui()\n            \n            # Generate animation frame dates\n            dates_list = create_animation_dates(current_date, step, N)\n\n\n            # Calculate days_ahead\n            days_ahead = 0\n            if dates_list:\n                days_ahead = (dates_list[-1] - dates_list[0]).days\n\n            # INCREMENTAL UPDATE: Before animating, ensure we have updated data\n            selected_objects = [obj for obj in objects if obj['var'].get() == 1]\n            selected_object_names = [obj['name'] for obj in selected_objects]  # Add this for plot_idealized_orbits\n\n            output_label.config(text=\"Checking for orbit data updates for animation...\")\n            root.update_idletasks()\n            \n            # Skip orbit data updates for exoplanet systems (they use Keplerian orbits, not JPL)\n            if not is_exoplanet_mode:\n                # Call the incremental update for selected objects only\n                updated, current, total, time_saved = orbit_data_manager.update_orbit_paths_incrementally(\n                    object_list=selected_objects,\n                    center_object_name=center_object_name,\n                    days_ahead=max(days_ahead, 365),  # Ensure we have enough data for the animation\n                    planetary_params=active_planetary_params,\n                    parent_planets=parent_planets,\n                    root_widget=root\n                )\n                \n                if updated > 0:\n                    output_label.config(text=f\"Updated {updated} orbit paths. Creating animation...\")\n                else:\n                    output_label.config(text=\"Using existing orbit data. Creating animation...\")\n                root.update_idletasks()\n            else:\n                # Exoplanet mode - skip JPL data update\n                output_label.config(text=\"Exoplanet mode: Using Keplerian orbits. Creating animation...\")\n                root.update_idletasks()\n\n\n            # Define planets with shell visualizations\n            planets_with_shells = {\n                'Mercury': {'positions': [], 'shell_vars': mercury_shell_vars},\n                'Venus': {'positions': [], 'shell_vars': venus_shell_vars},\n                'Earth': {'positions': [], 'shell_vars': earth_shell_vars},\n                'Moon': {'positions': [], 'shell_vars': moon_shell_vars},\n                'Mars': {'positions': [], 'shell_vars': mars_shell_vars},\n                'Jupiter': {'positions': [], 'shell_vars': jupiter_shell_vars},\n                'Saturn': {'positions': [], 'shell_vars': saturn_shell_vars},\n                'Uranus': {'positions': [], 'shell_vars': uranus_shell_vars},\n                'Neptune': {'positions': [], 'shell_vars': neptune_shell_vars},\n                'Pluto': {'positions': [], 'shell_vars': pluto_shell_vars},\n                'Eris': {'positions': [], 'shell_vars': eris_shell_vars},\n                'Planet 9': {'positions': [], 'shell_vars': planet9_shell_vars}\n            }\n            \n            # Handle exoplanet objects separately using Keplerian orbits\n            exoplanet_positions_over_time = {}\n            binary_star_positions_over_time = {} \n            if is_exoplanet_mode:\n                from exoplanet_orbits import calculate_planet_position\n                from exoplanet_systems import get_system\n                \n                # Get unique exoplanet systems\n                exo_systems = set()\n                for obj in exo_objects + exo_host_stars:\n                    system_id = obj.get('system_id')\n                    if system_id:\n                        exo_systems.add(system_id)\n                \n                print(f\"[EXOPLANET ANIMATION] Processing {len(exo_systems)} exoplanet systems\", flush=True)\n                \n                # Calculate positions for each exoplanet at each animation date\n                for obj in exo_objects:\n                    obj_name = obj['name']\n                    system_id = obj.get('system_id')\n                    \n                    if system_id:\n                        system = get_system(system_id)\n                        if system:\n                            # Find this planet in the catalog\n                            planet_id = obj.get('id')\n                            planet_data = None\n                            for catalog_planet in system['planets']:\n                                if catalog_planet.get('planet_id') == planet_id:\n                                    planet_data = catalog_planet\n                                    break\n                            \n                            if planet_data:\n                                # Extract orbital parameters\n                                a = planet_data['semi_major_axis_au']\n                                e = planet_data.get('eccentricity', 0.0)\n                                i = planet_data.get('inclination_deg', 90.0)\n                                omega = planet_data.get('omega_deg', 0.0)\n                                Omega = planet_data.get('Omega_deg', 0.0)\n                                period = planet_data['period_days']\n                                epoch = planet_data['epoch']\n                                \n                                # Calculate position at each animation date\n                                positions = []\n                                for date in dates_list:\n                                    x_pos, y_pos, z_pos = calculate_planet_position(\n                                        a, e, i, omega, Omega, period, epoch, date\n                                    )\n                                    positions.append({\n                                        'x': x_pos,\n                                        'y': y_pos,\n                                        'z': z_pos,\n                                        'date': date\n                                    })\n                                \n                                exoplanet_positions_over_time[obj_name] = positions\n                                print(f\"[EXOPLANET ANIMATION] Generated {len(positions)} positions for {obj_name}\", flush=True)\n\n# Calculate binary star positions over time if needed\n            #    binary_star_positions_over_time = {}\n                                \n                # Process each exoplanet system that has planets or barycenter selected\n                processed_systems = set()\n                for obj in exo_objects + exo_host_stars:\n                    if obj['var'].get() == 1:\n                        system_id = obj.get('system_id')\n                        \n                        # Skip if we've already processed this system\n                        if system_id in processed_systems or not system_id:\n                            continue\n                            \n                        system = get_system(system_id)\n                        if system and system['host_star'].get('is_binary'):\n                                print(f\"[BINARY ANIMATION] Detected binary system: {system['system_name']}\", flush=True)\n\n                                from exoplanet_orbits import calculate_binary_star_orbits, calculate_binary_star_position\n                                \n                                host_star_system = system['host_star']\n                                star_A = host_star_system['star_A']\n                                star_B = host_star_system['star_B']\n                                \n                                # Calculate binary orbital parameters\n                                binary_params = calculate_binary_star_orbits(\n                                    star_A['mass_solar'],\n                                    star_B['mass_solar'],\n                                    host_star_system['binary_separation_au'],\n                                    host_star_system['binary_period_days'],\n                                    host_star_system.get('binary_eccentricity', 0.0)\n                                )\n                                \n                                epoch = host_star_system['epoch']\n                                binary_i = host_star_system.get('binary_inclination_deg', 0.0)\n                                binary_Omega = host_star_system.get('binary_Omega_deg', 0.0)\n                                \n                                # Calculate Star A positions\n                                star_A_positions = []\n                                for date in dates_list:\n                                    x_A, y_A, z_A = calculate_binary_star_position(\n                                        binary_params['star_A'], date, epoch, binary_i, binary_Omega\n                                    )\n                                    star_A_positions.append({'x': x_A, 'y': y_A, 'z': z_A, 'date': date})\n                                \n                                binary_star_positions_over_time[star_A['name']] = star_A_positions\n                                print(f\"[BINARY ANIMATION] Generated {len(star_A_positions)} positions for {star_A['name']}\", flush=True)\n                                \n                                # Calculate Star B positions\n                                star_B_positions = []\n                                for date in dates_list:\n                                    x_B, y_B, z_B = calculate_binary_star_position(\n                                        binary_params['star_B'], date, epoch, binary_i, binary_Omega\n                                    )\n                                    star_B_positions.append({'x': x_B, 'y': y_B, 'z': z_B, 'date': date})\n                                \n                                binary_star_positions_over_time[star_B['name']] = star_B_positions\n                                print(f\"[BINARY ANIMATION] Generated {len(star_B_positions)} positions for {star_B['name']}\", flush=True)\n                                \n                                # Mark this system as processed\n                                processed_systems.add(system_id)\n\n\n            # Create dates_lists for each object\n            dates_lists = {}\n\n            for obj in objects:\n                obj_type = obj.get('object_type', 'orbital')\n\n                # Skip exoplanet objects - they're handled separately\n                if obj_type == 'exoplanet':\n                    continue\n\n                if obj['var'].get() == 1 and obj['name'] != center_object_name:\n                    \n                    # For animations, we need to handle each type appropriately\n                    if obj_type == 'trajectory':\n                        # Time-bounded paths\n                        start_date = obj.get('start_date', dates_list[0])\n                        end_date = obj.get('end_date', dates_list[-1])\n                        filtered_dates = [d for d in dates_list if start_date <= d <= end_date]\n                        dates_lists[obj['name']] = filtered_dates if filtered_dates else [start_date]\n                        \n                    elif obj_type == 'satellite' and obj['name'] in parent_planets.get(center_object_name, []):\n                        # Satellites of the center object use animation dates\n                        dates_lists[obj['name']] = dates_list\n                        \n            #        elif obj_type == 'orbital' and obj['name'] in planetary_params:\n                    elif obj_type == 'orbital' and obj['name'] in active_planetary_params:      # uses osculating elements\n\n                        # Planets, dwarf planets, TNOs use animation dates\n                        dates_lists[obj['name']] = dates_list\n                        \n                    elif obj_type == 'lagrange_point':\n                        # Lagrange points use animation dates\n                        dates_lists[obj['name']] = dates_list\n                        \n                    elif obj_type == 'fixed':\n                        if obj['name'] == 'Sun':\n\n                            if is_exoplanet_mode:\n                                print(f\"Skipping Sun in exoplanet animation mode\", flush=True)\n                                continue\n\n                            if center_object_name != 'Sun':\n                                # Sun needs trajectory when viewed from another center\n                                # Use the animation dates_list that was already created\n                                dates_lists[obj['name']] = dates_list  # dates_list should be defined by now\n                                print(f\"Sun will be animated relative to {center_object_name}\", flush=True)\n                            else:\n                                # Sun at center doesn't need animation\n                                # But still needs a dates list for frame generation\n                                dates_lists[obj['name']] = [dates_list[0]] if dates_list else [current_date]\n                        else:\n                            # Other fixed objects\n                            # Use single date repeated for each frame, or full dates_list\n                            dates_lists[obj['name']] = dates_list if dates_list else [current_date]\n                            print(f\"Fixed object {obj['name']} using animation dates\", flush=True)\n\n                    else:\n                        # Default: use animation dates\n                        print(f\"WARNING: Unknown object type '{obj_type}' for {obj['name']}\", flush=True)\n                        dates_lists[obj['name']] = dates_list\n\n            # Debug: Print what we're animating\n            for name, dates in dates_lists.items():\n                print(f\"  {name}: {len(dates)} dates\", flush=True)\n\n            # Fetch trajectory data for all selected objects\n            positions_over_time = {}\n            for obj in objects:\n                if obj['var'].get() == 1 and obj['name'] != center_object_name:\n                    # Use the dates from dates_lists\n                    obj_dates = dates_lists.get(obj['name'], dates_list)\n                    \n                    \n                    # Handle objects with date ranges\n                    if 'start_date' in obj or 'end_date' in obj:\n                        # Get start/end dates with fallbacks\n                        obj_start = obj.get('start_date', dates_list[0])\n                        obj_end = obj.get('end_date', dates_list[-1])\n\n                        # Use helio_id for Sun-centered plots if available\n                        fetch_id = obj['id']\n                        fetch_id_type = obj.get('id_type')\n                        if center_object_name == 'Sun' and 'helio_id' in obj:\n                            fetch_id = obj['helio_id']\n                            fetch_id_type = 'smallbody'\n                        \n                        positions_over_time[obj['name']] = pad_trajectory(\n                            dates_list, \n                            obj_start,\n                            obj_end,\n                            fetch_id, \n                            center_id, \n                            fetch_id_type\n                        )\n                    \n                    else:\n                        # Fetch positions for the animation dates\n                        # Use helio_id for Sun-centered plots if available (longer ephemeris coverage)\n                        # System barycenter IDs (e.g., 20136108) only have data to ~2030\n                        # Heliocentric IDs (e.g., 2003 EL61) have data to ~2500\n                        fetch_id = obj['id']\n                        fetch_id_type = obj.get('id_type')\n                        if center_object_name == 'Sun' and 'helio_id' in obj:\n                            fetch_id = obj['helio_id']\n                            fetch_id_type = 'smallbody'  # helio_ids are smallbody designations\n                        \n                        positions_over_time[obj['name']] = fetch_trajectory(\n                            fetch_id, \n                            obj_dates, \n                            center_id=center_id, \n                            id_type=fetch_id_type\n                        )\n                        \n                        # ORCUS TRAJECTORY DERIVATION: JPL doesn't support 920090482 as query target\n                        if obj['name'] == 'Orcus' and center_object_name == 'Orcus-Vanth Barycenter':\n                            traj = positions_over_time.get('Orcus')\n                            traj_all_zeros = traj and all(\n                                (pos is None or (pos.get('x', 0) == 0 and pos.get('y', 0) == 0 and pos.get('z', 0) == 0))\n                                for pos in traj\n                            )\n                            if not traj or traj_all_zeros:\n                                print(f\"  - Deriving Orcus trajectory from Vanth (mass ratio method)...\", flush=True)\n                                vanth_trajectory = fetch_trajectory('120090482', obj_dates, center_id=center_id, id_type=None)\n                                if vanth_trajectory:\n                                    mass_ratio = 0.16\n                                    derived_traj = []\n                                    for vanth_pos in vanth_trajectory:\n                                        if vanth_pos and vanth_pos.get('x') != 0:\n                                            derived_traj.append({\n                                                'x': -vanth_pos['x'] * mass_ratio,\n                                                'y': -vanth_pos['y'] * mass_ratio,\n                                                'z': -vanth_pos['z'] * mass_ratio\n                                            })\n                                        else:\n                                            derived_traj.append({'x': 0, 'y': 0, 'z': 0})\n                                    positions_over_time['Orcus'] = derived_traj\n                                    print(f\"  -> Derived {len(derived_traj)} Orcus positions from Vanth\", flush=True)\n\n\n                        # Fallback for objects without JPL ephemeris\n                        # ===================================================================\n                        # Handles two cases:\n                        #   1. TNO moons (circular orbits): Uses J2000 epoch, MA=0\n                        #   2. Objects with MA in elements: Uses object's epoch and MA,\n                        #      solves Kepler's equation for eccentric orbits\n                        # ===================================================================\n\n                #        ANALYTICAL_ANIMATION_FALLBACK = ['MK2', 'Xiangliu', 'Vanth', 'Weywot', '6AC4721']  # Objects without usable JPL ephemeris\n                        ANALYTICAL_ANIMATION_FALLBACK = ['MK2', 'Xiangliu', 'Vanth', 'Gonggong', '6AC4721']  # Weywot removed - JPL data works at Quaoar\n\n                        if obj['name'] in ANALYTICAL_ANIMATION_FALLBACK:\n                            # Check if fetch_trajectory returned empty/None\n                            traj = positions_over_time.get(obj['name'])\n                            if not traj or all(p is None for p in traj):\n                                print(f\"  - No JPL data for {obj['name']}, calculating analytical positions...\", flush=True)\n                                \n                                from orbital_elements import planetary_params\n                                if obj['name'] in planetary_params:\n                                    elements = planetary_params[obj['name']]\n                                    a = elements.get('a', 0)\n                                    e = elements.get('e', 0)\n                                    i = elements.get('i', 0)\n                                    omega = elements.get('omega', 0)\n                                    Omega = elements.get('Omega', 0)\n                                    \n                                    # Get orbital period - calculate from a if not provided\n                                    if 'orbital_period_days' in elements:\n                                        orbital_period = elements['orbital_period_days']\n                                    elif a > 0:\n                                        # Kepler's 3rd law: P^2 = a^3 (P in years, a in AU)\n                                        orbital_period = np.sqrt(a**3) * 365.25\n                                    else:\n                                        orbital_period = 18.023  # Default fallback\n                                    \n                                    # Pre-calculate rotation angles (convert to radians)\n                                    i_rad = np.radians(i)\n                                    omega_rad = np.radians(omega)\n                                    Omega_rad = np.radians(Omega)\n                                    \n                                    # Reference epoch and mean anomaly at epoch\n                                    # Use object's values if available, else J2000 with MA=0\n                                    if 'MA' in elements and 'epoch' in elements:\n                                        MA_epoch = elements['MA']\n                                        epoch_str = str(elements['epoch']).replace(' osc.', '').strip()\n                                        try:\n                                            ref_epoch = datetime.strptime(epoch_str, '%Y-%m-%d')\n                                        except ValueError:\n                                            ref_epoch = datetime(2000, 1, 1, 12, 0, 0)\n                                    else:\n                                        MA_epoch = 0.0\n                                        ref_epoch = datetime(2000, 1, 1, 12, 0, 0)\n                                    \n                                    # Mean motion (degrees per day)\n                                    n = 360.0 / orbital_period\n                                    \n                                    # GM of Sun in AU^3/day^2 for velocity calculation\n                                    GM_sun = 2.959122e-4\n                                    \n                                    # Calculate position for each animation date\n                                    analytical_positions = []\n                                    for anim_date in obj_dates:\n                                        # Days since reference epoch\n                                        delta_days = (anim_date - ref_epoch).total_seconds() / 86400.0\n                                        \n                                        # Current mean anomaly\n                                        M_deg = (MA_epoch + n * delta_days) % 360.0\n                                        M_rad = np.radians(M_deg)\n                                        \n                                        # Solve Kepler's equation if e > 0.01\n                                        if e > 0.01:\n                                            # Newton-Raphson iteration\n                                            E = M_rad if e < 0.8 else np.pi\n                                            for _ in range(50):\n                                                f = E - e * np.sin(E) - M_rad\n                                                f_prime = 1 - e * np.cos(E)\n                                                if abs(f_prime) < 1e-12:\n                                                    break\n                                                delta = f / f_prime\n                                                E = E - delta\n                                                if abs(delta) < 1e-10:\n                                                    break\n                                            \n                                            # Convert eccentric anomaly to true anomaly\n                                            true_anomaly = 2 * np.arctan2(\n                                                np.sqrt(1 + e) * np.sin(E / 2),\n                                                np.sqrt(1 - e) * np.cos(E / 2)\n                                            )\n                                        else:\n                                            # For near-circular orbits, mean anomaly ~ true anomaly\n                                            true_anomaly = M_rad\n                                        \n                                        # Position in orbital plane\n                                        r = a * (1 - e**2) / (1 + e * np.cos(true_anomaly)) if e > 0 else a\n                                        x_orb = r * np.cos(true_anomaly)\n                                        y_orb = r * np.sin(true_anomaly)\n                                        z_orb = 0.0\n                                        \n                                        # Apply 3D rotations\n                                        # Rotation 1: omega around z\n                                        x1 = x_orb * np.cos(omega_rad) - y_orb * np.sin(omega_rad)\n                                        y1 = x_orb * np.sin(omega_rad) + y_orb * np.cos(omega_rad)\n                                        z1 = z_orb\n                                        \n                                        # Rotation 2: i around x\n                                        x2 = x1\n                                        y2 = y1 * np.cos(i_rad) - z1 * np.sin(i_rad)\n                                        z2 = y1 * np.sin(i_rad) + z1 * np.cos(i_rad)\n                                        \n                                        # Rotation 3: Omega around z\n                                        x_final = x2 * np.cos(Omega_rad) - y2 * np.sin(Omega_rad)\n                                        y_final = x2 * np.sin(Omega_rad) + y2 * np.cos(Omega_rad)\n                                        z_final = z2\n                                        \n                                        # Calculate velocity (vis-viva for elliptical, circular approx for e~0)\n                                        if e > 0.01 and a > 0:\n                                            v_au_day = np.sqrt(GM_sun * (2/r - 1/a))\n                                        else:\n                                            v_au_day = 2 * np.pi * a / orbital_period\n                                        \n                                        analytical_positions.append({\n                                            'x': x_final,\n                                            'y': y_final,\n                                            'z': z_final,\n                                            'velocity': v_au_day,  # AU/day - expected by hover text\n                                            'range': r,\n                                            'date': anim_date\n                                        })\n\n                                    positions_over_time[obj['name']] = analytical_positions\n                                    print(f\"  -> Generated {len(analytical_positions)} analytical positions for {obj['name']} (e={e:.5f})\", flush=True)\n\n            # Extract initial positions for idealized orbits\n            initial_positions = {}\n            for obj_name, trajectory in positions_over_time.items():\n                if trajectory and len(trajectory) > 0 and trajectory[0] is not None:\n                    initial_pos = trajectory[0]\n                    if 'x' in initial_pos and 'y' in initial_pos and 'z' in initial_pos:\n                        initial_positions[obj_name] = {\n                            'x': initial_pos['x'],\n                            'y': initial_pos['y'],\n                            'z': initial_pos['z']\n                        }\n            \n            # Add center object position\n            initial_positions[center_object_name] = {'x': 0, 'y': 0, 'z': 0}\n            \n\n            # Add position data for center planet if it has shells\n            if center_object_name in planets_with_shells:\n                # Create a list of positions at (0,0,0) for all frames\n                center_positions = []\n                for i in range(N):\n                    center_positions.append({\n                        'x': 0, 'y': 0, 'z': 0,\n                        'date': dates_list[i]\n                    })\n                positions_over_time[center_object_name] = center_positions\n            \n\n            # Initialize figure\n            fig = go.Figure()\n\n            # =================================================================\n            # STATIC CENTER SHELLS - Added once, not duplicated in frames\n            # This enables shell visualizations in animations without memory explosion\n            # =================================================================\n            # Define planet shell configuration (same as plot_objects)\n            animation_shell_config = {\n                'Mercury': mercury_shell_vars,\n                'Venus': venus_shell_vars,\n                'Earth': earth_shell_vars,\n                'Moon': moon_shell_vars,\n                'Mars': mars_shell_vars,\n                'Jupiter': jupiter_shell_vars,\n                'Saturn': saturn_shell_vars,\n                'Uranus': uranus_shell_vars,\n                'Neptune': neptune_shell_vars,\n                'Pluto': pluto_shell_vars,\n                'Eris': eris_shell_vars,\n                'Planet 9': planet9_shell_vars\n            }\n\n            # Flag to track if shells have been added for center object\n            center_shells_added = False\n\n            # Add Sun visualization if needed\n            if center_object_name == 'Sun' and any(var.get() == 1 for var in sun_shell_vars.values()):\n                fig = create_sun_visualization(fig, sun_shell_vars)\n                center_shells_added = True\n                print(f\"[ANIMATION] Added Sun shells ({len(fig.data)} static traces)\", flush=True)\n                \n            # Add planet visualization if the center is a planet with shells\n            elif center_object_name in animation_shell_config:\n                shell_vars = animation_shell_config[center_object_name]\n                if any(var.get() == 1 for var in shell_vars.values()):\n                    fig = create_planet_visualization(fig, center_object_name, shell_vars)\n                    center_shells_added = True\n                    print(f\"[ANIMATION] Added {center_object_name} shells ({len(fig.data)} static traces)\", flush=True)\n\n            # Track where static traces end - frames will only update traces after this point\n            static_trace_count = len(fig.data)\n\n            # Add center marker only if shells haven't been added\n            if not center_shells_added:\n                if center_object_name == 'Sun':\n                    # Just add the central Sun marker if shells not selected\n                    fig.add_trace(\n                        go.Scatter3d(\n                            x=[0], y=[0], z=[0],\n                            mode='markers',\n                            marker=dict(\n                                color='rgb(102, 187, 106)',\n                                size=12,\n                                symbol='circle'\n                            ),\n                            name=\"Sun\",\n                            text=[\"Sun - Center of Solar System\"],\n                            hovertemplate='%{text}<extra></extra>',\n                            showlegend=True\n                        )\n                    )\n                else:\n                    # Add center marker for non-Sun objects\n                    center_object_info = next((obj for obj in objects if obj['name'] == center_object_name), None)\n                    if center_object_info:\n                        # Check if color is transparent to hide legend\n                        is_transparent = 'rgba(0,0,0,0)' in str(center_object_info['color']).replace(' ', '')\n                        \n                        fig.add_trace(\n                            go.Scatter3d(\n                                x=[0], y=[0], z=[0],\n                                mode='markers',\n                                marker=dict(\n                                    color=center_object_info['color'],\n                                    size=12,\n                                    symbol=center_object_info['symbol']\n                                ),\n                                name=center_object_name,\n                                # FIXED: Barycenter text only for multi-body systems, not single bodies like Bennu\n                                text=[f\"{center_object_name} system <br>center of gravity<br>(barycenter)\"] if 'Barycenter' in center_object_name else [center_object_name],\n                                hovertemplate='%{text}<extra></extra>',\n                                showlegend=not is_transparent  # Hide legend if transparent\n                            )\n                        )\n\n            # Also update the orbit path creation for animations to match plot_objects:\n            # For animations, calculate the actual span from animation dates, not days_to_plot\n        #    animation_span_days = (dates_list[-1] - dates_list[0]).days if len(dates_list) > 1 else settings['days_to_plot']\n            # Use total_seconds() to preserve fractional days (e.g., 27 hours = 1.125 days, not 1 day)\n            animation_span_days = (dates_list[-1] - dates_list[0]).total_seconds() / 86400 if len(dates_list) > 1 else settings['days_to_plot']\n            \n            orbit_dates_lists = {}\n            # NEW: Separate dict for trajectory context layers (full mission)\n            trajectory_context_dates = {}\n            \n            for obj in objects:\n                if obj['var'].get() == 1 and obj['name'] != center_object_name:\n                    obj_type = obj.get('object_type', 'orbital')\n                    \n        #            if obj_type == 'orbital' and obj['name'] in planetary_params:\n                    if obj_type == 'orbital' and obj['name'] in active_planetary_params:    \n                        # Use the full animation span for orbit display (not days_to_plot)\n                        requested_days = animation_span_days\n\n                        num_points = int(settings['orbital_points']) + 1\n                        orbit_dates = [current_date + timedelta(days=float(d)) \n                                    for d in np.linspace(0, requested_days, num=num_points)]\n                        orbit_dates_lists[obj['name']] = orbit_dates\n\n                    elif obj_type == 'satellite' and obj['name'] in parent_planets.get(center_object_name, []):\n                        # For satellites, use full animation span\n                        requested_days = animation_span_days\n\n                        num_points = int(settings['satellite_points']) + 1\n                        orbit_dates = [current_date + timedelta(days=float(d)) \n                                    for d in np.linspace(0, requested_days, num=num_points)]\n                        orbit_dates_lists[obj['name']] = orbit_dates\n                    elif obj_type == 'trajectory':\n                        # TWO-LAYER TRAJECTORY SYSTEM:\n                        # Context layer: Full mission (faded background)\n                        # Detail layer: Plotted Period only (solid, for fine resolution)\n                        \n                        mission_start = obj.get('start_date', current_date)\n                        mission_end = obj.get('end_date', current_date + timedelta(days=settings['days_to_plot']))\n                        mission_days = (mission_end - mission_start).total_seconds() / 86400\n                        \n                        num_points = int(settings['trajectory_points']) + 1\n                        \n                        # CONTEXT: Full mission trajectory (for background/context)\n                        if mission_days > 0:\n                            context_dates = [mission_start + timedelta(days=float(d)) \n                                           for d in np.linspace(0, mission_days, num=num_points)]\n                            trajectory_context_dates[obj['name']] = context_dates\n                            print(f\"[TRAJECTORY] {obj['name']} context: {num_points} points over {mission_days:.1f} days (full mission)\", flush=True)\n                        \n                        # DETAIL: Plotted Period only (for fine resolution)\n                        # Clip to mission bounds\n                        detail_start = max(current_date, mission_start)\n                        animation_end = current_date + timedelta(days=animation_span_days)\n                        detail_end = min(animation_end, mission_end)\n                        detail_days = (detail_end - detail_start).total_seconds() / 86400\n                        \n                        if detail_days > 0:\n                            detail_dates = [detail_start + timedelta(days=float(d)) \n                                          for d in np.linspace(0, detail_days, num=num_points)]\n                            orbit_dates_lists[obj['name']] = detail_dates\n                            print(f\"[TRAJECTORY] {obj['name']} detail: {num_points} points over {detail_days:.1f} days (plotted period)\", flush=True)\n                        else:\n                            # Plotted Period doesn't overlap with mission - use mission dates\n                            orbit_dates_lists[obj['name']] = trajectory_context_dates.get(obj['name'], [current_date])\n                    else:\n                        # Use appropriate dates for other object types\n                        orbit_dates_lists[obj['name']] = dates_lists.get(obj['name'], dates_list)\n\n            # PLOT TRAJECTORY CONTEXT LAYERS (Full Mission - faded background)\n            # This provides mission context while detail layer shows plotted period\n            if trajectory_context_dates:\n                print(f\"\\n[TRAJECTORY CONTEXT] Plotting {len(trajectory_context_dates)} full mission trajectories...\", flush=True)\n                for obj_name, context_dates in trajectory_context_dates.items():\n                    obj_info = next((obj for obj in objects if obj['name'] == obj_name), None)\n                    if not obj_info or not context_dates:\n                        continue\n                    \n                    # Get fetch ID (use helio_id for Sun-centered if available)\n                    fetch_id = obj_info['id']\n                    fetch_id_type = obj_info.get('id_type')\n                    if center_object_name == 'Sun' and 'helio_id' in obj_info:\n                        fetch_id = obj_info['helio_id']\n                        fetch_id_type = 'smallbody'\n                    \n                    # Fetch trajectory for context layer\n                    context_trajectory = fetch_trajectory(fetch_id, context_dates, center_id=center_id, id_type=fetch_id_type)\n                    \n                    if context_trajectory:\n                        x = [pos['x'] for pos in context_trajectory if pos is not None]\n                        y = [pos['y'] for pos in context_trajectory if pos is not None]\n                        z = [pos['z'] for pos in context_trajectory if pos is not None]\n                        \n                        if x:  # Only plot if we have data\n                            # Get base color and create faded version\n                            base_color = color_map(obj_name)\n                            \n                            fig.add_trace(\n                                go.Scatter3d(\n                                    x=x,\n                                    y=y,\n                                    z=z,\n                                    mode='lines',\n                                    line=dict(\n                                        color=base_color,\n                                        width=2,  # Thinner than detail\n                                #        dash='dot'  # Dotted line for context\n                                    ),\n                                #    opacity=0.5,  # Faded\n                                    opacity=1.0,  \n                                    name=f\"{obj_name} Full Mission\",\n                                    text=[f\"{obj_name} Full Mission Trajectory\"] * len(x),\n                                    hovertemplate='%{text}<extra></extra>',\n                                    showlegend=True\n                                )\n                            )\n\n                            print(f\"[TRAJECTORY CONTEXT] Plotted {obj_name} full mission: {len(x)} points\", flush=True)\n                            \n                            # Add closest approach marker for Full Mission (base color)\n                            if show_closest_approach_var.get():\n                                from apsidal_markers import add_closest_approach_marker\n                                \n                                # Build positions_dict from context trajectory data\n                                positions_dict = {}\n                                for i in range(len(x)):\n                                    if i < len(context_dates):\n                                        positions_dict[context_dates[i].isoformat()] = {\n                                            'x': x[i],\n                                            'y': y[i],\n                                            'z': z[i]\n                                        }\n                                \n                                add_closest_approach_marker(\n                                    fig=fig,\n                                    positions_dict=positions_dict,\n                                    obj_name=obj_name,\n                                    center_body=center_object_name,\n                                    color_map=color_map,\n                                    date_range=(context_dates[0], context_dates[-1]) if context_dates else None,\n                                    marker_color=base_color  # Use base color for Full Mission\n                                )\n\n            # Plot actual orbits using the orbit_dates_lists (DETAIL layer for trajectories)\n\n            selected_planets = [obj['name'] for obj in objects if obj['var'].get() == 1 and obj['name'] != center_object_name]\n            # FIXED: Added center_object_name - was defaulting to 'Sun' causing wrong hover text\n    #        plot_actual_orbits(fig, selected_planets, orbit_dates_lists, center_id=center_id, show_lines=True, center_object_name=center_object_name, show_closest_approach=show_closest_approach_var.get())\n    #        plot_actual_orbits(fig, selected_planets, orbit_dates_lists, center_id=center_id, show_lines=True, center_object_name=center_object_name, show_closest_approach=show_closest_approach_var.get(), trajectory_style='plotted_period')\n            # Pass yellow marker color for trajectory Plotted Period traces\n            plot_actual_orbits(fig, selected_planets, orbit_dates_lists, center_id=center_id, show_lines=True, center_object_name=center_object_name, show_closest_approach=show_closest_approach_var.get(), trajectory_marker_color='yellow')\n    \n            for i, trace in enumerate(fig.data):\n                trace_type = type(trace).__name__\n                trace_mode = getattr(trace, 'mode', 'N/A')  # Mesh3d has no mode\n                print(f\"  Trace {i}: {trace.name} ({trace_type}, mode: {trace_mode})\", flush=True)\n\n            # ADD THIS SECTION - Plot idealized orbits\n            selected_object_names = [obj['name'] for obj in selected_objects]  # Convert to names list\n            plot_idealized_orbits(\n                fig, \n                selected_object_names,  # Use the names list\n                center_id=center_object_name,\n                objects=objects,\n                planetary_params=active_planetary_params,\n                parent_planets=parent_planets,\n                color_map=color_map,\n                date=dates_list[0] if dates_list else datetime.now(),\n                days_to_plot=settings['days_to_plot'],\n                current_positions=initial_positions,\n                fetch_position=fetch_position,\n                show_apsidal_markers=show_apsidal_markers_var.get(),\n                parent_window=root  \n            )\n\n            for i, trace in enumerate(fig.data):\n                print(f\"  Trace {i}: {trace.name}\", flush=True)      \n\n            # Initialize trace_indices BEFORE trying to use it\n            trace_indices = {}\n            \n            # Find and track the Pluto-Charon Barycenter trace if it exists\n            # This trace is added by idealized_orbits.py for Pluto-centered views\n            for idx, trace in enumerate(fig.data):\n                if trace.name == 'Pluto-Charon Barycenter':\n                    trace_indices['Pluto-Charon Barycenter'] = idx\n                    break\n\n            # Find and track the Earth-Moon Barycenter trace if it exists\n            for idx, trace in enumerate(fig.data):\n                if trace.name == 'Earth-Moon Barycenter':\n                    trace_indices['Earth-Moon Barycenter'] = idx\n                    break\n\n            # Add exoplanet traces if in exoplanet mode\n            if is_exoplanet_mode:\n                from exoplanet_orbits import plot_exoplanet_orbits, plot_binary_host_stars, calculate_exoplanet_axis_range\n                from exoplanet_systems import get_system\n                \n                # Get unique systems\n                exo_systems = set()\n                for obj in exo_objects + exo_host_stars:\n                    system_id = obj.get('system_id')\n                    if system_id:\n                        exo_systems.add(system_id)\n                \n                # Plot each system (orbits and host stars)\n                for system_id in exo_systems:\n                    system = get_system(system_id)\n                    if not system:\n                        continue\n                    \n                    # Get objects for this system\n                    system_planets = []\n                    for obj in exo_objects:\n                        if obj.get('system_id') == system_id:\n                            planet_id = obj.get('id')\n                            if planet_id:\n                                for catalog_planet in system['planets']:\n                                    if catalog_planet.get('planet_id') == planet_id:\n                                        full_planet = catalog_planet.copy()\n                                        full_planet['var'] = obj['var']\n                                        full_planet['name'] = obj['name']\n                                        full_planet['color'] = obj.get('color', 'lightblue')\n                                        system_planets.append(full_planet)\n                                        break\n                    \n                    system_stars = [obj for obj in exo_host_stars \n                                if obj.get('system_id') == system_id]\n                    \n                    # Plot host star(s)\n                    barycenter_obj = next((obj for obj in exo_host_stars \n                                        if obj.get('id_type') == 'barycenter' \n                                        and obj.get('system_id') == system_id \n                                        and obj['var'].get() == 1), None)\n                    \n                    if system_stars or barycenter_obj or not system['host_star'].get('is_binary'):\n                        fig = plot_binary_host_stars(fig, system['host_star'], dates_list[0], \n                                                    show_orbits=True, show_markers=False, system_data=system)\n                    \n                    # Plot planet orbits (static orbits for the animation)\n                    if system_planets:\n                        fig = plot_exoplanet_orbits(\n                            fig, system_planets, system, dates_list[0],\n                            show_orbits=True, show_markers=False  # Markers will be animated\n                        )\n                \n                # Add initial position markers for exoplanets\n                for obj in exo_objects:\n                    obj_name = obj['name']\n                    if obj_name in exoplanet_positions_over_time:\n                        positions = exoplanet_positions_over_time[obj_name]\n                        if positions and len(positions) > 0:\n                            first_pos = positions[0]\n                            \n                            # Get planet data for hover text\n                            system_id = obj.get('system_id')\n                            system = get_system(system_id)\n                            planet_data = None\n                            if system:\n                                planet_id = obj.get('id')\n                                for catalog_planet in system['planets']:\n                                    if catalog_planet.get('planet_id') == planet_id:\n                                        planet_data = catalog_planet\n                                        break\n                            \n                            hover_text = f\"<b>{obj_name}</b><br>\"\n                            if planet_data:\n                                from formatting_utils import format_maybe_float\n                                hover_text += f\"Period: {planet_data['period_days']:.2f} days<br>\"\n                                hover_text += f\"Semi-major axis: {planet_data['semi_major_axis_au']:.4f} AU<br>\"\n                                hover_text += f\"Mass: {format_maybe_float(planet_data.get('mass_earth'))} Mearth<br>\"\n                                if planet_data.get('in_habitable_zone'):\n                                    hover_text += \"<br><b>* IN HABITABLE ZONE *</b>\"\n                            \n                            trace = go.Scatter3d(\n                                x=[first_pos['x']],\n                                y=[first_pos['y']],\n                                z=[first_pos['z']],\n                                mode='markers',\n                                marker=dict(\n                                    symbol='circle',\n                                    color=obj.get('color', 'lightblue'),\n                                    size=8 if planet_data and planet_data.get('in_habitable_zone') else 6\n                                ),\n                                name=obj_name,\n                                text=[hover_text],\n                                hoverinfo='text',\n                                showlegend=True\n                            )\n                            fig.add_trace(trace)\n                            trace_indices[obj_name] = len(fig.data) - 1\n                \n                print(f\"[EXOPLANET ANIMATION] Added {len([k for k in trace_indices if k in exoplanet_positions_over_time])} exoplanet traces\", flush=True)\n\n                # Add initial traces for binary stars\n                if binary_star_positions_over_time:\n                    # Get the system data to access star properties\n                    for star_name, positions in binary_star_positions_over_time.items():\n                        if positions and len(positions) > 0:\n                            first_pos = positions[0]\n                            \n                            # Find which system this star belongs to and get its properties\n                            star_data = None\n                            for obj in exo_objects + exo_host_stars:\n                                if obj['var'].get() == 1:\n                                    sys_id = obj.get('system_id')\n                                    if sys_id:\n                                        sys = get_system(sys_id)\n                                        if sys and sys['host_star'].get('is_binary'):\n                                            # Check if this is Star A or Star B\n                                            if star_name == sys['host_star']['star_A']['name']:\n                                                star_data = sys['host_star']['star_A']\n                                                break\n                                            elif star_name == sys['host_star']['star_B']['name']:\n                                                star_data = sys['host_star']['star_B']\n                                                break\n                            \n                            if star_data:\n                                # Calculate temperature-based color and size\n                                from exoplanet_stellar_properties import get_temperature_color, calculate_marker_size\n                                \n                                teff = star_data.get('teff_k', 5778)\n                                star_color = get_temperature_color(teff)\n                                luminosity = star_data.get('luminosity_solar', 1.0)\n                                marker_size = calculate_marker_size(luminosity, base_size=10)\n                                \n                                hover_text = f\"<b>{star_name}</b><br>\"\n                                hover_text += f\"Spectral Type: {star_data.get('spectral_type', 'Unknown')}<br>\"\n                                hover_text += f\"Temperature: {teff} K<br>\"\n                                hover_text += f\"Mass: {star_data.get('mass_solar', 1.0):.2f} Mearth<br>\"\n                                hover_text += f\"Luminosity: {luminosity:.3f} Lsun\"\n                                \n                                trace = go.Scatter3d(\n                                    x=[first_pos['x']],\n                                    y=[first_pos['y']],\n                                    z=[first_pos['z']],\n                                    mode='markers',\n                                    marker=dict(\n                                        symbol='circle',\n                                        color=star_color,\n                                        size=marker_size\n                                    ),\n                                    name=star_name,\n                                    text=[hover_text],\n                                    hoverinfo='text',\n                                    showlegend=True\n                                )\n                                fig.add_trace(trace)\n                                trace_indices[star_name] = len(fig.data) - 1\n                    \n                    print(f\"[BINARY ANIMATION] Added {len(binary_star_positions_over_time)} binary star traces\", flush=True)\n\n            # Create initial traces for moving objects and store their indices\n            for obj in objects:\n\n                # Skip exoplanet objects - already handled above\n                if obj.get('object_type') == 'exoplanet':\n                    continue\n\n                if obj['var'].get() == 1 and obj['name'] != center_object_name:\n                    obj_name = obj['name']\n                    obj_positions = positions_over_time.get(obj_name)\n                    \n                    if obj_positions and len(obj_positions) > 0 and obj_positions[0] is not None and 'x' in obj_positions[0]:\n                        obj_data = obj_positions[0]\n                        \n                        # Use format_detailed_hover_text\n                        full_hover_text, minimal_hover_text, satellite_note = format_detailed_hover_text(\n                            obj_data, \n                            obj_name, \n                            center_object_name,\n                            objects,\n                    #        planetary_params,\n                            active_planetary_params,\n                            parent_planets,\n                            CENTER_BODY_RADII,\n                            KM_PER_AU,\n                            LIGHT_MINUTES_PER_AU,\n                            KNOWN_ORBITAL_PERIODS\n                        )\n                        \n                        # Add satellite note if present\n                        if satellite_note:\n                            full_hover_text += satellite_note\n\n                        trace = go.Scatter3d(\n                            x=[obj_data['x']],\n                            y=[obj_data['y']],\n                            z=[obj_data['z']],\n                            mode='markers',\n                            marker=dict(symbol=obj['symbol'], color=obj['color'], size=6),\n                            name=obj_name,\n                            text=[full_hover_text],\n                            customdata=[minimal_hover_text],\n                            hovertemplate='%{text}<extra></extra>',\n                            showlegend=True\n                        )\n                        fig.add_trace(trace)\n                        trace_indices[obj_name] = len(fig.data) - 1\n                    else:\n                        # If no initial position, still create a trace for the legend\n                        trace = go.Scatter3d(\n                            x=[None], y=[None], z=[None],\n                            mode='markers',\n                            marker=dict(symbol=obj['symbol'], color=obj['color'], size=6),\n                            name=obj_name,\n                            text=[obj_name],\n                            customdata=[obj_name],\n                            hovertemplate='%{text}<extra></extra>',\n                            showlegend=True\n                        )\n                        fig.add_trace(trace)\n                        trace_indices[obj_name] = len(fig.data) - 1\n\n            \n            # ============ ADD COMET TAILS INTEGRATION ============\n            # Conservative comet tail integration for first frame\n            # Note: For animations, we only add tails to the initial figure state\n            # as recalculating them every frame would be too expensive\n            if len(dates_list) > 0:\n                first_frame_date = dates_list[0]\n                print(f\"\\n[COMET TAILS] Adding comet tails for animation initial state (date: {first_frame_date})\", flush=True)\n                \n                for obj in objects:\n                    if obj['var'].get() == 1:\n                        # Check if this is a comet by its properties\n                        is_comet = (\n                            obj.get('object_type') == 'orbital' and \n                            obj.get('id_type') == 'smallbody' and\n                            obj.get('symbol') == 'diamond'\n                        )\n                        \n                        obj_name = obj['name']\n                        if is_comet and obj_name in positions_over_time:\n                            # Get position for first frame\n                            obj_positions = positions_over_time.get(obj_name)\n                            if obj_positions and len(obj_positions) > 0 and obj_positions[0] is not None:\n                                first_position = obj_positions[0]\n                                print(f\"Processing comet tails for {obj_name} in animation...\", flush=True)\n                                fig = add_comet_tails_to_figure(\n                                    fig,\n                                    obj_name,\n                                    first_position,\n                                    center_object_name\n                                )\n            # ============ END COMET TAILS INTEGRATION ============\n\n            # NOW create frames - after trace_indices has been defined\n            # =================================================================\n            # OPTIMIZATION: Only include dynamic traces in frames\n            # Static shell traces (indices 0 to static_trace_count-1) are not duplicated\n            # This dramatically reduces memory for animations with shell visualizations\n            # =================================================================\n            dynamic_trace_indices = list(range(static_trace_count, len(fig.data)))\n            print(f\"[ANIMATION] Static traces: 0-{static_trace_count-1} ({static_trace_count} traces)\", flush=True)\n            print(f\"[ANIMATION] Dynamic traces: {static_trace_count}-{len(fig.data)-1} ({len(dynamic_trace_indices)} traces)\", flush=True)\n            \n            # Helper function to convert absolute trace index to frame_data index\n            def to_frame_idx(absolute_idx):\n                \"\"\"Convert absolute fig.data index to frame_data index.\n                Returns None if this is a static trace (not in frame_data).\"\"\"\n                if absolute_idx >= static_trace_count:\n                    return absolute_idx - static_trace_count\n                return None  # Static trace, not in frame_data\n            \n            for i in range(N):\n                # Only copy dynamic traces (skip static shell traces at indices 0 to static_trace_count-1)\n                frame_data = [copy.deepcopy(fig.data[idx]) for idx in dynamic_trace_indices]\n                current_date = dates_list[i]\n                \n                # Update position traces for selected objects\n                # First, update exoplanet positions\n                for obj_name in exoplanet_positions_over_time:\n                    if obj_name in trace_indices:\n                        trace_idx = trace_indices[obj_name]\n                        frame_idx = to_frame_idx(trace_idx)\n                        if frame_idx is None:\n                            continue  # Skip static traces\n                        positions = exoplanet_positions_over_time[obj_name]\n                        \n                        if i < len(positions):\n                            pos = positions[i]\n                            frame_data[frame_idx].x = [pos['x']]\n                            frame_data[frame_idx].y = [pos['y']]\n                            frame_data[frame_idx].z = [pos['z']]\n                            frame_data[frame_idx].visible = True\n                        else:\n                            frame_data[frame_idx].visible = False\n                \n                # Update binary star positions\n                for star_name in binary_star_positions_over_time:\n                    if star_name in trace_indices:\n                        trace_idx = trace_indices[star_name]\n                        frame_idx = to_frame_idx(trace_idx)\n                        if frame_idx is None:\n                            continue  # Skip static traces\n                        positions = binary_star_positions_over_time[star_name]\n                        \n                        if i < len(positions):\n                            pos = positions[i]\n                            frame_data[frame_idx].x = [pos['x']]\n                            frame_data[frame_idx].y = [pos['y']]\n                            frame_data[frame_idx].z = [pos['z']]\n                            frame_data[frame_idx].visible = True\n                        else:\n                            frame_data[frame_idx].visible = False\n\n                # Update Pluto-Charon Barycenter position (derived from Charon)\n                # In Pluto-centered view, barycenter is at fixed distance along Pluto-Charon direction\n                if 'Pluto-Charon Barycenter' in trace_indices and center_object_name == 'Pluto':\n                    trace_idx = trace_indices['Pluto-Charon Barycenter']\n                    frame_idx = to_frame_idx(trace_idx)\n                    charon_positions = positions_over_time.get('Charon')\n                    \n                    if frame_idx is not None and charon_positions and i < len(charon_positions) and charon_positions[i] is not None:\n                        charon_pos = charon_positions[i]\n                        if 'x' in charon_pos:\n                            # Barycenter distance from Pluto center: ~2,050 km = 0.0000137 AU\n                            BARYCENTER_DIST_AU = 0.0000137\n                            \n                            # Calculate unit vector from Pluto toward Charon\n                            cx, cy, cz = charon_pos['x'], charon_pos['y'], charon_pos['z']\n                            charon_dist = (cx**2 + cy**2 + cz**2)**0.5\n                            \n                            if charon_dist > 0:\n                                # Barycenter is along the Pluto-Charon line\n                                bary_x = BARYCENTER_DIST_AU * (cx / charon_dist)\n                                bary_y = BARYCENTER_DIST_AU * (cy / charon_dist)\n                                bary_z = BARYCENTER_DIST_AU * (cz / charon_dist)\n                                \n                                frame_data[frame_idx].x = [bary_x]\n                                frame_data[frame_idx].y = [bary_y]\n                                frame_data[frame_idx].z = [bary_z]\n                                frame_data[frame_idx].visible = True\n\n                # Update Earth-Moon Barycenter position (derived from Moon)\n                if 'Earth-Moon Barycenter' in trace_indices and center_object_name == 'Earth':\n                    trace_idx = trace_indices['Earth-Moon Barycenter']\n                    frame_idx = to_frame_idx(trace_idx)\n                    moon_positions = positions_over_time.get('Moon')\n                    \n                    if frame_idx is not None and moon_positions and i < len(moon_positions) and moon_positions[i] is not None:\n                        moon_pos = moon_positions[i]\n                        if 'x' in moon_pos:\n                            EMB_DIST_AU = 0.0000312  # ~4,670 km\n                            mx, my, mz = moon_pos['x'], moon_pos['y'], moon_pos['z']\n                            moon_dist = (mx**2 + my**2 + mz**2)**0.5\n                            if moon_dist > 0:\n                                bary_x = EMB_DIST_AU * (mx / moon_dist)\n                                bary_y = EMB_DIST_AU * (my / moon_dist)\n                                bary_z = EMB_DIST_AU * (mz / moon_dist)\n                                frame_data[frame_idx].x = [bary_x]\n                                frame_data[frame_idx].y = [bary_y]\n                                frame_data[frame_idx].z = [bary_z]\n                                frame_data[frame_idx].visible = True\n\n                # Then update regular solar system objects\n                for obj in objects:\n                        if obj['var'].get() == 1 and obj['name'] != center_object_name:\n                            obj_name = obj['name']\n                                        \n                            # Skip exoplanets - already handled above\n                            if obj.get('object_type') == 'exoplanet':\n                                continue\n                                        \n                            if obj_name in positions_over_time and obj_name in trace_indices:\n                                trace_idx = trace_indices[obj_name]\n                                frame_idx = to_frame_idx(trace_idx)\n                                if frame_idx is None:\n                                    continue  # Skip static traces\n                                obj_positions = positions_over_time[obj_name]\n                                            \n                                if i < len(obj_positions) and obj_positions[i] is not None and 'x' in obj_positions[i]:\n                                    obj_data = obj_positions[i]\n\n                                    # Use format_detailed_hover_text\n                                    full_hover_text, minimal_hover_text, satellite_note = format_detailed_hover_text(\n                                        obj_data, \n                                        obj_name, \n                                        center_object_name,\n                                        objects,\n                                #        planetary_params,\n                                        active_planetary_params,\n                                        parent_planets,\n                                        CENTER_BODY_RADII,\n                                        KM_PER_AU,\n                                        LIGHT_MINUTES_PER_AU,\n                                        KNOWN_ORBITAL_PERIODS\n                                    )\n                                                \n                                    # Add satellite note if present\n                                    if satellite_note:\n                                        full_hover_text += satellite_note\n\n                                    # Update the trace with new position data\n                                    frame_data[frame_idx].x = [obj_data['x']]\n                                    frame_data[frame_idx].y = [obj_data['y']]\n                                    frame_data[frame_idx].z = [obj_data['z']]\n                                    frame_data[frame_idx].text = [full_hover_text]\n                                    frame_data[frame_idx].customdata = [minimal_hover_text]\n                                    frame_data[frame_idx].visible = True\n                                else:\n                                    # If position is missing for this frame, make the object invisible\n                                    frame_data[frame_idx].visible = False\n\n                # Create frame with selective trace update\n                # The traces parameter tells Plotly which fig.data indices this frame updates\n                frames.append(go.Frame(\n                    data=frame_data,\n                    traces=dynamic_trace_indices,  # Only update dynamic traces, not static shells\n                    name=str(dates_list[i].strftime('%Y-%m-%d %H:%M'))\n                ))\n\n\n            # Get axis range using orbital parameters (same as static plots)\n            if is_exoplanet_mode and exo_objects:\n                # Use exoplanet-specific axis range calculation\n                from exoplanet_orbits import calculate_exoplanet_axis_range\n                from exoplanet_systems import get_system\n                \n                # Get all selected exoplanet systems\n                all_exo_planets = []\n                for obj in exo_objects:\n                    system_id = obj.get('system_id')\n                    if system_id:\n                        system = get_system(system_id)\n                        if system:\n                            planet_id = obj.get('id')\n                            for catalog_planet in system['planets']:\n                                if catalog_planet.get('planet_id') == planet_id:\n                                    all_exo_planets.append(catalog_planet)\n                                    break\n                \n                if all_exo_planets:\n                    axis_range = calculate_exoplanet_axis_range(all_exo_planets)\n                    # Convert to list for Plotly\n                    axis_range = [-axis_range, axis_range]\n                    print(f\"[EXOPLANET ANIMATION] Using exoplanet axis range: +/-{axis_range[1]:.4f} AU\", flush=True)\n                else:\n                    axis_range = get_animation_axis_range(\n            #            scale_var, custom_scale_entry, objects, planetary_params, \n                        scale_var, custom_scale_entry, objects, active_planetary_params,\n                        parent_planets, center_object_name\n                    )\n            else:\n                axis_range = get_animation_axis_range(\n            #        scale_var, custom_scale_entry, objects, planetary_params, \n                    scale_var, custom_scale_entry, objects, active_planetary_params,\n                    parent_planets, center_object_name\n                )\n\n                        \n            # Update layout with dynamic scaling\n            fig.update_layout(\n                scene=dict(\n                    xaxis=dict(title='X (AU)', range=axis_range, \n                            backgroundcolor='black', gridcolor='gray', \n                            showbackground=True, showgrid=True),\n                    yaxis=dict(title='Y (AU)', range=axis_range, \n                            backgroundcolor='black', gridcolor='gray', \n                            showbackground=True, showgrid=True),\n                    zaxis=dict(title='Z (AU)', range=axis_range, \n                            backgroundcolor='black', gridcolor='gray', \n                            showbackground=True, showgrid=True),\n                    aspectmode='cube',\n                    camera=get_default_camera(),\n            #        domain=dict(x=[0.25, 1.0], y=[0.15, 1.0])\n                    domain=dict(x=[0.2, 1.0], y=[0.0, 1.0])\n                ),\n            \n                paper_bgcolor='black',\n                plot_bgcolor='black',\n                title_font_color='white',\n                font_color='white',\n                title=\"Paloma's Orrery - Animation Over Below Dates\",\n                showlegend=True,\n                legend=dict(\n                    font=dict(color='white'),\n                    x=1,\n                    y=1,\n                    xanchor='left',\n                    yanchor='top'\n                ),\n\n        #        margin=dict(l=75, r=50, t=100, b=100),\n                margin=dict(l=75, r=50, t=80, b=50),\n\n                annotations=[\n\n                    # NEW: Coordinate System explanation box\n                    dict(\n\n                        text=\"<b>Coordinate System (J2000 Ecliptic):</b><br><br>\"\n                            \"<b>+X:</b> Sun's direction from Earth at the vernal equinox (&#9800;)<br><br>\"\n                            \"<b>+Z:</b> Ecliptic North perpendicular to Earth's orbit<br><br>\"\n                            \"<b>XY plane:</b> Ecliptic, Earth's orbital plane<br><br><br>\"\n                            \"<i>See Orbital Parameter Visualization for detailed explanation</i>\" if not is_exoplanet_mode\n                            else \"<b>Coordinate System (Exoplanet):</b><br><br>\"\n                            \"<b>Origin:</b> Host star at (0, 0, 0)<br><br>\"\n                            \"<b>XY plane:</b> Sky plane (perpendicular to Earth)<br><br>\"\n                            \"<b>+Z:</b> Toward Earth (line of sight)<br><br>\"\n                            \"<i>Local system independent of solar system</i>\",\n\n                        xref='paper',\n                        yref='paper',\n                        x=-0.04,\n                        y=0.7,  \n                        showarrow=False,\n                        font=dict(size=11, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top',\n                        bgcolor='rgba(0, 0, 0, 0.3)',\n                        bordercolor='white',\n                        borderwidth=1,\n                        borderpad=4\n                    ),\n\n                    dict(\n                        text=\"Search: <a href='https://www.nasa.gov/' target='_blank'>NASA</a>\",\n                        xref='paper',\n                        yref='paper',\n                        x=0,\n                        y=0.35,\n                        showarrow=False,\n                        font=dict(size=12, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top'\n                    ),\n                    dict(\n                        text=\"Data source: <a href='https://ssd.jpl.nasa.gov/horizons/app.html#/' target='_blank'>JPL Horizons</a>\",\n                        xref='paper',\n                        yref='paper',\n                        x=0,\n                        y=0.3,\n                        showarrow=False,\n                        font=dict(size=12, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top'\n                    ),\n                    dict(\n                        text=\"Click on the legend items <br>to toggle them off or back on:\",\n                        xref='paper',\n                        yref='paper',\n                        x=0.95,\n                        y=1.07,\n                        showarrow=False,\n                        font=dict(size=12, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top'\n                    ),\n                ],\n                updatemenus=[\n                    dict(\n                        type='buttons',\n                        showactive=False,\n                        buttons=[\n                            dict(label='Play  ',\n                                method='animate',\n                                args=[None, {'frame': {'duration': 500, 'redraw': True},\n                                        'fromcurrent': True,\n                                        'transition': {'duration': 0}}]),\n                            dict(label='Pause',\n                                method='animate',\n                                args=[[None], {'frame': {'duration': 0},\n                                                'mode': 'immediate',\n                                                'transition': {'duration': 0}}])\n                        ],\n                        x=0.1,\n                        y=0.85\n                    )\n                ]\n            )\n\n            # Add sliders for date navigation\n            sliders = [dict(\n                active=0,\n                steps=[dict(method='animate',\n                            args=[[str(dates_list[k].strftime('%Y-%m-%d %H:%M'))],\n                                {'frame': {'duration': 500, 'redraw': True},\n                                'mode': 'immediate'}],\n                            label=dates_list[k].strftime('%Y-%m-%d %H:%M')) for k in range(N)],\n                transition=dict(duration=0),\n                x=0,\n                y=0,\n                currentvalue=dict(font=dict(size=14), prefix='Date: ', visible=True, xanchor='center'),\n                len=1.0\n            )]\n\n            # First, assign frames to the figure\n            fig.frames = frames\n\n\n            # Then update layout with sliders\n            fig.update_layout(sliders=sliders)\n\n            # Now set the initial slider position (outside try/except)\n            fig.layout.sliders[0].active = 0\n\n            # Explicitly sync the displayed data with the first frame's data\n            # Note: frames now only contain dynamic traces, so we need to map indices\n            for obj_name, trace_idx in trace_indices.items():\n                frame_idx = trace_idx - static_trace_count  # Convert to frame index\n                if (trace_idx >= static_trace_count and  # Only dynamic traces\n                    trace_idx < len(fig.data) and \n                    len(frames) > 0 and \n                    frame_idx < len(frames[0].data)):\n                    fig.data[trace_idx].x = frames[0].data[frame_idx].x\n                    fig.data[trace_idx].y = frames[0].data[frame_idx].y\n                    fig.data[trace_idx].z = frames[0].data[frame_idx].z\n                    fig.data[trace_idx].text = frames[0].data[frame_idx].text\n                    fig.data[trace_idx].customdata = frames[0].data[frame_idx].customdata\n                    fig.data[trace_idx].visible = frames[0].data[frame_idx].visible\n\n            # Add hover toggle buttons\n            fig = add_hover_toggle_buttons(fig)\n\n            # Add camera view buttons with dropdown for different target objects\n            fig = add_look_at_object_buttons(fig, initial_positions, center_object_name)            \n          \n            fig = add_fly_to_object_buttons(fig, initial_positions, center_object_name)  # NEW\n\n            # Add URL buttons before showing/saving\n            fig = add_url_buttons(fig, objects, selected_objects)            \n\n            # Generate default name with timestamp\n            current_date = STATIC_TODAY\n            default_name = f\"{center_object_name}_system_animation_{current_date.strftime('%Y%m%d_%H%M')}\"\n\n            show_animation_safely(fig, default_name)\n\n            # Store fig for social media export\n            _last_plotted_fig[0] = fig\n            _last_plot_name[0] = default_name\n\n            # Update output_label with instructions (schedule on main thread for macOS)\n\n            root.after(0, lambda: output_label.config(\n                text=f\"Animation of objects around {center_object_name} opened in browser.\"\n            ))\n            root.after(0, lambda: progress_bar.stop())\n\n        except Exception as e:\n            root.after(0, lambda msg=str(e): output_label.config(text=f\"Error during animation: {msg}\"))\n            print(f\"Error during animation: {e}\", flush=True)\n            traceback.print_exc()\n            root.after(0, lambda: progress_bar.stop())        \n\n    # Create and start monitored thread\n    animation_thread = create_monitored_thread(shutdown_handler, animation_worker)\n    animation_thread.start()",
    "start_line": 5208,
    "end_line": 6818,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "step",
      "label"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function animate_objects",
    "component_id": "palomas_orrery.animate_objects"
  },
  "palomas_orrery.animation_worker": {
    "id": "palomas_orrery.animation_worker",
    "name": "animation_worker",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "visualization_utils.format_detailed_hover_text",
      "orbit_data_manager.update_orbit_paths_incrementally",
      "planet_visualization.create_planet_visualization",
      "palomas_orrery_helpers.pad_trajectory",
      "idealized_orbits.plot_idealized_orbits",
      "apsidal_markers.add_closest_approach_marker",
      "palomas_orrery.create_animation_dates",
      "palomas_orrery_helpers.fetch_trajectory",
      "exoplanet_orbits.calculate_binary_star_position",
      "exoplanet_orbits.calculate_binary_star_orbits",
      "exoplanet_systems.get_system",
      "exoplanet_orbits.plot_binary_host_stars",
      "exoplanet_stellar_properties.get_temperature_color",
      "exoplanet_orbits.plot_exoplanet_orbits",
      "comet_visualization_shells.add_comet_tails_to_figure",
      "palomas_orrery.get_date_from_gui",
      "palomas_orrery.plot_actual_orbits",
      "palomas_orrery.get_interval_settings",
      "planet_visualization.create_sun_visualization",
      "visualization_3d.calculate_marker_size",
      "formatting_utils.format_maybe_float",
      "exoplanet_orbits.calculate_planet_position",
      "constants_new.color_map"
    ],
    "source_code": "    def animation_worker():\n        try:\n            # Global references\n            global orbit_paths_over_time\n            nonlocal active_planetary_params  # Access the pre-fetched orbital params\n\n            # Initialize frames list at the beginning\n            frames = []\n\n            # Display status message at the beginning of animation\n            output_label.config(text=f\"Creating {label} animation. Please be patient as data is being fetched...\")\n            progress_bar['mode'] = 'indeterminate'\n            progress_bar.start(10)  # Start the progress bar\n            root.update_idletasks()  # Force GUI to update\n\n            # Detect exoplanet objects (same as in plot_objects)\n            exo_objects = [obj for obj in objects \n                        if obj['var'].get() == 1 and obj.get('object_type') == 'exoplanet']\n\n            exo_host_stars = [obj for obj in objects\n                        if obj['var'].get() == 1 and obj.get('object_type') in ['exo_host_star', 'exo_binary_star', 'exo_barycenter']]\n\n            # Detect if we're in exoplanet mode\n            is_exoplanet_mode = bool(exo_objects or exo_host_stars)\n\n            if is_exoplanet_mode:\n                print(f\"\\n[EXOPLANET ANIMATION MODE] Detected {len(exo_objects)} exoplanets and {len(exo_host_stars)} host stars\", flush=True)            \n\n            # Original setup code remains unchanged\n            center_object_name = center_object_var.get()\n            center_object_info = next((obj for obj in objects if obj['name'] == center_object_name), None)\n            if center_object_info:\n                if center_object_name == 'Sun':\n                    center_id = 'Sun'\n                    center_id_type = None\n                else:\n            #        center_id = center_object_info['id']\n                    center_id = center_object_info.get('center_id', center_object_info['id'])\n                    center_id_type = center_object_info.get('id_type')\n            else:\n                center_id = 'Sun'\n                center_id_type = None\n\n            # Get frames number and validate\n            N_str = num_frames_entry.get()\n            if not N_str.strip():\n                output_label.config(text=\"Please enter a valid number of frames.\")\n                return\n            N = int(N_str)\n            if N <= 0:\n                output_label.config(text=\"Number of frames must be positive.\")\n                return\n\n            # Get interval settings\n            settings, error_msg = get_interval_settings()\n            if error_msg:\n                output_label.config(text=error_msg)\n                return\n            \n            # Apply fix for days_to_plot\n        #    gui_days = int(days_to_plot_entry.get())\n        #    if settings['days_to_plot'] != gui_days:\n        #        print(f\"[ANIMATION WARNING] Settings mismatch: settings={settings['days_to_plot']}, GUI={gui_days}\", flush=True)\n        #        settings['days_to_plot'] = gui_days\n\n            # Debug check - don't override the precise calculated value from date range\n            gui_days = int(days_to_plot_entry.get()) if days_to_plot_entry.get() else 0\n            if int(settings['days_to_plot']) != gui_days:\n                print(f\"[INFO] Animation days_to_plot: calculated={settings['days_to_plot']:.6f} days ({settings['days_to_plot']*24*60:.1f} min), GUI shows={gui_days} days\", flush=True)\n            # Note: Don't override - calculated value preserves sub-day precision for flybys       \n\n            # Debug output\n            print(f\"Days to Plot: {settings['days_to_plot']}\", flush=True)\n            print(f\"Number of Frames: {N}\", flush=True)\n            print(f\"Animation Step: {label}\", flush=True)\n            print(\"=\" * 50, flush=True)\n\n            # Extract the values needed for animation\n            trajectory_points = settings['trajectory_points']\n            orbital_points = settings['orbital_points']\n            satellite_days = settings['satellite_days']\n            satellite_points = settings['satellite_points']\n            end_date = settings['end_date']\n            start_date = settings['start_date']\n            \n            # Get the current date\n            current_date = get_date_from_gui()\n            \n            # Generate animation frame dates\n            dates_list = create_animation_dates(current_date, step, N)\n\n\n            # Calculate days_ahead\n            days_ahead = 0\n            if dates_list:\n                days_ahead = (dates_list[-1] - dates_list[0]).days\n\n            # INCREMENTAL UPDATE: Before animating, ensure we have updated data\n            selected_objects = [obj for obj in objects if obj['var'].get() == 1]\n            selected_object_names = [obj['name'] for obj in selected_objects]  # Add this for plot_idealized_orbits\n\n            output_label.config(text=\"Checking for orbit data updates for animation...\")\n            root.update_idletasks()\n            \n            # Skip orbit data updates for exoplanet systems (they use Keplerian orbits, not JPL)\n            if not is_exoplanet_mode:\n                # Call the incremental update for selected objects only\n                updated, current, total, time_saved = orbit_data_manager.update_orbit_paths_incrementally(\n                    object_list=selected_objects,\n                    center_object_name=center_object_name,\n                    days_ahead=max(days_ahead, 365),  # Ensure we have enough data for the animation\n                    planetary_params=active_planetary_params,\n                    parent_planets=parent_planets,\n                    root_widget=root\n                )\n                \n                if updated > 0:\n                    output_label.config(text=f\"Updated {updated} orbit paths. Creating animation...\")\n                else:\n                    output_label.config(text=\"Using existing orbit data. Creating animation...\")\n                root.update_idletasks()\n            else:\n                # Exoplanet mode - skip JPL data update\n                output_label.config(text=\"Exoplanet mode: Using Keplerian orbits. Creating animation...\")\n                root.update_idletasks()\n\n\n            # Define planets with shell visualizations\n            planets_with_shells = {\n                'Mercury': {'positions': [], 'shell_vars': mercury_shell_vars},\n                'Venus': {'positions': [], 'shell_vars': venus_shell_vars},\n                'Earth': {'positions': [], 'shell_vars': earth_shell_vars},\n                'Moon': {'positions': [], 'shell_vars': moon_shell_vars},\n                'Mars': {'positions': [], 'shell_vars': mars_shell_vars},\n                'Jupiter': {'positions': [], 'shell_vars': jupiter_shell_vars},\n                'Saturn': {'positions': [], 'shell_vars': saturn_shell_vars},\n                'Uranus': {'positions': [], 'shell_vars': uranus_shell_vars},\n                'Neptune': {'positions': [], 'shell_vars': neptune_shell_vars},\n                'Pluto': {'positions': [], 'shell_vars': pluto_shell_vars},\n                'Eris': {'positions': [], 'shell_vars': eris_shell_vars},\n                'Planet 9': {'positions': [], 'shell_vars': planet9_shell_vars}\n            }\n            \n            # Handle exoplanet objects separately using Keplerian orbits\n            exoplanet_positions_over_time = {}\n            binary_star_positions_over_time = {} \n            if is_exoplanet_mode:\n                from exoplanet_orbits import calculate_planet_position\n                from exoplanet_systems import get_system\n                \n                # Get unique exoplanet systems\n                exo_systems = set()\n                for obj in exo_objects + exo_host_stars:\n                    system_id = obj.get('system_id')\n                    if system_id:\n                        exo_systems.add(system_id)\n                \n                print(f\"[EXOPLANET ANIMATION] Processing {len(exo_systems)} exoplanet systems\", flush=True)\n                \n                # Calculate positions for each exoplanet at each animation date\n                for obj in exo_objects:\n                    obj_name = obj['name']\n                    system_id = obj.get('system_id')\n                    \n                    if system_id:\n                        system = get_system(system_id)\n                        if system:\n                            # Find this planet in the catalog\n                            planet_id = obj.get('id')\n                            planet_data = None\n                            for catalog_planet in system['planets']:\n                                if catalog_planet.get('planet_id') == planet_id:\n                                    planet_data = catalog_planet\n                                    break\n                            \n                            if planet_data:\n                                # Extract orbital parameters\n                                a = planet_data['semi_major_axis_au']\n                                e = planet_data.get('eccentricity', 0.0)\n                                i = planet_data.get('inclination_deg', 90.0)\n                                omega = planet_data.get('omega_deg', 0.0)\n                                Omega = planet_data.get('Omega_deg', 0.0)\n                                period = planet_data['period_days']\n                                epoch = planet_data['epoch']\n                                \n                                # Calculate position at each animation date\n                                positions = []\n                                for date in dates_list:\n                                    x_pos, y_pos, z_pos = calculate_planet_position(\n                                        a, e, i, omega, Omega, period, epoch, date\n                                    )\n                                    positions.append({\n                                        'x': x_pos,\n                                        'y': y_pos,\n                                        'z': z_pos,\n                                        'date': date\n                                    })\n                                \n                                exoplanet_positions_over_time[obj_name] = positions\n                                print(f\"[EXOPLANET ANIMATION] Generated {len(positions)} positions for {obj_name}\", flush=True)\n\n# Calculate binary star positions over time if needed\n            #    binary_star_positions_over_time = {}\n                                \n                # Process each exoplanet system that has planets or barycenter selected\n                processed_systems = set()\n                for obj in exo_objects + exo_host_stars:\n                    if obj['var'].get() == 1:\n                        system_id = obj.get('system_id')\n                        \n                        # Skip if we've already processed this system\n                        if system_id in processed_systems or not system_id:\n                            continue\n                            \n                        system = get_system(system_id)\n                        if system and system['host_star'].get('is_binary'):\n                                print(f\"[BINARY ANIMATION] Detected binary system: {system['system_name']}\", flush=True)\n\n                                from exoplanet_orbits import calculate_binary_star_orbits, calculate_binary_star_position\n                                \n                                host_star_system = system['host_star']\n                                star_A = host_star_system['star_A']\n                                star_B = host_star_system['star_B']\n                                \n                                # Calculate binary orbital parameters\n                                binary_params = calculate_binary_star_orbits(\n                                    star_A['mass_solar'],\n                                    star_B['mass_solar'],\n                                    host_star_system['binary_separation_au'],\n                                    host_star_system['binary_period_days'],\n                                    host_star_system.get('binary_eccentricity', 0.0)\n                                )\n                                \n                                epoch = host_star_system['epoch']\n                                binary_i = host_star_system.get('binary_inclination_deg', 0.0)\n                                binary_Omega = host_star_system.get('binary_Omega_deg', 0.0)\n                                \n                                # Calculate Star A positions\n                                star_A_positions = []\n                                for date in dates_list:\n                                    x_A, y_A, z_A = calculate_binary_star_position(\n                                        binary_params['star_A'], date, epoch, binary_i, binary_Omega\n                                    )\n                                    star_A_positions.append({'x': x_A, 'y': y_A, 'z': z_A, 'date': date})\n                                \n                                binary_star_positions_over_time[star_A['name']] = star_A_positions\n                                print(f\"[BINARY ANIMATION] Generated {len(star_A_positions)} positions for {star_A['name']}\", flush=True)\n                                \n                                # Calculate Star B positions\n                                star_B_positions = []\n                                for date in dates_list:\n                                    x_B, y_B, z_B = calculate_binary_star_position(\n                                        binary_params['star_B'], date, epoch, binary_i, binary_Omega\n                                    )\n                                    star_B_positions.append({'x': x_B, 'y': y_B, 'z': z_B, 'date': date})\n                                \n                                binary_star_positions_over_time[star_B['name']] = star_B_positions\n                                print(f\"[BINARY ANIMATION] Generated {len(star_B_positions)} positions for {star_B['name']}\", flush=True)\n                                \n                                # Mark this system as processed\n                                processed_systems.add(system_id)\n\n\n            # Create dates_lists for each object\n            dates_lists = {}\n\n            for obj in objects:\n                obj_type = obj.get('object_type', 'orbital')\n\n                # Skip exoplanet objects - they're handled separately\n                if obj_type == 'exoplanet':\n                    continue\n\n                if obj['var'].get() == 1 and obj['name'] != center_object_name:\n                    \n                    # For animations, we need to handle each type appropriately\n                    if obj_type == 'trajectory':\n                        # Time-bounded paths\n                        start_date = obj.get('start_date', dates_list[0])\n                        end_date = obj.get('end_date', dates_list[-1])\n                        filtered_dates = [d for d in dates_list if start_date <= d <= end_date]\n                        dates_lists[obj['name']] = filtered_dates if filtered_dates else [start_date]\n                        \n                    elif obj_type == 'satellite' and obj['name'] in parent_planets.get(center_object_name, []):\n                        # Satellites of the center object use animation dates\n                        dates_lists[obj['name']] = dates_list\n                        \n            #        elif obj_type == 'orbital' and obj['name'] in planetary_params:\n                    elif obj_type == 'orbital' and obj['name'] in active_planetary_params:      # uses osculating elements\n\n                        # Planets, dwarf planets, TNOs use animation dates\n                        dates_lists[obj['name']] = dates_list\n                        \n                    elif obj_type == 'lagrange_point':\n                        # Lagrange points use animation dates\n                        dates_lists[obj['name']] = dates_list\n                        \n                    elif obj_type == 'fixed':\n                        if obj['name'] == 'Sun':\n\n                            if is_exoplanet_mode:\n                                print(f\"Skipping Sun in exoplanet animation mode\", flush=True)\n                                continue\n\n                            if center_object_name != 'Sun':\n                                # Sun needs trajectory when viewed from another center\n                                # Use the animation dates_list that was already created\n                                dates_lists[obj['name']] = dates_list  # dates_list should be defined by now\n                                print(f\"Sun will be animated relative to {center_object_name}\", flush=True)\n                            else:\n                                # Sun at center doesn't need animation\n                                # But still needs a dates list for frame generation\n                                dates_lists[obj['name']] = [dates_list[0]] if dates_list else [current_date]\n                        else:\n                            # Other fixed objects\n                            # Use single date repeated for each frame, or full dates_list\n                            dates_lists[obj['name']] = dates_list if dates_list else [current_date]\n                            print(f\"Fixed object {obj['name']} using animation dates\", flush=True)\n\n                    else:\n                        # Default: use animation dates\n                        print(f\"WARNING: Unknown object type '{obj_type}' for {obj['name']}\", flush=True)\n                        dates_lists[obj['name']] = dates_list\n\n            # Debug: Print what we're animating\n            for name, dates in dates_lists.items():\n                print(f\"  {name}: {len(dates)} dates\", flush=True)\n\n            # Fetch trajectory data for all selected objects\n            positions_over_time = {}\n            for obj in objects:\n                if obj['var'].get() == 1 and obj['name'] != center_object_name:\n                    # Use the dates from dates_lists\n                    obj_dates = dates_lists.get(obj['name'], dates_list)\n                    \n                    \n                    # Handle objects with date ranges\n                    if 'start_date' in obj or 'end_date' in obj:\n                        # Get start/end dates with fallbacks\n                        obj_start = obj.get('start_date', dates_list[0])\n                        obj_end = obj.get('end_date', dates_list[-1])\n\n                        # Use helio_id for Sun-centered plots if available\n                        fetch_id = obj['id']\n                        fetch_id_type = obj.get('id_type')\n                        if center_object_name == 'Sun' and 'helio_id' in obj:\n                            fetch_id = obj['helio_id']\n                            fetch_id_type = 'smallbody'\n                        \n                        positions_over_time[obj['name']] = pad_trajectory(\n                            dates_list, \n                            obj_start,\n                            obj_end,\n                            fetch_id, \n                            center_id, \n                            fetch_id_type\n                        )\n                    \n                    else:\n                        # Fetch positions for the animation dates\n                        # Use helio_id for Sun-centered plots if available (longer ephemeris coverage)\n                        # System barycenter IDs (e.g., 20136108) only have data to ~2030\n                        # Heliocentric IDs (e.g., 2003 EL61) have data to ~2500\n                        fetch_id = obj['id']\n                        fetch_id_type = obj.get('id_type')\n                        if center_object_name == 'Sun' and 'helio_id' in obj:\n                            fetch_id = obj['helio_id']\n                            fetch_id_type = 'smallbody'  # helio_ids are smallbody designations\n                        \n                        positions_over_time[obj['name']] = fetch_trajectory(\n                            fetch_id, \n                            obj_dates, \n                            center_id=center_id, \n                            id_type=fetch_id_type\n                        )\n                        \n                        # ORCUS TRAJECTORY DERIVATION: JPL doesn't support 920090482 as query target\n                        if obj['name'] == 'Orcus' and center_object_name == 'Orcus-Vanth Barycenter':\n                            traj = positions_over_time.get('Orcus')\n                            traj_all_zeros = traj and all(\n                                (pos is None or (pos.get('x', 0) == 0 and pos.get('y', 0) == 0 and pos.get('z', 0) == 0))\n                                for pos in traj\n                            )\n                            if not traj or traj_all_zeros:\n                                print(f\"  - Deriving Orcus trajectory from Vanth (mass ratio method)...\", flush=True)\n                                vanth_trajectory = fetch_trajectory('120090482', obj_dates, center_id=center_id, id_type=None)\n                                if vanth_trajectory:\n                                    mass_ratio = 0.16\n                                    derived_traj = []\n                                    for vanth_pos in vanth_trajectory:\n                                        if vanth_pos and vanth_pos.get('x') != 0:\n                                            derived_traj.append({\n                                                'x': -vanth_pos['x'] * mass_ratio,\n                                                'y': -vanth_pos['y'] * mass_ratio,\n                                                'z': -vanth_pos['z'] * mass_ratio\n                                            })\n                                        else:\n                                            derived_traj.append({'x': 0, 'y': 0, 'z': 0})\n                                    positions_over_time['Orcus'] = derived_traj\n                                    print(f\"  -> Derived {len(derived_traj)} Orcus positions from Vanth\", flush=True)\n\n\n                        # Fallback for objects without JPL ephemeris\n                        # ===================================================================\n                        # Handles two cases:\n                        #   1. TNO moons (circular orbits): Uses J2000 epoch, MA=0\n                        #   2. Objects with MA in elements: Uses object's epoch and MA,\n                        #      solves Kepler's equation for eccentric orbits\n                        # ===================================================================\n\n                #        ANALYTICAL_ANIMATION_FALLBACK = ['MK2', 'Xiangliu', 'Vanth', 'Weywot', '6AC4721']  # Objects without usable JPL ephemeris\n                        ANALYTICAL_ANIMATION_FALLBACK = ['MK2', 'Xiangliu', 'Vanth', 'Gonggong', '6AC4721']  # Weywot removed - JPL data works at Quaoar\n\n                        if obj['name'] in ANALYTICAL_ANIMATION_FALLBACK:\n                            # Check if fetch_trajectory returned empty/None\n                            traj = positions_over_time.get(obj['name'])\n                            if not traj or all(p is None for p in traj):\n                                print(f\"  - No JPL data for {obj['name']}, calculating analytical positions...\", flush=True)\n                                \n                                from orbital_elements import planetary_params\n                                if obj['name'] in planetary_params:\n                                    elements = planetary_params[obj['name']]\n                                    a = elements.get('a', 0)\n                                    e = elements.get('e', 0)\n                                    i = elements.get('i', 0)\n                                    omega = elements.get('omega', 0)\n                                    Omega = elements.get('Omega', 0)\n                                    \n                                    # Get orbital period - calculate from a if not provided\n                                    if 'orbital_period_days' in elements:\n                                        orbital_period = elements['orbital_period_days']\n                                    elif a > 0:\n                                        # Kepler's 3rd law: P^2 = a^3 (P in years, a in AU)\n                                        orbital_period = np.sqrt(a**3) * 365.25\n                                    else:\n                                        orbital_period = 18.023  # Default fallback\n                                    \n                                    # Pre-calculate rotation angles (convert to radians)\n                                    i_rad = np.radians(i)\n                                    omega_rad = np.radians(omega)\n                                    Omega_rad = np.radians(Omega)\n                                    \n                                    # Reference epoch and mean anomaly at epoch\n                                    # Use object's values if available, else J2000 with MA=0\n                                    if 'MA' in elements and 'epoch' in elements:\n                                        MA_epoch = elements['MA']\n                                        epoch_str = str(elements['epoch']).replace(' osc.', '').strip()\n                                        try:\n                                            ref_epoch = datetime.strptime(epoch_str, '%Y-%m-%d')\n                                        except ValueError:\n                                            ref_epoch = datetime(2000, 1, 1, 12, 0, 0)\n                                    else:\n                                        MA_epoch = 0.0\n                                        ref_epoch = datetime(2000, 1, 1, 12, 0, 0)\n                                    \n                                    # Mean motion (degrees per day)\n                                    n = 360.0 / orbital_period\n                                    \n                                    # GM of Sun in AU^3/day^2 for velocity calculation\n                                    GM_sun = 2.959122e-4\n                                    \n                                    # Calculate position for each animation date\n                                    analytical_positions = []\n                                    for anim_date in obj_dates:\n                                        # Days since reference epoch\n                                        delta_days = (anim_date - ref_epoch).total_seconds() / 86400.0\n                                        \n                                        # Current mean anomaly\n                                        M_deg = (MA_epoch + n * delta_days) % 360.0\n                                        M_rad = np.radians(M_deg)\n                                        \n                                        # Solve Kepler's equation if e > 0.01\n                                        if e > 0.01:\n                                            # Newton-Raphson iteration\n                                            E = M_rad if e < 0.8 else np.pi\n                                            for _ in range(50):\n                                                f = E - e * np.sin(E) - M_rad\n                                                f_prime = 1 - e * np.cos(E)\n                                                if abs(f_prime) < 1e-12:\n                                                    break\n                                                delta = f / f_prime\n                                                E = E - delta\n                                                if abs(delta) < 1e-10:\n                                                    break\n                                            \n                                            # Convert eccentric anomaly to true anomaly\n                                            true_anomaly = 2 * np.arctan2(\n                                                np.sqrt(1 + e) * np.sin(E / 2),\n                                                np.sqrt(1 - e) * np.cos(E / 2)\n                                            )\n                                        else:\n                                            # For near-circular orbits, mean anomaly ~ true anomaly\n                                            true_anomaly = M_rad\n                                        \n                                        # Position in orbital plane\n                                        r = a * (1 - e**2) / (1 + e * np.cos(true_anomaly)) if e > 0 else a\n                                        x_orb = r * np.cos(true_anomaly)\n                                        y_orb = r * np.sin(true_anomaly)\n                                        z_orb = 0.0\n                                        \n                                        # Apply 3D rotations\n                                        # Rotation 1: omega around z\n                                        x1 = x_orb * np.cos(omega_rad) - y_orb * np.sin(omega_rad)\n                                        y1 = x_orb * np.sin(omega_rad) + y_orb * np.cos(omega_rad)\n                                        z1 = z_orb\n                                        \n                                        # Rotation 2: i around x\n                                        x2 = x1\n                                        y2 = y1 * np.cos(i_rad) - z1 * np.sin(i_rad)\n                                        z2 = y1 * np.sin(i_rad) + z1 * np.cos(i_rad)\n                                        \n                                        # Rotation 3: Omega around z\n                                        x_final = x2 * np.cos(Omega_rad) - y2 * np.sin(Omega_rad)\n                                        y_final = x2 * np.sin(Omega_rad) + y2 * np.cos(Omega_rad)\n                                        z_final = z2\n                                        \n                                        # Calculate velocity (vis-viva for elliptical, circular approx for e~0)\n                                        if e > 0.01 and a > 0:\n                                            v_au_day = np.sqrt(GM_sun * (2/r - 1/a))\n                                        else:\n                                            v_au_day = 2 * np.pi * a / orbital_period\n                                        \n                                        analytical_positions.append({\n                                            'x': x_final,\n                                            'y': y_final,\n                                            'z': z_final,\n                                            'velocity': v_au_day,  # AU/day - expected by hover text\n                                            'range': r,\n                                            'date': anim_date\n                                        })\n\n                                    positions_over_time[obj['name']] = analytical_positions\n                                    print(f\"  -> Generated {len(analytical_positions)} analytical positions for {obj['name']} (e={e:.5f})\", flush=True)\n\n            # Extract initial positions for idealized orbits\n            initial_positions = {}\n            for obj_name, trajectory in positions_over_time.items():\n                if trajectory and len(trajectory) > 0 and trajectory[0] is not None:\n                    initial_pos = trajectory[0]\n                    if 'x' in initial_pos and 'y' in initial_pos and 'z' in initial_pos:\n                        initial_positions[obj_name] = {\n                            'x': initial_pos['x'],\n                            'y': initial_pos['y'],\n                            'z': initial_pos['z']\n                        }\n            \n            # Add center object position\n            initial_positions[center_object_name] = {'x': 0, 'y': 0, 'z': 0}\n            \n\n            # Add position data for center planet if it has shells\n            if center_object_name in planets_with_shells:\n                # Create a list of positions at (0,0,0) for all frames\n                center_positions = []\n                for i in range(N):\n                    center_positions.append({\n                        'x': 0, 'y': 0, 'z': 0,\n                        'date': dates_list[i]\n                    })\n                positions_over_time[center_object_name] = center_positions\n            \n\n            # Initialize figure\n            fig = go.Figure()\n\n            # =================================================================\n            # STATIC CENTER SHELLS - Added once, not duplicated in frames\n            # This enables shell visualizations in animations without memory explosion\n            # =================================================================\n            # Define planet shell configuration (same as plot_objects)\n            animation_shell_config = {\n                'Mercury': mercury_shell_vars,\n                'Venus': venus_shell_vars,\n                'Earth': earth_shell_vars,\n                'Moon': moon_shell_vars,\n                'Mars': mars_shell_vars,\n                'Jupiter': jupiter_shell_vars,\n                'Saturn': saturn_shell_vars,\n                'Uranus': uranus_shell_vars,\n                'Neptune': neptune_shell_vars,\n                'Pluto': pluto_shell_vars,\n                'Eris': eris_shell_vars,\n                'Planet 9': planet9_shell_vars\n            }\n\n            # Flag to track if shells have been added for center object\n            center_shells_added = False\n\n            # Add Sun visualization if needed\n            if center_object_name == 'Sun' and any(var.get() == 1 for var in sun_shell_vars.values()):\n                fig = create_sun_visualization(fig, sun_shell_vars)\n                center_shells_added = True\n                print(f\"[ANIMATION] Added Sun shells ({len(fig.data)} static traces)\", flush=True)\n                \n            # Add planet visualization if the center is a planet with shells\n            elif center_object_name in animation_shell_config:\n                shell_vars = animation_shell_config[center_object_name]\n                if any(var.get() == 1 for var in shell_vars.values()):\n                    fig = create_planet_visualization(fig, center_object_name, shell_vars)\n                    center_shells_added = True\n                    print(f\"[ANIMATION] Added {center_object_name} shells ({len(fig.data)} static traces)\", flush=True)\n\n            # Track where static traces end - frames will only update traces after this point\n            static_trace_count = len(fig.data)\n\n            # Add center marker only if shells haven't been added\n            if not center_shells_added:\n                if center_object_name == 'Sun':\n                    # Just add the central Sun marker if shells not selected\n                    fig.add_trace(\n                        go.Scatter3d(\n                            x=[0], y=[0], z=[0],\n                            mode='markers',\n                            marker=dict(\n                                color='rgb(102, 187, 106)',\n                                size=12,\n                                symbol='circle'\n                            ),\n                            name=\"Sun\",\n                            text=[\"Sun - Center of Solar System\"],\n                            hovertemplate='%{text}<extra></extra>',\n                            showlegend=True\n                        )\n                    )\n                else:\n                    # Add center marker for non-Sun objects\n                    center_object_info = next((obj for obj in objects if obj['name'] == center_object_name), None)\n                    if center_object_info:\n                        # Check if color is transparent to hide legend\n                        is_transparent = 'rgba(0,0,0,0)' in str(center_object_info['color']).replace(' ', '')\n                        \n                        fig.add_trace(\n                            go.Scatter3d(\n                                x=[0], y=[0], z=[0],\n                                mode='markers',\n                                marker=dict(\n                                    color=center_object_info['color'],\n                                    size=12,\n                                    symbol=center_object_info['symbol']\n                                ),\n                                name=center_object_name,\n                                # FIXED: Barycenter text only for multi-body systems, not single bodies like Bennu\n                                text=[f\"{center_object_name} system <br>center of gravity<br>(barycenter)\"] if 'Barycenter' in center_object_name else [center_object_name],\n                                hovertemplate='%{text}<extra></extra>',\n                                showlegend=not is_transparent  # Hide legend if transparent\n                            )\n                        )\n\n            # Also update the orbit path creation for animations to match plot_objects:\n            # For animations, calculate the actual span from animation dates, not days_to_plot\n        #    animation_span_days = (dates_list[-1] - dates_list[0]).days if len(dates_list) > 1 else settings['days_to_plot']\n            # Use total_seconds() to preserve fractional days (e.g., 27 hours = 1.125 days, not 1 day)\n            animation_span_days = (dates_list[-1] - dates_list[0]).total_seconds() / 86400 if len(dates_list) > 1 else settings['days_to_plot']\n            \n            orbit_dates_lists = {}\n            # NEW: Separate dict for trajectory context layers (full mission)\n            trajectory_context_dates = {}\n            \n            for obj in objects:\n                if obj['var'].get() == 1 and obj['name'] != center_object_name:\n                    obj_type = obj.get('object_type', 'orbital')\n                    \n        #            if obj_type == 'orbital' and obj['name'] in planetary_params:\n                    if obj_type == 'orbital' and obj['name'] in active_planetary_params:    \n                        # Use the full animation span for orbit display (not days_to_plot)\n                        requested_days = animation_span_days\n\n                        num_points = int(settings['orbital_points']) + 1\n                        orbit_dates = [current_date + timedelta(days=float(d)) \n                                    for d in np.linspace(0, requested_days, num=num_points)]\n                        orbit_dates_lists[obj['name']] = orbit_dates\n\n                    elif obj_type == 'satellite' and obj['name'] in parent_planets.get(center_object_name, []):\n                        # For satellites, use full animation span\n                        requested_days = animation_span_days\n\n                        num_points = int(settings['satellite_points']) + 1\n                        orbit_dates = [current_date + timedelta(days=float(d)) \n                                    for d in np.linspace(0, requested_days, num=num_points)]\n                        orbit_dates_lists[obj['name']] = orbit_dates\n                    elif obj_type == 'trajectory':\n                        # TWO-LAYER TRAJECTORY SYSTEM:\n                        # Context layer: Full mission (faded background)\n                        # Detail layer: Plotted Period only (solid, for fine resolution)\n                        \n                        mission_start = obj.get('start_date', current_date)\n                        mission_end = obj.get('end_date', current_date + timedelta(days=settings['days_to_plot']))\n                        mission_days = (mission_end - mission_start).total_seconds() / 86400\n                        \n                        num_points = int(settings['trajectory_points']) + 1\n                        \n                        # CONTEXT: Full mission trajectory (for background/context)\n                        if mission_days > 0:\n                            context_dates = [mission_start + timedelta(days=float(d)) \n                                           for d in np.linspace(0, mission_days, num=num_points)]\n                            trajectory_context_dates[obj['name']] = context_dates\n                            print(f\"[TRAJECTORY] {obj['name']} context: {num_points} points over {mission_days:.1f} days (full mission)\", flush=True)\n                        \n                        # DETAIL: Plotted Period only (for fine resolution)\n                        # Clip to mission bounds\n                        detail_start = max(current_date, mission_start)\n                        animation_end = current_date + timedelta(days=animation_span_days)\n                        detail_end = min(animation_end, mission_end)\n                        detail_days = (detail_end - detail_start).total_seconds() / 86400\n                        \n                        if detail_days > 0:\n                            detail_dates = [detail_start + timedelta(days=float(d)) \n                                          for d in np.linspace(0, detail_days, num=num_points)]\n                            orbit_dates_lists[obj['name']] = detail_dates\n                            print(f\"[TRAJECTORY] {obj['name']} detail: {num_points} points over {detail_days:.1f} days (plotted period)\", flush=True)\n                        else:\n                            # Plotted Period doesn't overlap with mission - use mission dates\n                            orbit_dates_lists[obj['name']] = trajectory_context_dates.get(obj['name'], [current_date])\n                    else:\n                        # Use appropriate dates for other object types\n                        orbit_dates_lists[obj['name']] = dates_lists.get(obj['name'], dates_list)\n\n            # PLOT TRAJECTORY CONTEXT LAYERS (Full Mission - faded background)\n            # This provides mission context while detail layer shows plotted period\n            if trajectory_context_dates:\n                print(f\"\\n[TRAJECTORY CONTEXT] Plotting {len(trajectory_context_dates)} full mission trajectories...\", flush=True)\n                for obj_name, context_dates in trajectory_context_dates.items():\n                    obj_info = next((obj for obj in objects if obj['name'] == obj_name), None)\n                    if not obj_info or not context_dates:\n                        continue\n                    \n                    # Get fetch ID (use helio_id for Sun-centered if available)\n                    fetch_id = obj_info['id']\n                    fetch_id_type = obj_info.get('id_type')\n                    if center_object_name == 'Sun' and 'helio_id' in obj_info:\n                        fetch_id = obj_info['helio_id']\n                        fetch_id_type = 'smallbody'\n                    \n                    # Fetch trajectory for context layer\n                    context_trajectory = fetch_trajectory(fetch_id, context_dates, center_id=center_id, id_type=fetch_id_type)\n                    \n                    if context_trajectory:\n                        x = [pos['x'] for pos in context_trajectory if pos is not None]\n                        y = [pos['y'] for pos in context_trajectory if pos is not None]\n                        z = [pos['z'] for pos in context_trajectory if pos is not None]\n                        \n                        if x:  # Only plot if we have data\n                            # Get base color and create faded version\n                            base_color = color_map(obj_name)\n                            \n                            fig.add_trace(\n                                go.Scatter3d(\n                                    x=x,\n                                    y=y,\n                                    z=z,\n                                    mode='lines',\n                                    line=dict(\n                                        color=base_color,\n                                        width=2,  # Thinner than detail\n                                #        dash='dot'  # Dotted line for context\n                                    ),\n                                #    opacity=0.5,  # Faded\n                                    opacity=1.0,  \n                                    name=f\"{obj_name} Full Mission\",\n                                    text=[f\"{obj_name} Full Mission Trajectory\"] * len(x),\n                                    hovertemplate='%{text}<extra></extra>',\n                                    showlegend=True\n                                )\n                            )\n\n                            print(f\"[TRAJECTORY CONTEXT] Plotted {obj_name} full mission: {len(x)} points\", flush=True)\n                            \n                            # Add closest approach marker for Full Mission (base color)\n                            if show_closest_approach_var.get():\n                                from apsidal_markers import add_closest_approach_marker\n                                \n                                # Build positions_dict from context trajectory data\n                                positions_dict = {}\n                                for i in range(len(x)):\n                                    if i < len(context_dates):\n                                        positions_dict[context_dates[i].isoformat()] = {\n                                            'x': x[i],\n                                            'y': y[i],\n                                            'z': z[i]\n                                        }\n                                \n                                add_closest_approach_marker(\n                                    fig=fig,\n                                    positions_dict=positions_dict,\n                                    obj_name=obj_name,\n                                    center_body=center_object_name,\n                                    color_map=color_map,\n                                    date_range=(context_dates[0], context_dates[-1]) if context_dates else None,\n                                    marker_color=base_color  # Use base color for Full Mission\n                                )\n\n            # Plot actual orbits using the orbit_dates_lists (DETAIL layer for trajectories)\n\n            selected_planets = [obj['name'] for obj in objects if obj['var'].get() == 1 and obj['name'] != center_object_name]\n            # FIXED: Added center_object_name - was defaulting to 'Sun' causing wrong hover text\n    #        plot_actual_orbits(fig, selected_planets, orbit_dates_lists, center_id=center_id, show_lines=True, center_object_name=center_object_name, show_closest_approach=show_closest_approach_var.get())\n    #        plot_actual_orbits(fig, selected_planets, orbit_dates_lists, center_id=center_id, show_lines=True, center_object_name=center_object_name, show_closest_approach=show_closest_approach_var.get(), trajectory_style='plotted_period')\n            # Pass yellow marker color for trajectory Plotted Period traces\n            plot_actual_orbits(fig, selected_planets, orbit_dates_lists, center_id=center_id, show_lines=True, center_object_name=center_object_name, show_closest_approach=show_closest_approach_var.get(), trajectory_marker_color='yellow')\n    \n            for i, trace in enumerate(fig.data):\n                trace_type = type(trace).__name__\n                trace_mode = getattr(trace, 'mode', 'N/A')  # Mesh3d has no mode\n                print(f\"  Trace {i}: {trace.name} ({trace_type}, mode: {trace_mode})\", flush=True)\n\n            # ADD THIS SECTION - Plot idealized orbits\n            selected_object_names = [obj['name'] for obj in selected_objects]  # Convert to names list\n            plot_idealized_orbits(\n                fig, \n                selected_object_names,  # Use the names list\n                center_id=center_object_name,\n                objects=objects,\n                planetary_params=active_planetary_params,\n                parent_planets=parent_planets,\n                color_map=color_map,\n                date=dates_list[0] if dates_list else datetime.now(),\n                days_to_plot=settings['days_to_plot'],\n                current_positions=initial_positions,\n                fetch_position=fetch_position,\n                show_apsidal_markers=show_apsidal_markers_var.get(),\n                parent_window=root  \n            )\n\n            for i, trace in enumerate(fig.data):\n                print(f\"  Trace {i}: {trace.name}\", flush=True)      \n\n            # Initialize trace_indices BEFORE trying to use it\n            trace_indices = {}\n            \n            # Find and track the Pluto-Charon Barycenter trace if it exists\n            # This trace is added by idealized_orbits.py for Pluto-centered views\n            for idx, trace in enumerate(fig.data):\n                if trace.name == 'Pluto-Charon Barycenter':\n                    trace_indices['Pluto-Charon Barycenter'] = idx\n                    break\n\n            # Find and track the Earth-Moon Barycenter trace if it exists\n            for idx, trace in enumerate(fig.data):\n                if trace.name == 'Earth-Moon Barycenter':\n                    trace_indices['Earth-Moon Barycenter'] = idx\n                    break\n\n            # Add exoplanet traces if in exoplanet mode\n            if is_exoplanet_mode:\n                from exoplanet_orbits import plot_exoplanet_orbits, plot_binary_host_stars, calculate_exoplanet_axis_range\n                from exoplanet_systems import get_system\n                \n                # Get unique systems\n                exo_systems = set()\n                for obj in exo_objects + exo_host_stars:\n                    system_id = obj.get('system_id')\n                    if system_id:\n                        exo_systems.add(system_id)\n                \n                # Plot each system (orbits and host stars)\n                for system_id in exo_systems:\n                    system = get_system(system_id)\n                    if not system:\n                        continue\n                    \n                    # Get objects for this system\n                    system_planets = []\n                    for obj in exo_objects:\n                        if obj.get('system_id') == system_id:\n                            planet_id = obj.get('id')\n                            if planet_id:\n                                for catalog_planet in system['planets']:\n                                    if catalog_planet.get('planet_id') == planet_id:\n                                        full_planet = catalog_planet.copy()\n                                        full_planet['var'] = obj['var']\n                                        full_planet['name'] = obj['name']\n                                        full_planet['color'] = obj.get('color', 'lightblue')\n                                        system_planets.append(full_planet)\n                                        break\n                    \n                    system_stars = [obj for obj in exo_host_stars \n                                if obj.get('system_id') == system_id]\n                    \n                    # Plot host star(s)\n                    barycenter_obj = next((obj for obj in exo_host_stars \n                                        if obj.get('id_type') == 'barycenter' \n                                        and obj.get('system_id') == system_id \n                                        and obj['var'].get() == 1), None)\n                    \n                    if system_stars or barycenter_obj or not system['host_star'].get('is_binary'):\n                        fig = plot_binary_host_stars(fig, system['host_star'], dates_list[0], \n                                                    show_orbits=True, show_markers=False, system_data=system)\n                    \n                    # Plot planet orbits (static orbits for the animation)\n                    if system_planets:\n                        fig = plot_exoplanet_orbits(\n                            fig, system_planets, system, dates_list[0],\n                            show_orbits=True, show_markers=False  # Markers will be animated\n                        )\n                \n                # Add initial position markers for exoplanets\n                for obj in exo_objects:\n                    obj_name = obj['name']\n                    if obj_name in exoplanet_positions_over_time:\n                        positions = exoplanet_positions_over_time[obj_name]\n                        if positions and len(positions) > 0:\n                            first_pos = positions[0]\n                            \n                            # Get planet data for hover text\n                            system_id = obj.get('system_id')\n                            system = get_system(system_id)\n                            planet_data = None\n                            if system:\n                                planet_id = obj.get('id')\n                                for catalog_planet in system['planets']:\n                                    if catalog_planet.get('planet_id') == planet_id:\n                                        planet_data = catalog_planet\n                                        break\n                            \n                            hover_text = f\"<b>{obj_name}</b><br>\"\n                            if planet_data:\n                                from formatting_utils import format_maybe_float\n                                hover_text += f\"Period: {planet_data['period_days']:.2f} days<br>\"\n                                hover_text += f\"Semi-major axis: {planet_data['semi_major_axis_au']:.4f} AU<br>\"\n                                hover_text += f\"Mass: {format_maybe_float(planet_data.get('mass_earth'))} Mearth<br>\"\n                                if planet_data.get('in_habitable_zone'):\n                                    hover_text += \"<br><b>* IN HABITABLE ZONE *</b>\"\n                            \n                            trace = go.Scatter3d(\n                                x=[first_pos['x']],\n                                y=[first_pos['y']],\n                                z=[first_pos['z']],\n                                mode='markers',\n                                marker=dict(\n                                    symbol='circle',\n                                    color=obj.get('color', 'lightblue'),\n                                    size=8 if planet_data and planet_data.get('in_habitable_zone') else 6\n                                ),\n                                name=obj_name,\n                                text=[hover_text],\n                                hoverinfo='text',\n                                showlegend=True\n                            )\n                            fig.add_trace(trace)\n                            trace_indices[obj_name] = len(fig.data) - 1\n                \n                print(f\"[EXOPLANET ANIMATION] Added {len([k for k in trace_indices if k in exoplanet_positions_over_time])} exoplanet traces\", flush=True)\n\n                # Add initial traces for binary stars\n                if binary_star_positions_over_time:\n                    # Get the system data to access star properties\n                    for star_name, positions in binary_star_positions_over_time.items():\n                        if positions and len(positions) > 0:\n                            first_pos = positions[0]\n                            \n                            # Find which system this star belongs to and get its properties\n                            star_data = None\n                            for obj in exo_objects + exo_host_stars:\n                                if obj['var'].get() == 1:\n                                    sys_id = obj.get('system_id')\n                                    if sys_id:\n                                        sys = get_system(sys_id)\n                                        if sys and sys['host_star'].get('is_binary'):\n                                            # Check if this is Star A or Star B\n                                            if star_name == sys['host_star']['star_A']['name']:\n                                                star_data = sys['host_star']['star_A']\n                                                break\n                                            elif star_name == sys['host_star']['star_B']['name']:\n                                                star_data = sys['host_star']['star_B']\n                                                break\n                            \n                            if star_data:\n                                # Calculate temperature-based color and size\n                                from exoplanet_stellar_properties import get_temperature_color, calculate_marker_size\n                                \n                                teff = star_data.get('teff_k', 5778)\n                                star_color = get_temperature_color(teff)\n                                luminosity = star_data.get('luminosity_solar', 1.0)\n                                marker_size = calculate_marker_size(luminosity, base_size=10)\n                                \n                                hover_text = f\"<b>{star_name}</b><br>\"\n                                hover_text += f\"Spectral Type: {star_data.get('spectral_type', 'Unknown')}<br>\"\n                                hover_text += f\"Temperature: {teff} K<br>\"\n                                hover_text += f\"Mass: {star_data.get('mass_solar', 1.0):.2f} Mearth<br>\"\n                                hover_text += f\"Luminosity: {luminosity:.3f} Lsun\"\n                                \n                                trace = go.Scatter3d(\n                                    x=[first_pos['x']],\n                                    y=[first_pos['y']],\n                                    z=[first_pos['z']],\n                                    mode='markers',\n                                    marker=dict(\n                                        symbol='circle',\n                                        color=star_color,\n                                        size=marker_size\n                                    ),\n                                    name=star_name,\n                                    text=[hover_text],\n                                    hoverinfo='text',\n                                    showlegend=True\n                                )\n                                fig.add_trace(trace)\n                                trace_indices[star_name] = len(fig.data) - 1\n                    \n                    print(f\"[BINARY ANIMATION] Added {len(binary_star_positions_over_time)} binary star traces\", flush=True)\n\n            # Create initial traces for moving objects and store their indices\n            for obj in objects:\n\n                # Skip exoplanet objects - already handled above\n                if obj.get('object_type') == 'exoplanet':\n                    continue\n\n                if obj['var'].get() == 1 and obj['name'] != center_object_name:\n                    obj_name = obj['name']\n                    obj_positions = positions_over_time.get(obj_name)\n                    \n                    if obj_positions and len(obj_positions) > 0 and obj_positions[0] is not None and 'x' in obj_positions[0]:\n                        obj_data = obj_positions[0]\n                        \n                        # Use format_detailed_hover_text\n                        full_hover_text, minimal_hover_text, satellite_note = format_detailed_hover_text(\n                            obj_data, \n                            obj_name, \n                            center_object_name,\n                            objects,\n                    #        planetary_params,\n                            active_planetary_params,\n                            parent_planets,\n                            CENTER_BODY_RADII,\n                            KM_PER_AU,\n                            LIGHT_MINUTES_PER_AU,\n                            KNOWN_ORBITAL_PERIODS\n                        )\n                        \n                        # Add satellite note if present\n                        if satellite_note:\n                            full_hover_text += satellite_note\n\n                        trace = go.Scatter3d(\n                            x=[obj_data['x']],\n                            y=[obj_data['y']],\n                            z=[obj_data['z']],\n                            mode='markers',\n                            marker=dict(symbol=obj['symbol'], color=obj['color'], size=6),\n                            name=obj_name,\n                            text=[full_hover_text],\n                            customdata=[minimal_hover_text],\n                            hovertemplate='%{text}<extra></extra>',\n                            showlegend=True\n                        )\n                        fig.add_trace(trace)\n                        trace_indices[obj_name] = len(fig.data) - 1\n                    else:\n                        # If no initial position, still create a trace for the legend\n                        trace = go.Scatter3d(\n                            x=[None], y=[None], z=[None],\n                            mode='markers',\n                            marker=dict(symbol=obj['symbol'], color=obj['color'], size=6),\n                            name=obj_name,\n                            text=[obj_name],\n                            customdata=[obj_name],\n                            hovertemplate='%{text}<extra></extra>',\n                            showlegend=True\n                        )\n                        fig.add_trace(trace)\n                        trace_indices[obj_name] = len(fig.data) - 1\n\n            \n            # ============ ADD COMET TAILS INTEGRATION ============\n            # Conservative comet tail integration for first frame\n            # Note: For animations, we only add tails to the initial figure state\n            # as recalculating them every frame would be too expensive\n            if len(dates_list) > 0:\n                first_frame_date = dates_list[0]\n                print(f\"\\n[COMET TAILS] Adding comet tails for animation initial state (date: {first_frame_date})\", flush=True)\n                \n                for obj in objects:\n                    if obj['var'].get() == 1:\n                        # Check if this is a comet by its properties\n                        is_comet = (\n                            obj.get('object_type') == 'orbital' and \n                            obj.get('id_type') == 'smallbody' and\n                            obj.get('symbol') == 'diamond'\n                        )\n                        \n                        obj_name = obj['name']\n                        if is_comet and obj_name in positions_over_time:\n                            # Get position for first frame\n                            obj_positions = positions_over_time.get(obj_name)\n                            if obj_positions and len(obj_positions) > 0 and obj_positions[0] is not None:\n                                first_position = obj_positions[0]\n                                print(f\"Processing comet tails for {obj_name} in animation...\", flush=True)\n                                fig = add_comet_tails_to_figure(\n                                    fig,\n                                    obj_name,\n                                    first_position,\n                                    center_object_name\n                                )\n            # ============ END COMET TAILS INTEGRATION ============\n\n            # NOW create frames - after trace_indices has been defined\n            # =================================================================\n            # OPTIMIZATION: Only include dynamic traces in frames\n            # Static shell traces (indices 0 to static_trace_count-1) are not duplicated\n            # This dramatically reduces memory for animations with shell visualizations\n            # =================================================================\n            dynamic_trace_indices = list(range(static_trace_count, len(fig.data)))\n            print(f\"[ANIMATION] Static traces: 0-{static_trace_count-1} ({static_trace_count} traces)\", flush=True)\n            print(f\"[ANIMATION] Dynamic traces: {static_trace_count}-{len(fig.data)-1} ({len(dynamic_trace_indices)} traces)\", flush=True)\n            \n            # Helper function to convert absolute trace index to frame_data index\n            def to_frame_idx(absolute_idx):\n                \"\"\"Convert absolute fig.data index to frame_data index.\n                Returns None if this is a static trace (not in frame_data).\"\"\"\n                if absolute_idx >= static_trace_count:\n                    return absolute_idx - static_trace_count\n                return None  # Static trace, not in frame_data\n            \n            for i in range(N):\n                # Only copy dynamic traces (skip static shell traces at indices 0 to static_trace_count-1)\n                frame_data = [copy.deepcopy(fig.data[idx]) for idx in dynamic_trace_indices]\n                current_date = dates_list[i]\n                \n                # Update position traces for selected objects\n                # First, update exoplanet positions\n                for obj_name in exoplanet_positions_over_time:\n                    if obj_name in trace_indices:\n                        trace_idx = trace_indices[obj_name]\n                        frame_idx = to_frame_idx(trace_idx)\n                        if frame_idx is None:\n                            continue  # Skip static traces\n                        positions = exoplanet_positions_over_time[obj_name]\n                        \n                        if i < len(positions):\n                            pos = positions[i]\n                            frame_data[frame_idx].x = [pos['x']]\n                            frame_data[frame_idx].y = [pos['y']]\n                            frame_data[frame_idx].z = [pos['z']]\n                            frame_data[frame_idx].visible = True\n                        else:\n                            frame_data[frame_idx].visible = False\n                \n                # Update binary star positions\n                for star_name in binary_star_positions_over_time:\n                    if star_name in trace_indices:\n                        trace_idx = trace_indices[star_name]\n                        frame_idx = to_frame_idx(trace_idx)\n                        if frame_idx is None:\n                            continue  # Skip static traces\n                        positions = binary_star_positions_over_time[star_name]\n                        \n                        if i < len(positions):\n                            pos = positions[i]\n                            frame_data[frame_idx].x = [pos['x']]\n                            frame_data[frame_idx].y = [pos['y']]\n                            frame_data[frame_idx].z = [pos['z']]\n                            frame_data[frame_idx].visible = True\n                        else:\n                            frame_data[frame_idx].visible = False\n\n                # Update Pluto-Charon Barycenter position (derived from Charon)\n                # In Pluto-centered view, barycenter is at fixed distance along Pluto-Charon direction\n                if 'Pluto-Charon Barycenter' in trace_indices and center_object_name == 'Pluto':\n                    trace_idx = trace_indices['Pluto-Charon Barycenter']\n                    frame_idx = to_frame_idx(trace_idx)\n                    charon_positions = positions_over_time.get('Charon')\n                    \n                    if frame_idx is not None and charon_positions and i < len(charon_positions) and charon_positions[i] is not None:\n                        charon_pos = charon_positions[i]\n                        if 'x' in charon_pos:\n                            # Barycenter distance from Pluto center: ~2,050 km = 0.0000137 AU\n                            BARYCENTER_DIST_AU = 0.0000137\n                            \n                            # Calculate unit vector from Pluto toward Charon\n                            cx, cy, cz = charon_pos['x'], charon_pos['y'], charon_pos['z']\n                            charon_dist = (cx**2 + cy**2 + cz**2)**0.5\n                            \n                            if charon_dist > 0:\n                                # Barycenter is along the Pluto-Charon line\n                                bary_x = BARYCENTER_DIST_AU * (cx / charon_dist)\n                                bary_y = BARYCENTER_DIST_AU * (cy / charon_dist)\n                                bary_z = BARYCENTER_DIST_AU * (cz / charon_dist)\n                                \n                                frame_data[frame_idx].x = [bary_x]\n                                frame_data[frame_idx].y = [bary_y]\n                                frame_data[frame_idx].z = [bary_z]\n                                frame_data[frame_idx].visible = True\n\n                # Update Earth-Moon Barycenter position (derived from Moon)\n                if 'Earth-Moon Barycenter' in trace_indices and center_object_name == 'Earth':\n                    trace_idx = trace_indices['Earth-Moon Barycenter']\n                    frame_idx = to_frame_idx(trace_idx)\n                    moon_positions = positions_over_time.get('Moon')\n                    \n                    if frame_idx is not None and moon_positions and i < len(moon_positions) and moon_positions[i] is not None:\n                        moon_pos = moon_positions[i]\n                        if 'x' in moon_pos:\n                            EMB_DIST_AU = 0.0000312  # ~4,670 km\n                            mx, my, mz = moon_pos['x'], moon_pos['y'], moon_pos['z']\n                            moon_dist = (mx**2 + my**2 + mz**2)**0.5\n                            if moon_dist > 0:\n                                bary_x = EMB_DIST_AU * (mx / moon_dist)\n                                bary_y = EMB_DIST_AU * (my / moon_dist)\n                                bary_z = EMB_DIST_AU * (mz / moon_dist)\n                                frame_data[frame_idx].x = [bary_x]\n                                frame_data[frame_idx].y = [bary_y]\n                                frame_data[frame_idx].z = [bary_z]\n                                frame_data[frame_idx].visible = True\n\n                # Then update regular solar system objects\n                for obj in objects:\n                        if obj['var'].get() == 1 and obj['name'] != center_object_name:\n                            obj_name = obj['name']\n                                        \n                            # Skip exoplanets - already handled above\n                            if obj.get('object_type') == 'exoplanet':\n                                continue\n                                        \n                            if obj_name in positions_over_time and obj_name in trace_indices:\n                                trace_idx = trace_indices[obj_name]\n                                frame_idx = to_frame_idx(trace_idx)\n                                if frame_idx is None:\n                                    continue  # Skip static traces\n                                obj_positions = positions_over_time[obj_name]\n                                            \n                                if i < len(obj_positions) and obj_positions[i] is not None and 'x' in obj_positions[i]:\n                                    obj_data = obj_positions[i]\n\n                                    # Use format_detailed_hover_text\n                                    full_hover_text, minimal_hover_text, satellite_note = format_detailed_hover_text(\n                                        obj_data, \n                                        obj_name, \n                                        center_object_name,\n                                        objects,\n                                #        planetary_params,\n                                        active_planetary_params,\n                                        parent_planets,\n                                        CENTER_BODY_RADII,\n                                        KM_PER_AU,\n                                        LIGHT_MINUTES_PER_AU,\n                                        KNOWN_ORBITAL_PERIODS\n                                    )\n                                                \n                                    # Add satellite note if present\n                                    if satellite_note:\n                                        full_hover_text += satellite_note\n\n                                    # Update the trace with new position data\n                                    frame_data[frame_idx].x = [obj_data['x']]\n                                    frame_data[frame_idx].y = [obj_data['y']]\n                                    frame_data[frame_idx].z = [obj_data['z']]\n                                    frame_data[frame_idx].text = [full_hover_text]\n                                    frame_data[frame_idx].customdata = [minimal_hover_text]\n                                    frame_data[frame_idx].visible = True\n                                else:\n                                    # If position is missing for this frame, make the object invisible\n                                    frame_data[frame_idx].visible = False\n\n                # Create frame with selective trace update\n                # The traces parameter tells Plotly which fig.data indices this frame updates\n                frames.append(go.Frame(\n                    data=frame_data,\n                    traces=dynamic_trace_indices,  # Only update dynamic traces, not static shells\n                    name=str(dates_list[i].strftime('%Y-%m-%d %H:%M'))\n                ))\n\n\n            # Get axis range using orbital parameters (same as static plots)\n            if is_exoplanet_mode and exo_objects:\n                # Use exoplanet-specific axis range calculation\n                from exoplanet_orbits import calculate_exoplanet_axis_range\n                from exoplanet_systems import get_system\n                \n                # Get all selected exoplanet systems\n                all_exo_planets = []\n                for obj in exo_objects:\n                    system_id = obj.get('system_id')\n                    if system_id:\n                        system = get_system(system_id)\n                        if system:\n                            planet_id = obj.get('id')\n                            for catalog_planet in system['planets']:\n                                if catalog_planet.get('planet_id') == planet_id:\n                                    all_exo_planets.append(catalog_planet)\n                                    break\n                \n                if all_exo_planets:\n                    axis_range = calculate_exoplanet_axis_range(all_exo_planets)\n                    # Convert to list for Plotly\n                    axis_range = [-axis_range, axis_range]\n                    print(f\"[EXOPLANET ANIMATION] Using exoplanet axis range: +/-{axis_range[1]:.4f} AU\", flush=True)\n                else:\n                    axis_range = get_animation_axis_range(\n            #            scale_var, custom_scale_entry, objects, planetary_params, \n                        scale_var, custom_scale_entry, objects, active_planetary_params,\n                        parent_planets, center_object_name\n                    )\n            else:\n                axis_range = get_animation_axis_range(\n            #        scale_var, custom_scale_entry, objects, planetary_params, \n                    scale_var, custom_scale_entry, objects, active_planetary_params,\n                    parent_planets, center_object_name\n                )\n\n                        \n            # Update layout with dynamic scaling\n            fig.update_layout(\n                scene=dict(\n                    xaxis=dict(title='X (AU)', range=axis_range, \n                            backgroundcolor='black', gridcolor='gray', \n                            showbackground=True, showgrid=True),\n                    yaxis=dict(title='Y (AU)', range=axis_range, \n                            backgroundcolor='black', gridcolor='gray', \n                            showbackground=True, showgrid=True),\n                    zaxis=dict(title='Z (AU)', range=axis_range, \n                            backgroundcolor='black', gridcolor='gray', \n                            showbackground=True, showgrid=True),\n                    aspectmode='cube',\n                    camera=get_default_camera(),\n            #        domain=dict(x=[0.25, 1.0], y=[0.15, 1.0])\n                    domain=dict(x=[0.2, 1.0], y=[0.0, 1.0])\n                ),\n            \n                paper_bgcolor='black',\n                plot_bgcolor='black',\n                title_font_color='white',\n                font_color='white',\n                title=\"Paloma's Orrery - Animation Over Below Dates\",\n                showlegend=True,\n                legend=dict(\n                    font=dict(color='white'),\n                    x=1,\n                    y=1,\n                    xanchor='left',\n                    yanchor='top'\n                ),\n\n        #        margin=dict(l=75, r=50, t=100, b=100),\n                margin=dict(l=75, r=50, t=80, b=50),\n\n                annotations=[\n\n                    # NEW: Coordinate System explanation box\n                    dict(\n\n                        text=\"<b>Coordinate System (J2000 Ecliptic):</b><br><br>\"\n                            \"<b>+X:</b> Sun's direction from Earth at the vernal equinox (&#9800;)<br><br>\"\n                            \"<b>+Z:</b> Ecliptic North perpendicular to Earth's orbit<br><br>\"\n                            \"<b>XY plane:</b> Ecliptic, Earth's orbital plane<br><br><br>\"\n                            \"<i>See Orbital Parameter Visualization for detailed explanation</i>\" if not is_exoplanet_mode\n                            else \"<b>Coordinate System (Exoplanet):</b><br><br>\"\n                            \"<b>Origin:</b> Host star at (0, 0, 0)<br><br>\"\n                            \"<b>XY plane:</b> Sky plane (perpendicular to Earth)<br><br>\"\n                            \"<b>+Z:</b> Toward Earth (line of sight)<br><br>\"\n                            \"<i>Local system independent of solar system</i>\",\n\n                        xref='paper',\n                        yref='paper',\n                        x=-0.04,\n                        y=0.7,  \n                        showarrow=False,\n                        font=dict(size=11, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top',\n                        bgcolor='rgba(0, 0, 0, 0.3)',\n                        bordercolor='white',\n                        borderwidth=1,\n                        borderpad=4\n                    ),\n\n                    dict(\n                        text=\"Search: <a href='https://www.nasa.gov/' target='_blank'>NASA</a>\",\n                        xref='paper',\n                        yref='paper',\n                        x=0,\n                        y=0.35,\n                        showarrow=False,\n                        font=dict(size=12, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top'\n                    ),\n                    dict(\n                        text=\"Data source: <a href='https://ssd.jpl.nasa.gov/horizons/app.html#/' target='_blank'>JPL Horizons</a>\",\n                        xref='paper',\n                        yref='paper',\n                        x=0,\n                        y=0.3,\n                        showarrow=False,\n                        font=dict(size=12, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top'\n                    ),\n                    dict(\n                        text=\"Click on the legend items <br>to toggle them off or back on:\",\n                        xref='paper',\n                        yref='paper',\n                        x=0.95,\n                        y=1.07,\n                        showarrow=False,\n                        font=dict(size=12, color='white'),\n                        align='left',\n                        xanchor='left',\n                        yanchor='top'\n                    ),\n                ],\n                updatemenus=[\n                    dict(\n                        type='buttons',\n                        showactive=False,\n                        buttons=[\n                            dict(label='Play  ',\n                                method='animate',\n                                args=[None, {'frame': {'duration': 500, 'redraw': True},\n                                        'fromcurrent': True,\n                                        'transition': {'duration': 0}}]),\n                            dict(label='Pause',\n                                method='animate',\n                                args=[[None], {'frame': {'duration': 0},\n                                                'mode': 'immediate',\n                                                'transition': {'duration': 0}}])\n                        ],\n                        x=0.1,\n                        y=0.85\n                    )\n                ]\n            )\n\n            # Add sliders for date navigation\n            sliders = [dict(\n                active=0,\n                steps=[dict(method='animate',\n                            args=[[str(dates_list[k].strftime('%Y-%m-%d %H:%M'))],\n                                {'frame': {'duration': 500, 'redraw': True},\n                                'mode': 'immediate'}],\n                            label=dates_list[k].strftime('%Y-%m-%d %H:%M')) for k in range(N)],\n                transition=dict(duration=0),\n                x=0,\n                y=0,\n                currentvalue=dict(font=dict(size=14), prefix='Date: ', visible=True, xanchor='center'),\n                len=1.0\n            )]\n\n            # First, assign frames to the figure\n            fig.frames = frames\n\n\n            # Then update layout with sliders\n            fig.update_layout(sliders=sliders)\n\n            # Now set the initial slider position (outside try/except)\n            fig.layout.sliders[0].active = 0\n\n            # Explicitly sync the displayed data with the first frame's data\n            # Note: frames now only contain dynamic traces, so we need to map indices\n            for obj_name, trace_idx in trace_indices.items():\n                frame_idx = trace_idx - static_trace_count  # Convert to frame index\n                if (trace_idx >= static_trace_count and  # Only dynamic traces\n                    trace_idx < len(fig.data) and \n                    len(frames) > 0 and \n                    frame_idx < len(frames[0].data)):\n                    fig.data[trace_idx].x = frames[0].data[frame_idx].x\n                    fig.data[trace_idx].y = frames[0].data[frame_idx].y\n                    fig.data[trace_idx].z = frames[0].data[frame_idx].z\n                    fig.data[trace_idx].text = frames[0].data[frame_idx].text\n                    fig.data[trace_idx].customdata = frames[0].data[frame_idx].customdata\n                    fig.data[trace_idx].visible = frames[0].data[frame_idx].visible\n\n            # Add hover toggle buttons\n            fig = add_hover_toggle_buttons(fig)\n\n            # Add camera view buttons with dropdown for different target objects\n            fig = add_look_at_object_buttons(fig, initial_positions, center_object_name)            \n          \n            fig = add_fly_to_object_buttons(fig, initial_positions, center_object_name)  # NEW\n\n            # Add URL buttons before showing/saving\n            fig = add_url_buttons(fig, objects, selected_objects)            \n\n            # Generate default name with timestamp\n            current_date = STATIC_TODAY\n            default_name = f\"{center_object_name}_system_animation_{current_date.strftime('%Y%m%d_%H%M')}\"\n\n            show_animation_safely(fig, default_name)\n\n            # Store fig for social media export\n            _last_plotted_fig[0] = fig\n            _last_plot_name[0] = default_name\n\n            # Update output_label with instructions (schedule on main thread for macOS)\n\n            root.after(0, lambda: output_label.config(\n                text=f\"Animation of objects around {center_object_name} opened in browser.\"\n            ))\n            root.after(0, lambda: progress_bar.stop())\n\n        except Exception as e:\n            root.after(0, lambda msg=str(e): output_label.config(text=f\"Error during animation: {msg}\"))\n            print(f\"Error during animation: {e}\", flush=True)\n            traceback.print_exc()\n            root.after(0, lambda: progress_bar.stop())        ",
    "start_line": 5316,
    "end_line": 6814,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function animation_worker",
    "component_id": "palomas_orrery.animation_worker"
  },
  "palomas_orrery.to_frame_idx": {
    "id": "palomas_orrery.to_frame_idx",
    "name": "to_frame_idx",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "            def to_frame_idx(absolute_idx):\n                \"\"\"Convert absolute fig.data index to frame_data index.\n                Returns None if this is a static trace (not in frame_data).\"\"\"\n                if absolute_idx >= static_trace_count:\n                    return absolute_idx - static_trace_count\n                return None  # Static trace, not in frame_data",
    "start_line": 6423,
    "end_line": 6428,
    "has_docstring": true,
    "docstring": "Convert absolute fig.data index to frame_data index.\nReturns None if this is a static trace (not in frame_data).",
    "parameters": [
      "absolute_idx"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function to_frame_idx",
    "component_id": "palomas_orrery.to_frame_idx"
  },
  "palomas_orrery.on_closing": {
    "id": "palomas_orrery.on_closing",
    "name": "on_closing",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.save_window_config"
    ],
    "source_code": "def on_closing():\n    \"\"\"Handle cleanup when the main window is closed.\"\"\"\n    try:\n        # Save window geometry and sash positions\n        save_window_config()\n        \n        # Clean up temp cache\n        if os.path.exists(TEMP_CACHE_FILE):\n            os.remove(TEMP_CACHE_FILE)\n            print(\"[CLEANUP] Temporary cache file removed\", flush=True)\n        \n        # Existing cleanup code...\n        temp_files = [\"palomas_orrery.html\", \"palomas_orrery_animation.html\"]\n        for temp_file in temp_files:\n            try:\n                if os.path.exists(temp_file):\n                    os.remove(temp_file)\n            except:\n                pass\n    finally:\n        root.destroy()",
    "start_line": 6820,
    "end_line": 6840,
    "has_docstring": true,
    "docstring": "Handle cleanup when the main window is closed.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function on_closing",
    "component_id": "palomas_orrery.on_closing"
  },
  "palomas_orrery.set_palomas_birthday": {
    "id": "palomas_orrery.set_palomas_birthday",
    "name": "set_palomas_birthday",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.update_date_fields"
    ],
    "source_code": "def set_palomas_birthday():\n    update_date_fields(datetime(2005, 2, 4, 1))",
    "start_line": 6846,
    "end_line": 6847,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function set_palomas_birthday",
    "component_id": "palomas_orrery.set_palomas_birthday"
  },
  "palomas_orrery.update_date_fields": {
    "id": "palomas_orrery.update_date_fields",
    "name": "update_date_fields",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def update_date_fields(new_date):\n    entry_year.delete(0, tk.END)\n    entry_year.insert(0, new_date.year)\n    entry_month.delete(0, tk.END)\n    entry_month.insert(0, new_date.month)\n    entry_day.delete(0, tk.END)\n    entry_day.insert(0, new_date.day)\n    entry_hour.delete(0, tk.END)\n    entry_hour.insert(0, new_date.hour)\n    entry_minute.delete(0, tk.END)\n    entry_minute.insert(0, new_date.minute)",
    "start_line": 6850,
    "end_line": 6860,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "new_date"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function update_date_fields",
    "component_id": "palomas_orrery.update_date_fields"
  },
  "palomas_orrery.fill_now": {
    "id": "palomas_orrery.fill_now",
    "name": "fill_now",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.update_date_fields",
      "palomas_orrery.sync_end_date_from_days",
      "palomas_orrery.sync_days_from_dates"
    ],
    "source_code": "def fill_now():\n    now = datetime.now()\n    update_date_fields(now)\n    sync_end_date_from_days()\n\n    # Also ensure event bindings are set up\n    if not hasattr(fill_now, 'initialized'):\n\n        # Bind events for synchronization\n        # When start date or days change, update end date\n        entry_year.bind('<FocusOut>', lambda e: sync_end_date_from_days())\n        entry_month.bind('<FocusOut>', lambda e: sync_end_date_from_days())\n        entry_day.bind('<FocusOut>', lambda e: sync_end_date_from_days())\n        entry_hour.bind('<FocusOut>', lambda e: sync_end_date_from_days())\n        entry_minute.bind('<FocusOut>', lambda e: sync_end_date_from_days())\n        days_to_plot_entry.bind('<FocusOut>', lambda e: sync_end_date_from_days())\n        days_to_plot_entry.bind('<Return>', lambda e: sync_end_date_from_days())  # <-- ADD HERE\n\n        # When end date changes, update days\n        end_entry_year.bind('<FocusOut>', lambda e: sync_days_from_dates())\n        end_entry_month.bind('<FocusOut>', lambda e: sync_days_from_dates())\n        end_entry_day.bind('<FocusOut>', lambda e: sync_days_from_dates())\n        end_entry_hour.bind('<FocusOut>', lambda e: sync_days_from_dates())\n        end_entry_minute.bind('<FocusOut>', lambda e: sync_days_from_dates())\n\n        fill_now.initialized = True",
    "start_line": 6863,
    "end_line": 6888,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fill_now",
    "component_id": "palomas_orrery.fill_now"
  },
  "palomas_orrery.calculate_next_vernal_equinox": {
    "id": "palomas_orrery.calculate_next_vernal_equinox",
    "name": "calculate_next_vernal_equinox",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def calculate_next_vernal_equinox(from_date):\n    \"\"\"\n    Calculate the next vernal equinox (March equinox) from a given date.\n    Uses a simple astronomical approximation.\n    \n    The vernal equinox occurs around March 19-21 each year when the Sun \n    crosses the celestial equator moving northward.\n    \"\"\"\n    year = from_date.year\n    \n    # Check if we've already passed this year's vernal equinox\n    # Vernal equinox is typically March 19-21\n    # We'll use March 20 as an approximation\n    approx_equinox = datetime(year, 3, 20, 0, 0, 0)\n    \n    # If the current date is after this year's approximate equinox,\n    # calculate next year's equinox\n    if from_date >= approx_equinox:\n        year += 1\n    \n    # More accurate calculation using astronomical formula\n    # This gives the approximate time of vernal equinox\n    # Based on Jean Meeus's astronomical algorithms\n    \n    # For years 2000-2100, use this approximation\n    if 2000 <= year <= 2100:\n        # March equinox approximation for year Y\n        Y = year\n        # JDE = Julian Ephemeris Day of the equinox\n        # Simplified formula for March equinox\n        JDE0 = 2451623.80984 + 365242.37404 * (Y - 2000) / 1000.0 + \\\n               0.05169 * ((Y - 2000) / 1000.0) ** 2\n        \n        # Convert JDE to Gregorian calendar\n        # This is a simplified conversion\n        JD = JDE0\n        \n        # Convert Julian Day to datetime\n        # JD 0 corresponds to January 1, 4713 BC at 12:00 GMT\n        a = int(JD + 0.5)\n        if a < 2299161:\n            c = a + 1524\n        else:\n            b = int((a - 1867216.25) / 36524.25)\n            c = a + b - int(b / 4) + 1525\n        \n        d = int((c - 122.1) / 365.25)\n        e = int(365.25 * d)\n        f = int((c - e) / 30.6001)\n        \n        day_frac = c - e - int(30.6001 * f) + (JD + 0.5 - a)\n        day = int(day_frac)\n        \n        month = f - 1 if f < 14 else f - 13\n        year_calc = d - 4716 if month > 2 else d - 4715\n        \n        # Calculate hour and minute from fractional day\n        frac = day_frac - day\n        hour = int(frac * 24)\n        minute = int((frac * 24 - hour) * 60)\n        \n        equinox_date = datetime(year_calc, month, day, hour, minute)\n    else:\n        # For years outside 2000-2100, use simple approximation\n        # March 20 at 00:00 UTC\n        equinox_date = datetime(year, 3, 20, 0, 0, 0)\n    \n    return equinox_date",
    "start_line": 6890,
    "end_line": 6957,
    "has_docstring": true,
    "docstring": "Calculate the next vernal equinox (March equinox) from a given date.\nUses a simple astronomical approximation.\n\nThe vernal equinox occurs around March 19-21 each year when the Sun \ncrosses the celestial equator moving northward.",
    "parameters": [
      "from_date"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_next_vernal_equinox",
    "component_id": "palomas_orrery.calculate_next_vernal_equinox"
  },
  "palomas_orrery.fill_next_vernal_equinox": {
    "id": "palomas_orrery.fill_next_vernal_equinox",
    "name": "fill_next_vernal_equinox",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.calculate_next_vernal_equinox",
      "palomas_orrery.sync_end_date_from_days",
      "palomas_orrery.update_date_fields",
      "palomas_orrery.get_date_from_gui"
    ],
    "source_code": "def fill_next_vernal_equinox():\n    \"\"\"Fill the date fields with the next vernal equinox from the current date.\"\"\"\n    try:\n        current_date = get_date_from_gui()\n    except:\n        current_date = datetime.now()\n    \n    next_equinox = calculate_next_vernal_equinox(current_date)\n    update_date_fields(next_equinox)\n    sync_end_date_from_days()",
    "start_line": 6960,
    "end_line": 6969,
    "has_docstring": true,
    "docstring": "Fill the date fields with the next vernal equinox from the current date.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fill_next_vernal_equinox",
    "component_id": "palomas_orrery.fill_next_vernal_equinox"
  },
  "palomas_orrery.toggle_all_shells": {
    "id": "palomas_orrery.toggle_all_shells",
    "name": "toggle_all_shells",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def toggle_all_shells():\n    \"\"\"Toggle all sun shell checkboxes based on the main shell checkbox.\"\"\"\n    state = sun_shells_var.get()\n    sun_core_var.set(state)\n    sun_radiative_var.set(state)\n    sun_photosphere_var.set(state)\n    sun_chromosphere_var.set(state)\n    sun_inner_corona_var.set(state)\n    sun_outer_corona_var.set(state)\n\n    # Asteroid belt shells\n    asteroid_belt_main_var.set(state)\n    asteroid_belt_hildas_var.set(state)\n    asteroid_belt_trojans_greeks_var.set(state)\n    asteroid_belt_trojans_trojans_var.set(state)\n\n    sun_termination_shock_var.set(state)\n    sun_heliopause_var.set(state)\n\n    sun_inner_oort_limit_var.set(state)\n    sun_inner_oort_var.set(state)\n    sun_outer_oort_var.set(state)\n\n    sun_hills_cloud_torus_var.set(state) \n    sun_outer_oort_clumpy_var.set(state)           \n    sun_galactic_tide_var.set(state)              \n    sun_gravitational_var.set(state)",
    "start_line": 6971,
    "end_line": 6997,
    "has_docstring": true,
    "docstring": "Toggle all sun shell checkboxes based on the main shell checkbox.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function toggle_all_shells",
    "component_id": "palomas_orrery.toggle_all_shells"
  },
  "palomas_orrery.handle_mission_selection": {
    "id": "palomas_orrery.handle_mission_selection",
    "name": "handle_mission_selection",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def handle_mission_selection():\n    # Function no longer adjusts the date based on mission selection\n    pass",
    "start_line": 7000,
    "end_line": 7002,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_mission_selection",
    "component_id": "palomas_orrery.handle_mission_selection"
  },
  "palomas_orrery.animate_one_minute": {
    "id": "palomas_orrery.animate_one_minute",
    "name": "animate_one_minute",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.animate_objects"
    ],
    "source_code": "def animate_one_minute():\n    # Update status before calling animate_objects\n    output_label.config(text=\"Preparing minute-by-minute animation. Please wait...\")\n    root.update_idletasks()  # Force GUI to update\n    animate_objects(timedelta(minutes=1), \"Minute\") ",
    "start_line": 7006,
    "end_line": 7010,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function animate_one_minute",
    "component_id": "palomas_orrery.animate_one_minute"
  },
  "palomas_orrery.animate_one_hour": {
    "id": "palomas_orrery.animate_one_hour",
    "name": "animate_one_hour",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.animate_objects"
    ],
    "source_code": "def animate_one_hour():\n    output_label.config(text=\"Preparing hour-by-hour animation. Please wait...\")\n    root.update_idletasks()\n    animate_objects(timedelta(hours=1), \"Hour\") ",
    "start_line": 7012,
    "end_line": 7015,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function animate_one_hour",
    "component_id": "palomas_orrery.animate_one_hour"
  },
  "palomas_orrery.animate_one_day": {
    "id": "palomas_orrery.animate_one_day",
    "name": "animate_one_day",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.animate_objects"
    ],
    "source_code": "def animate_one_day():\n    output_label.config(text=\"Preparing day-by-day animation. Please wait...\")\n    root.update_idletasks()\n    animate_objects(timedelta(days=1), \"Day\") ",
    "start_line": 7017,
    "end_line": 7020,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function animate_one_day",
    "component_id": "palomas_orrery.animate_one_day"
  },
  "palomas_orrery.animate_one_week": {
    "id": "palomas_orrery.animate_one_week",
    "name": "animate_one_week",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.animate_objects"
    ],
    "source_code": "def animate_one_week():\n    output_label.config(text=\"Preparing week-by-week animation. Please wait...\")\n    root.update_idletasks()\n    animate_objects(timedelta(weeks=1), \"Week\")            ",
    "start_line": 7023,
    "end_line": 7026,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function animate_one_week",
    "component_id": "palomas_orrery.animate_one_week"
  },
  "palomas_orrery.animate_one_month": {
    "id": "palomas_orrery.animate_one_month",
    "name": "animate_one_month",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.animate_objects"
    ],
    "source_code": "def animate_one_month():\n    output_label.config(text=\"Preparing month-by-month animation. Please wait...\")\n    root.update_idletasks()\n    animate_objects('month', \"Month\")",
    "start_line": 7028,
    "end_line": 7031,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function animate_one_month",
    "component_id": "palomas_orrery.animate_one_month"
  },
  "palomas_orrery.animate_one_year": {
    "id": "palomas_orrery.animate_one_year",
    "name": "animate_one_year",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.animate_objects"
    ],
    "source_code": "def animate_one_year():\n    output_label.config(text=\"Preparing year-by-year animation. Please wait...\")\n    root.update_idletasks()\n    animate_objects('year', \"Year\")",
    "start_line": 7033,
    "end_line": 7036,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function animate_one_year",
    "component_id": "palomas_orrery.animate_one_year"
  },
  "palomas_orrery.animate_palomas_birthday": {
    "id": "palomas_orrery.animate_palomas_birthday",
    "name": "animate_palomas_birthday",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.set_palomas_birthday",
      "palomas_orrery.animate_objects"
    ],
    "source_code": "def animate_palomas_birthday():\n    # Set Paloma's birthday in the date fields\n    set_palomas_birthday()\n    \n    # Define Paloma's birth date\n    paloma_birthday = datetime(2005, 2, 4, 1, 0, 0)  # February 4, 2005 at 01:00\n    \n    # Get the current date\n    current_date = datetime.today()\n    \n    # Calculate Paloma's age\n    age = current_date.year - paloma_birthday.year - ((current_date.month, current_date.day) < (paloma_birthday.month, paloma_birthday.day))\n    \n    # Set the number of frames to Paloma's age plus one\n    num_frames = age + 1\n    num_frames_entry.delete(0, tk.END)  # Clear existing value\n    num_frames_entry.insert(0, str(num_frames))  # Insert new value\n    \n    # Optionally, update the hour to 0 for consistency\n    entry_hour.delete(0, tk.END)\n    entry_hour.insert(0, '0')\n    \n    # Call the animate_objects function with 'year' step\n    animate_objects('year', \"Year\")  ",
    "start_line": 7038,
    "end_line": 7061,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function animate_palomas_birthday",
    "component_id": "palomas_orrery.animate_palomas_birthday"
  },
  "palomas_orrery.report_callback_exception": {
    "id": "palomas_orrery.report_callback_exception",
    "name": "report_callback_exception",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def report_callback_exception(self, exc_type, exc_value, exc_traceback):\n    print('Exception in Tkinter callback', flush=True)\n    traceback.print_exception(exc_type, exc_value, exc_traceback)",
    "start_line": 7068,
    "end_line": 7070,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "self",
      "exc_type",
      "exc_value",
      "exc_traceback"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function report_callback_exception",
    "component_id": "palomas_orrery.report_callback_exception"
  },
  "palomas_orrery.get_end_date_from_gui": {
    "id": "palomas_orrery.get_end_date_from_gui",
    "name": "get_end_date_from_gui",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.get_date_from_gui"
    ],
    "source_code": "def get_end_date_from_gui():\n    \"\"\"Get end date from GUI fields\"\"\"\n    try:\n        return datetime(\n            int(end_entry_year.get()),\n            int(end_entry_month.get()),\n            int(end_entry_day.get()),\n            int(end_entry_hour.get()),\n            int(end_entry_minute.get())\n        )\n    except (ValueError, TypeError):\n        # Return a sensible default if fields are empty/invalid\n        return get_date_from_gui() + timedelta(days=365)",
    "start_line": 7276,
    "end_line": 7288,
    "has_docstring": true,
    "docstring": "Get end date from GUI fields",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_end_date_from_gui",
    "component_id": "palomas_orrery.get_end_date_from_gui"
  },
  "palomas_orrery.sync_end_date_from_days": {
    "id": "palomas_orrery.sync_end_date_from_days",
    "name": "sync_end_date_from_days",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.get_date_from_gui"
    ],
    "source_code": "def sync_end_date_from_days():\n    \"\"\"Calculate end date from start date + days to plot\"\"\"\n    try:\n        start = get_date_from_gui()\n        days = int(days_to_plot_entry.get())\n        end = start + timedelta(days=days)\n        \n        # Check Horizons limits\n        if end > HORIZONS_MAX_DATE:\n            end = HORIZONS_MAX_DATE\n            # Recalculate days\n            days = (end - start).days\n            days_to_plot_entry.delete(0, tk.END)\n            days_to_plot_entry.insert(0, str(days))\n            horizons_warning.config(text=\"WARNING: End date capped at Horizons limit!\", fg='red')\n        else:\n            horizons_warning.config(text=\"WARNING: JPL Horizons limits: Jan 1900 - Dec 2199\", fg='orange')\n        \n        # Update end date fields\n        end_entry_year.delete(0, tk.END)\n        end_entry_year.insert(0, end.year)\n        end_entry_month.delete(0, tk.END)\n        end_entry_month.insert(0, end.month)\n        end_entry_day.delete(0, tk.END)\n        end_entry_day.insert(0, end.day)\n        end_entry_hour.delete(0, tk.END)\n        end_entry_hour.insert(0, end.hour)\n        end_entry_minute.delete(0, tk.END)\n        end_entry_minute.insert(0, end.minute)\n    except ValueError:\n        pass",
    "start_line": 7232,
    "end_line": 7262,
    "has_docstring": true,
    "docstring": "Calculate end date from start date + days to plot",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function sync_end_date_from_days",
    "component_id": "palomas_orrery.sync_end_date_from_days"
  },
  "palomas_orrery.sync_days_from_dates": {
    "id": "palomas_orrery.sync_days_from_dates",
    "name": "sync_days_from_dates",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.get_date_from_gui",
      "palomas_orrery.get_end_date_from_gui"
    ],
    "source_code": "def sync_days_from_dates():\n    \"\"\"Calculate days to plot from start and end dates\"\"\"\n    try:\n        start = get_date_from_gui()\n        end = get_end_date_from_gui()\n        days = (end - start).days\n        \n        days_to_plot_entry.delete(0, tk.END)\n        days_to_plot_entry.insert(0, str(days))\n    except ValueError:\n        pass",
    "start_line": 7264,
    "end_line": 7274,
    "has_docstring": true,
    "docstring": "Calculate days to plot from start and end dates",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function sync_days_from_dates",
    "component_id": "palomas_orrery.sync_days_from_dates"
  },
  "palomas_orrery.can_be_horizons_center": {
    "id": "palomas_orrery.can_be_horizons_center",
    "name": "can_be_horizons_center",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def can_be_horizons_center(obj):\n    \"\"\"Check if object can be used as Horizons coordinate center.\"\"\"\n    obj_name = obj.get('name', 'UNKNOWN')  # ADD THIS\n    \n    excluded_object_types = {'hypothetical', 'exoplanet', 'exo_host_star', 'exo_binary_star', 'trajectory'}\n    if obj.get('object_type') in excluded_object_types:\n        return False\n    \n    # Exclude missions (spacecraft can't be Horizons centers)\n    if obj.get('is_mission'):\n        return False\n\n    # Explicitly exclude binary system components (use barycenter instead)\n#    excluded_names = {'Patroclus', 'Menoetius'}\n    excluded_names = {}\n    if obj.get('name') in excluded_names:\n        print(f\"[DEBUG] Excluding binary component: {obj_name}\", flush=True)  # ADD THIS\n        return False\n\n    # Has explicit center_id? Can be centered\n    if obj.get('center_id'):\n        print(f\"[DEBUG] {obj_name} can be center (has center_id)\", flush=True)  # ADD THIS\n        return True\n    \n    # Otherwise check if main ID is numeric (negative allowed for spacecraft)\n    obj_id = str(obj.get('id', ''))\n    id_to_check = obj_id.lstrip('-')\n    result = id_to_check.isdigit()\n    if result:\n        print(f\"[DEBUG] {obj_name} can be center (numeric ID: {obj_id})\", flush=True)  # ADD THIS\n    return result",
    "start_line": 7306,
    "end_line": 7336,
    "has_docstring": true,
    "docstring": "Check if object can be used as Horizons coordinate center.",
    "parameters": [
      "obj"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function can_be_horizons_center",
    "component_id": "palomas_orrery.can_be_horizons_center"
  },
  "palomas_orrery.create_celestial_checkbutton": {
    "id": "palomas_orrery.create_celestial_checkbutton",
    "name": "create_celestial_checkbutton",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.CreateToolTip",
      "palomas_orrery.can_be_horizons_center"
    ],
    "source_code": "def create_celestial_checkbutton(name, variable):\n    # Bold objects that can be used as centers (determined dynamically)\n    # Strip leading hyphens/spaces used for visual hierarchy (e.g., \"- Orcus\" -> \"Orcus\")\n    lookup_name = name.lstrip('- ')\n    obj_def = next((obj for obj in objects if obj.get('name') == lookup_name), None)\n    is_centerable = obj_def and can_be_horizons_center(obj_def)\n\n    # Also bold exoplanet host stars/barycenters\n    if obj_def and obj_def.get('object_type') in ['exo_host_star', 'exo_barycenter']:\n        is_centerable = True\n        \n    if is_centerable:\n\n        # Create frame to hold checkbox and label\n        frame = tk.Frame(celestial_frame)\n        frame.pack(anchor='w')\n        \n        # Create checkbox without text\n        checkbutton = tk.Checkbutton(frame, text='', variable=variable)\n        checkbutton.pack(side='left')\n        \n        # Create bold label\n        label = tk.Label(frame, text=name, font=(\"Arial\", 10, \"bold\"))\n        label.pack(side='left')\n        \n        # Add tooltip to the frame\n        info_text = INFO.get(name.strip('- '), \"No information available\")\n        CreateToolTip(frame, info_text)\n\n        # Track creation order for center dropdown\n        checkbox_creation_order.append(name)\n\n    else:\n        # Regular checkbutton for other objects\n        checkbutton = tk.Checkbutton(celestial_frame, text=name, variable=variable)\n        checkbutton.pack(anchor='w')\n        info_text = INFO.get(name.strip('- '), \"No information available\")\n        CreateToolTip(checkbutton, info_text)\n\n        # Track creation order for center dropdown\n        checkbox_creation_order.append(name)",
    "start_line": 7342,
    "end_line": 7382,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name",
      "variable"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_celestial_checkbutton",
    "component_id": "palomas_orrery.create_celestial_checkbutton"
  },
  "palomas_orrery.create_mission_checkbutton": {
    "id": "palomas_orrery.create_mission_checkbutton",
    "name": "create_mission_checkbutton",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.CreateToolTip"
    ],
    "source_code": "def create_mission_checkbutton(name, variable, dates):\n    checkbutton = tk.Checkbutton(mission_frame, text=f\"{name} {dates}\", variable=variable, command=handle_mission_selection)\n    checkbutton.pack(anchor='w')\n\n    info_text = INFO.get(name, \"No information available\")\n    tooltip_text = f\"{info_text}\\nMission duration: {dates}\"\n    if 'mission_url' in INFO:\n        tooltip_text += f\"\\nMore Info: {INFO['mission_url']}\"\n    CreateToolTip(checkbutton, tooltip_text)",
    "start_line": 7789,
    "end_line": 7797,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "name",
      "variable",
      "dates"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_mission_checkbutton",
    "component_id": "palomas_orrery.create_mission_checkbutton"
  },
  "palomas_orrery.create_comet_checkbutton": {
    "id": "palomas_orrery.create_comet_checkbutton",
    "name": "create_comet_checkbutton",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.CreateToolTip"
    ],
    "source_code": "def create_comet_checkbutton(name, variable, dates, perihelion):\n    \"\"\"\n    Creates a checkbutton for a comet with a tooltip containing its description and perihelion date.\n\n    Parameters:\n    - name (str): The name of the comet.\n    - variable (tk.IntVar): The Tkinter variable linked to the checkbutton.\n    - dates (str): The mission duration or observation period.\n    - perihelion (str): The date of perihelion passage.\n    \"\"\"\n    checkbutton = tk.Checkbutton(\n        comet_frame,\n        text=f\"{name} {dates}\",\n        variable=variable,\n        command=handle_mission_selection\n    )\n    checkbutton.pack(anchor='w')\n\n    # Fetch the description from INFO\n    info_text = INFO.get(name, \"No information available.\")\n\n    # Create the tooltip with description and perihelion\n    tooltip_text = f\"{info_text}\\nPerihelion: {perihelion}\"\n    CreateToolTip(checkbutton, tooltip_text)",
    "start_line": 7833,
    "end_line": 7856,
    "has_docstring": true,
    "docstring": "Creates a checkbutton for a comet with a tooltip containing its description and perihelion date.\n\nParameters:\n- name (str): The name of the comet.\n- variable (tk.IntVar): The Tkinter variable linked to the checkbutton.\n- dates (str): The mission duration or observation period.\n- perihelion (str): The date of perihelion passage.",
    "parameters": [
      "name",
      "variable",
      "dates",
      "perihelion"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_comet_checkbutton",
    "component_id": "palomas_orrery.create_comet_checkbutton"
  },
  "palomas_orrery.create_interstellar_checkbutton": {
    "id": "palomas_orrery.create_interstellar_checkbutton",
    "name": "create_interstellar_checkbutton",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.CreateToolTip"
    ],
    "source_code": "def create_interstellar_checkbutton(name, variable, dates, perihelion):\n    \"\"\"\n    Creates a checkbutton for a comet with a tooltip containing its description and perihelion date.\n\n    Parameters:\n    - name (str): The name of the interstellar object.\n    - variable (tk.IntVar): The Tkinter variable linked to the checkbutton.\n    - dates (str): The mission duration or observation period.\n    - perihelion (str): The date of perihelion passage.\n    \"\"\"\n    checkbutton = tk.Checkbutton(\n        interstellar_frame,\n        text=f\"{name} {dates}\",\n        variable=variable,\n        command=handle_mission_selection\n    )\n    checkbutton.pack(anchor='w')\n\n    # Fetch the description from INFO\n    info_text = INFO.get(name, \"No information available.\")\n\n    # Create the tooltip with description and perihelion\n    tooltip_text = f\"{info_text}\\nPerihelion: {perihelion}\"\n    CreateToolTip(checkbutton, tooltip_text)",
    "start_line": 7894,
    "end_line": 7917,
    "has_docstring": true,
    "docstring": "Creates a checkbutton for a comet with a tooltip containing its description and perihelion date.\n\nParameters:\n- name (str): The name of the interstellar object.\n- variable (tk.IntVar): The Tkinter variable linked to the checkbutton.\n- dates (str): The mission duration or observation period.\n- perihelion (str): The date of perihelion passage.",
    "parameters": [
      "name",
      "variable",
      "dates",
      "perihelion"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_interstellar_checkbutton",
    "component_id": "palomas_orrery.create_interstellar_checkbutton"
  },
  "palomas_orrery.toggle_special_fetch_mode": {
    "id": "palomas_orrery.toggle_special_fetch_mode",
    "name": "toggle_special_fetch_mode",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def toggle_special_fetch_mode():\n    \"\"\"DEPRECATED: Special fetch mode removed - two-layer trajectories provide automatic detail\"\"\"\n    pass  # Function kept as stub for compatibility but does nothing",
    "start_line": 7958,
    "end_line": 7960,
    "has_docstring": true,
    "docstring": "DEPRECATED: Special fetch mode removed - two-layer trajectories provide automatic detail",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function toggle_special_fetch_mode",
    "component_id": "palomas_orrery.toggle_special_fetch_mode"
  },
  "palomas_orrery.create_exoplanet_checkbutton": {
    "id": "palomas_orrery.create_exoplanet_checkbutton",
    "name": "create_exoplanet_checkbutton",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.CreateToolTip"
    ],
    "source_code": "def create_exoplanet_checkbutton(name, variable, is_star=False):\n    \"\"\"Create checkbutton for exoplanet objects\"\"\"\n    if is_star:\n        # Stars get bold labels (same style as main planets)\n        frame = tk.Frame(exoplanet_frame)\n        frame.pack(anchor='w')\n        checkbutton = tk.Checkbutton(frame, text='', variable=variable)\n        checkbutton.pack(side='left')\n        label = tk.Label(frame, text=name, font=(\"Arial\", 10, \"bold\"))\n        label.pack(side='left')\n        info_text = INFO.get(name.strip('- '), \"Exoplanet host star\\n\"\n        \"***IMPORTANT: RE-SET THE CENTER OBJECT FROM \\\"Sun\\\" TO THE EXO-PLANET SYSTEM\\n\" \n              \"IN THE \\\"Select Center Object for Your Plot\\\" DROP DOWN MENU***\")\n        CreateToolTip(frame, info_text)\n    else:\n        # Planets get regular checkbuttons\n        checkbutton = tk.Checkbutton(exoplanet_frame, text=name, variable=variable)\n        checkbutton.pack(anchor='w')\n        info_text = INFO.get(name.strip('- '), \"Exoplanet\")\n        CreateToolTip(checkbutton, info_text)",
    "start_line": 7974,
    "end_line": 7993,
    "has_docstring": true,
    "docstring": "Create checkbutton for exoplanet objects",
    "parameters": [
      "name",
      "variable",
      "is_star"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_exoplanet_checkbutton",
    "component_id": "palomas_orrery.create_exoplanet_checkbutton"
  },
  "palomas_orrery.open_star_visualization": {
    "id": "palomas_orrery.open_star_visualization",
    "name": "open_star_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def open_star_visualization():\n    \"\"\"Inform user about standalone Star Visualization executable.\"\"\"\n    # Platform-aware executable name\n    if platform.system() == 'Darwin':  # macOS\n        exe_name = \"star_visualization.app (or run star_visualization_gui.py)\"\n    elif platform.system() == 'Windows':\n        exe_name = \"star_visualization.exe\"\n    else:  # Linux\n        exe_name = \"star_visualization_gui.py\"\n    \n    message = f\"\"\"Star Visualization is available as a separate application.\n\nPlease run '{exe_name}' from the same folder as this application.\n\nThe Star Visualization provides:\n- 2D and 3D stellar neighborhood plots\n- HR diagrams by distance or magnitude\n- Star search and property lookup\n- Data for 123,000+ stars\"\"\"\n    \n    messagebox.showinfo(\"Star Visualization\", message)",
    "start_line": 7995,
    "end_line": 8015,
    "has_docstring": true,
    "docstring": "Inform user about standalone Star Visualization executable.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function open_star_visualization",
    "component_id": "palomas_orrery.open_star_visualization"
  },
  "palomas_orrery.launch_galactic_center": {
    "id": "palomas_orrery.launch_galactic_center",
    "name": "launch_galactic_center",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "sgr_a_grand_tour.create_grand_tour_dashboard"
    ],
    "source_code": "def launch_galactic_center():\n    \"\"\"Launch the Sagittarius A* Grand Tour visualization.\"\"\"\n    import os\n    import webbrowser\n    \n    # Path to the HTML file (same directory as this script)\n    script_dir = os.path.dirname(os.path.abspath(__file__))\n    html_path = os.path.join(script_dir, \"sgr_a_grand_tour.html\")\n    \n    # Check if HTML exists\n    if os.path.exists(html_path):\n        # Open in default browser\n        webbrowser.open('file://' + os.path.realpath(html_path))\n        print(f\"[GALACTIC CENTER] Opened visualization: {html_path}\", flush=True)\n    else:\n        # Try to generate it\n        print(f\"[GALACTIC CENTER] HTML not found, attempting to generate...\", flush=True)\n        try:\n            # Import and run the generator\n            import sgr_a_grand_tour as sgr\n            fig = sgr.create_grand_tour_dashboard()\n            fig.write_html(html_path)\n            print(f\"[GALACTIC CENTER] Generated: {html_path}\", flush=True)\n            webbrowser.open('file://' + os.path.realpath(html_path))\n        except ImportError as e:\n            print(f\"[GALACTIC CENTER] ERROR: Missing module - {e}\", flush=True)\n            print(\"Please ensure sgr_a_grand_tour.py and dependencies are in the same folder.\", flush=True)\n            # Show error dialog\n            import tkinter.messagebox as messagebox\n            messagebox.showerror(\"Galactic Center\", \n                f\"Could not launch visualization.\\n\\n\"\n                f\"Missing module: {e}\\n\\n\"\n                f\"Please ensure these files are in the same folder:\\n\"\n                f\"- sgr_a_star_data.py\\n\"\n                f\"- sgr_a_visualization_core.py\\n\"\n                f\"- sgr_a_grand_tour.py\")\n        except Exception as e:\n            print(f\"[GALACTIC CENTER] ERROR: {e}\", flush=True)\n            import tkinter.messagebox as messagebox\n            messagebox.showerror(\"Galactic Center\", f\"Error launching visualization:\\n{e}\")",
    "start_line": 8068,
    "end_line": 8107,
    "has_docstring": true,
    "docstring": "Launch the Sagittarius A* Grand Tour visualization.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function launch_galactic_center",
    "component_id": "palomas_orrery.launch_galactic_center"
  },
  "palomas_orrery.update_center_dropdown": {
    "id": "palomas_orrery.update_center_dropdown",
    "name": "update_center_dropdown",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.can_be_horizons_center"
    ],
    "source_code": "def update_center_dropdown(*args):\n    \"\"\"\n    Update the center dropdown to show only Sun + selected centerable objects.\n    Called whenever any object checkbox changes state.\n    \"\"\"\n    # Get currently selected objects that can be centers\n    # Also include the current center (it may be shadowed/unchecked but should stay in dropdown)\n    selected_centerable = []\n    current_center = center_object_var.get()\n    \n    for obj in objects:\n        obj_name = obj['name']\n        \n        # Check if object is selected OR if it's the current center (shadowed)\n        is_selected = obj.get('var') and obj['var'].get() == 1\n        is_current_center = (obj_name == current_center)\n        \n        if is_selected or is_current_center:\n            # Check if it can be a center (solar system object)\n            if can_be_horizons_center(obj):\n                if obj_name not in selected_centerable:\n                    selected_centerable.append(obj_name)\n            # Also check for exoplanet host stars\n            elif obj.get('object_type') in ['exo_host_star', 'exo_barycenter']:\n                if obj_name not in selected_centerable:\n                    selected_centerable.append(obj_name)\n    \n    # Build new options: Sun first, then selected objects in checkbox creation order\n    ordered_centers = []\n    for name in checkbox_creation_order:\n        if name in selected_centerable:\n            ordered_centers.append(name)\n    # Add any barycenters that aren't in checkbox_creation_order (auto-added ones)\n    for name in selected_centerable:\n        if name not in ordered_centers:\n            ordered_centers.append(name)\n    \n    new_options = ['Sun'] + ordered_centers\n    \n    # Update the dropdown values\n    center_menu['values'] = new_options\n    \n    # If current selection is no longer valid, revert to Sun\n    if current_center not in new_options:\n        center_object_var.set('Sun')\n        print(f\"[CENTER MENU] '{current_center}' deselected, reverting to Sun\", flush=True)\n    \n    # Debug output (can be removed later)\n    if len(selected_centerable) > 0:\n        print(f\"[CENTER MENU] Dynamic centers: Sun + {selected_centerable}\", flush=True)",
    "start_line": 8226,
    "end_line": 8275,
    "has_docstring": true,
    "docstring": "Update the center dropdown to show only Sun + selected centerable objects.\nCalled whenever any object checkbox changes state.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function update_center_dropdown",
    "component_id": "palomas_orrery.update_center_dropdown"
  },
  "palomas_orrery.setup_center_dropdown_traces": {
    "id": "palomas_orrery.setup_center_dropdown_traces",
    "name": "setup_center_dropdown_traces",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def setup_center_dropdown_traces():\n    \"\"\"Add traces to all object IntVars to update center dropdown on selection change.\"\"\"\n    trace_count = 0\n    for obj in objects:\n        if obj.get('var'):\n            obj['var'].trace_add('write', update_center_dropdown)\n            trace_count += 1\n    print(f\"[CENTER MENU] Added traces to {trace_count} object variables\", flush=True)",
    "start_line": 8287,
    "end_line": 8294,
    "has_docstring": true,
    "docstring": "Add traces to all object IntVars to update center dropdown on selection change.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function setup_center_dropdown_traces",
    "component_id": "palomas_orrery.setup_center_dropdown_traces"
  },
  "palomas_orrery.on_center_change": {
    "id": "palomas_orrery.on_center_change",
    "name": "on_center_change",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery.update_status_display"
    ],
    "source_code": "def on_center_change(*args):\n    \"\"\"Update frame title when the center object is changed.\n    Also shadows/unshadows checkboxes to prevent duplicate legend entries.\n    \"\"\"\n    center_object = center_object_var.get()\n    previous_center = _previous_center[0]\n    \n    # Just update the frame title, don't fetch any data\n    orbit_path_frame.config(text=f\"Standard Orbit Path Fetching Controls for JSON Cache (Center: {center_object})\")\n    \n    # Update status to show current center\n    update_status_display(f\"Center changed to: {center_object}\", 'info')\n    \n    # CHECKBOX SHADOWING: Prevent duplicate legend entries\n    # When an object becomes the center, uncheck it (it's shown at origin anyway)\n    # When it stops being the center, restore its checked state\n    \n    # Restore previous center's checkbox if it was a non-Sun object\n    if previous_center != 'Sun':\n        prev_obj = next((obj for obj in objects if obj['name'] == previous_center), None)\n        if prev_obj and prev_obj.get('var'):\n            # Check if the object was shadowed (has _was_checked flag)\n            if prev_obj.get('_was_checked', False):\n                prev_obj['var'].set(1)\n                prev_obj['_was_checked'] = False\n                print(f\"[CENTER MENU] Restored checkbox for '{previous_center}'\", flush=True)\n    \n    # Shadow the new center's checkbox if it's not Sun\n    if center_object != 'Sun':\n        new_obj = next((obj for obj in objects if obj['name'] == center_object), None)\n        if new_obj and new_obj.get('var'):\n            if new_obj['var'].get() == 1:\n                new_obj['_was_checked'] = True\n                new_obj['var'].set(0)\n                print(f\"[CENTER MENU] Shadowed checkbox for '{center_object}' (will restore when center changes)\", flush=True)\n    \n    # Update previous center tracker\n    _previous_center[0] = center_object",
    "start_line": 8305,
    "end_line": 8342,
    "has_docstring": true,
    "docstring": "Update frame title when the center object is changed.\nAlso shadows/unshadows checkboxes to prevent duplicate legend entries.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function on_center_change",
    "component_id": "palomas_orrery.on_center_change"
  },
  "palomas_orrery.open_orbital_param_visualization": {
    "id": "palomas_orrery.open_orbital_param_visualization",
    "name": "open_orbital_param_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [
      "palomas_orrery_helpers.fetch_trajectory",
      "orbital_param_viz.create_orbital_viz_window",
      "palomas_orrery.get_date_from_gui"
    ],
    "source_code": "def open_orbital_param_visualization():\n    \"\"\"\n    Opens the orbital parameter visualization window by calling the\n    dedicated function in orbital_param_viz.py.\n    \"\"\"\n    # Access global variables\n    global date_entry, center_object_var, objects\n    \n    # Collect current positions from the latest data\n    current_positions = {}\n    \n    # Get the current date being displayed\n    current_date = None\n    try:\n#        current_date = datetime.strptime(date_entry.get(), '%Y-%m-%d')\n        current_date = get_date_from_gui()\n    except:\n        current_date = datetime.now()\n    \n    # Get the current center object\n    center = center_object_var.get() if center_object_var else 'Sun'\n    center_id = None\n    \n    # Find center object ID\n    for obj in objects:\n        if obj['name'] == center:\n            center_id = obj['id']\n            break\n    \n    if center_id is None:\n        center_id = 0  # Sun\n    \n    print(f\"Fetching positions for orbital parameter visualization...\", flush=True)\n    print(f\"  Date: {current_date.strftime('%Y-%m-%d')}\", flush=True)\n    print(f\"  Center: {center} (ID: {center_id})\", flush=True)\n    \n    # Debug: Show all objects and their selection status\n    print(f\"  Total objects: {len(objects)}\", flush=True)\n    selected_count = 0\n    \n    for obj in objects:\n        is_selected = obj['var'].get() == 1\n        if is_selected:\n            selected_count += 1\n            print(f\"  Selected: {obj['name']} (ID: {obj['id']}, type: {obj.get('id_type', 'None')})\", flush=True)\n            \n            if obj['name'] != center:  # Don't fetch position for center object\n                try:\n                    # Use fetch_trajectory to get just one position\n                    dates_list = [current_date.strftime('%Y-%m-%d')]\n                    print(f\"    Fetching trajectory for dates: {dates_list}\", flush=True)\n                    \n                    trajectory = fetch_trajectory(\n                        obj['id'], \n                        dates_list,\n                        center_id=center_id,\n                        id_type=obj.get('id_type', None)\n                    )\n                    \n                    print(f\"    Trajectory result: {trajectory}\", flush=True)\n                    \n                    if trajectory and len(trajectory) > 0 and trajectory[0] is not None:\n                        position = trajectory[0]\n                        if 'x' in position:\n                            current_positions[obj['name']] = position\n                            print(f\"    Success: {obj['name']}: ({position['x']:.3f}, {position['y']:.3f}, {position['z']:.3f})\", flush=True)\n                        else:\n                            print(f\"    No position data in trajectory for {obj['name']}\", flush=True)\n                    else:\n                        print(f\"    Empty trajectory for {obj['name']}\", flush=True)\n                except Exception as e:\n                    print(f\"    Error fetching position for {obj['name']}: {e}\", flush=True)\n                    import traceback\n                    traceback.print_exc()\n    \n    print(f\"  Total selected objects: {selected_count}\", flush=True)\n    print(f\"Passing {len(current_positions)} object positions to orbital viz\", flush=True)\n    \n    # Call the visualization window with current positions\n    create_orbital_viz_window(root, objects, planetary_params, parent_planets,\n                            current_positions=current_positions,\n                            current_date=current_date)",
    "start_line": 8743,
    "end_line": 8824,
    "has_docstring": true,
    "docstring": "Opens the orbital parameter visualization window by calling the\ndedicated function in orbital_param_viz.py.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function open_orbital_param_visualization",
    "component_id": "palomas_orrery.open_orbital_param_visualization"
  },
  "palomas_orrery.restore_sash_positions": {
    "id": "palomas_orrery.restore_sash_positions",
    "name": "restore_sash_positions",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery.py",
    "relative_path": "palomas_orrery.py",
    "depends_on": [],
    "source_code": "def restore_sash_positions():\n    try:\n        positions = None\n        if saved_config and saved_config.get('platform') == platform.system():\n            positions = saved_config.get('sash_positions')\n        if positions and len(positions) >= 2:\n            main_paned.sash_place(0, positions[0], 0)\n            main_paned.sash_place(1, positions[1], 0)\n            print(f\"Restored sash positions: {positions}\", flush=True)\n        else:\n            main_paned.sash_place(0, DEFAULT_SASH[0], 0)\n            main_paned.sash_place(1, DEFAULT_SASH[1], 0)\n            print(f\"Using default sash positions: {DEFAULT_SASH}\", flush=True)\n    except Exception as e:\n        print(f\"Note: Could not restore sash positions: {e}\", flush=True)",
    "start_line": 8915,
    "end_line": 8929,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function restore_sash_positions",
    "component_id": "palomas_orrery.restore_sash_positions"
  },
  "palomas_orrery_helpers.calculate_planet9_position_on_orbit": {
    "id": "palomas_orrery_helpers.calculate_planet9_position_on_orbit",
    "name": "calculate_planet9_position_on_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery_helpers.py",
    "relative_path": "palomas_orrery_helpers.py",
    "depends_on": [],
    "source_code": "def calculate_planet9_position_on_orbit(a=600, e=0.30, i=6, omega=150, Omega=90, theta=75):\n    \"\"\"\n    Calculate position that lies exactly on the orbit defined by the parameters\n    \n    Parameters:\n        a: Semi-major axis in AU\n        e: Eccentricity\n        i: Inclination in degrees\n        omega: Argument of perihelion in degrees\n        Omega: Longitude of ascending node in degrees\n        theta: True anomaly in degrees - adjusted to place object on orbit\n    \n    Returns:\n        (x, y, z) position in AU and range (distance from Sun)\n    \"\"\"\n    # Convert angles to radians\n    i_rad = math.radians(i)\n    omega_rad = math.radians(omega)\n    Omega_rad = math.radians(Omega)\n    theta_rad = math.radians(theta)\n    \n    # Calculate distance from Sun at this point in the orbit\n    r = a * (1 - e**2) / (1 + e * math.cos(theta_rad))\n    \n    # Calculate position in orbital plane\n    x_orbit = r * math.cos(theta_rad)\n    y_orbit = r * math.sin(theta_rad)\n    \n    # Rotate to account for orientation of orbit in 3D space\n    # First, rotate by argument of perihelion\n    x_perihelion = x_orbit * math.cos(omega_rad) - y_orbit * math.sin(omega_rad)\n    y_perihelion = x_orbit * math.sin(omega_rad) + y_orbit * math.cos(omega_rad)\n    \n    # Then, rotate to account for inclination\n    x_inclined = x_perihelion\n    y_inclined = y_perihelion * math.cos(i_rad)\n    z_inclined = y_perihelion * math.sin(i_rad)\n    \n    # Finally, rotate by longitude of ascending node\n    x = x_inclined * math.cos(Omega_rad) - y_inclined * math.sin(Omega_rad)\n    y = x_inclined * math.sin(Omega_rad) + y_inclined * math.cos(Omega_rad)\n    z = z_inclined\n    \n    # Calculate range for consistency\n    range_val = math.sqrt(x**2 + y**2 + z**2)\n    \n    return x, y, z, range_val",
    "start_line": 205,
    "end_line": 251,
    "has_docstring": true,
    "docstring": "Calculate position that lies exactly on the orbit defined by the parameters\n\nParameters:\n    a: Semi-major axis in AU\n    e: Eccentricity\n    i: Inclination in degrees\n    omega: Argument of perihelion in degrees\n    Omega: Longitude of ascending node in degrees\n    theta: True anomaly in degrees - adjusted to place object on orbit\n\nReturns:\n    (x, y, z) position in AU and range (distance from Sun)",
    "parameters": [
      "a",
      "e",
      "i",
      "omega",
      "Omega",
      "theta"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_planet9_position_on_orbit",
    "component_id": "palomas_orrery_helpers.calculate_planet9_position_on_orbit"
  },
  "palomas_orrery_helpers.rotate_points2": {
    "id": "palomas_orrery_helpers.rotate_points2",
    "name": "rotate_points2",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery_helpers.py",
    "relative_path": "palomas_orrery_helpers.py",
    "depends_on": [],
    "source_code": "def rotate_points2(x, y, z, angle, axis='z'):\n    \"\"\"\n    Rotates points (x,y,z) about the given axis by 'angle' radians.\n    Returns (xr, yr, zr) as numpy arrays.\n    \n    Parameters:\n        x (array-like): x coordinates\n        y (array-like): y coordinates\n        z (array-like): z coordinates\n        angle (float): rotation angle in radians\n        axis (str): axis of rotation ('x', 'y', or 'z')\n        \n    Returns:\n        tuple: (xr, yr, zr) rotated coordinates\n    \"\"\"\n    import numpy as np\n    \n    # Convert inputs to numpy arrays if they aren't already\n    x = np.array(x, copy=True)\n    y = np.array(y, copy=True)\n    z = np.array(z, copy=True)\n\n    # Initialize rotated coordinates\n    xr = x.copy()\n    yr = y.copy()\n    zr = z.copy()\n\n    # Perform rotation based on specified axis\n    if axis == 'z':\n        # Rotate about z-axis\n        xr = x * np.cos(angle) - y * np.sin(angle)\n        yr = x * np.sin(angle) + y * np.cos(angle)\n        # zr remains the same\n    elif axis == 'x':\n        # Rotate about x-axis\n        yr = y * np.cos(angle) - z * np.sin(angle)\n        zr = y * np.sin(angle) + z * np.cos(angle)\n        # xr remains the same\n    elif axis == 'y':\n        # Rotate about y-axis\n        zr = z * np.cos(angle) - x * np.sin(angle)\n        xr = z * np.sin(angle) + x * np.cos(angle)\n        # yr remains the same\n    else:\n        raise ValueError(f\"Unknown rotation axis: {axis}. Use 'x', 'y', or 'z'.\")\n\n    return xr, yr, zr",
    "start_line": 253,
    "end_line": 299,
    "has_docstring": true,
    "docstring": "Rotates points (x,y,z) about the given axis by 'angle' radians.\nReturns (xr, yr, zr) as numpy arrays.\n\nParameters:\n    x (array-like): x coordinates\n    y (array-like): y coordinates\n    z (array-like): z coordinates\n    angle (float): rotation angle in radians\n    axis (str): axis of rotation ('x', 'y', or 'z')\n    \nReturns:\n    tuple: (xr, yr, zr) rotated coordinates",
    "parameters": [
      "x",
      "y",
      "z",
      "angle",
      "axis"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function rotate_points2",
    "component_id": "palomas_orrery_helpers.rotate_points2"
  },
  "palomas_orrery_helpers.calculate_axis_range": {
    "id": "palomas_orrery_helpers.calculate_axis_range",
    "name": "calculate_axis_range",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery_helpers.py",
    "relative_path": "palomas_orrery_helpers.py",
    "depends_on": [],
    "source_code": "def calculate_axis_range(objects_to_plot):\n    \"\"\"Calculate appropriate axis range based on outermost planet\"\"\"\n    # Find the maximum semi-major axis of selected planets\n    max_orbit = max(planetary_params[obj['name']]['a'] \n                   for obj in objects_to_plot \n                   if obj['name'] in planetary_params)\n    \n    # Add 20% padding\n    max_range = max_orbit * 1.2\n    \n    # Print debug info\n    print(f\"\\nAxis range calculation:\")\n    print(f\"Maximum orbit (AU): {max_orbit}\")\n    print(f\"Range with padding:  deg+/-{max_range}\")\n    \n    return [-max_range, max_range]",
    "start_line": 301,
    "end_line": 316,
    "has_docstring": true,
    "docstring": "Calculate appropriate axis range based on outermost planet",
    "parameters": [
      "objects_to_plot"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_axis_range",
    "component_id": "palomas_orrery_helpers.calculate_axis_range"
  },
  "palomas_orrery_helpers.fetch_trajectory": {
    "id": "palomas_orrery_helpers.fetch_trajectory",
    "name": "fetch_trajectory",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery_helpers.py",
    "relative_path": "palomas_orrery_helpers.py",
    "depends_on": [],
    "source_code": "def fetch_trajectory(object_id, dates_list, center_id='Sun', id_type=None):\n    \"\"\"\n    Fetch trajectory data in batch for all dates, handling missing epochs through interpolation.\n    Includes velocity calculations and additional orbital parameters for each point.\n    \n    Parameters:\n        object_id (str): ID of the object to fetch\n        dates_list (list): List of datetime objects\n        center_id (str): ID of central body (default: 'Sun')\n        id_type (str): Type of ID (e.g., None, 'smallbody')\n        \n    Returns:\n        list: List of position dictionaries with complete orbital data\n    \"\"\"\n    # Debug output for BepiColombo\n    if object_id == '-121':\n        print(f\"\\nNOTE: BepiColombo trajectory has a known display bug.\")\n        print(f\"      Position marker shows correctly; trajectory line may not appear.\")\n        print(f\"      Debug: {len(dates_list)} dates requested from {dates_list[0].strftime('%Y-%m-%d')} to {dates_list[-1].strftime('%Y-%m-%d')}\")      \n    \n    # Skip trajectory fetching for Planet 9\n    if object_id == 'planet9_placeholder':\n        # Return a list of None values matching the length of dates_list\n        return [None] * len(dates_list)\n\n    # Skip trajectory fetching for exoplanets (not in JPL Horizons database)\n    if id_type == 'exoplanet':\n        # Exoplanets use separate orbital calculation system\n        return [None] * len(dates_list)\n    \n    try:\n\n        # Convert dates to Julian Date\n        times = Time(dates_list)\n        epochs = times.jd.tolist()\n        \n        # Query Horizons\n        obj = Horizons(id=object_id, id_type=id_type, location='@' + center_id, epochs=epochs)\n        vectors = obj.vectors()\n\n        # Use a small tolerance when matching returned JD to requested epochs\n        tolerance = 1e-3    # original 1e-5 does not work for spacecraft BepiColombo; loosening the tolerance\n        positions = [None] * len(epochs)\n        \n        print(f\"\\nProcessing trajectory for {object_id}:\")\n        print(f\"Requested epochs: {len(epochs)}\")\n        print(f\"Returned vectors: {len(vectors)}\")\n        \n        # First pass: Match direct positions using tolerance\n        for vec in vectors:\n            jd_returned = float(vec['datetime_jd'])\n            # Find the closest epoch in our list\n            differences = [abs(jd_returned - epoch) for epoch in epochs]\n            idx = differences.index(min(differences))\n            if differences[idx] < tolerance:\n                # Extract position components\n                x = float(vec['x']) if 'x' in vec.colnames else None\n                y = float(vec['y']) if 'y' in vec.colnames else None\n                z = float(vec['z']) if 'z' in vec.colnames else None\n                \n                # Extract velocity components\n                vx = float(vec['vx']) if 'vx' in vec.colnames else None\n                vy = float(vec['vy']) if 'vy' in vec.colnames else None\n                vz = float(vec['vz']) if 'vz' in vec.colnames else None\n                \n                # Calculate velocity magnitude\n                velocity = np.sqrt(vx**2 + vy**2 + vz**2) if (vx is not None and \n                                                             vy is not None and \n                                                             vz is not None) else 'N/A'\n                \n                # Extract range and range_rate\n                range_ = float(vec['range']) if 'range' in vec.colnames else None\n                range_rate = float(vec['range_rate']) if 'range_rate' in vec.colnames else None\n                \n                # Calculate distance in light-minutes and light-hours\n                distance_km = range_ * KM_PER_AU if range_ is not None else 'N/A'\n                distance_lm = range_ * LIGHT_MINUTES_PER_AU if range_ is not None else 'N/A'\n                distance_lh = (distance_lm / 60) if isinstance(distance_lm, float) else 'N/A'\n                \n                # Store complete position data\n                positions[idx] = {\n                    'x': x,\n                    'y': y,\n                    'z': z,\n                    'vx': vx,\n                    'vy': vy,\n                    'vz': vz,\n                    'velocity': velocity,\n                    'range': range_,\n                    'range_rate': range_rate,\n                    'distance_km': distance_km,\n                    'distance_lm': distance_lm,\n                    'distance_lh': distance_lh,\n                    'date': dates_list[idx]\n                }\n\n        # Count how many direct matches we got\n        direct_matches = sum(1 for pos in positions if pos is not None)\n        print(f\"Direct position matches: {direct_matches}\")\n\n        # Second pass: Fill in missing entries through interpolation\n        interpolated_count = 0\n        for i in range(len(positions)):\n            if positions[i] is None:\n                # Search backward for previous valid position\n                prev_idx = i - 1\n                while prev_idx >= 0 and positions[prev_idx] is None:\n                    prev_idx -= 1\n                    \n                # Search forward for next valid position\n                next_idx = i + 1\n                while next_idx < len(positions) and positions[next_idx] is None:\n                    next_idx += 1\n\n                # Attempt interpolation if we have both bounds\n                if prev_idx >= 0 and next_idx < len(positions):\n                    # Calculate interpolation fraction based on timestamps\n                    t0 = dates_list[prev_idx].timestamp()\n                    t1 = dates_list[next_idx].timestamp()\n                    t = dates_list[i].timestamp()\n                    frac = (t - t0) / (t1 - t0)\n                    \n                    # Linear interpolation for position\n                    interp_x = (1 - frac) * positions[prev_idx]['x'] + frac * positions[next_idx]['x']\n                    interp_y = (1 - frac) * positions[prev_idx]['y'] + frac * positions[next_idx]['y']\n                    interp_z = (1 - frac) * positions[prev_idx]['z'] + frac * positions[next_idx]['z']\n                    \n                    # Initialize interpolated values\n                    interp_vx = None\n                    interp_vy = None\n                    interp_vz = None\n                    interp_velocity = 'N/A'\n                    interp_range = None\n                    interp_range_rate = None\n                    interp_distance_km = 'N/A'\n                    interp_distance_lm = 'N/A'\n                    interp_distance_lh = 'N/A'\n                    \n                    # Interpolate velocity components if available\n                    if (isinstance(positions[prev_idx]['vx'], (int, float)) and \n                        isinstance(positions[next_idx]['vx'], (int, float))):\n                        interp_vx = (1 - frac) * positions[prev_idx]['vx'] + frac * positions[next_idx]['vx']\n                        interp_vy = (1 - frac) * positions[prev_idx]['vy'] + frac * positions[next_idx]['vy']\n                        interp_vz = (1 - frac) * positions[prev_idx]['vz'] + frac * positions[next_idx]['vz']\n                        interp_velocity = np.sqrt(interp_vx**2 + interp_vy**2 + interp_vz**2)\n                    \n                    # Interpolate range if available\n                    if (isinstance(positions[prev_idx]['range'], (int, float)) and \n                        isinstance(positions[next_idx]['range'], (int, float))):\n                        interp_range = (1 - frac) * positions[prev_idx]['range'] + frac * positions[next_idx]['range']\n                        interp_distance_km = interp_range * KM_PER_AU\n                        interp_distance_lm = interp_range * LIGHT_MINUTES_PER_AU\n                        interp_distance_lh = interp_distance_lm / 60\n                    \n                    # Interpolate range_rate if available\n                    if (isinstance(positions[prev_idx]['range_rate'], (int, float)) and \n                        isinstance(positions[next_idx]['range_rate'], (int, float))):\n                        interp_range_rate = (1 - frac) * positions[prev_idx]['range_rate'] + frac * positions[next_idx]['range_rate']\n                    \n                    positions[i] = {\n                        'x': interp_x,\n                        'y': interp_y,\n                        'z': interp_z,\n                        'vx': interp_vx,\n                        'vy': interp_vy,\n                        'vz': interp_vz,\n                        'velocity': interp_velocity,\n                        'range': interp_range,\n                        'range_rate': interp_range_rate,\n                        'distance_km': interp_distance_km,\n                        'distance_lm': interp_distance_lm,\n                        'distance_lh': interp_distance_lh,\n                        'date': dates_list[i]\n                    }\n                    interpolated_count += 1\n                    \n                # If we only have data on one side, use nearest neighbor\n                elif prev_idx >= 0:\n                    positions[i] = positions[prev_idx].copy()\n                    positions[i]['date'] = dates_list[i]\n                    interpolated_count += 1\n                elif next_idx < len(positions):\n                    positions[i] = positions[next_idx].copy()\n                    positions[i]['date'] = dates_list[i]\n                    interpolated_count += 1\n\n        print(f\"Interpolated positions: {interpolated_count}\")\n        print(f\"Final coverage: {direct_matches + interpolated_count}/{len(epochs)} epochs\")\n        \n        # If we have very low coverage, warn the user\n        coverage_pct = (direct_matches + interpolated_count) / len(epochs) * 100\n        if coverage_pct < 50:\n            print(f\"Warning: Low data coverage ({coverage_pct:.1f}%) for {object_id}\")\n        \n        return positions\n        \n    except Exception as e:\n        if \"No ephemeris for target\" in str(e):\n            print(f\"No ephemeris available for {object_id}\")\n            return [None] * len(dates_list)\n        print(f\"Error fetching trajectory for {object_id}: {e}\")\n        traceback.print_exc()  # Add traceback for better debugging\n        return [None] * len(dates_list)",
    "start_line": 318,
    "end_line": 520,
    "has_docstring": true,
    "docstring": "Fetch trajectory data in batch for all dates, handling missing epochs through interpolation.\nIncludes velocity calculations and additional orbital parameters for each point.\n\nParameters:\n    object_id (str): ID of the object to fetch\n    dates_list (list): List of datetime objects\n    center_id (str): ID of central body (default: 'Sun')\n    id_type (str): Type of ID (e.g., None, 'smallbody')\n    \nReturns:\n    list: List of position dictionaries with complete orbital data",
    "parameters": [
      "object_id",
      "dates_list",
      "center_id",
      "id_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_trajectory",
    "component_id": "palomas_orrery_helpers.fetch_trajectory"
  },
  "palomas_orrery_helpers.fetch_orbit_path": {
    "id": "palomas_orrery_helpers.fetch_orbit_path",
    "name": "fetch_orbit_path",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery_helpers.py",
    "relative_path": "palomas_orrery_helpers.py",
    "depends_on": [],
    "source_code": "def fetch_orbit_path(obj_info, start_date, end_date, interval, center_id='@0', id_type=None):\n    \"\"\"\n    Fetch orbit path data from JPL Horizons for the given object between start_date and end_date,\n    using the specified time interval.\n    Returns a dictionary with keys 'x', 'y', and 'z' or None on failure.\n    \n    Parameters:\n        obj_info (dict): Object information dictionary\n        start_date (datetime): Start date for the orbit path\n        end_date (datetime): End date for the orbit path\n        interval (str): Time interval (e.g., \"1d\", \"12h\")\n        center_id (str): ID of the central body (default: '@0' for solar system barycenter)\n        id_type (str): Type of ID for the object (None, 'id', 'smallbody', etc.)\n    \"\"\"\n# def fetch_orbit_path(obj_info, start_date, end_date, interval):\n\n    try:\n        from astroquery.jplhorizons import Horizons\n        # Use the object's id and id_type\n        object_id = obj_info['id']\n        id_type = obj_info.get('id_type', None)\n        \n        # Format the center_id appropriately\n        location = center_id\n        if not location.startswith('@'):\n            location = '@' + location\n\n#        location = \"@0\"  # This typically refers to the solar system barycenter\n        \n        # Format dates as required by Horizons\n        epochs = {\n            'start': start_date.strftime('%Y-%m-%d'),\n            'stop': end_date.strftime('%Y-%m-%d'),\n            'step': interval  # e.g. \"1d\" for one day, \"12h\" for 12 hours\n        }\n\n        # Create Horizons object and fetch vectors        \n        obj = Horizons(id=object_id, id_type=id_type, location=location, epochs=epochs)\n        eph = obj.vectors()\n        \n        # Process the ephemerides table to extract x, y, z coordinates\n        x_coords = list(eph['x'])\n        y_coords = list(eph['y'])\n        z_coords = list(eph['z'])\n        \n        return {'x': x_coords, 'y': y_coords, 'z': z_coords}\n    except Exception as e:\n        print(f\"Error fetching orbit path for {obj_info['name']}: {e}\")\n        return None",
    "start_line": 522,
    "end_line": 570,
    "has_docstring": true,
    "docstring": "Fetch orbit path data from JPL Horizons for the given object between start_date and end_date,\nusing the specified time interval.\nReturns a dictionary with keys 'x', 'y', and 'z' or None on failure.\n\nParameters:\n    obj_info (dict): Object information dictionary\n    start_date (datetime): Start date for the orbit path\n    end_date (datetime): End date for the orbit path\n    interval (str): Time interval (e.g., \"1d\", \"12h\")\n    center_id (str): ID of the central body (default: '@0' for solar system barycenter)\n    id_type (str): Type of ID for the object (None, 'id', 'smallbody', etc.)",
    "parameters": [
      "obj_info",
      "start_date",
      "end_date",
      "interval",
      "center_id",
      "id_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fetch_orbit_path",
    "component_id": "palomas_orrery_helpers.fetch_orbit_path"
  },
  "palomas_orrery_helpers.pad_trajectory": {
    "id": "palomas_orrery_helpers.pad_trajectory",
    "name": "pad_trajectory",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery_helpers.py",
    "relative_path": "palomas_orrery_helpers.py",
    "depends_on": [
      "palomas_orrery_helpers.fetch_trajectory"
    ],
    "source_code": "def pad_trajectory(global_dates, object_start_date, object_end_date, object_id, center_id, id_type):\n    \"\"\"Fetch trajectory and pad with None before start_date and after end_date.\"\"\"\n    # Filter dates within the object's active period\n    filtered_dates = [d for d in global_dates if object_start_date <= d <= object_end_date]\n    # Fetch trajectory for active dates\n    fetched_positions = fetch_trajectory(object_id, filtered_dates, center_id=center_id, id_type=id_type)\n    \n    # Calculate padding\n    start_pad_count = 0\n    end_pad_count = 0\n    \n    # Count dates before start_date\n    for d in global_dates:\n        if d < object_start_date:\n            start_pad_count += 1\n        else:\n            break\n    \n    # Count dates after end_date\n    for d in reversed(global_dates):\n        if d > object_end_date:\n            end_pad_count += 1\n        else:\n            break\n    \n    # Pad with None before and after\n    padded_positions = (\n        [None] * start_pad_count +\n        fetched_positions +\n        [None] * end_pad_count\n    )\n    \n    return padded_positions",
    "start_line": 572,
    "end_line": 604,
    "has_docstring": true,
    "docstring": "Fetch trajectory and pad with None before start_date and after end_date.",
    "parameters": [
      "global_dates",
      "object_start_date",
      "object_end_date",
      "object_id",
      "center_id",
      "id_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function pad_trajectory",
    "component_id": "palomas_orrery_helpers.pad_trajectory"
  },
  "palomas_orrery_helpers.add_url_buttons": {
    "id": "palomas_orrery_helpers.add_url_buttons",
    "name": "add_url_buttons",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery_helpers.py",
    "relative_path": "palomas_orrery_helpers.py",
    "depends_on": [],
    "source_code": "def add_url_buttons(fig, objects_to_plot, selected_objects):\n    \"\"\"\n    Add URL buttons for missions and objects in solar system visualizations.\n    Displays buttons in two rows if needed (max 14 per row).\n    \n    Parameters:\n        fig: plotly figure object\n        objects_to_plot: full list of available objects\n        selected_objects: list of currently selected object names\n        \n    Returns:\n        plotly.graph_objects.Figure: The modified figure with URL buttons added\n    \"\"\"\n    import os\n    \n    # Collect objects with URLs that are currently selected\n    url_objects = []\n    for obj in objects_to_plot:\n        if obj['var'].get() == 1 and ('mission_url' in obj or 'url' in obj):          # adds urls for any object   \n            raw_url = obj.get('mission_url') or obj.get('url')\n            \n            # Handle local HTML files - convert to file:// URL\n            if raw_url and raw_url.endswith('.html') and not raw_url.startswith('http'):\n                # Get absolute path relative to the script location\n                script_dir = os.path.dirname(os.path.abspath(__file__))\n                local_path = os.path.join(script_dir, raw_url)\n                url = 'file://' + os.path.realpath(local_path)\n            else:\n                url = raw_url\n            \n            url_objects.append({\n                'name': obj['name'],\n                'url': url,\n        #        'is_earth': obj['name'].lower() == 'earth'  # <- NEW LINE ADDED FOR EARTH DATA VISUALIZATION\n            })\n\n    # Remove duplicates while preserving order\n    seen = set()\n    url_objects = [x for x in url_objects if x['name'] not in seen and not seen.add(x['name'])]\n    \n    if not url_objects:\n        return fig\n\n    # Get existing annotations and create new list\n    annotations = list(fig.layout.annotations) if fig.layout.annotations else []\n        \n    # Dynamic button layout - sizes based on name length\n    start_x = -0.05\n    char_width = 0.0068  # paper units per character (monospace size 12)\n    button_padding = 0.018  # gap between buttons\n    min_button_width = 0.075\n    max_row_x = 1.05  # right edge of paper\n\n    # Add URL buttons with cumulative positioning\n    current_x = start_x\n    current_row = 0\n    for idx, obj in enumerate(url_objects):\n        padded_name = obj['name']\n        # Calculate width needed for this name\n        name_width = max(min_button_width, len(padded_name) * char_width + button_padding)\n        # Wrap to next row if this button would exceed right edge\n        if current_x + name_width > max_row_x and current_x > start_x:\n            current_row += 1\n            current_x = start_x\n        button_x = current_x\n        button_y = 0.07 - (current_row * 0.06)\n        current_x += name_width\n\n        # >>>>>>>>> NEW CONDITIONAL BLOCK ADDED FOR EARTH SYSTEM VISUALIZATION >>>>>>>>>\n        # Earth gets special styling - professional double border with ocean blue\n        if obj.get('is_earth', False):\n            border_color = '#4AFF00'  # chlorophyll green\n            border_width = 2          # Double border\n            bg_color = 'rgba(46, 134, 171, 0.15)'  # Light blue tint\n            text_color = '#2E86AB'\n        else:\n            # Standard styling for other objects\n            border_color = '#1E90FF'\n            border_width = 1\n            bg_color = 'rgba(255, 255, 255, 0.1)'\n            text_color = '#1E90FF'\n        # <<<<<<<<< END NEW BLOCK <<<<<<<<<\n\n        annotations.append(dict(\n    #        text=f\"<a href='{obj['url']}' target='_blank' style='color:#1E90FF; font-family:monospace;'>{padded_name}</a>\",  # uniform\n            text=f\"<a href='{obj['url']}' target='_blank' style='color:{text_color}; font-family:monospace;'>{padded_name}</a>\",  # uniform\n            xref='paper',\n            yref='paper',\n            x=button_x,\n            y=button_y,  \n            showarrow=False,\n    #        font=dict(size=12, color='#1E90FF'),\n            font=dict(size=12, color=text_color),  # <- CHANGED\n            align='left',\n    #        bgcolor='rgba(255, 255, 255, 0.1)',\n            bgcolor=bg_color,          # <- CHANGED (uses variable)\n    #        bordercolor='#1E90FF',\n            bordercolor=border_color,  # <- CHANGED (uses variable)\n    #        borderwidth=1,\n            borderwidth=border_width,  # <- CHANGED (uses variable - 2 for Earth!)\n            borderpad=4,\n            xanchor='left',\n            yanchor='middle'\n        ))\n\n    # Update layout with new annotations using update_layout\n    fig.update_layout(annotations=annotations)\n    \n    return fig",
    "start_line": 607,
    "end_line": 715,
    "has_docstring": true,
    "docstring": "Add URL buttons for missions and objects in solar system visualizations.\nDisplays buttons in two rows if needed (max 14 per row).\n\nParameters:\n    fig: plotly figure object\n    objects_to_plot: full list of available objects\n    selected_objects: list of currently selected object names\n    \nReturns:\n    plotly.graph_objects.Figure: The modified figure with URL buttons added",
    "parameters": [
      "fig",
      "objects_to_plot",
      "selected_objects"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_url_buttons",
    "component_id": "palomas_orrery_helpers.add_url_buttons"
  },
  "palomas_orrery_helpers.get_default_camera": {
    "id": "palomas_orrery_helpers.get_default_camera",
    "name": "get_default_camera",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery_helpers.py",
    "relative_path": "palomas_orrery_helpers.py",
    "depends_on": [],
    "source_code": "def get_default_camera():\n    \"\"\"Return the default orthographic camera settings for top-down view\"\"\"\n    return {\n        \"projection\": {\n            \"type\": \"orthographic\"\n        },\n        # Looking straight down the z-axis\n        \"eye\": {\"x\": 0, \"y\": 0, \"z\": 1},  # Position above the x-y plane\n        \"center\": {\"x\": 0, \"y\": 0, \"z\": 0},  # Looking at origin\n        \"up\": {\"x\": 0, \"y\": 1, \"z\": 0}  # \"Up\" direction aligned with y-axis\n    }",
    "start_line": 717,
    "end_line": 727,
    "has_docstring": true,
    "docstring": "Return the default orthographic camera settings for top-down view",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_default_camera",
    "component_id": "palomas_orrery_helpers.get_default_camera"
  },
  "palomas_orrery_helpers.print_planet_positions": {
    "id": "palomas_orrery_helpers.print_planet_positions",
    "name": "print_planet_positions",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery_helpers.py",
    "relative_path": "palomas_orrery_helpers.py",
    "depends_on": [],
    "source_code": "def print_planet_positions(positions):\n    \"\"\"Print positions and distances for planets.\"\"\"\n    print(\"\\nCurrent Object Positions:\")\n    print(\"=\" * 50)\n    for name, data in positions.items():\n        if data is None:\n            print(f\"{name:15} No position data available\")\n            continue\n            \n        x = data.get('x', 'N/A')\n        y = data.get('y', 'N/A')\n        z = data.get('z', 'N/A')\n        distance = data.get('range', 'N/A')\n        \n        # Format position information\n        if isinstance(x, (int, float)) and isinstance(y, (int, float)) and isinstance(z, (int, float)):\n            pos_str = f\"({x:8.3f}, {y:8.3f}, {z:8.3f}) AU\"\n        else:\n            pos_str = \"Position data unavailable\"\n            \n        # Format distance information\n        if isinstance(distance, (int, float)):\n            dist_str = f\"{distance:8.3f} AU\"\n        else:\n            dist_str = \"Distance data unavailable\"\n        \n        print(f\"{name:15} Position: {pos_str:35} Distance from center: {dist_str}\")\n    print(\"=\" * 50)",
    "start_line": 729,
    "end_line": 756,
    "has_docstring": true,
    "docstring": "Print positions and distances for planets.",
    "parameters": [
      "positions"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function print_planet_positions",
    "component_id": "palomas_orrery_helpers.print_planet_positions"
  },
  "palomas_orrery_helpers.create_orbit_backup": {
    "id": "palomas_orrery_helpers.create_orbit_backup",
    "name": "create_orbit_backup",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery_helpers.py",
    "relative_path": "palomas_orrery_helpers.py",
    "depends_on": [],
    "source_code": "def create_orbit_backup():\n    \"\"\"Create a backup of orbit cache on startup\"\"\"\n#    if os.path.exists('orbit_paths.json'):\n    if os.path.exists('data/orbit_paths.json'):\n        try:\n    #        shutil.copy('orbit_paths.json', 'orbit_paths_backup.json')\n            shutil.copy('data/orbit_paths.json', 'data/orbit_paths_backup.json')\n    #        file_size = os.path.getsize('orbit_paths.json') / (1024 * 1024)  # MB\n            file_size = os.path.getsize('data/orbit_paths.json') / (1024 * 1024)  # MB\n    #        message = f\"Backup created: orbit_paths_backup.json ({file_size:.1f}MB)\"\n            message = f\"Backup created: data/orbit_paths_backup.json ({file_size:.1f}MB)\"\n            print(f\"[STARTUP] {message}\")\n            \n            # Print cache statistics to terminal\n    #        with open('orbit_paths.json', 'r') as f:\n            with open('data/orbit_paths.json', 'r') as f:\n                orbit_data = json.load(f)\n                print(f\"[CACHE INFO] Total orbits cached: {len(orbit_data)}\")\n    #            print(\"[CACHE INFO] To manually delete cache, remove 'orbit_paths.json' file\")\n                print(\"[CACHE INFO] To manually delete cache, remove 'data/orbit_paths.json' file\")\n            \n            return message, 'info'\n                \n        except Exception as e:\n            error_msg = f\"Warning: Could not create backup: {e}\"\n            print(f\"[ERROR] {error_msg}\")\n            return error_msg, 'error'\n    else:\n        message = \"No cache found. Will create new cache as needed.\"\n        print(f\"[STARTUP] {message}\")\n        return message, 'info'",
    "start_line": 759,
    "end_line": 789,
    "has_docstring": true,
    "docstring": "Create a backup of orbit cache on startup",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_orbit_backup",
    "component_id": "palomas_orrery_helpers.create_orbit_backup"
  },
  "palomas_orrery_helpers.cleanup_old_orbits": {
    "id": "palomas_orrery_helpers.cleanup_old_orbits",
    "name": "cleanup_old_orbits",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery_helpers.py",
    "relative_path": "palomas_orrery_helpers.py",
    "depends_on": [],
    "source_code": "def cleanup_old_orbits():\n    \"\"\"Remove orbit data older than 30 days\"\"\"\n    try:\n        # Check if it's been 7 days since last cleanup\n        should_cleanup = True\n        if os.path.exists(CLEANUP_TRACKING_FILE):\n            with open(CLEANUP_TRACKING_FILE, 'r') as f:\n                last_cleanup = float(f.read())\n                days_since = (time.time() - last_cleanup) / (24 * 60 * 60)\n                should_cleanup = days_since >= 7\n        \n        if not should_cleanup:\n            return None, None\n        \n        # Load orbit data\n    #    if not os.path.exists('orbit_paths.json'):\n        if not os.path.exists('data/orbit_paths.json'):\n            return None, None\n            \n    #    with open('orbit_paths.json', 'r') as f:\n        with open('data/orbit_paths.json', 'r') as f:\n            orbit_data = json.load(f)\n        \n        initial_count = len(orbit_data)\n        cutoff_time = time.time() - (30 * 24 * 60 * 60)  # 30 days ago\n        cleaned_data = {}\n        \n        # Keep only recent data\n        for key, data in orbit_data.items():\n            # Add timestamp to old data if missing\n            if isinstance(data, dict) and 'last_accessed' not in data:\n                data['last_accessed'] = time.time()\n            \n            # Check age\n            if isinstance(data, dict) and 'last_accessed' in data:\n                if data['last_accessed'] > cutoff_time:\n                    cleaned_data[key] = data\n            else:\n                # Keep data without timestamp but add one\n                if isinstance(data, dict):\n                    data['last_accessed'] = time.time()\n                cleaned_data[key] = data\n        \n        removed_count = initial_count - len(cleaned_data)\n        \n        if removed_count > 0:\n            # Save cleaned data\n    #        with open('orbit_paths.json', 'w') as f:\n            with open('data/orbit_paths.json', 'w') as f:\n                json.dump(cleaned_data, f)\n            \n            message = f\"Cleanup: Removed {removed_count} orbits older than 30 days\"\n            print(f\"[CLEANUP] {message}\")\n            print(f\"[CLEANUP] Remaining orbits: {len(cleaned_data)}\")\n            \n            # Update tracking file\n            with open(CLEANUP_TRACKING_FILE, 'w') as f:\n                f.write(str(time.time()))\n                \n            return message, 'success'\n        \n        # Update tracking file even if nothing removed\n        with open(CLEANUP_TRACKING_FILE, 'w') as f:\n            f.write(str(time.time()))\n            \n        return None, None\n            \n    except Exception as e:\n        error_msg = f\"Cleanup error: {e}\"\n        print(f\"[ERROR] {error_msg}\")\n        return error_msg, 'error'",
    "start_line": 792,
    "end_line": 862,
    "has_docstring": true,
    "docstring": "Remove orbit data older than 30 days",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function cleanup_old_orbits",
    "component_id": "palomas_orrery_helpers.cleanup_old_orbits"
  },
  "palomas_orrery_helpers.show_animation_safely": {
    "id": "palomas_orrery_helpers.show_animation_safely",
    "name": "show_animation_safely",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\palomas_orrery_helpers.py",
    "relative_path": "palomas_orrery_helpers.py",
    "depends_on": [],
    "source_code": "def show_animation_safely(fig, default_name):\n    \"\"\"\n    Show and optionally save an animation.\n    \n    This function now delegates to the consolidated save_utils module\n    while maintaining backward compatibility.\n    \n    Parameters:\n        fig: Plotly figure object with animation\n        default_name: Default filename without extension\n    \n    Returns:\n        str or None: Path to saved file, or None if not saved\n    \"\"\"\n    return _show_and_save_impl(fig, default_name)",
    "start_line": 864,
    "end_line": 878,
    "has_docstring": true,
    "docstring": "Show and optionally save an animation.\n\nThis function now delegates to the consolidated save_utils module\nwhile maintaining backward compatibility.\n\nParameters:\n    fig: Plotly figure object with animation\n    default_name: Default filename without extension\n\nReturns:\n    str or None: Path to saved file, or None if not saved",
    "parameters": [
      "fig",
      "default_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function show_animation_safely",
    "component_id": "palomas_orrery_helpers.show_animation_safely"
  },
  "planet9_visualization_shells.create_planet9_surface_shell": {
    "id": "planet9_visualization_shells.create_planet9_surface_shell",
    "name": "create_planet9_surface_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planet9_visualization_shells.py",
    "relative_path": "planet9_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_planet9_surface_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates eris's cloud layer shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.0,  # the top of the troposphere is actually 1.002\n        'color': 'rgb(83, 68, 55)',  # optical brownish\n        'opacity': 1.0,\n        'name': 'Crust',\n        'description': (\n            \"Planet 9 Surface<br>\" \n            \"(Note: toggle off the cloud layer in the legend to better see the interior structure.)<br><br>\"\n            \"The estimation of Planet Nine's radius being between 3 and 4 Earth radii, with a specific estimate of around 3.7 Earth <br>\" \n            \"radii (or 23,500 - 24,000 km), appears in several scientific discussions. This size estimate is often linked to the <br>\" \n            \"assumption that Planet Nine is likely an ice giant, similar in composition to Uranus and Neptune, but potentially a <br>\" \n            \"smaller version.<br>\" \n            \"* Mass and Density Relationship: For a given mass, the radius of a planet is strongly influenced by its density.<br>\" \n            \"* Terrestrial Planets: Terrestrial planets (like Earth, Mars, Venus, Mercury) are primarily composed of rock and metal, <br>\" \n            \"  making them quite dense. If Planet Nine were a terrestrial planet with 5-10 times the mass of Earth, its radius would <br>\" \n            \"  likely be significantly smaller than 3-4 Earth radii due to its high density.<br>\" \n            \"* Gas Giants: Gas giants (like Jupiter and Saturn) are composed mostly of hydrogen and helium, making them very large and <br>\" \n            \"  not very dense. A planet with several Earth masses composed primarily of these light gases would have a much larger radius <br>\" \n            \"  than 3-4 Earth radii.<br>\" \n            \"* Ice Giants: Ice giants (like Uranus and Neptune) have a composition that includes heavier elements like oxygen, carbon, <br>\" \n            \"  nitrogen, and sulfur, often in the form of water, methane, and ammonia ices, along with a significant amount of hydrogen and <br>\" \n            \"  helium. This composition results in densities higher than gas giants but lower than terrestrial planets.<br>\" \n            \"The 3-4 Earth radii estimate, particularly the 3.7 Earth radii figure, comes from models that assume Planet Nine has a mass <br>\" \n            \"around 5-10 Earth masses and an internal composition similar to Uranus and Neptune. These models predict that such a planet <br>\" \n            \"would have a larger radius than Earth due to its significant mass, but not as large as a pure gas giant with the same mass due <br>\" \n            \"to the presence of heavier \\\"ice\\\" materials. Therefore, the estimated radius of 3-4 Earth radii strongly suggests that Planet <br>\" \n            \"Nine, if it exists, is likely an ice giant or a sub-Neptune type of planet, rather than a rocky terrestrial planet or a large <br>\" \n            \"gas giant. This is also consistent with theories about how a planet could have formed or been captured in the distant outer <br>\" \n            \"solar system.\"\n            )\n    }\n    \n    # Calculate radius in AU\n    radius = layer_info['radius_fraction'] * PLANET9_RADIUS_AU\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Create mesh with reasonable resolution for performance\n    resolution = 24  # Reduced from typical 50 for markers\n    \n    # Create a UV sphere\n    phi = np.linspace(0, 2*np.pi, resolution)\n    theta = np.linspace(-np.pi/2, np.pi/2, resolution)\n    phi, theta = np.meshgrid(phi, theta)\n    \n    x = radius * np.cos(theta) * np.cos(phi)\n    y = radius * np.cos(theta) * np.sin(phi)\n    z = radius * np.sin(theta)\n    \n    # Apply center position offset\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    # Create triangulation\n    indices = []\n    for i in range(resolution-1):\n        for j in range(resolution-1):\n            p1 = i * resolution + j\n            p2 = i * resolution + (j + 1)\n            p3 = (i + 1) * resolution + j\n            p4 = (i + 1) * resolution + (j + 1)\n            \n            indices.append([p1, p2, p4])\n            indices.append([p1, p4, p3])\n    \n    # Create main surface\n    surface_trace = go.Mesh3d(\n        x=x.flatten(), \n        y=y.flatten(), \n        z=z.flatten(),\n        i=[idx[0] for idx in indices],\n        j=[idx[1] for idx in indices],\n        k=[idx[2] for idx in indices],\n        color=layer_info['color'],\n        opacity=layer_info['opacity'],\n        name=f\"Planet 9: {layer_info['name']}\",\n        showlegend=True,\n        hoverinfo='none',  # Disable hover on mesh surface\n        # Add these new parameters to make hover text invisible\n        hovertemplate=' ',  # Empty template instead of None\n        hoverlabel=dict(\n    #        bgcolor='rgba(0,0,0,0)',  # Transparent background\n            font=dict(\n                color='rgba(0,0,0,0)',  # Transparent text\n    #            size=0                  # Zero font size\n            ),\n            bordercolor='rgba(0,0,0,0)'  # Transparent border\n        ), \n        # Add these new parameters to eliminate shading\n        flatshading=True,  # Use flat shading instead of smooth\n        lighting=dict(\n            ambient=1.0,     # Set to maximum (1.0)\n            diffuse=0.0,     # Turn off diffuse lighting\n            specular=0.0,    # Turn off specular highlights\n            roughness=1.0,   # Maximum roughness\n            fresnel=0.0      # Turn off fresnel effect\n        ),\n        lightposition=dict(\n            x=0,  # Centered light\n            y=0,  # Centered light\n            z=10000  # Light from very far above to minimize shadows\n        )       \n    )\n        \n    # Use the Fibonacci sphere algorithm for more even point distribution\n    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points\n    \n    # Generate fibonacci sphere points\n    fib_points = fibonacci_sphere(samples=50)  # Originally, 50 hover points evenly distributed\n    \n    # Scale and offset the points\n    x_hover = [p[0] * radius + center_x for p in fib_points]\n    y_hover = [p[1] * radius + center_y for p in fib_points]\n    z_hover = [p[2] * radius + center_z for p in fib_points]\n        \n    # Create a list of repeated descriptions for each point\n    # This is crucial - we need exactly one text entry per point\n    hover_texts = [layer_info['description']] * len(x_hover)\n\n    # Just the name for \"Object Names Only\" mode\n    layer_name = f\"Planet 9: {layer_info['name']}\"\n    minimal_hover_texts = [layer_name] * len(x_hover)\n\n    # Create hover trace with direct text assignment\n    hover_trace = go.Scatter3d(\n        x=x_hover, \n        y=y_hover, \n        z=z_hover,\n        mode='markers',\n        marker=dict(\n            size=2,  # originally 5\n            color='rgb(83, 68, 55)',  # brownish\n            opacity=1.0,  # originally 0.8\n            line=dict(  # Add a contrasting outline\n                width=1,\n                color='black'\n            )\n        ),\n        name=f\"Planet 9: {layer_info['name']} (Info)\",\n        text=hover_texts,  # IMPORTANT: Matching length with coordinate arrays\n        customdata=minimal_hover_texts,  # For \"Object Names Only\" mode\n        hovertemplate='%{text}<extra></extra>',  # Use the standard hover template\n        showlegend=False  # Don't show in legend since it's just for hover\n    )\n\n    return [surface_trace, hover_trace]",
    "start_line": 18,
    "end_line": 183,
    "has_docstring": true,
    "docstring": "Creates eris's cloud layer shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_planet9_surface_shell",
    "component_id": "planet9_visualization_shells.create_planet9_surface_shell"
  },
  "planet9_visualization_shells.fibonacci_sphere": {
    "id": "planet9_visualization_shells.fibonacci_sphere",
    "name": "fibonacci_sphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planet9_visualization_shells.py",
    "relative_path": "planet9_visualization_shells.py",
    "depends_on": [],
    "source_code": "    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points",
    "start_line": 128,
    "end_line": 143,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "samples"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fibonacci_sphere",
    "component_id": "planet9_visualization_shells.fibonacci_sphere"
  },
  "planet9_visualization_shells.create_planet9_hill_sphere_shell": {
    "id": "planet9_visualization_shells.create_planet9_hill_sphere_shell",
    "name": "create_planet9_hill_sphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planet9_visualization_shells.py",
    "relative_path": "planet9_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_planet9_hill_sphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Planet 9's Hill sphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 48000, # this is estimated based on the modeled data\n        'color': 'rgb(0, 255, 0)',  # Green for Hill sphere\n        'opacity': 0.3,\n        'name': 'Hill Sphere',\n        'description': (\n            \"SELECT MANUAL SCALE OF AT LEAST 8 AU TO VISUALIZE PLANET 9 CENTERED OR 800 AU HELIOCENTRIC.<br><br>\"\n            \"Hill Sphere: Planet 9's Hill sphere, or Roche sphere, is the region around it where its gravitational influence dominates <br><br>\" \n            \"over the Sun's. The radius of Planet 9's Hill sphere is very large, approximately 7.6 AU.<br>\" \n            \"To arrive at the Hill sphere estimate of 7.6 AU, we made the following key assumptions about Planet Nine: <br>\" \n            \"* Semi-major axis (a): We assumed a semi-major axis of 600 AU. This value is within the range of 500-700 AU suggested <br>\" \n            \"  by some studies, including those considering the IRAS/AKARI observations. The semi-major axis is the average distance <br>\" \n            \"  of the planet from the Sun and has a direct linear relationship with the Hill sphere radius. A larger semi-major axis <br>\" \n            \"  leads to a larger Hill sphere.<br>\" \n            \"* Eccentricity (e): We assumed an eccentricity of 0.30. This value aligns with estimates that suggest a highly elliptical <br>\" \n            \"  orbit for Planet Nine, consistent with a perihelion around 280 AU and an aphelion around 1120 AU. The eccentricity <br>\" \n            \"  affects the Hill sphere radius because the formula uses the distance to the Sun at the perihelion. A higher eccentricity <br>\" \n            \"  would result in a smaller Hill sphere radius.<br>\" \n            \"* Mass of Planet Nine (m): We assumed a mass of 6 times the mass of Earth. This is within the generally accepted range of <br>\" \n            \"  a few to ten Earth masses, and close to some refined estimates. The mass of Planet Nine has a cubic root relationship <br>\" \n            \"  with the Hill sphere radius, meaning a larger mass leads to a larger Hill sphere, but the effect is less pronounced than <br>\" \n            \"  that of the semi-major axis.<br>\" \n            \"* Mass of the Sun (M): We used the standard value for the mass of the Sun. This is a well-established constant.<br>\" \n            \"* In summary: the region where Planet 9's gravity is strong enough to hold onto its own moons despite the Sun's pull is <br>\" \n            \"  what the Hill sphere represents. To estimate the radius of this safe zone, we take Planet Nine's average distance from <br>\" \n            \"  the Sun, which we're assuming to be 600 AU (that's 600 times the distance between the Earth and the Sun). Because <br>\" \n            \"  Planet Nine's orbit isn't a perfect circle but more of an oval shape (we call this eccentricity, and we're assuming <br>\" \n            \"  it's 0.30), the closest it gets to the Sun is a bit less than this average. To account for this, we consider the distance <br>\" \n            \"  at its closest approach, which is roughly its average distance multiplied by (one minus the eccentricity), <br>\" \n            \"  so 600AUx(1-0.30)=600AUx0.70=420AU. This closest distance is important because the Sun's gravity is strongest there, <br>\" \n            \"  making it harder for Planet Nine to hold onto moons. Now, we also need to consider how strong Planet Nine's gravity is <br>\" \n            \"  compared to the Sun's. We're assuming Planet Nine has a mass of 6 times the mass of the Earth. The Sun, of course, is <br>\" \n            \"  vastly more massive.<br>\" \n            \"* The full equation for calculating the Hill sphere radius is: r_Hill = a x (m/(3 x M))^(1/3). Where: a is the semi-major <br>\" \n            \"  axis of Eris's orbit around the Sun; m is the mass of Eris; M is the mass of the Sun.\"        \n            )\n    }\n        \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * PLANET9_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Planet 9: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Planet 9: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    # Add a sun direction indicator (arrow pointing toward Sun along negative X-axis)\n    sun_traces = create_sun_direction_indicator(center_position)\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 193,
    "end_line": 268,
    "has_docstring": true,
    "docstring": "Creates Planet 9's Hill sphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_planet9_hill_sphere_shell",
    "component_id": "planet9_visualization_shells.create_planet9_hill_sphere_shell"
  },
  "planet_visualization.create_sun_visualization": {
    "id": "planet_visualization.create_sun_visualization",
    "name": "create_sun_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planet_visualization.py",
    "relative_path": "planet_visualization.py",
    "depends_on": [],
    "source_code": "def create_sun_visualization(fig, sun_shell_vars, animate=False, frames=None):\n    \"\"\"\n    Creates a visualization of the Sun's layers based on which shells are selected.\n    \n    Parameters:\n        fig (plotly.graph_objects.Figure): The figure to add the Sun visualization to\n        sun_shell_vars (dict): Dictionary of selection variables for each Sun shell\n        animate (bool): Whether this is for an animated plot\n        frames (list, optional): List of frames for animation\n        \n    Returns:\n        plotly.graph_objects.Figure: The updated figure\n    \"\"\"\n    # Create base traces for static visualization\n    def create_layer_traces():\n        traces = []\n        \n        # Add each selected shell based on the selection variables\n        # Order from outermost to innermost\n        if sun_shell_vars['gravitational'].get() == 1:\n            traces.extend(create_sun_gravitational_shell())\n\n        if sun_shell_vars['galactic_tide'].get() == 1:\n            traces.extend(create_sun_galactic_tide())    \n\n        if sun_shell_vars['outer_oort_clumpy'].get() == 1:\n            traces.extend(create_sun_outer_oort_clumpy())   \n\n        if sun_shell_vars['hills_cloud_torus'].get() == 1:\n            traces.extend(create_sun_hills_cloud_torus())       \n            \n\n        if sun_shell_vars['outer_oort'].get() == 1:\n            traces.extend(create_sun_outer_oort_shell())\n            \n        if sun_shell_vars['inner_oort'].get() == 1:\n            traces.extend(create_sun_inner_oort_shell())\n            \n        if sun_shell_vars['inner_oort_limit'].get() == 1:\n            traces.extend(create_sun_inner_oort_limit_shell())\n            \n\n        if sun_shell_vars['heliopause'].get() == 1:\n            traces.extend(create_sun_heliopause_shell())\n            \n        if sun_shell_vars['termination_shock'].get() == 1:\n            traces.extend(create_sun_termination_shock_shell())\n\n\n        if sun_shell_vars['trojans_greeks'].get() == 1:\n            # Get Jupiter's current position for L4 point calculation\n            jupiter_angle = 0  # Default angle\n            # If Jupiter data is available in the current context, calculate its angle\n            # This would need to be passed from the calling context\n            traces.extend(create_jupiter_trojans_greeks(jupiter_angle=jupiter_angle))\n        \n        if sun_shell_vars['trojans_trojans'].get() == 1:\n            # Get Jupiter's current position for L5 point calculation\n            jupiter_angle = 0  # Default angle\n            # If Jupiter data is available in the current context, calculate its angle\n            # This would need to be passed from the calling context\n            traces.extend(create_jupiter_trojans_trojans(jupiter_angle=jupiter_angle))\n\n\n        if sun_shell_vars['main_belt'].get() == 1:\n            traces.extend(create_main_asteroid_belt())\n        \n        if sun_shell_vars['hildas'].get() == 1:\n            traces.extend(create_hilda_group())\n\n            \n        if sun_shell_vars['outer_corona'].get() == 1:\n            traces.extend(create_sun_outer_corona_shell())\n            \n        if sun_shell_vars['inner_corona'].get() == 1:\n            traces.extend(create_sun_inner_corona_shell())\n            \n        if sun_shell_vars['chromosphere'].get() == 1:\n            traces.extend(create_sun_chromosphere_shell())\n            \n        if sun_shell_vars['photosphere'].get() == 1:\n            traces.extend(create_sun_photosphere_shell())\n            \n        if sun_shell_vars['radiative'].get() == 1:\n            traces.extend(create_sun_radiative_shell())\n            \n        if sun_shell_vars['core'].get() == 1:\n            traces.extend(create_sun_core_shell())\n        \n        return traces\n\n    # Add base traces to figure\n    traces = create_layer_traces()\n    for trace in traces:\n        fig.add_trace(trace)\n\n    # If this is for animation, add the traces to each frame\n    if animate and frames is not None:\n        for frame in frames:\n            frame_data = list(frame.data)  # Convert tuple to list if necessary\n            frame_data.extend(traces)\n            frame.data = frame_data\n\n    return fig",
    "start_line": 316,
    "end_line": 419,
    "has_docstring": true,
    "docstring": "Creates a visualization of the Sun's layers based on which shells are selected.\n\nParameters:\n    fig (plotly.graph_objects.Figure): The figure to add the Sun visualization to\n    sun_shell_vars (dict): Dictionary of selection variables for each Sun shell\n    animate (bool): Whether this is for an animated plot\n    frames (list, optional): List of frames for animation\n    \nReturns:\n    plotly.graph_objects.Figure: The updated figure",
    "parameters": [
      "fig",
      "sun_shell_vars",
      "animate",
      "frames"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_visualization",
    "component_id": "planet_visualization.create_sun_visualization"
  },
  "planet_visualization.create_layer_traces": {
    "id": "planet_visualization.create_layer_traces",
    "name": "create_layer_traces",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planet_visualization.py",
    "relative_path": "planet_visualization.py",
    "depends_on": [
      "solar_visualization_shells.create_sun_inner_corona_shell",
      "solar_visualization_shells.create_sun_galactic_tide",
      "solar_visualization_shells.create_sun_core_shell",
      "solar_visualization_shells.create_sun_outer_oort_clumpy",
      "asteroid_belt_visualization_shells.create_jupiter_trojans_trojans",
      "solar_visualization_shells.create_sun_outer_oort_shell",
      "solar_visualization_shells.create_sun_photosphere_shell",
      "solar_visualization_shells.create_sun_hills_cloud_torus",
      "solar_visualization_shells.create_sun_heliopause_shell",
      "solar_visualization_shells.create_sun_outer_corona_shell",
      "solar_visualization_shells.create_sun_chromosphere_shell",
      "asteroid_belt_visualization_shells.create_hilda_group",
      "solar_visualization_shells.create_sun_inner_oort_shell",
      "asteroid_belt_visualization_shells.create_jupiter_trojans_greeks",
      "solar_visualization_shells.create_sun_radiative_shell",
      "asteroid_belt_visualization_shells.create_main_asteroid_belt",
      "solar_visualization_shells.create_sun_inner_oort_limit_shell",
      "solar_visualization_shells.create_sun_gravitational_shell",
      "solar_visualization_shells.create_sun_termination_shock_shell"
    ],
    "source_code": "    def create_layer_traces():\n        traces = []\n        \n        # Add each selected shell based on the selection variables\n        # Order from outermost to innermost\n        if sun_shell_vars['gravitational'].get() == 1:\n            traces.extend(create_sun_gravitational_shell())\n\n        if sun_shell_vars['galactic_tide'].get() == 1:\n            traces.extend(create_sun_galactic_tide())    \n\n        if sun_shell_vars['outer_oort_clumpy'].get() == 1:\n            traces.extend(create_sun_outer_oort_clumpy())   \n\n        if sun_shell_vars['hills_cloud_torus'].get() == 1:\n            traces.extend(create_sun_hills_cloud_torus())       \n            \n\n        if sun_shell_vars['outer_oort'].get() == 1:\n            traces.extend(create_sun_outer_oort_shell())\n            \n        if sun_shell_vars['inner_oort'].get() == 1:\n            traces.extend(create_sun_inner_oort_shell())\n            \n        if sun_shell_vars['inner_oort_limit'].get() == 1:\n            traces.extend(create_sun_inner_oort_limit_shell())\n            \n\n        if sun_shell_vars['heliopause'].get() == 1:\n            traces.extend(create_sun_heliopause_shell())\n            \n        if sun_shell_vars['termination_shock'].get() == 1:\n            traces.extend(create_sun_termination_shock_shell())\n\n\n        if sun_shell_vars['trojans_greeks'].get() == 1:\n            # Get Jupiter's current position for L4 point calculation\n            jupiter_angle = 0  # Default angle\n            # If Jupiter data is available in the current context, calculate its angle\n            # This would need to be passed from the calling context\n            traces.extend(create_jupiter_trojans_greeks(jupiter_angle=jupiter_angle))\n        \n        if sun_shell_vars['trojans_trojans'].get() == 1:\n            # Get Jupiter's current position for L5 point calculation\n            jupiter_angle = 0  # Default angle\n            # If Jupiter data is available in the current context, calculate its angle\n            # This would need to be passed from the calling context\n            traces.extend(create_jupiter_trojans_trojans(jupiter_angle=jupiter_angle))\n\n\n        if sun_shell_vars['main_belt'].get() == 1:\n            traces.extend(create_main_asteroid_belt())\n        \n        if sun_shell_vars['hildas'].get() == 1:\n            traces.extend(create_hilda_group())\n\n            \n        if sun_shell_vars['outer_corona'].get() == 1:\n            traces.extend(create_sun_outer_corona_shell())\n            \n        if sun_shell_vars['inner_corona'].get() == 1:\n            traces.extend(create_sun_inner_corona_shell())\n            \n        if sun_shell_vars['chromosphere'].get() == 1:\n            traces.extend(create_sun_chromosphere_shell())\n            \n        if sun_shell_vars['photosphere'].get() == 1:\n            traces.extend(create_sun_photosphere_shell())\n            \n        if sun_shell_vars['radiative'].get() == 1:\n            traces.extend(create_sun_radiative_shell())\n            \n        if sun_shell_vars['core'].get() == 1:\n            traces.extend(create_sun_core_shell())\n        \n        return traces",
    "start_line": 330,
    "end_line": 405,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_layer_traces",
    "component_id": "planet_visualization.create_layer_traces"
  },
  "planet_visualization.create_sun_corona_from_distance": {
    "id": "planet_visualization.create_sun_corona_from_distance",
    "name": "create_sun_corona_from_distance",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planet_visualization.py",
    "relative_path": "planet_visualization.py",
    "depends_on": [],
    "source_code": "def create_sun_corona_from_distance(fig, sun_shell_vars, sun_position):\n    \"\"\"\n    Creates a simplified Sun corona visualization for non-Sun-centered views.\n    Uses a simpler particle representation that scales appropriately.\n    \n    Parameters:\n        fig: The plotly figure\n        sun_shell_vars: Dictionary of Sun shell selection variables\n        sun_position: (x, y, z) tuple of Sun's position in AU\n        \n    Returns:\n        Updated figure\n    \"\"\"\n    import numpy as np\n    import plotly.graph_objects as go\n    \n    # Simple sphere generation at Sun's position\n    def create_offset_sphere(radius_au, n_points=30):\n        \"\"\"Create sphere points offset to sun_position\"\"\"\n        phi = np.linspace(0, 2*np.pi, n_points)\n        theta = np.linspace(0, np.pi, n_points)\n        phi, theta = np.meshgrid(phi, theta)\n        \n        x = radius_au * np.sin(theta) * np.cos(phi) + sun_position[0]\n        y = radius_au * np.sin(theta) * np.sin(phi) + sun_position[1]\n        z = radius_au * np.cos(theta) + sun_position[2]\n        \n        return x.flatten(), y.flatten(), z.flatten()\n    \n    # Add selected layers (outermost to innermost)\n    if sun_shell_vars.get('outer_corona') and sun_shell_vars['outer_corona'].get() == 1:\n        radius = OUTER_CORONA_RADII * SOLAR_RADIUS_AU\n        x, y, z = create_offset_sphere(radius, n_points=30)\n        \n        fig.add_trace(go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(size=0.5, color='rgba(255, 245, 200, 0.3)', opacity=0.3),\n            name='Sun: Outer Corona',\n            hovertemplate='Sun: Outer Corona<br>~10 solar radii<br>Temperature: ~2M K<extra></extra>',\n            showlegend=True\n        ))\n    \n    if sun_shell_vars.get('inner_corona') and sun_shell_vars['inner_corona'].get() == 1:\n        radius = INNER_CORONA_RADII * SOLAR_RADIUS_AU\n        x, y, z = create_offset_sphere(radius, n_points=30)\n        \n        fig.add_trace(go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(size=0.75, color='rgba(255, 235, 180, 0.4)', opacity=0.4),\n            name='Sun: Inner Corona',\n            hovertemplate='Sun: Inner Corona<br>~3 solar radii<br>Temperature: 1-3M K<extra></extra>',\n            showlegend=True\n        ))\n    \n    if sun_shell_vars.get('chromosphere') and sun_shell_vars['chromosphere'].get() == 1:\n        radius = CHROMOSPHERE_RADII * SOLAR_RADIUS_AU\n        x, y, z = create_offset_sphere(radius, n_points=30)\n        \n        fig.add_trace(go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(size=1.0, color='rgba(255, 100, 100, 0.5)', opacity=0.5),\n            name='Sun: Chromosphere',\n            hovertemplate='Sun: Chromosphere<br>~2000 km thick<br>Temperature: 4,000-20,000 K<extra></extra>',\n            showlegend=True\n        ))\n    \n    if sun_shell_vars.get('photosphere') and sun_shell_vars['photosphere'].get() == 1:\n        radius = SOLAR_RADIUS_AU\n        x, y, z = create_offset_sphere(radius, n_points=40)\n        \n        fig.add_trace(go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(size=1.5, color='rgba(255, 220, 100, 0.8)', opacity=0.8),\n            name='Sun: Photosphere',\n            hovertemplate='Sun: Photosphere<br>Visible surface<br>Temperature: ~5,800 K<extra></extra>',\n            showlegend=True\n        ))\n    \n    return fig",
    "start_line": 421,
    "end_line": 503,
    "has_docstring": true,
    "docstring": "Creates a simplified Sun corona visualization for non-Sun-centered views.\nUses a simpler particle representation that scales appropriately.\n\nParameters:\n    fig: The plotly figure\n    sun_shell_vars: Dictionary of Sun shell selection variables\n    sun_position: (x, y, z) tuple of Sun's position in AU\n    \nReturns:\n    Updated figure",
    "parameters": [
      "fig",
      "sun_shell_vars",
      "sun_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_corona_from_distance",
    "component_id": "planet_visualization.create_sun_corona_from_distance"
  },
  "planet_visualization.create_offset_sphere": {
    "id": "planet_visualization.create_offset_sphere",
    "name": "create_offset_sphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planet_visualization.py",
    "relative_path": "planet_visualization.py",
    "depends_on": [],
    "source_code": "    def create_offset_sphere(radius_au, n_points=30):\n        \"\"\"Create sphere points offset to sun_position\"\"\"\n        phi = np.linspace(0, 2*np.pi, n_points)\n        theta = np.linspace(0, np.pi, n_points)\n        phi, theta = np.meshgrid(phi, theta)\n        \n        x = radius_au * np.sin(theta) * np.cos(phi) + sun_position[0]\n        y = radius_au * np.sin(theta) * np.sin(phi) + sun_position[1]\n        z = radius_au * np.cos(theta) + sun_position[2]\n        \n        return x.flatten(), y.flatten(), z.flatten()",
    "start_line": 438,
    "end_line": 448,
    "has_docstring": true,
    "docstring": "Create sphere points offset to sun_position",
    "parameters": [
      "radius_au",
      "n_points"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_offset_sphere",
    "component_id": "planet_visualization.create_offset_sphere"
  },
  "planet_visualization.create_celestial_body_visualization": {
    "id": "planet_visualization.create_celestial_body_visualization",
    "name": "create_celestial_body_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planet_visualization.py",
    "relative_path": "planet_visualization.py",
    "depends_on": [
      "eris_visualization_shells.create_eris_crust_shell",
      "eris_visualization_shells.create_eris_core_shell",
      "jupiter_visualization_shells.create_jupiter_cloud_layer_shell",
      "mercury_visualization_shells.create_mercury_hill_sphere_shell",
      "moon_visualization_shells.create_moon_crust_shell",
      "mercury_visualization_shells.create_mercury_mantle_shell",
      "earth_visualization_shells.create_earth_inner_core_shell",
      "jupiter_visualization_shells.create_jupiter_ring_system",
      "mars_visualization_shells.create_mars_outer_core_shell",
      "jupiter_visualization_shells.create_jupiter_io_plasma_torus",
      "saturn_visualization_shells.create_saturn_upper_atmosphere_shell",
      "uranus_visualization_shells.create_uranus_cloud_layer_shell",
      "planet9_visualization_shells.create_planet9_surface_shell",
      "earth_visualization_shells.create_earth_hill_sphere_shell",
      "solar_visualization_shells.create_sun_gravitational_shell",
      "solar_visualization_shells.create_sun_termination_shock_shell",
      "saturn_visualization_shells.create_saturn_enceladus_plasma_torus",
      "jupiter_visualization_shells.create_jupiter_magnetosphere",
      "neptune_visualization_shells.create_neptune_magnetosphere",
      "moon_visualization_shells.create_moon_inner_core_shell",
      "saturn_visualization_shells.create_saturn_metallic_hydrogen_shell",
      "neptune_visualization_shells.create_neptune_mantle_shell",
      "venus_visualization_shells.create_venus_atmosphere_shell",
      "venus_visualization_shells.create_venus_magnetosphere_shell",
      "eris_visualization_shells.create_eris_mantle_shell",
      "venus_visualization_shells.create_venus_mantle_shell",
      "venus_visualization_shells.create_venus_hill_sphere_shell",
      "uranus_visualization_shells.create_uranus_core_shell",
      "uranus_visualization_shells.create_uranus_upper_atmosphere_shell",
      "uranus_visualization_shells.create_uranus_magnetosphere",
      "earth_visualization_shells.create_earth_upper_mantle_shell",
      "jupiter_visualization_shells.create_jupiter_hill_sphere_shell",
      "jupiter_visualization_shells.create_jupiter_molecular_hydrogen_shell",
      "pluto_visualization_shells.create_pluto_haze_layer_shell",
      "solar_visualization_shells.create_sun_outer_corona_shell",
      "earth_visualization_shells.create_earth_lower_mantle_shell",
      "neptune_visualization_shells.create_neptune_upper_atmosphere_shell",
      "eris_visualization_shells.create_eris_hill_sphere_shell",
      "saturn_visualization_shells.create_saturn_magnetosphere",
      "saturn_visualization_shells.create_saturn_radiation_belts",
      "uranus_visualization_shells.create_uranus_ring_system",
      "pluto_visualization_shells.create_pluto_crust_shell",
      "solar_visualization_shells.create_sun_inner_oort_limit_shell",
      "moon_visualization_shells.create_moon_outer_core_shell",
      "mercury_visualization_shells.create_mercury_atmosphere_shell",
      "jupiter_visualization_shells.create_jupiter_upper_atmosphere_shell",
      "moon_visualization_shells.create_moon_exosphere_shell",
      "moon_visualization_shells.create_moon_mantle_shell",
      "saturn_visualization_shells.create_saturn_core_shell",
      "mars_visualization_shells.create_mars_upper_atmosphere_shell",
      "solar_visualization_shells.create_sun_inner_corona_shell",
      "mercury_visualization_shells.create_mercury_outer_core_shell",
      "solar_visualization_shells.create_sun_galactic_tide",
      "planet9_visualization_shells.create_planet9_hill_sphere_shell",
      "uranus_visualization_shells.create_uranus_hill_sphere_shell",
      "solar_visualization_shells.create_sun_core_shell",
      "uranus_visualization_shells.create_uranus_radiation_belts",
      "solar_visualization_shells.create_sun_outer_oort_shell",
      "solar_visualization_shells.create_sun_photosphere_shell",
      "mars_visualization_shells.create_mars_crust_shell",
      "saturn_visualization_shells.create_saturn_ring_system",
      "jupiter_visualization_shells.create_jupiter_radiation_belts",
      "solar_visualization_shells.create_sun_heliopause_shell",
      "earth_visualization_shells.create_earth_atmosphere_shell",
      "pluto_visualization_shells.create_pluto_mantle_shell",
      "mars_visualization_shells.create_mars_hill_sphere_shell",
      "saturn_visualization_shells.create_saturn_molecular_hydrogen_shell",
      "neptune_visualization_shells.create_neptune_cloud_layer_shell",
      "uranus_visualization_shells.create_uranus_mantle_shell",
      "solar_visualization_shells.create_sun_inner_oort_shell",
      "pluto_visualization_shells.create_pluto_atmosphere_shell",
      "saturn_visualization_shells.create_saturn_hill_sphere_shell",
      "venus_visualization_shells.create_venus_core_shell",
      "jupiter_visualization_shells.create_jupiter_metallic_hydrogen_shell",
      "neptune_visualization_shells.create_neptune_ring_system",
      "neptune_visualization_shells.create_neptune_hill_sphere_shell",
      "moon_visualization_shells.create_moon_hill_sphere_shell",
      "mars_visualization_shells.create_mars_inner_core_shell",
      "venus_visualization_shells.create_venus_crust_shell",
      "earth_visualization_shells.create_earth_crust_shell",
      "pluto_visualization_shells.create_pluto_core_shell",
      "solar_visualization_shells.create_sun_outer_oort_clumpy",
      "mars_visualization_shells.create_mars_mantle_shell",
      "mercury_visualization_shells.create_mercury_magnetosphere_shell",
      "earth_visualization_shells.create_earth_upper_atmosphere_shell",
      "jupiter_visualization_shells.create_jupiter_core_shell",
      "earth_visualization_shells.create_earth_magnetosphere_shell",
      "eris_visualization_shells.create_eris_atmosphere_shell",
      "solar_visualization_shells.create_sun_hills_cloud_torus",
      "mars_visualization_shells.create_mars_atmosphere_shell",
      "solar_visualization_shells.create_sun_chromosphere_shell",
      "pluto_visualization_shells.create_pluto_hill_sphere_shell",
      "mars_visualization_shells.create_mars_magnetosphere_shell",
      "solar_visualization_shells.create_sun_radiative_shell",
      "mercury_visualization_shells.create_mercury_inner_core_shell",
      "venus_visualization_shells.create_venus_upper_atmosphere_shell",
      "neptune_visualization_shells.create_neptune_radiation_belts",
      "saturn_visualization_shells.create_saturn_cloud_layer_shell",
      "earth_visualization_shells.create_earth_outer_core_shell",
      "neptune_visualization_shells.create_neptune_core_shell",
      "mercury_visualization_shells.create_mercury_crust_shell"
    ],
    "source_code": "def create_celestial_body_visualization(fig, body_name, shell_vars, animate=False, frames=None, center_position=(0, 0, 0)):\n    \"\"\"\n    Unified function to create shell visualizations for any celestial body (Sun or planets).\n    Ensures consistent animation support across all body types.\n    \n    Parameters:\n        fig (plotly.graph_objects.Figure): The figure to add the visualization to\n        body_name (str): Name of the celestial body ('Sun', 'Earth', 'Jupiter', etc.)\n        shell_vars (dict): Dictionary of selection variables for each body's shells\n        animate (bool): Whether this is for an animated plot\n        frames (list, optional): List of frames for animation\n        center_position (tuple): (x, y, z) position of the body's center\n        \n    Returns:\n        plotly.graph_objects.Figure: The updated figure\n    \"\"\"\n    print(f\"\\nCreating visualization for {body_name} (animate={animate})\")\n    \n    # Initialize shell_type to avoid undefined variable errors\n#    shell_type = \"\"\n\n    # Create shell traces based on selected variables\n    traces = []\n    \n    if body_name == 'Sun':\n        # Handle Sun visualization with its specific shells\n        for shell_name, var in shell_vars.items():\n            if var.get() == 1:\n                # Call the appropriate shell creation function based on name\n                if shell_name == 'core':\n                    traces.extend(create_sun_core_shell())\n                elif shell_name == 'radiative':\n                    traces.extend(create_sun_radiative_shell())\n                elif shell_name == 'photosphere':\n                    traces.extend(create_sun_photosphere_shell())\n                elif shell_name == 'chromosphere':\n                    traces.extend(create_sun_chromosphere_shell())\n                elif shell_name == 'inner_corona':\n                    traces.extend(create_sun_inner_corona_shell())\n                elif shell_name == 'outer_corona':\n                    traces.extend(create_sun_outer_corona_shell())\n                elif shell_name == 'termination_shock':\n                    traces.extend(create_sun_termination_shock_shell())\n                elif shell_name == 'heliopause':\n                    traces.extend(create_sun_heliopause_shell())\n\n                elif shell_name == 'inner_oort_limit':\n                    traces.extend(create_sun_inner_oort_limit_shell())\n                elif shell_name == 'inner_oort':\n                    traces.extend(create_sun_inner_oort_shell())\n                elif shell_name == 'outer_oort':\n                    traces.extend(create_sun_outer_oort_shell())\n\n                elif shell_name == 'hills_cloud_torus':\n                    traces.extend(create_sun_hills_cloud_torus())\n                elif shell_name == 'outer_oort_clumpy':\n                    traces.extend(create_sun_outer_oort_clumpy())\n                elif shell_name == 'galactic_tide':\n                    traces.extend(create_sun_galactic_tide())\n                elif shell_name == 'gravitational':\n                    traces.extend(create_sun_gravitational_shell())\n    \n    elif body_name == 'Mercury':\n        # Handle Mercury visualization with its specific shells\n        for shell_name, var in shell_vars.items():\n            if var.get() == 1:\n    #            shell_type = shell_name.replace('mercury_', '')\n                if shell_name == 'inner_core':\n                    traces.extend(create_mercury_inner_core_shell(center_position))\n                elif shell_name == 'outer_core':\n                    traces.extend(create_mercury_outer_core_shell(center_position))\n                elif shell_name == 'mantle':\n                    traces.extend(create_mercury_mantle_shell(center_position))\n                elif shell_name == 'crust':\n                    traces.extend(create_mercury_crust_shell(center_position))\n                elif shell_name == 'atmosphere':\n                    traces.extend(create_mercury_atmosphere_shell(center_position))\n                elif shell_name == 'magnetosphere':\n                    traces.extend(create_mercury_magnetosphere_shell(center_position))\n                elif shell_name == 'hill_sphere':\n                    traces.extend(create_mercury_hill_sphere_shell(center_position))\n\n    elif body_name == 'Venus':\n        # Handle Venus visualization with its specific shells\n        for shell_name, var in shell_vars.items():\n            if var.get() == 1:\n    #            shell_name = shell_name.replace('venus_', '')\n                if shell_name == 'core':\n                    traces.extend(create_venus_core_shell(center_position))\n                elif shell_name == 'mantle':\n                    traces.extend(create_venus_mantle_shell(center_position))\n                elif shell_name == 'crust':\n                    traces.extend(create_venus_crust_shell(center_position))\n                elif shell_name == 'atmosphere':\n                    traces.extend(create_venus_atmosphere_shell(center_position))\n                elif shell_name == 'upper_atmosphere':\n                    traces.extend(create_venus_upper_atmosphere_shell(center_position))\n                elif shell_name == 'magnetosphere':\n                    traces.extend(create_venus_magnetosphere_shell(center_position))\n                elif shell_name == 'hill_sphere':\n                    traces.extend(create_venus_hill_sphere_shell(center_position))\n\n    elif body_name == 'Earth':\n        # Handle Earth visualization with its specific shells\n        for shell_name, var in shell_vars.items():\n            if var.get() == 1:\n    #            shell_name = shell_name.replace('earth_', '')\n                if shell_name == 'inner_core':\n                    traces.extend(create_earth_inner_core_shell(center_position))\n                elif shell_name == 'outer_core':\n                    traces.extend(create_earth_outer_core_shell(center_position))\n                elif shell_name == 'lower_mantle':\n                    traces.extend(create_earth_lower_mantle_shell(center_position))\n                elif shell_name == 'upper_mantle':\n                    traces.extend(create_earth_upper_mantle_shell(center_position))\n                elif shell_name == 'crust':\n                    traces.extend(create_earth_crust_shell(center_position))\n                elif shell_name == 'atmosphere':\n                    traces.extend(create_earth_atmosphere_shell(center_position))\n                elif shell_name == 'upper_atmosphere':\n                    traces.extend(create_earth_upper_atmosphere_shell(center_position))\n                elif shell_name == 'magnetosphere':\n                    traces.extend(create_earth_magnetosphere_shell(center_position))\n                elif shell_name == 'hill_sphere':\n                    traces.extend(create_earth_hill_sphere_shell(center_position))\n    \n    elif body_name == 'Moon':\n        # Handle moon visualization with its specific shells\n        for shell_name, var in shell_vars.items():\n            if var.get() == 1:\n    #            shell_name = shell_name.replace('moon_', '')\n                if shell_name == 'inner_core':\n                    traces.extend(create_moon_inner_core_shell(center_position))\n                elif shell_name == 'outer_core':\n                    traces.extend(create_moon_outer_core_shell(center_position))\n                elif shell_name == 'mantle':\n                    traces.extend(create_moon_mantle_shell(center_position))\n                elif shell_name == 'crust':\n                    traces.extend(create_moon_crust_shell(center_position))\n                elif shell_name == 'exosphere':\n                    traces.extend(create_moon_exosphere_shell(center_position))\n                elif shell_name == 'hill_sphere':\n                    traces.extend(create_moon_hill_sphere_shell(center_position))\n\n    elif body_name == 'Mars':\n        # Handle Mars visualization with its specific shells\n        for shell_name, var in shell_vars.items():\n            if var.get() == 1:\n    #            shell_name = shell_name.replace('mars_', '')\n                if shell_name == 'inner_core':\n                    traces.extend(create_mars_inner_core_shell(center_position))\n                elif shell_name == 'outer_core':\n                    traces.extend(create_mars_outer_core_shell(center_position))\n                elif shell_name == 'mantle':\n                    traces.extend(create_mars_mantle_shell(center_position))\n                elif shell_name == 'crust':\n                    traces.extend(create_mars_crust_shell(center_position))\n                elif shell_name == 'atmosphere':\n                    traces.extend(create_mars_atmosphere_shell(center_position))\n                elif shell_name == 'upper_atmosphere':\n                    traces.extend(create_mars_upper_atmosphere_shell(center_position))\n                elif shell_name == 'magnetosphere':\n                    traces.extend(create_mars_magnetosphere_shell(center_position))\n                elif shell_name == 'hill_sphere':\n                    traces.extend(create_mars_hill_sphere_shell(center_position))\n\n    elif body_name == 'Jupiter':\n        # Handle Jupiter visualization with its specific shells\n        for shell_name, var in shell_vars.items():\n            if var.get() == 1:\n    #            shell_name = shell_name.replace('jupiter_', '')\n                if shell_name == 'core':\n                    traces.extend(create_jupiter_core_shell(center_position))\n                elif shell_name == 'metallic_hydrogen':\n                    traces.extend(create_jupiter_metallic_hydrogen_shell(center_position))\n                elif shell_name == 'molecular_hydrogen':\n                    traces.extend(create_jupiter_molecular_hydrogen_shell(center_position))\n                elif shell_name == 'cloud_layer':\n                    traces.extend(create_jupiter_cloud_layer_shell(center_position))\n                elif shell_name == 'upper_atmosphere':\n                    traces.extend(create_jupiter_upper_atmosphere_shell(center_position))\n                elif shell_name == 'ring_system':\n                    traces.extend(create_jupiter_ring_system(center_position))\n                elif shell_name == 'radiation_belts':\n                    traces.extend(create_jupiter_radiation_belts(center_position))\n                elif shell_name == 'io_plasma_torus':\n                    traces.extend(create_jupiter_io_plasma_torus(center_position))\n                elif shell_name == 'magnetosphere':\n                    traces.extend(create_jupiter_magnetosphere(center_position))\n                elif shell_name == 'hill_sphere':\n                    traces.extend(create_jupiter_hill_sphere_shell(center_position))\n\n    elif body_name == 'Saturn':\n        # Handle Saturn visualization with its specific shells\n        for shell_name, var in shell_vars.items():\n            if var.get() == 1:\n    #            shell_name = shell_name.replace('saturn_', '')\n                if shell_name == 'core':\n                    traces.extend(create_saturn_core_shell(center_position))\n                elif shell_name == 'metallic_hydrogen':\n                    traces.extend(create_saturn_metallic_hydrogen_shell(center_position))\n                elif shell_name == 'molecular_hydrogen':\n                    traces.extend(create_saturn_molecular_hydrogen_shell(center_position))\n                elif shell_name == 'cloud_layer':\n                    traces.extend(create_saturn_cloud_layer_shell(center_position))\n                elif shell_name == 'upper_atmosphere':\n                    traces.extend(create_saturn_upper_atmosphere_shell(center_position))\n                elif shell_name == 'ring_system':\n                    traces.extend(create_saturn_ring_system(center_position))\n                elif shell_name == 'radiation_belts':\n                    traces.extend(create_saturn_radiation_belts(center_position))\n                elif shell_name == 'enceladus_plasma_torus':\n                    traces.extend(create_saturn_enceladus_plasma_torus(center_position))\n                elif shell_name == 'magnetosphere':\n                    traces.extend(create_saturn_magnetosphere(center_position))\n                elif shell_name == 'hill_sphere':\n                    traces.extend(create_saturn_hill_sphere_shell(center_position))\n\n    elif body_name == 'Uranus':\n        # Handle uranus visualization with its specific shells\n        for shell_name, var in shell_vars.items():\n            if var.get() == 1:\n    #            shell_name = shell_name.replace('uranus_', '')\n                if shell_name == 'core':\n                    traces.extend(create_uranus_core_shell(center_position))\n                elif shell_name == 'mantle':\n                    traces.extend(create_uranus_mantle_shell(center_position))\n                elif shell_name == 'cloud_layer':\n                    traces.extend(create_uranus_cloud_layer_shell(center_position))\n                elif shell_name == 'upper_atmosphere':\n                    traces.extend(create_uranus_upper_atmosphere_shell(center_position))\n                elif shell_name == 'ring_system':\n                    traces.extend(create_uranus_ring_system(center_position))\n                elif shell_name == 'radiation_belts':\n                    traces.extend(create_uranus_radiation_belts(center_position))\n                elif shell_name == 'magnetosphere':\n                    traces.extend(create_uranus_magnetosphere(center_position))\n                elif shell_name == 'hill_sphere':\n                    traces.extend(create_uranus_hill_sphere_shell(center_position))\n\n    elif body_name == 'Neptune':\n        # Handle Neptune visualization with its specific shells\n        for shell_name, var in shell_vars.items():\n            if var.get() == 1:\n    #            shell_name = shell_name.replace('neptune_', '')\n                if shell_name == 'core':\n                    traces.extend(create_neptune_core_shell(center_position))\n                elif shell_name == 'mantle':\n                    traces.extend(create_neptune_mantle_shell(center_position))\n                elif shell_name == 'cloud_layer':\n                    traces.extend(create_neptune_cloud_layer_shell(center_position))\n                elif shell_name == 'upper_atmosphere':\n                    traces.extend(create_neptune_upper_atmosphere_shell(center_position))\n                elif shell_name == 'ring_system':\n                    traces.extend(create_neptune_ring_system(center_position))\n                elif shell_name == 'radiation_belts':\n                    traces.extend(create_neptune_radiation_belts(center_position))\n                elif shell_name == 'magnetosphere':\n                    traces.extend(create_neptune_magnetosphere(center_position))\n                elif shell_name == 'hill_sphere':\n                    traces.extend(create_neptune_hill_sphere_shell(center_position))\n\n    elif body_name == 'Pluto':\n        # Handle Pluto visualization with its specific shells\n        for shell_name, var in shell_vars.items():\n            if var.get() == 1:\n    #            shell_name = shell_name.replace('pluto_', '')\n                if shell_name == 'core':\n                    traces.extend(create_pluto_core_shell(center_position))\n                elif shell_name == 'mantle':\n                    traces.extend(create_pluto_mantle_shell(center_position))\n                elif shell_name == 'crust':\n                    traces.extend(create_pluto_crust_shell(center_position))\n                elif shell_name == 'haze_layer':\n                    traces.extend(create_pluto_haze_layer_shell(center_position))\n                elif shell_name == 'atmosphere':\n                    traces.extend(create_pluto_atmosphere_shell(center_position))\n                elif shell_name == 'hill_sphere':\n                    traces.extend(create_pluto_hill_sphere_shell(center_position))\n\n    elif body_name == 'Eris':\n        # Handle eris visualization with its specific shells\n        for shell_name, var in shell_vars.items():\n            if var.get() == 1:\n    #            shell_name = shell_name.replace('eris_', '')\n                if shell_name == 'core':\n                    traces.extend(create_eris_core_shell(center_position))\n                elif shell_name == 'mantle':\n                    traces.extend(create_eris_mantle_shell(center_position))\n                elif shell_name == 'crust':\n                    traces.extend(create_eris_crust_shell(center_position))\n                elif shell_name == 'atmosphere':\n                    traces.extend(create_eris_atmosphere_shell(center_position))\n                elif shell_name == 'hill_sphere':\n                    traces.extend(create_eris_hill_sphere_shell(center_position))\n\n    elif body_name == 'Planet 9':\n        # Handle Planet 9 visualization with its specific shells\n        for shell_name, var in shell_vars.items():\n            if var.get() == 1:\n    #            shell_name = shell_name.replace('planet9_', '')\n                if shell_name == 'surface':\n                    traces.extend(create_planet9_surface_shell(center_position))\n                elif shell_name == 'hill_sphere':\n                    traces.extend(create_planet9_hill_sphere_shell(center_position))\n\n    else:\n        print(f\"Warning: No visualization available for {body_name}\")\n        return fig\n    \n    # Apply consistent animation handling for all bodies\n    print(f\"Created {len(traces)} traces for {body_name}\")\n    \n    # Add traces to the figure\n    for trace in traces:\n        fig.add_trace(trace)\n    \n    # IMPORTANT: Skip adding to frames completely\n    if animate and frames is not None:\n        print(f\"Animation mode: Added {len(traces)} traces to figure only (skipping frames)\")\n    \n    return fig",
    "start_line": 505,
    "end_line": 826,
    "has_docstring": true,
    "docstring": "Unified function to create shell visualizations for any celestial body (Sun or planets).\nEnsures consistent animation support across all body types.\n\nParameters:\n    fig (plotly.graph_objects.Figure): The figure to add the visualization to\n    body_name (str): Name of the celestial body ('Sun', 'Earth', 'Jupiter', etc.)\n    shell_vars (dict): Dictionary of selection variables for each body's shells\n    animate (bool): Whether this is for an animated plot\n    frames (list, optional): List of frames for animation\n    center_position (tuple): (x, y, z) position of the body's center\n    \nReturns:\n    plotly.graph_objects.Figure: The updated figure",
    "parameters": [
      "fig",
      "body_name",
      "shell_vars",
      "animate",
      "frames",
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_celestial_body_visualization",
    "component_id": "planet_visualization.create_celestial_body_visualization"
  },
  "planet_visualization.create_planet_visualization": {
    "id": "planet_visualization.create_planet_visualization",
    "name": "create_planet_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planet_visualization.py",
    "relative_path": "planet_visualization.py",
    "depends_on": [
      "eris_visualization_shells.create_eris_crust_shell",
      "eris_visualization_shells.create_eris_core_shell",
      "jupiter_visualization_shells.create_jupiter_cloud_layer_shell",
      "mercury_visualization_shells.create_mercury_hill_sphere_shell",
      "moon_visualization_shells.create_moon_crust_shell",
      "mercury_visualization_shells.create_mercury_mantle_shell",
      "earth_visualization_shells.create_earth_inner_core_shell",
      "jupiter_visualization_shells.create_jupiter_ring_system",
      "mars_visualization_shells.create_mars_outer_core_shell",
      "jupiter_visualization_shells.create_jupiter_io_plasma_torus",
      "saturn_visualization_shells.create_saturn_upper_atmosphere_shell",
      "uranus_visualization_shells.create_uranus_cloud_layer_shell",
      "planet9_visualization_shells.create_planet9_surface_shell",
      "earth_visualization_shells.create_earth_hill_sphere_shell",
      "saturn_visualization_shells.create_saturn_enceladus_plasma_torus",
      "jupiter_visualization_shells.create_jupiter_magnetosphere",
      "neptune_visualization_shells.create_neptune_magnetosphere",
      "moon_visualization_shells.create_moon_inner_core_shell",
      "saturn_visualization_shells.create_saturn_metallic_hydrogen_shell",
      "neptune_visualization_shells.create_neptune_mantle_shell",
      "venus_visualization_shells.create_venus_atmosphere_shell",
      "venus_visualization_shells.create_venus_magnetosphere_shell",
      "eris_visualization_shells.create_eris_mantle_shell",
      "venus_visualization_shells.create_venus_mantle_shell",
      "venus_visualization_shells.create_venus_hill_sphere_shell",
      "uranus_visualization_shells.create_uranus_core_shell",
      "uranus_visualization_shells.create_uranus_upper_atmosphere_shell",
      "uranus_visualization_shells.create_uranus_magnetosphere",
      "earth_visualization_shells.create_earth_upper_mantle_shell",
      "jupiter_visualization_shells.create_jupiter_hill_sphere_shell",
      "jupiter_visualization_shells.create_jupiter_molecular_hydrogen_shell",
      "pluto_visualization_shells.create_pluto_haze_layer_shell",
      "earth_visualization_shells.create_earth_lower_mantle_shell",
      "neptune_visualization_shells.create_neptune_upper_atmosphere_shell",
      "eris_visualization_shells.create_eris_hill_sphere_shell",
      "saturn_visualization_shells.create_saturn_magnetosphere",
      "saturn_visualization_shells.create_saturn_radiation_belts",
      "uranus_visualization_shells.create_uranus_ring_system",
      "pluto_visualization_shells.create_pluto_crust_shell",
      "moon_visualization_shells.create_moon_outer_core_shell",
      "mercury_visualization_shells.create_mercury_atmosphere_shell",
      "jupiter_visualization_shells.create_jupiter_upper_atmosphere_shell",
      "moon_visualization_shells.create_moon_exosphere_shell",
      "moon_visualization_shells.create_moon_mantle_shell",
      "saturn_visualization_shells.create_saturn_core_shell",
      "mars_visualization_shells.create_mars_upper_atmosphere_shell",
      "mercury_visualization_shells.create_mercury_outer_core_shell",
      "mercury_visualization_shells.create_mercury_sodium_tail",
      "planet9_visualization_shells.create_planet9_hill_sphere_shell",
      "uranus_visualization_shells.create_uranus_hill_sphere_shell",
      "uranus_visualization_shells.create_uranus_radiation_belts",
      "mars_visualization_shells.create_mars_crust_shell",
      "saturn_visualization_shells.create_saturn_ring_system",
      "jupiter_visualization_shells.create_jupiter_radiation_belts",
      "earth_visualization_shells.create_earth_atmosphere_shell",
      "pluto_visualization_shells.create_pluto_mantle_shell",
      "mars_visualization_shells.create_mars_hill_sphere_shell",
      "saturn_visualization_shells.create_saturn_molecular_hydrogen_shell",
      "neptune_visualization_shells.create_neptune_cloud_layer_shell",
      "uranus_visualization_shells.create_uranus_mantle_shell",
      "pluto_visualization_shells.create_pluto_atmosphere_shell",
      "saturn_visualization_shells.create_saturn_hill_sphere_shell",
      "venus_visualization_shells.create_venus_core_shell",
      "jupiter_visualization_shells.create_jupiter_metallic_hydrogen_shell",
      "neptune_visualization_shells.create_neptune_ring_system",
      "neptune_visualization_shells.create_neptune_hill_sphere_shell",
      "moon_visualization_shells.create_moon_hill_sphere_shell",
      "mars_visualization_shells.create_mars_inner_core_shell",
      "venus_visualization_shells.create_venus_crust_shell",
      "earth_visualization_shells.create_earth_crust_shell",
      "pluto_visualization_shells.create_pluto_core_shell",
      "mars_visualization_shells.create_mars_mantle_shell",
      "mercury_visualization_shells.create_mercury_magnetosphere_shell",
      "earth_visualization_shells.create_earth_upper_atmosphere_shell",
      "jupiter_visualization_shells.create_jupiter_core_shell",
      "earth_visualization_shells.create_earth_magnetosphere_shell",
      "eris_visualization_shells.create_eris_atmosphere_shell",
      "mars_visualization_shells.create_mars_atmosphere_shell",
      "pluto_visualization_shells.create_pluto_hill_sphere_shell",
      "mars_visualization_shells.create_mars_magnetosphere_shell",
      "mercury_visualization_shells.create_mercury_inner_core_shell",
      "venus_visualization_shells.create_venus_upper_atmosphere_shell",
      "neptune_visualization_shells.create_neptune_radiation_belts",
      "saturn_visualization_shells.create_saturn_cloud_layer_shell",
      "earth_visualization_shells.create_earth_outer_core_shell",
      "neptune_visualization_shells.create_neptune_core_shell",
      "mercury_visualization_shells.create_mercury_crust_shell"
    ],
    "source_code": "def create_planet_visualization(fig, planet_name, shell_vars, animate=False, frames=None, center_position=(0, 0, 0)):\n    \"\"\"\n    Creates a visualization of a planet's layers based on which shells are selected.\n    Works for both static plots and animations.\n    \n    Parameters:\n        fig (plotly.graph_objects.Figure): The figure to add the visualization to\n        planet_name (str): Name of the planet \n        shell_vars (dict): Dictionary of selection variables for each planet shell\n        animate (bool): Whether this is for an animated plot\n        frames (list, optional): List of frames for animation\n        center_position (tuple): (x, y, z) position of the planet's center\n        \n    Returns:\n        plotly.graph_objects.Figure: The updated figure\n    \"\"\"\n    # Create base traces for static visualization\n    traces = []\n    \n    # Create shell traces based on selected variables\n\n    if planet_name == 'Mercury':\n        if shell_vars['mercury_inner_core'].get() == 1:\n            traces.extend(create_mercury_inner_core_shell(center_position))\n        if shell_vars['mercury_outer_core'].get() == 1:\n            traces.extend(create_mercury_outer_core_shell(center_position))\n        if shell_vars['mercury_mantle'].get() == 1:\n            traces.extend(create_mercury_mantle_shell(center_position))\n        if shell_vars['mercury_crust'].get() == 1:\n            traces.extend(create_mercury_crust_shell(center_position))\n        if shell_vars['mercury_atmosphere'].get() == 1:\n            traces.extend(create_mercury_atmosphere_shell(center_position))\n        if shell_vars['mercury_sodium_tail'].get() == 1:  \n            traces.extend(create_mercury_sodium_tail(center_position))\n        if shell_vars['mercury_magnetosphere'].get() == 1:\n            traces.extend(create_mercury_magnetosphere_shell(center_position))\n        if shell_vars['mercury_hill_sphere'].get() == 1:\n            traces.extend(create_mercury_hill_sphere_shell(center_position))\n\n    if planet_name == 'Venus':\n        if shell_vars['venus_core'].get() == 1:\n            traces.extend(create_venus_core_shell(center_position))\n        if shell_vars['venus_mantle'].get() == 1:\n            traces.extend(create_venus_mantle_shell(center_position))\n        if shell_vars['venus_crust'].get() == 1:\n            traces.extend(create_venus_crust_shell(center_position))\n        if shell_vars['venus_atmosphere'].get() == 1:\n            traces.extend(create_venus_atmosphere_shell(center_position))\n        if shell_vars['venus_upper_atmosphere'].get() == 1:\n            traces.extend(create_venus_upper_atmosphere_shell(center_position))\n        if shell_vars['venus_magnetosphere'].get() == 1:\n            traces.extend(create_venus_magnetosphere_shell(center_position))\n        if shell_vars['venus_hill_sphere'].get() == 1:\n            traces.extend(create_venus_hill_sphere_shell(center_position))\n\n    if planet_name == 'Earth':\n        if shell_vars['earth_inner_core'].get() == 1:\n            traces.extend(create_earth_inner_core_shell(center_position))\n        if shell_vars['earth_outer_core'].get() == 1:\n            traces.extend(create_earth_outer_core_shell(center_position))\n        if shell_vars['earth_lower_mantle'].get() == 1:\n            traces.extend(create_earth_lower_mantle_shell(center_position))\n        if shell_vars['earth_upper_mantle'].get() == 1:\n            traces.extend(create_earth_upper_mantle_shell(center_position))\n        if shell_vars['earth_crust'].get() == 1:\n            traces.extend(create_earth_crust_shell(center_position))\n        if shell_vars['earth_atmosphere'].get() == 1:\n            traces.extend(create_earth_atmosphere_shell(center_position))\n        if shell_vars['earth_upper_atmosphere'].get() == 1:\n            traces.extend(create_earth_upper_atmosphere_shell(center_position))\n        if shell_vars['earth_magnetosphere'].get() == 1:\n            traces.extend(create_earth_magnetosphere_shell(center_position))\n        if shell_vars['earth_hill_sphere'].get() == 1:\n            traces.extend(create_earth_hill_sphere_shell(center_position))\n\n    if planet_name == 'Moon':\n        if shell_vars['moon_inner_core'].get() == 1:\n            traces.extend(create_moon_inner_core_shell(center_position))\n        if shell_vars['moon_outer_core'].get() == 1:\n            traces.extend(create_moon_outer_core_shell(center_position))\n        if shell_vars['moon_mantle'].get() == 1:\n            traces.extend(create_moon_mantle_shell(center_position))\n        if shell_vars['moon_crust'].get() == 1:\n            traces.extend(create_moon_crust_shell(center_position))\n        if shell_vars['moon_exosphere'].get() == 1:\n            traces.extend(create_moon_exosphere_shell(center_position))\n        if shell_vars['moon_hill_sphere'].get() == 1:\n            traces.extend(create_moon_hill_sphere_shell(center_position))\n\n    if planet_name == 'Mars':\n        if shell_vars['mars_inner_core'].get() == 1:\n            traces.extend(create_mars_inner_core_shell(center_position))\n        if shell_vars['mars_outer_core'].get() == 1:\n            traces.extend(create_mars_outer_core_shell(center_position))\n        if shell_vars['mars_mantle'].get() == 1:\n            traces.extend(create_mars_mantle_shell(center_position))\n        if shell_vars['mars_crust'].get() == 1:\n            traces.extend(create_mars_crust_shell(center_position))\n        if shell_vars['mars_atmosphere'].get() == 1:\n            traces.extend(create_mars_atmosphere_shell(center_position))\n        if shell_vars['mars_upper_atmosphere'].get() == 1:\n            traces.extend(create_mars_upper_atmosphere_shell(center_position))\n        if shell_vars['mars_magnetosphere'].get() == 1:\n            traces.extend(create_mars_magnetosphere_shell(center_position))\n        if shell_vars['mars_hill_sphere'].get() == 1:\n            traces.extend(create_mars_hill_sphere_shell(center_position))\n\n    if planet_name == 'Jupiter':\n        if shell_vars['jupiter_core'].get() == 1:\n            traces.extend(create_jupiter_core_shell(center_position))\n        if shell_vars['jupiter_metallic_hydrogen'].get() == 1:\n            traces.extend(create_jupiter_metallic_hydrogen_shell(center_position))\n        if shell_vars['jupiter_molecular_hydrogen'].get() == 1:\n            traces.extend(create_jupiter_molecular_hydrogen_shell(center_position))\n        if shell_vars['jupiter_cloud_layer'].get() == 1:\n            traces.extend(create_jupiter_cloud_layer_shell(center_position))\n        if shell_vars['jupiter_upper_atmosphere'].get() == 1:\n            traces.extend(create_jupiter_upper_atmosphere_shell(center_position))\n        if shell_vars['jupiter_ring_system'].get() == 1:\n            traces.extend(create_jupiter_ring_system(center_position))\n        if shell_vars['jupiter_radiation_belts'].get() == 1:\n            traces.extend(create_jupiter_radiation_belts(center_position))\n        if shell_vars['jupiter_io_plasma_torus'].get() == 1:\n            traces.extend(create_jupiter_io_plasma_torus(center_position))\n        if shell_vars['jupiter_magnetosphere'].get() == 1:\n            traces.extend(create_jupiter_magnetosphere(center_position))\n        if shell_vars['jupiter_hill_sphere'].get() == 1:\n            traces.extend(create_jupiter_hill_sphere_shell(center_position))\n\n    if planet_name == 'Saturn':\n        if shell_vars['saturn_core'].get() == 1:\n            traces.extend(create_saturn_core_shell(center_position))\n        if shell_vars['saturn_metallic_hydrogen'].get() == 1:\n            traces.extend(create_saturn_metallic_hydrogen_shell(center_position))\n        if shell_vars['saturn_molecular_hydrogen'].get() == 1:\n            traces.extend(create_saturn_molecular_hydrogen_shell(center_position))\n        if shell_vars['saturn_cloud_layer'].get() == 1:\n            traces.extend(create_saturn_cloud_layer_shell(center_position))\n        if shell_vars['saturn_upper_atmosphere'].get() == 1:\n            traces.extend(create_saturn_upper_atmosphere_shell(center_position))\n        if shell_vars['saturn_ring_system'].get() == 1:\n            traces.extend(create_saturn_ring_system(center_position))\n        if shell_vars['saturn_radiation_belts'].get() == 1:\n            traces.extend(create_saturn_radiation_belts(center_position))\n        if shell_vars['saturn_enceladus_plasma_torus'].get() == 1:\n            traces.extend(create_saturn_enceladus_plasma_torus(center_position))\n        if shell_vars['saturn_magnetosphere'].get() == 1:\n            traces.extend(create_saturn_magnetosphere(center_position))\n        if shell_vars['saturn_hill_sphere'].get() == 1:\n            traces.extend(create_saturn_hill_sphere_shell(center_position))\n\n    if planet_name == 'Uranus':\n        if shell_vars['uranus_core'].get() == 1:\n            traces.extend(create_uranus_core_shell(center_position))\n        if shell_vars['uranus_mantle'].get() == 1:\n            traces.extend(create_uranus_mantle_shell(center_position))\n        if shell_vars['uranus_cloud_layer'].get() == 1:\n            traces.extend(create_uranus_cloud_layer_shell(center_position))\n        if shell_vars['uranus_upper_atmosphere'].get() == 1:\n            traces.extend(create_uranus_upper_atmosphere_shell(center_position))\n        if shell_vars['uranus_ring_system'].get() == 1:\n            traces.extend(create_uranus_ring_system(center_position))\n        if shell_vars['uranus_radiation_belts'].get() == 1:\n            traces.extend(create_uranus_radiation_belts(center_position))\n        if shell_vars['uranus_magnetosphere'].get() == 1:\n            traces.extend(create_uranus_magnetosphere(center_position))\n        if shell_vars['uranus_hill_sphere'].get() == 1:\n            traces.extend(create_uranus_hill_sphere_shell(center_position))\n\n    if planet_name == 'Neptune':\n        if shell_vars['neptune_core'].get() == 1:\n            traces.extend(create_neptune_core_shell(center_position))\n        if shell_vars['neptune_mantle'].get() == 1:\n            traces.extend(create_neptune_mantle_shell(center_position))\n        if shell_vars['neptune_cloud_layer'].get() == 1:\n            traces.extend(create_neptune_cloud_layer_shell(center_position))\n        if shell_vars['neptune_upper_atmosphere'].get() == 1:\n            traces.extend(create_neptune_upper_atmosphere_shell(center_position))\n        if shell_vars['neptune_ring_system'].get() == 1:\n            traces.extend(create_neptune_ring_system(center_position))\n        if shell_vars['neptune_radiation_belts'].get() == 1:\n            traces.extend(create_neptune_radiation_belts(center_position))\n        if shell_vars['neptune_magnetosphere'].get() == 1:\n            traces.extend(create_neptune_magnetosphere(center_position))\n        if shell_vars['neptune_hill_sphere'].get() == 1:\n            traces.extend(create_neptune_hill_sphere_shell(center_position))\n\n    if planet_name == 'Pluto':\n        if shell_vars['pluto_core'].get() == 1:\n            traces.extend(create_pluto_core_shell(center_position))\n        if shell_vars['pluto_mantle'].get() == 1:\n            traces.extend(create_pluto_mantle_shell(center_position))\n        if shell_vars['pluto_crust'].get() == 1:\n            traces.extend(create_pluto_crust_shell(center_position))\n        if shell_vars['pluto_haze_layer'].get() == 1:\n            traces.extend(create_pluto_haze_layer_shell(center_position))\n        if shell_vars['pluto_atmosphere'].get() == 1:\n            traces.extend(create_pluto_atmosphere_shell(center_position))\n        if shell_vars['pluto_hill_sphere'].get() == 1:\n            traces.extend(create_pluto_hill_sphere_shell(center_position))\n\n    if planet_name == 'Eris':\n        if shell_vars['eris_core'].get() == 1:\n            traces.extend(create_eris_core_shell(center_position))\n        if shell_vars['eris_mantle'].get() == 1:\n            traces.extend(create_eris_mantle_shell(center_position))\n        if shell_vars['eris_crust'].get() == 1:\n            traces.extend(create_eris_crust_shell(center_position))\n        if shell_vars['eris_atmosphere'].get() == 1:\n            traces.extend(create_eris_atmosphere_shell(center_position))\n        if shell_vars['eris_hill_sphere'].get() == 1:\n            traces.extend(create_eris_hill_sphere_shell(center_position))\n\n    if planet_name == 'Planet 9':\n        if shell_vars['planet9_surface'].get() == 1:\n            traces.extend(create_planet9_surface_shell(center_position))\n        if shell_vars['planet9_hill_sphere'].get() == 1:\n            traces.extend(create_planet9_hill_sphere_shell(center_position))\n    \n    # Add base traces to figure for static visualization\n    for trace in traces:\n        fig.add_trace(trace)\n\n    # If this is for animation, add the traces to each frame\n    if animate and frames is not None:\n        for frame in frames:\n            frame_data = list(frame.data)  # Convert tuple to list if necessary\n            frame_data.extend(traces)\n            frame.data = frame_data\n\n    return fig",
    "start_line": 835,
    "end_line": 1065,
    "has_docstring": true,
    "docstring": "Creates a visualization of a planet's layers based on which shells are selected.\nWorks for both static plots and animations.\n\nParameters:\n    fig (plotly.graph_objects.Figure): The figure to add the visualization to\n    planet_name (str): Name of the planet \n    shell_vars (dict): Dictionary of selection variables for each planet shell\n    animate (bool): Whether this is for an animated plot\n    frames (list, optional): List of frames for animation\n    center_position (tuple): (x, y, z) position of the planet's center\n    \nReturns:\n    plotly.graph_objects.Figure: The updated figure",
    "parameters": [
      "fig",
      "planet_name",
      "shell_vars",
      "animate",
      "frames",
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_planet_visualization",
    "component_id": "planet_visualization.create_planet_visualization"
  },
  "planet_visualization.create_planet_shell_traces": {
    "id": "planet_visualization.create_planet_shell_traces",
    "name": "create_planet_shell_traces",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planet_visualization.py",
    "relative_path": "planet_visualization.py",
    "depends_on": [],
    "source_code": "def create_planet_shell_traces(planet_name, shell_vars, center_position=(0, 0, 0)):\n    \"\"\"\n    Creates traces for planet shells without adding them to a figure.\n    Useful for animations where traces need to be created for each frame.\n    \n    Parameters:\n        planet_name (str): Name of the planet\n        shell_vars (dict): Dictionary of selection variables for each planet shell\n        center_position (tuple): (x, y, z) position of the planet's center\n        \n    Returns:\n        list: List of plotly traces\n    \"\"\"\n    traces = []\n    \n    # Get the prefix for this planet's shell variables\n    prefix = planet_name.lower() + \"_\"\n    \n    # Check each shell variable and add corresponding traces if selected\n    for shell_name, var in shell_vars.items():\n        if var.get() == 1:\n            # Extract the actual shell name without the planet prefix\n            shell_type = shell_name.replace(prefix, \"\")\n            \n            # Dynamically call the appropriate shell creation function\n            creation_func_name = f\"create_{planet_name.lower()}_{shell_type}_shell\"\n            if creation_func_name in globals():\n                creation_func = globals()[creation_func_name]\n                new_traces = creation_func(center_position=center_position)\n                traces.extend(new_traces)\n            else:\n                print(f\"Warning: No creation function found for {shell_type} shell of {planet_name}\")\n    \n    # Fix the hovertemplate for all traces\n    for trace in traces:\n        # Ensure proper customdata for hovering\n        if hasattr(trace, 'customdata'):\n            if isinstance(trace.customdata, list):\n                # Make sure all customdata items reference the correct planet\n                trace.customdata = [str(item).replace(\"Mercury\", planet_name).replace(\"Venus\", planet_name).replace(\"Earth\", planet_name).replace(\"Moon\", planet_name)\n                                    .replace(\"Mars\", planet_name).replace(\"Jupiter\", planet_name).replace(\"Saturn\", planet_name)\n                                    .replace(\"Uranus\", planet_name).replace(\"Neptune\", planet_name).replace(\"Pluto\", planet_name)\n                                    .replace(\"Eris\", planet_name).replace(\"Planet 9\", planet_name)\n                            if \"Mercury\" in str(item) or \"Venus\" in str(item) or \"Earth\" in str(item) or \"Moon\" in str(item) or \"Mars\" in str(item)\n                                or \"Jupiter\" in str(item) or \"Saturn\" in str(item) or \"Uranus\" in str(item) or \"Neptune\" in str(item)\n                                or \"Pluto\" in str(item) or \"Eris\" in str(item) or \"Planet 9\" in str(item)\n                            else str(item) for item in trace.customdata]\n        \n        # Set correct hovertemplate\n        trace.hovertemplate = '%{text}<extra></extra>'\n    \n    return traces",
    "start_line": 1067,
    "end_line": 1118,
    "has_docstring": true,
    "docstring": "Creates traces for planet shells without adding them to a figure.\nUseful for animations where traces need to be created for each frame.\n\nParameters:\n    planet_name (str): Name of the planet\n    shell_vars (dict): Dictionary of selection variables for each planet shell\n    center_position (tuple): (x, y, z) position of the planet's center\n    \nReturns:\n    list: List of plotly traces",
    "parameters": [
      "planet_name",
      "shell_vars",
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_planet_shell_traces",
    "component_id": "planet_visualization.create_planet_shell_traces"
  },
  "planet_visualization_utilities.rotate_points": {
    "id": "planet_visualization_utilities.rotate_points",
    "name": "rotate_points",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planet_visualization_utilities.py",
    "relative_path": "planet_visualization_utilities.py",
    "depends_on": [],
    "source_code": "def rotate_points(x, y, z, angle, axis='x'):\n    \"\"\"\n    Rotate points around a specified axis by the given angle.\n    \n    Parameters:\n        x, y, z (arrays): Coordinates of points\n        angle (float): Rotation angle in radians\n        axis (str): Axis of rotation ('x', 'y', or 'z')\n        \n    Returns:\n        tuple: (x_rotated, y_rotated, z_rotated)\n    \"\"\"\n    # Create rotation matrices\n    if axis == 'x':\n        # Rotation around x-axis\n        rot_matrix = np.array([\n            [1, 0, 0],\n            [0, np.cos(angle), -np.sin(angle)],\n            [0, np.sin(angle), np.cos(angle)]\n        ])\n    elif axis == 'y':\n        # Rotation around y-axis\n        rot_matrix = np.array([\n            [np.cos(angle), 0, np.sin(angle)],\n            [0, 1, 0],\n            [-np.sin(angle), 0, np.cos(angle)]\n        ])\n    elif axis == 'z':\n        # Rotation around z-axis\n        rot_matrix = np.array([\n            [np.cos(angle), -np.sin(angle), 0],\n            [np.sin(angle), np.cos(angle), 0],\n            [0, 0, 1]\n        ])\n    \n    # Stack coordinates into a single array\n    points = np.vstack((x, y, z))\n    \n    # Apply rotation\n    rotated_points = np.dot(rot_matrix, points)\n    \n    # Unpack results\n    x_rotated = rotated_points[0, :]\n    y_rotated = rotated_points[1, :]\n    z_rotated = rotated_points[2, :]\n    \n    return x_rotated, y_rotated, z_rotated",
    "start_line": 90,
    "end_line": 136,
    "has_docstring": true,
    "docstring": "Rotate points around a specified axis by the given angle.\n\nParameters:\n    x, y, z (arrays): Coordinates of points\n    angle (float): Rotation angle in radians\n    axis (str): Axis of rotation ('x', 'y', or 'z')\n    \nReturns:\n    tuple: (x_rotated, y_rotated, z_rotated)",
    "parameters": [
      "x",
      "y",
      "z",
      "angle",
      "axis"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function rotate_points",
    "component_id": "planet_visualization_utilities.rotate_points"
  },
  "planet_visualization_utilities.create_hover_markers_for_planet": {
    "id": "planet_visualization_utilities.create_hover_markers_for_planet",
    "name": "create_hover_markers_for_planet",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planet_visualization_utilities.py",
    "relative_path": "planet_visualization_utilities.py",
    "depends_on": [],
    "source_code": "def create_hover_markers_for_planet(center_position, radius, color, name, description, num_points=40):\n    \"\"\"\n    Creates clean hover markers for a planet with proper hover text formatting.\n    This is a helper function to ensure consistent hover behavior across static and animated views.\n    \"\"\"\n    import math\n    import numpy as np\n    import plotly.graph_objects as go\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Fibonacci sphere algorithm for even distribution\n    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points\n    \n    # Generate fibonacci sphere points\n    fib_points = fibonacci_sphere(samples=num_points)\n    \n    # Scale and offset the points\n    x_hover = [p[0] * radius + center_x for p in fib_points]\n    y_hover = [p[1] * radius + center_y for p in fib_points]\n    z_hover = [p[2] * radius + center_z for p in fib_points]\n    \n    # Create hover markers with clean hover text\n    hover_trace = go.Scatter3d(\n        x=x_hover, \n        y=y_hover, \n        z=z_hover,\n        mode='markers',\n        marker=dict(\n            size=3,\n            color=color,\n            opacity=0.5\n        ),\n        name=f\"{name} (Info)\",\n        text=[description] * len(x_hover),  # Array of identical description strings\n        hoverinfo='text',  # Use only the text for hover\n        showlegend=False\n    )\n    \n    return hover_trace",
    "start_line": 138,
    "end_line": 193,
    "has_docstring": true,
    "docstring": "Creates clean hover markers for a planet with proper hover text formatting.\nThis is a helper function to ensure consistent hover behavior across static and animated views.",
    "parameters": [
      "center_position",
      "radius",
      "color",
      "name",
      "description",
      "num_points"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_hover_markers_for_planet",
    "component_id": "planet_visualization_utilities.create_hover_markers_for_planet"
  },
  "planet_visualization_utilities.fibonacci_sphere": {
    "id": "planet_visualization_utilities.fibonacci_sphere",
    "name": "fibonacci_sphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planet_visualization_utilities.py",
    "relative_path": "planet_visualization_utilities.py",
    "depends_on": [],
    "source_code": "    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points",
    "start_line": 151,
    "end_line": 166,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "samples"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fibonacci_sphere",
    "component_id": "planet_visualization_utilities.fibonacci_sphere"
  },
  "planet_visualization_utilities.create_magnetosphere_shape": {
    "id": "planet_visualization_utilities.create_magnetosphere_shape",
    "name": "create_magnetosphere_shape",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planet_visualization_utilities.py",
    "relative_path": "planet_visualization_utilities.py",
    "depends_on": [],
    "source_code": "def create_magnetosphere_shape(params):\n    \"\"\"\n    Creates points for a magnetosphere with asymmetry, compressed on sunward side\n    and extended on the tail side.\n    \n    Parameters:\n        params (dict): Dictionary of shape parameters\n        \n    Returns:\n        tuple: (x, y, z) coordinates as lists\n    \"\"\"\n    x_coords = []\n    y_coords = []\n    z_coords = []\n    \n    # Number of points to generate (reduced for memory efficiency)\n    n_phi = 20              # from 30 to 20\n    n_theta = 20            # from 30 to 20\n    n_tail_segments = 10    # from 20 to 10\n    \n    # 1. Generate sunward hemisphere (compressed, use an ellipsoid)\n    for i_phi in range(int(n_phi/2)):\n        phi = (i_phi / (n_phi-1)) * np.pi\n        \n        for i_theta in range(n_theta):\n            theta = (i_theta / (n_theta-1)) * 2 * np.pi\n            \n            # Use ellipsoidal shaping - compress in x direction (sunward)\n            x = -params['sunward_distance'] * np.cos(phi)  # Negative for sunward direction\n            rho = np.sin(phi)\n            y = params['equatorial_radius'] * rho * np.cos(theta)\n            z = params['polar_radius'] * rho * np.sin(theta)\n            \n            x_coords.append(x)\n            y_coords.append(y)\n            z_coords.append(z)\n    \n    # 2. Generate magnetotail (anti-sunward direction, expands outward)\n    for i in range(n_tail_segments + 1):\n        fraction = i / n_tail_segments\n        tail_x = fraction * params['tail_length']  # Positive for tail direction\n        tail_radius = params['tail_base_radius'] + (params['tail_end_radius'] - params['tail_base_radius']) * fraction\n        \n        for i_theta in range(n_theta):\n            theta = (i_theta / (n_theta-1)) * 2 * np.pi\n            y = tail_radius * np.cos(theta)\n            z = tail_radius * np.sin(theta)\n            \n            x_coords.append(tail_x)\n            y_coords.append(y)\n            z_coords.append(z)\n    \n    return x_coords, y_coords, z_coords",
    "start_line": 195,
    "end_line": 247,
    "has_docstring": true,
    "docstring": "Creates points for a magnetosphere with asymmetry, compressed on sunward side\nand extended on the tail side.\n\nParameters:\n    params (dict): Dictionary of shape parameters\n    \nReturns:\n    tuple: (x, y, z) coordinates as lists",
    "parameters": [
      "params"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_magnetosphere_shape",
    "component_id": "planet_visualization_utilities.create_magnetosphere_shape"
  },
  "planet_visualization_utilities.create_sphere_points": {
    "id": "planet_visualization_utilities.create_sphere_points",
    "name": "create_sphere_points",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planet_visualization_utilities.py",
    "relative_path": "planet_visualization_utilities.py",
    "depends_on": [],
    "source_code": "def create_sphere_points(radius, n_points=50):\n    \"\"\"\n    Create points for a sphere surface to represent celestial body layers.\n    \n    Parameters:\n        radius (float): Radius of the sphere in AU\n        n_points (int): Number of points to generate along each dimension\n        \n    Returns:\n        tuple: (x, y, z) coordinates as flattened arrays\n    \"\"\"\n    phi = np.linspace(0, 2*np.pi, n_points)\n    theta = np.linspace(-np.pi/2, np.pi/2, n_points)\n    phi, theta = np.meshgrid(phi, theta)\n\n    x = radius * np.cos(theta) * np.cos(phi)\n    y = radius * np.cos(theta) * np.sin(phi)\n    z = radius * np.sin(theta)\n    \n    return x.flatten(), y.flatten(), z.flatten()",
    "start_line": 249,
    "end_line": 268,
    "has_docstring": true,
    "docstring": "Create points for a sphere surface to represent celestial body layers.\n\nParameters:\n    radius (float): Radius of the sphere in AU\n    n_points (int): Number of points to generate along each dimension\n    \nReturns:\n    tuple: (x, y, z) coordinates as flattened arrays",
    "parameters": [
      "radius",
      "n_points"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sphere_points",
    "component_id": "planet_visualization_utilities.create_sphere_points"
  },
  "planet_visualization_utilities.create_sun_direction_indicator_old": {
    "id": "planet_visualization_utilities.create_sun_direction_indicator_old",
    "name": "create_sun_direction_indicator_old",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planet_visualization_utilities.py",
    "relative_path": "planet_visualization_utilities.py",
    "depends_on": [],
    "source_code": "def create_sun_direction_indicator_old(center_position=(0, 0, 0)):\n    \"\"\"Creates a visual indicator showing the direction to the Sun (along negative X-axis).\"\"\"\n    center_x, center_y, center_z = center_position\n    \n    # Create a line pointing in the negative X direction (toward Sun)\n    sun_direction_x = [center_x, center_x - 40 * NEPTUNE_RADIUS_AU]  # Line from planet toward Sun\n    sun_direction_y = [center_y, center_y]\n    sun_direction_z = [center_z, center_z]\n    \n    # Create the Sun direction indicator\n    indicator_trace = go.Scatter3d(\n        x=sun_direction_x,\n        y=sun_direction_y,\n        z=sun_direction_z,\n        mode='lines+text',\n        line=dict(\n            color='yellow',\n            width=3,\n            dash='dash'\n        ),\n        text=['', 'Sun Direction'],  # Text at the end of the line\n        textposition='middle right',\n        textfont=dict(\n            color='yellow',\n            size=14,\n        ),\n        name='Sun Direction',\n        showlegend=False,\n        hoverinfo='none'\n    )\n    \n    # Create a small sun symbol at the end of the line\n    sun_symbol_trace = go.Scatter3d(\n        x=[sun_direction_x[1]],\n        y=[sun_direction_y[1]],\n        z=[sun_direction_z[1]],\n        mode='markers',\n        marker=dict(\n            size=6,\n            color='yellow',\n            symbol='circle',\n            line=dict(\n                color='orange',\n                width=2\n            )\n        ),\n        name='Sun Direction',\n        hoverinfo='name',\n        showlegend=False\n    )\n    \n    # Create an informational hover point with explanation\n    info_text = [\n        \"Direction to Sun: In the solar system, the Sun would be located in the negative X direction.<br><br>\"\n        \"Neptune's magnetosphere orientation: This scientifically accurate visualization shows:<br>\"\n        \"1. The bow shock facing the Sun, as it would in reality<br>\"\n        \"2. Neptune's unique magnetic field (47 deg tilt, 0.55 radius offset)<br>\"\n        \"3. A magnetotail that stretches away from the Sun but is influenced by Neptune's unusual field<br><br>\"\n        \"This complex interaction creates a magnetosphere unlike any other in our solar system.\"\n    ]\n    \n    info_trace = go.Scatter3d(\n        x=[center_x - 5 * NEPTUNE_RADIUS_AU],  # Position the info point near the start of the line\n        y=[center_y + 5 * NEPTUNE_RADIUS_AU],  # Offset from the line for visibility\n        z=[center_z + 5 * NEPTUNE_RADIUS_AU],\n        mode='markers',\n        marker=dict(\n            size=4,\n            color='white',\n            symbol='circle',\n            opacity=0.7\n        ),\n        name='Neptune Magnetosphere Info',\n        text=info_text,\n        hovertemplate='%{text}<extra></extra>',\n        showlegend=False\n    )\n    \n    return [indicator_trace, sun_symbol_trace, info_trace]",
    "start_line": 270,
    "end_line": 348,
    "has_docstring": true,
    "docstring": "Creates a visual indicator showing the direction to the Sun (along negative X-axis).",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_direction_indicator_old",
    "component_id": "planet_visualization_utilities.create_sun_direction_indicator_old"
  },
  "planetarium_apparent_magnitude.ensure_cache_system_ready": {
    "id": "planetarium_apparent_magnitude.ensure_cache_system_ready",
    "name": "ensure_cache_system_ready",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planetarium_apparent_magnitude.py",
    "relative_path": "planetarium_apparent_magnitude.py",
    "depends_on": [
      "simbad_manager.SimbadConfig",
      "simbad_manager.SimbadQueryManager",
      "star_properties.load_existing_properties"
    ],
    "source_code": "def ensure_cache_system_ready():\n    \"\"\"\n    Minimal cache system initialization using existing modules.\n    Ensures PKL files exist and checks cache health.\n    \"\"\"\n    import os\n    import pickle\n    \n    # Create empty PKL files if they don't exist\n    pkl_files = [\n        'star_data/star_properties_distance.pkl',\n        'star_data/star_properties_magnitude.pkl'        \n    ]\n    \n    for pkl_file in pkl_files:\n#        if not os.path.exists(pkl_file):\n#            print(f\"Creating missing cache: {pkl_file}\")\n#            with open(pkl_file, 'wb') as f:\n#                pickle.dump({}, f)\n        \n        if not os.path.exists(pkl_file):\n            print(f\"\\n[WARN]  WARNING: Cache file not found: {pkl_file}\")\n            print(f\"   This will create an EMPTY cache file.\")\n            print(f\"   If you have existing cache data, this may indicate a path problem.\")\n            response = input(f\"   Create empty cache at this location? (y/n): \")\n            if response.lower() == 'y':\n                print(f\"   Creating empty cache: {pkl_file}\")\n                with open(pkl_file, 'wb') as f:\n                    pickle.dump({}, f)\n            else:\n                print(f\"   Skipping cache creation. Please check your file paths.\")\n                print(f\"   Expected location: {pkl_file}\")\n        elif os.path.getsize(pkl_file) < 1000:  # Less than 1KB = suspicious\n                print(f\"\\n[WARN]  WARNING: Cache file is suspiciously small: {pkl_file}\")\n                print(f\"   Current size: {os.path.getsize(pkl_file)} bytes\")\n                print(f\"   Expected: ~3MB (distance) or ~32MB (magnitude)\")\n                print(f\"   This may indicate corruption or path misconfiguration.\")\n                response = input(f\"   Continue anyway? (y/n): \")\n                if response.lower() != 'y':\n                    print(f\"   Aborting. Please check your cache files.\")\n                    sys.exit(1) \n\n    # Quick status check using existing module\n    try:\n        from simbad_manager import SimbadQueryManager, SimbadConfig\n        config = SimbadConfig()\n        manager = SimbadQueryManager(config)\n        \n        # Check if magnitude PKL has any data\n        props = manager.load_existing_properties('star_data/star_properties_magnitude.pkl')\n        if len(props) == 0:\n            print(\"\\nWarning: star_properties_magnitude.pkl is empty\")\n            print(\"  Stars will appear gray until properties are fetched from SIMBAD\")\n            print(\"  Properties will be fetched automatically as you use the program\")\n        else:\n            print(f\"\\n[OK] Loaded {len(props)} cached star properties\")\n    except Exception as e:\n        # Silent fail is OK here - don't clutter output\n        pass",
    "start_line": 48,
    "end_line": 106,
    "has_docstring": true,
    "docstring": "Minimal cache system initialization using existing modules.\nEnsures PKL files exist and checks cache health.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function ensure_cache_system_ready",
    "component_id": "planetarium_apparent_magnitude.ensure_cache_system_ready"
  },
  "planetarium_apparent_magnitude.process_stars": {
    "id": "planetarium_apparent_magnitude.process_stars",
    "name": "process_stars",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planetarium_apparent_magnitude.py",
    "relative_path": "planetarium_apparent_magnitude.py",
    "depends_on": [
      "star_properties.generate_unique_ids",
      "star_properties.assign_properties_to_data",
      "stellar_parameters.calculate_stellar_parameters",
      "star_properties.query_simbad_for_star_properties",
      "star_properties.load_existing_properties",
      "data_processing.select_stars_by_magnitude",
      "data_processing.calculate_cartesian_coordinates"
    ],
    "source_code": "def process_stars(hip_data, gaia_data, mag_limit):\n    \"\"\"\n    Complete star processing pipeline for magnitude-based 3D visualization.\n    Handles selection, coordinates, properties, and parameters.\n    \n    Returns:\n        combined_data: The processed star data\n        counts: Dictionary of star counts\n        unique_ids: List of unique star identifiers\n        existing_properties: Dictionary of existing star properties\n        missing_ids: List of IDs that were missing (for PKL update check)\n    \"\"\"\n    \n    # Step 1: Select and combine stars from both catalogs\n    from data_processing import select_stars_by_magnitude\n    combined_data, counts = select_stars_by_magnitude(hip_data, gaia_data, mag_limit)\n    \n    if combined_data is None:\n        return None, {}, [], {}, []\n    \n    # Step 2: Calculate 3D cartesian coordinates\n    from data_processing import calculate_cartesian_coordinates\n    combined_data = calculate_cartesian_coordinates(combined_data)\n    \n    # Step 3: Load and query star properties from SIMBAD\n    from star_properties import (\n        load_existing_properties, \n        generate_unique_ids, \n        query_simbad_for_star_properties,\n        assign_properties_to_data\n    )\n    \n    properties_file = 'star_data/star_properties_magnitude.pkl'\n    existing_properties = load_existing_properties(properties_file)\n    unique_ids = generate_unique_ids(combined_data)\n    \n    # Find which stars need SIMBAD queries\n    missing_ids = [uid for uid in unique_ids if uid not in existing_properties]\n    \n    if missing_ids:\n        print(f\"Querying SIMBAD for {len(missing_ids)} stars...\")\n        existing_properties = query_simbad_for_star_properties(\n            missing_ids, existing_properties, properties_file\n        )\n    else:\n        print(\"All star properties are already cached.\")\n    \n    # Assign properties to the combined data\n    combined_data = assign_properties_to_data(combined_data, existing_properties, unique_ids)\n    \n    # Step 4: Calculate stellar parameters (temperature, luminosity)\n    from stellar_parameters import calculate_stellar_parameters\n    combined_data, source_counts, estimation_results = calculate_stellar_parameters(combined_data)\n    \n    # Step 5: Update counts with all the statistics\n    counts['source_counts'] = source_counts\n    counts['estimation_results'] = estimation_results\n    \n    # Calculate plottable count (stars with both temperature and luminosity)\n    if 'Temperature' in combined_data.colnames and 'Luminosity' in combined_data.colnames:\n        import numpy as np\n        plottable_mask = (\n            (~np.isnan(combined_data['Temperature'])) &\n            (~np.isnan(combined_data['Luminosity']))\n        )\n        counts['plottable_count'] = int(np.sum(plottable_mask))\n    else:\n        print(\"Warning: 'Temperature' or 'Luminosity' column not found in combined_data.\")\n        counts['plottable_count'] = 0\n    \n    counts['missing_temp_only'] = estimation_results.get('final_missing_temp', 0)\n    counts['missing_lum_only'] = estimation_results.get('final_missing_lum', 0)\n    \n    # Return all needed variables for PKL update check\n    return combined_data, counts, unique_ids, existing_properties, missing_ids",
    "start_line": 109,
    "end_line": 183,
    "has_docstring": true,
    "docstring": "Complete star processing pipeline for magnitude-based 3D visualization.\nHandles selection, coordinates, properties, and parameters.\n\nReturns:\n    combined_data: The processed star data\n    counts: Dictionary of star counts\n    unique_ids: List of unique star identifiers\n    existing_properties: Dictionary of existing star properties\n    missing_ids: List of IDs that were missing (for PKL update check)",
    "parameters": [
      "hip_data",
      "gaia_data",
      "mag_limit"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function process_stars",
    "component_id": "planetarium_apparent_magnitude.process_stars"
  },
  "planetarium_apparent_magnitude.main": {
    "id": "planetarium_apparent_magnitude.main",
    "name": "main",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planetarium_apparent_magnitude.py",
    "relative_path": "planetarium_apparent_magnitude.py",
    "depends_on": [
      "shutdown_handler.PlotlyShutdownHandler",
      "messier_catalog.get_visible_objects",
      "data_acquisition_distance.initialize_vizier",
      "data_processing.calculate_distances",
      "planetarium_apparent_magnitude.process_stars",
      "incremental_cache_manager.smart_load_or_fetch_hipparcos",
      "visualization_core.analyze_magnitude_distribution",
      "data_processing.align_coordinate_systems",
      "visualization_core.analyze_and_report_stars",
      "stellar_data_patches.apply_temperature_patches",
      "incremental_cache_manager.IncrementalCacheManager",
      "incremental_cache_manager.smart_load_or_fetch_gaia",
      "messier_object_data_handler.MessierObjectHandler",
      "planetarium_apparent_magnitude.ensure_cache_system_ready",
      "simbad_manager.SimbadQueryManager",
      "visualization_3d.prepare_3d_data"
    ],
    "source_code": "def main():\n    # CALL THE CACHE INITIALIZATION HERE - FIRST THING IN main()\n    ensure_cache_system_ready()\n    \n    # Initialize shutdown handler\n    shutdown_handler = PlotlyShutdownHandler()\n\n    # Parse command-line arguments\n    if len(sys.argv) > 1:\n        try:\n            mag_limit = float(sys.argv[1])\n            if mag_limit < -1.44 or mag_limit > 9:\n                print(\"Please enter a magnitude between -1.44 and 9.\")\n                print(\"Note: Sirius at magnitude -1.44 is the brightest star.\")\n                return\n\n            # Check for optional scale parameter\n            user_max_coord = None\n            if len(sys.argv) > 2:\n                user_max_coord = float(sys.argv[2])\n                if user_max_coord <= 0:\n                    print(\"Please enter a positive scale value.\")\n                    return\n                    \n        except ValueError:\n            print(\"Invalid input for magnitude limit. Using default value of 4.\")\n            mag_limit = 3.5\n            user_max_coord = None\n    else:\n        return    # prevents running this module without gui input    \n\n    print(f\"Filtering stars and objects with apparent magnitude <= {mag_limit}.\")\n    start_time = time.time()\n\n    try:\n        # Step 1: Initialize Messier Object Handler\n        print(\"Initializing Messier object handler...\")\n        messier_handler = MessierObjectHandler()\n        \n        # Step 2: Data Acquisition\n        print(\"\\nStarting data acquisition...\")\n        v = initialize_vizier()\n        hip_data_file = 'hipparcos_data_magnitude.vot'\n        gaia_data_file = 'gaia_data_magnitude.vot'\n\n#        hip_data_file = 'star_data/hipparcos_data_magnitude.vot'\n#        gaia_data_file = 'star_data/gaia_data_magnitude.vot'\n\n        # Load or fetch stellar data\n        hip_data = smart_load_or_fetch_hipparcos(v, hip_data_file,\n                                                mode='magnitude',\n                                                limit_value=mag_limit)\n        gaia_data = smart_load_or_fetch_gaia(v, gaia_data_file,\n                                            mode='magnitude',\n                                            limit_value=mag_limit)\n\n        if hip_data is None and gaia_data is None:\n            print(\"Error: Could not load or fetch data from either catalog.\")\n            return\n\n        print(f\"Data acquisition completed in {time.time() - start_time:.2f} seconds.\")\n        \n        # Cache status reporting\n        from incremental_cache_manager import IncrementalCacheManager\n        cache_mgr = IncrementalCacheManager()\n\n        hip_status, hip_meta = cache_mgr.check_cache_validity(hip_data_file, 'magnitude', mag_limit)\n        gaia_status, gaia_meta = cache_mgr.check_cache_validity(gaia_data_file, 'magnitude', mag_limit)\n\n        print(\"\\n\" + \"=\"*60)\n        print(\"CACHE STATUS REPORT\")\n        print(\"=\"*60)\n        print(f\"Hipparcos: {hip_status}\")\n        if hip_meta:\n            print(f\"  Cached: {hip_meta.entry_count} stars up to magnitude {hip_meta.limit_value}\")\n        print(f\"Gaia: {gaia_status}\")\n        if gaia_meta:\n            print(f\"  Cached: {gaia_meta.entry_count} stars up to magnitude {gaia_meta.limit_value}\")\n\n        if hip_status == 'expand' or gaia_status == 'expand':\n            print(\"\\n[OK] INCREMENTAL FETCH PERFORMED\")\n        elif hip_status == 'subset' or gaia_status == 'subset':\n            print(\"\\n[OK] FILTERED EXISTING CACHE (no fetch needed)\")\n        else:\n            print(\"\\n[OK] EXACT CACHE HIT - using existing data\")\n        print(\"=\"*60 + \"\\n\")\n        \n        # Step 3: Data Processing\n        print(\"\\nStarting data processing...\")\n        process_start = time.time()\n\n        # Prepare the data (distances and alignment)\n        hip_data = calculate_distances(hip_data) if hip_data is not None else None\n        gaia_data = calculate_distances(gaia_data) if gaia_data is not None else None\n\n        if hip_data is not None:\n            hip_data = align_coordinate_systems(hip_data)\n        \n        # Process all star data using consolidated function\n        combined_data, counts, unique_ids, existing_properties, missing_ids = process_stars(\n            hip_data, gaia_data, mag_limit\n        )\n        \n        if combined_data is None:\n            print(\"No valid stars found to process. Exiting.\")\n            return\n        \n        # Extract the nested values from counts for use later\n        source_counts = counts.get('source_counts', {})\n        estimation_results = counts.get('estimation_results', {})\n        \n        print(f\"Data processing completed in {time.time() - process_start:.2f} seconds.\")\n\n        # Step 4: Convert to DataFrame and apply patches\n        combined_df = combined_data.to_pandas()\n\n        # Apply temperature patches for known problematic stars\n        from stellar_data_patches import apply_temperature_patches\n        combined_df = apply_temperature_patches(combined_df)\n\n        # Define properties file for PKL update\n        properties_file = 'star_data/star_properties_magnitude.pkl'\n        \n        # Only update PKL if we actually added new stars to the dataset\n        if len(missing_ids) > 0:  # Now using missing_ids from process_stars\n            config = SimbadConfig.load_from_file()\n            manager = SimbadQueryManager(config)\n            updated_properties = manager.update_calculated_properties(combined_df, properties_file)\n            print(f\"Updated PKL with calculated properties for {len(missing_ids)} new stars\")\n        else:\n            print(\"No new stars added - PKL file unchanged\")\n\n        if len(combined_df) == 0:\n            print(\"No stars available for visualization after processing.\")\n            return\n\n        # Step 5: Fetch and Process Messier Objects\n        print(\"\\nProcessing Messier objects...\")\n        messier_objects = messier_handler.get_visible_objects(mag_limit)\n        \n        if messier_objects:\n            print(f\"Found {len(messier_objects)} Messier objects within magnitude {mag_limit}\")\n            messier_df = messier_handler.create_dataframe(messier_objects)\n            \n            # Combine with stellar data\n            if not messier_df.empty:\n                combined_df = pd.concat([combined_df, messier_df], ignore_index=True)\n                print(f\"Added {len(messier_df)} Messier objects to visualization dataset\")\n\n        # Step 6: Analysis\n        print(\"\\nRunning analysis...\")\n        analyze_magnitude_distribution(combined_df, mag_limit)\n        \n        # Run comprehensive analysis\n        analysis_results = analyze_and_report_stars(\n            combined_df,\n            mode='magnitude',\n            max_value=mag_limit\n        )\n\n        # Store the mode in the DataFrame attributes\n        combined_df.attrs['mode'] = 'magnitude'\n\n        # Debug star counts\n        print(\"\\nDEBUG: Star count breakdown:\")\n        print(f\"Total combined_df: {len(combined_df)}\")\n        print(f\"Hipparcos stars: {len(combined_df[combined_df['Source_Catalog'] == 'Hipparcos'])}\")\n        print(f\"Gaia stars: {len(combined_df[combined_df['Source_Catalog'] == 'Gaia'])}\")\n        print(f\"Messier objects: {len(combined_df[combined_df['Source_Catalog'] == 'Messier'])}\")\n\n        # Check temperature distribution\n        print(f\"\\nTemperature data:\")\n        print(f\"Stars WITH valid temperature: {(combined_df['Temperature'] > 0).sum()}\")\n        print(f\"Stars WITHOUT valid temperature: {(~(combined_df['Temperature'] > 0)).sum()}\")\n\n        # Calculate real counts for visualization\n        hip_df = combined_df[combined_df['Source_Catalog'] == 'Hipparcos']\n        gaia_df = combined_df[combined_df['Source_Catalog'] == 'Gaia']\n\n        hip_total = len(hip_df)\n        gaia_with_temp = (gaia_df['Temperature'] > 0).sum()\n        gaia_without_temp = len(gaia_df) - gaia_with_temp\n\n        flattened_analysis = {\n            'total_stars': len(combined_df),\n            'plottable_hip': hip_total,\n            'plottable_gaia': gaia_with_temp,\n            'missing_temp': gaia_without_temp,\n            'missing_lum': 0,\n            'temp_le_zero': 0\n        }\n\n        combined_df.attrs['analysis'] = flattened_analysis\n\n        # Add Has_Temperature flag for gray star display\n        combined_df['Has_Temperature'] = ~combined_df['Temperature'].isna() & (combined_df['Temperature'] > 0)\n\n        print(f\"\\nTemperature data availability:\")\n        print(f\"Stars with temperature data: {combined_df['Has_Temperature'].sum()}\")\n        print(f\"Stars without temperature data: {(~combined_df['Has_Temperature']).sum()}\")\n\n        \n        # Step 7: Prepare Data for Visualization\n        print(\"\\nPreparing visualization data...\")\n        prepared_df = prepare_3d_data(\n            combined_df,\n            max_value=mag_limit,\n            counts=counts,\n            mode='magnitude'\n        )\n\n        if prepared_df is None or len(prepared_df) == 0:\n            print(\"No plottable objects found after data preparation.\")\n            return\n\n        # Step 8: Create Visualization\n        print(\"\\nCreating visualization...\")\n        viz_start = time.time()  # ADD THIS LINE\n\n        # Define the visualize function\n        def visualize():\n            try:\n                fig = create_3d_visualization(prepared_df, mag_limit, user_max_coord=user_max_coord)\n                \n                # Show and save figure safely\n                default_name = f\"3d_stars_magnitude_{mag_limit}\"\n                show_figure_safely(fig, default_name)\n                \n            except Exception as e:\n                print(f\"Error during visualization: {e}\")\n                traceback.print_exc()\n\n        # Run visualization in monitored thread\n        viz_thread = create_monitored_thread(shutdown_handler, visualize)\n        viz_thread.start()\n        viz_thread.join()  # Wait for visualization to complete\n\n        print(f\"\\nVisualization completed in {time.time() - viz_start:.2f} seconds.\")\n\n    except Exception as e:\n        print(f\"Error during execution: {e}\")\n        traceback.print_exc()\n        return\n    finally:\n        shutdown_handler.cleanup()\n\n    print(f\"Total execution time: {time.time() - start_time:.2f} seconds.\")",
    "start_line": 186,
    "end_line": 432,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "planetarium_apparent_magnitude.main"
  },
  "planetarium_apparent_magnitude.visualize": {
    "id": "planetarium_apparent_magnitude.visualize",
    "name": "visualize",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planetarium_apparent_magnitude.py",
    "relative_path": "planetarium_apparent_magnitude.py",
    "depends_on": [
      "visualization_3d.create_3d_visualization",
      "shutdown_handler.show_figure_safely"
    ],
    "source_code": "        def visualize():\n            try:\n                fig = create_3d_visualization(prepared_df, mag_limit, user_max_coord=user_max_coord)\n                \n                # Show and save figure safely\n                default_name = f\"3d_stars_magnitude_{mag_limit}\"\n                show_figure_safely(fig, default_name)\n                \n            except Exception as e:\n                print(f\"Error during visualization: {e}\")\n                traceback.print_exc()",
    "start_line": 406,
    "end_line": 416,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function visualize",
    "component_id": "planetarium_apparent_magnitude.visualize"
  },
  "planetarium_distance.ensure_cache_system_ready": {
    "id": "planetarium_distance.ensure_cache_system_ready",
    "name": "ensure_cache_system_ready",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planetarium_distance.py",
    "relative_path": "planetarium_distance.py",
    "depends_on": [
      "simbad_manager.SimbadConfig",
      "simbad_manager.SimbadQueryManager",
      "star_properties.load_existing_properties"
    ],
    "source_code": "def ensure_cache_system_ready():\n    \"\"\"\n    Minimal cache system initialization using existing modules.\n    Ensures PKL files exist and checks cache health.\n    \"\"\"\n    import os\n    import pickle\n    \n    # Create empty PKL files if they don't exist\n    pkl_files = [\n        'star_data/star_properties_distance.pkl',\n        'star_data/star_properties_magnitude.pkl'\n    ]\n    \n    for pkl_file in pkl_files:\n#        if not os.path.exists(pkl_file):\n#            print(f\"Creating missing cache: {pkl_file}\")\n#           with open(pkl_file, 'wb') as f:\n#                pickle.dump({}, f)\n        \n        if not os.path.exists(pkl_file):\n            print(f\"\\n[WARN]  WARNING: Cache file not found: {pkl_file}\")\n            print(f\"   This will create an EMPTY cache file.\")\n            print(f\"   If you have existing cache data, this may indicate a path problem.\")\n            response = input(f\"   Create empty cache at this location? (y/n): \")\n            if response.lower() == 'y':\n                print(f\"   Creating empty cache: {pkl_file}\")\n                with open(pkl_file, 'wb') as f:\n                    pickle.dump({}, f)\n            else:\n                print(f\"   Skipping cache creation. Please check your file paths.\")\n                print(f\"   Expected location: {pkl_file}\")\n        elif os.path.getsize(pkl_file) < 1000:  # Less than 1KB = suspicious\n                print(f\"\\n[WARN]  WARNING: Cache file is suspiciously small: {pkl_file}\")\n                print(f\"   Current size: {os.path.getsize(pkl_file)} bytes\")\n                print(f\"   Expected: ~3MB (distance) or ~32MB (magnitude)\")\n                print(f\"   This may indicate corruption or path misconfiguration.\")\n                response = input(f\"   Continue anyway? (y/n): \")\n                if response.lower() != 'y':\n                    print(f\"   Aborting. Please check your cache files.\")\n                    sys.exit(1) \n\n    # Quick status check using existing module\n    try:\n        from simbad_manager import SimbadQueryManager, SimbadConfig\n        config = SimbadConfig()\n        manager = SimbadQueryManager(config)\n        \n        # Check if distance PKL has any data\n        props = manager.load_existing_properties('star_data/star_properties_distance.pkl')\n        if len(props) == 0:\n            print(\"\\nWarning: star_properties_distance.pkl is empty\")\n            print(\"  Stars will appear gray until properties are fetched from SIMBAD\")\n            print(\"  Properties will be fetched automatically as you use the program\")\n        else:\n            print(f\"\\n[OK] Loaded {len(props)} cached star properties\")\n    except Exception as e:\n        # Silent fail is OK here - don't clutter output\n        pass",
    "start_line": 56,
    "end_line": 114,
    "has_docstring": true,
    "docstring": "Minimal cache system initialization using existing modules.\nEnsures PKL files exist and checks cache health.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function ensure_cache_system_ready",
    "component_id": "planetarium_distance.ensure_cache_system_ready"
  },
  "planetarium_distance.process_stars": {
    "id": "planetarium_distance.process_stars",
    "name": "process_stars",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planetarium_distance.py",
    "relative_path": "planetarium_distance.py",
    "depends_on": [
      "star_properties.generate_unique_ids",
      "catalog_selection.select_stars",
      "star_properties.assign_properties_to_data",
      "stellar_parameters.calculate_stellar_parameters",
      "star_properties.query_simbad_for_star_properties",
      "star_properties.load_existing_properties",
      "data_processing.calculate_cartesian_coordinates"
    ],
    "source_code": "def process_stars(hip_data, gaia_data, max_light_years):\n    \"\"\"\n    Complete star processing pipeline for distance-based 3D visualization.\n    Handles selection, coordinates, properties, and parameters.\n    \n    Returns:\n        combined_data: The processed star data\n        counts: Dictionary of star counts\n        unique_ids: List of unique star identifiers\n        existing_properties: Dictionary of existing star properties\n        missing_ids: List of IDs that were missing (for PKL update check)\n    \"\"\"\n    \n    # Step 1: Select and combine stars from both catalogs\n    from catalog_selection import select_stars\n    combined_data, counts = select_stars(\n        hip_data, \n        gaia_data, \n        mode='distance', \n        limit_value=max_light_years\n    )\n    \n    if combined_data is None:\n        return None, {}, [], {}, []\n    \n    # Step 2: Calculate 3D cartesian coordinates\n    from data_processing import calculate_cartesian_coordinates\n    combined_data = calculate_cartesian_coordinates(combined_data)\n    \n    # Step 3: Load and query star properties from SIMBAD\n    from star_properties import (\n        load_existing_properties, \n        generate_unique_ids, \n        query_simbad_for_star_properties,\n        assign_properties_to_data\n    )\n    \n    properties_file = 'star_data/star_properties_distance.pkl'\n    existing_properties = load_existing_properties(properties_file)\n    unique_ids = generate_unique_ids(combined_data)\n    \n    # Find which stars need SIMBAD queries\n    missing_ids = [uid for uid in unique_ids if uid not in existing_properties]\n    \n    # DEBUG: Add this to see what's happening\n    print(f\"DEBUG: Total stars: {len(unique_ids)}\")\n    print(f\"DEBUG: Stars in PKL: {len(existing_properties)}\")\n    print(f\"DEBUG: Missing from PKL: {len(missing_ids)}\")\n    \n    if missing_ids:\n        print(f\"Querying SIMBAD for {len(missing_ids)} stars...\")\n        existing_properties = query_simbad_for_star_properties(\n            missing_ids, existing_properties, properties_file\n        )\n    \n    # Assign properties to the combined data\n    combined_data = assign_properties_to_data(combined_data, existing_properties, unique_ids)\n    \n    # Step 4: Calculate stellar parameters (temperature, luminosity)\n    from stellar_parameters import calculate_stellar_parameters\n    combined_data, source_counts, estimation_results = calculate_stellar_parameters(combined_data)\n    \n    # Step 5: Update counts with all the statistics\n    counts['source_counts'] = source_counts\n    counts['estimation_results'] = estimation_results\n    \n    # Calculate plottable count (stars with both temperature and luminosity)\n    if 'Temperature' in combined_data.colnames and 'Luminosity' in combined_data.colnames:\n        import numpy as np\n        plottable_mask = (\n    #        (~combined_data['Temperature'].isna()) &\n    #        (~combined_data['Luminosity'].isna())\n            (~np.isnan(combined_data['Temperature'])) &\n            (~np.isnan(combined_data['Luminosity']))\n        )\n        counts['plottable_count'] = int(np.sum(plottable_mask))\n    else:\n        print(\"Warning: 'Temperature' or 'Luminosity' column not found in combined_data.\")\n        counts['plottable_count'] = 0\n    \n    counts['missing_temp_only'] = estimation_results.get('final_missing_temp', 0)\n    counts['missing_lum_only'] = estimation_results.get('final_missing_lum', 0)\n    \n    # Return all needed variables for PKL update check\n    return combined_data, counts, unique_ids, existing_properties, missing_ids",
    "start_line": 117,
    "end_line": 201,
    "has_docstring": true,
    "docstring": "Complete star processing pipeline for distance-based 3D visualization.\nHandles selection, coordinates, properties, and parameters.\n\nReturns:\n    combined_data: The processed star data\n    counts: Dictionary of star counts\n    unique_ids: List of unique star identifiers\n    existing_properties: Dictionary of existing star properties\n    missing_ids: List of IDs that were missing (for PKL update check)",
    "parameters": [
      "hip_data",
      "gaia_data",
      "max_light_years"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function process_stars",
    "component_id": "planetarium_distance.process_stars"
  },
  "planetarium_distance.main": {
    "id": "planetarium_distance.main",
    "name": "main",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planetarium_distance.py",
    "relative_path": "planetarium_distance.py",
    "depends_on": [
      "shutdown_handler.PlotlyShutdownHandler",
      "data_acquisition_distance.initialize_vizier",
      "data_processing.calculate_distances",
      "simbad_manager.SimbadQueryManager",
      "incremental_cache_manager.smart_load_or_fetch_hipparcos",
      "incremental_cache_manager.IncrementalCacheManager",
      "planetarium_distance.ensure_cache_system_ready",
      "incremental_cache_manager.smart_load_or_fetch_gaia",
      "data_processing.align_coordinate_systems",
      "stellar_data_patches.apply_temperature_patches",
      "visualization_3d.create_3d_visualization",
      "planetarium_distance.process_stars",
      "data_processing.estimate_vmag_from_gaia",
      "visualization_core.analyze_magnitude_distribution",
      "visualization_core.analyze_and_report_stars",
      "data_acquisition_distance.calculate_parallax_limit",
      "visualization_3d.parse_stellar_classes",
      "visualization_3d.prepare_3d_data"
    ],
    "source_code": "def main():\n\n    # CALL THE CACHE INITIALIZATION HERE - FIRST THING IN main()\n    ensure_cache_system_ready()\n\n    # Initialize shutdown handler\n    shutdown_handler = PlotlyShutdownHandler()\n\n    # Parse command-line arguments for max light-years\n    if len(sys.argv) > 1:\n        try:\n            max_light_years = float(sys.argv[1])\n            if max_light_years <= 0:\n                print(\"Please enter a positive number of light-years.\")\n                print(\"Note: Current maximum reliable distance is 100.1 light-years.\")      # increasing limit from 100 to 100.1 ly\n                return\n        except ValueError:\n            print(\"Invalid input for light-years limit. Using default value of 100.1\")\n            max_light_years = 100.1\n    else:\n        # MODIFIED: No default - require explicit parameter\n        print(\"ERROR: Distance parameter required\")\n        return  # Exit without running\n\n    print(f\"Filtering stars within {max_light_years} light-years.\")\n    start_time = time.time()\n\n    try:\n        # Step 1: Data Acquisition\n        print(\"Starting data acquisition...\")\n        v = initialize_vizier()\n        min_parallax_mas = calculate_parallax_limit(max_light_years)\n        \n        hip_data_file = f'hipparcos_data_distance.vot'\n        gaia_data_file = f'gaia_data_distance.vot'\n        \n#        hip_data_file = f'star_data/hipparcos_data_distance.vot'\n#        gaia_data_file = f'star_data/gaia_data_distance.vot'\n\n        hip_data = smart_load_or_fetch_hipparcos(v, hip_data_file, \n                                                mode='distance',\n                                                limit_value=max_light_years,\n                                                parallax_constraint=f\">={min_parallax_mas}\")\n        gaia_data = smart_load_or_fetch_gaia(v, gaia_data_file, \n                                            mode='distance',\n                                            limit_value=max_light_years,\n                                            parallax_constraint=f\">={min_parallax_mas}\")\n\n        if hip_data is None and gaia_data is None:\n            print(\"Error: Could not load or fetch data from either catalog.\")\n            return\n\n        print(f\"Data acquisition completed in {time.time() - start_time:.2f} seconds.\")\n        \n        # ============ CACHE STATUS REPORT ============\n        from incremental_cache_manager import IncrementalCacheManager\n        cache_mgr = IncrementalCacheManager()\n\n        hip_status, hip_meta = cache_mgr.check_cache_validity(hip_data_file, 'distance', max_light_years)\n        gaia_status, gaia_meta = cache_mgr.check_cache_validity(gaia_data_file, 'distance', max_light_years)\n\n        print(\"\\n\" + \"=\"*60)\n        print(\"CACHE STATUS REPORT\")\n        print(\"=\"*60)\n        print(f\"Hipparcos: {hip_status}\")\n        if hip_meta:\n            print(f\"  Cached: {hip_meta.entry_count} stars up to {hip_meta.limit_value} ly\")\n            print(f\"  Cache date: {hip_meta.query_date}\")\n        print(f\"Gaia: {gaia_status}\")\n        if gaia_meta:\n            print(f\"  Cached: {gaia_meta.entry_count} stars up to {gaia_meta.limit_value} ly\")\n            print(f\"  Cache date: {gaia_meta.query_date}\")\n\n        # Explain what happened\n        if hip_status == 'expand' or gaia_status == 'expand':\n            print(\"\\nOK INCREMENTAL FETCH PERFORMED - only new data fetched\")\n        elif hip_status == 'subset' or gaia_status == 'subset':\n            print(\"\\nOK FILTERED EXISTING CACHE - no network queries needed\")\n        elif hip_status == 'exact' and gaia_status == 'exact':\n            print(\"\\nOK EXACT CACHE HIT - using existing data\")\n        elif hip_status == 'missing' or gaia_status == 'missing':\n            print(\"\\nWarning: FULL FETCH PERFORMED - no cache found\")\n        print(\"=\"*60 + \"\\n\")\n        # ============ END CACHE STATUS REPORT ============\n\n        # Step 2: Data Processing\n        print(\"Starting data processing...\")\n        process_start = time.time()\n\n        # Prepare the data (distances and alignment)\n        hip_data = calculate_distances(hip_data) if hip_data is not None else None\n        gaia_data = calculate_distances(gaia_data) if gaia_data is not None else None\n\n        if hip_data is not None:\n            hip_data = align_coordinate_systems(hip_data)\n\n        if gaia_data is not None:\n            gaia_data['Estimated_Vmag'] = estimate_vmag_from_gaia(gaia_data)\n\n        # Process everything - NOTE THE CHANGE HERE: now returns 5 values\n        combined_data, counts, unique_ids, existing_properties, missing_ids = process_stars(hip_data, gaia_data, max_light_years)\n\n        if combined_data is None:\n            print(\"No valid stars found to process. Exiting.\")\n            return\n\n        print(f\"Data processing completed in {time.time() - process_start:.2f} seconds.\")\n\n        # Step 3: Analysis and Visualization\n        print(\"Starting analysis and visualization...\")\n        viz_start = time.time()\n\n        # Convert to pandas DataFrame for visualization\n        combined_df = combined_data.to_pandas()\n\n        # Apply temperature patches for known problematic stars\n        from stellar_data_patches import apply_temperature_patches\n        combined_df = apply_temperature_patches(combined_df)\n\n        # Only update PKL if we actually added new stars to the dataset\n        if len(missing_ids) > 0:  # Now using missing_ids from process_stars\n            config = SimbadConfig.load_from_file()\n            manager = SimbadQueryManager(config)\n            properties_file = 'star_data/star_properties_distance.pkl'\n            updated_properties = manager.update_calculated_properties(combined_df, properties_file)\n            print(f\"Updated PKL with calculated properties for {len(missing_ids)} new stars\")\n        else:\n            print(\"No new stars added - PKL file unchanged\")\n\n        if len(combined_df) == 0:\n            print(\"No stars available for visualization after processing.\")\n            return\n\n        # Debug: Find Hipparcos stars without temperature\n        print(\"\\n\" + \"=\"*60)\n        print(\"DEBUG: Finding Hipparcos stars without temperature\")\n        print(\"=\"*60)\n\n        hip_stars = combined_df[combined_df['Source_Catalog'] == 'Hipparcos']\n        hip_no_temp = hip_stars[(hip_stars['Temperature'].isna()) | (hip_stars['Temperature'] <= 0)]\n\n        print(f\"Total Hipparcos stars: {len(hip_stars)}\")\n        print(f\"Hipparcos with valid temperature: {(hip_stars['Temperature'] > 0).sum()}\")\n        print(f\"Hipparcos without valid temperature: {len(hip_no_temp)}\")\n\n        if len(hip_no_temp) > 0:\n            print(\"\\nDetails of Hipparcos stars without temperature:\")\n            for idx, star in hip_no_temp.iterrows():\n                print(f\"\\n  Star: {star.get('Star_Name', 'Unknown')}\")\n                print(f\"  HIP: {star.get('HIP', 'N/A')}\")\n                print(f\"  Vmag: {star.get('Vmag', 'N/A')}\")\n                \n                # Safe distance formatting\n                distance = star.get('Distance_ly')\n                if distance is not None and not pd.isna(distance):\n                    print(f\"  Distance: {distance:.1f} ly\")\n                else:\n                    print(f\"  Distance: N/A\")\n                    \n                print(f\"  Spectral Type: {star.get('Spectral_Type', 'N/A')}\")\n                print(f\"  B-V: {star.get('B_V', 'N/A')}\")\n                print(f\"  Temperature: {star.get('Temperature', 'N/A')}\")\n                print(f\"  Object Type: {star.get('Object_Type', 'N/A')}\")\n                \n                # Check why temperature is missing\n                if pd.isna(star.get('B_mag')) or pd.isna(star.get('V_mag')):\n                    print(f\"  Issue: Missing B or V magnitude (B={star.get('B_mag', 'N/A')}, V={star.get('V_mag', 'N/A')})\")\n                if pd.isna(star.get('Spectral_Type')) or star.get('Spectral_Type') == '':\n                    print(f\"  Issue: Missing spectral type\")\n\n        print(\"=\"*60)\n\n        # Analyze magnitude distribution\n        analyze_magnitude_distribution(combined_df, mag_limit=None)\n        \n        # Run comprehensive analysis\n        analysis_results = analyze_and_report_stars(\n            combined_df,\n            mode='distance',\n            max_value=max_light_years\n        )\n        \n        # Parse stellar classes\n        combined_df = parse_stellar_classes(combined_df)\n        \n        # Store the mode in the DataFrame attributes\n        combined_df.attrs['mode'] = 'distance'\n        # Flatten the analysis for visualization (ADD THIS SECTION)\n\n        # Same logic for BOTH planetarium_distance.py and planetarium_apparent_magnitude.py\n        hip_df = combined_df[combined_df['Source_Catalog'] == 'Hipparcos']\n        gaia_df = combined_df[combined_df['Source_Catalog'] == 'Gaia']\n\n        hip_total = len(hip_df)\n        gaia_with_temp = (gaia_df['Temperature'] > 0).sum()\n        gaia_without_temp = len(gaia_df) - gaia_with_temp\n\n        flattened_analysis = {\n            'total_stars': len(combined_df),\n            'plottable_hip': hip_total,  # All Hipparcos stars\n            'plottable_gaia': gaia_with_temp,  # Gaia WITH temperature\n            'missing_temp': gaia_without_temp,  # Gaia WITHOUT temperature\n            'missing_lum': 0,\n            'temp_le_zero': 0\n        }\n\n        combined_df.attrs['analysis'] = flattened_analysis  # Use flattened version \n\n        final_counts = {\n            'hip_bright_count': counts['hip_bright_count'],\n            'hip_mid_count': counts['hip_mid_count'],\n            'gaia_mid_count': counts['gaia_mid_count'],\n            'gaia_faint_count': counts['gaia_faint_count'],\n            'total_stars': counts['total_stars'],\n            'plottable_count': counts['plottable_count'],\n            'missing_temp_only': counts['missing_temp_only'],\n            'missing_lum_only': counts['missing_lum_only'],\n            'source_counts': counts['source_counts'],\n            'estimation_results': counts['estimation_results']\n        }\n\n        # Prepare data for visualization\n        prepared_df = prepare_3d_data(\n            combined_df,  # your DataFrame from combined_data\n            max_value=max_light_years,\n            counts=final_counts,\n            mode='distance'  # Explicitly set mode to 'distance'\n        )\n\n        if prepared_df is None or len(prepared_df) == 0:\n            print(\"No plottable stars found after data preparation.\")\n            return\n\n        create_3d_visualization(\n            combined_df=prepared_df,\n            max_value=max_light_years,\n            user_max_coord=None  # Optional: you can pass a custom scale value here\n        )\n\n# Define the visualize function here, just before the visualization code\n        def visualize():\n            try:\n                prepared_df = prepare_3d_data(\n                    combined_df,\n                    max_value=max_light_years,\n                    counts=final_counts,\n                    mode='distance'\n                )\n                \n                if prepared_df is None or len(prepared_df) == 0:\n                    print(\"No plottable stars found after data preparation.\")\n                    return\n                    \n                # Create visualization\n                fig = create_3d_visualization(prepared_df, max_light_years)\n                \n                # Show and save figure safely\n                default_name = f\"3d_stars_distance_{int(max_light_years)}ly\"\n                show_figure_safely(fig, default_name)\n                \n            except Exception as e:\n                print(f\"Error during visualization: {e}\")\n                traceback.print_exc()\n\n        # Replace the existing visualization code with:\n        viz_thread = create_monitored_thread(shutdown_handler, visualize)\n        viz_thread.start()\n        viz_thread.join()  # Wait for visualization to complete\n\n        print(f\"Visualization completed in {time.time() - viz_start:.2f} seconds.\")\n\n    except Exception as e:\n        print(f\"Error during execution: {e}\")\n        traceback.print_exc()\n        return\n    finally:\n        shutdown_handler.cleanup()\n\n    print(f\"Total execution time: {time.time() - start_time:.2f} seconds.\")",
    "start_line": 204,
    "end_line": 482,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function main",
    "component_id": "planetarium_distance.main"
  },
  "planetarium_distance.visualize": {
    "id": "planetarium_distance.visualize",
    "name": "visualize",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\planetarium_distance.py",
    "relative_path": "planetarium_distance.py",
    "depends_on": [
      "visualization_3d.create_3d_visualization",
      "shutdown_handler.show_figure_safely",
      "visualization_3d.prepare_3d_data"
    ],
    "source_code": "        def visualize():\n            try:\n                prepared_df = prepare_3d_data(\n                    combined_df,\n                    max_value=max_light_years,\n                    counts=final_counts,\n                    mode='distance'\n                )\n                \n                if prepared_df is None or len(prepared_df) == 0:\n                    print(\"No plottable stars found after data preparation.\")\n                    return\n                    \n                # Create visualization\n                fig = create_3d_visualization(prepared_df, max_light_years)\n                \n                # Show and save figure safely\n                default_name = f\"3d_stars_distance_{int(max_light_years)}ly\"\n                show_figure_safely(fig, default_name)\n                \n            except Exception as e:\n                print(f\"Error during visualization: {e}\")\n                traceback.print_exc()",
    "start_line": 444,
    "end_line": 466,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function visualize",
    "component_id": "planetarium_distance.visualize"
  },
  "plot_data_exchange.PlotDataExchange": {
    "id": "plot_data_exchange.PlotDataExchange",
    "name": "PlotDataExchange",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\plot_data_exchange.py",
    "relative_path": "plot_data_exchange.py",
    "depends_on": [],
    "source_code": "class PlotDataExchange:\n    \"\"\"Exchange plot data between subprocess scripts and GUI.\"\"\"\n    \n#    EXCHANGE_FILE = \"last_plot_data.json\"\n    EXCHANGE_FILE = \"reports/last_plot_data.json\"\n    \n    @classmethod\n    def save_plot_data(cls, combined_df: pd.DataFrame, counts_dict: Dict,\n                       processing_times: Dict = None, mode: str = 'magnitude',\n                       limit_value: float = None):\n        \"\"\"\n        Save plot data for the GUI to read.\n        Called from hr_diagram_apparent_magnitude.py and hr_diagram_distance.py\n        \"\"\"\n        # Extract key statistics from DataFrame\n        total_stars = len(combined_df)\n        \n        # Temperature statistics\n        temp_valid = (combined_df['Temperature'] > 0).sum() if 'Temperature' in combined_df else 0\n        temp_missing = total_stars - temp_valid\n        \n        # Luminosity statistics\n        lum_valid = (combined_df['Luminosity'] > 0).sum() if 'Luminosity' in combined_df else 0\n        lum_missing = total_stars - lum_valid\n        \n        # Catalog distribution\n        catalog_counts = {}\n        if 'Source_Catalog' in combined_df:\n            for catalog, count in combined_df['Source_Catalog'].value_counts().items():\n                catalog_counts[str(catalog)] = int(count)\n        \n        # Magnitude statistics with NaN/Inf handling\n        mag_stats = {}\n        if 'Apparent_Magnitude' in combined_df:\n            mag_array = combined_df['Apparent_Magnitude'].dropna()\n            if len(mag_array) > 0:\n                # Convert to regular Python floats and handle NaN/Inf\n                mag_stats = {\n                    'min': cls._safe_float(mag_array.min()),\n                    'max': cls._safe_float(mag_array.max()),\n                    'mean': cls._safe_float(mag_array.mean()),\n                    'median': cls._safe_float(mag_array.median()),\n                    'std': cls._safe_float(mag_array.std())\n                }\n        \n        # Clean counts_dict to remove DataFrames and handle NaN/Inf\n        clean_counts = {}\n        for k, v in counts_dict.items():\n            if isinstance(v, pd.DataFrame):\n                continue  # Skip DataFrames\n            elif isinstance(v, dict):\n                # Recursively clean nested dicts\n                clean_counts[k] = cls._clean_dict_for_json(v)\n            elif isinstance(v, (np.integer, np.floating)):\n                # Convert numpy types to Python types\n                clean_counts[k] = cls._safe_float(v) if isinstance(v, np.floating) else int(v)\n            elif isinstance(v, (int, float)):\n                clean_counts[k] = cls._safe_float(v) if isinstance(v, float) else v\n            else:\n                clean_counts[k] = v\n        \n        # Clean processing_times\n        clean_times = {}\n        if processing_times:\n            for k, v in processing_times.items():\n                if isinstance(v, (float, np.floating)):\n                    clean_times[k] = cls._safe_float(v)\n                else:\n                    clean_times[k] = v\n        \n        # Prepare data for JSON serialization\n        plot_data = {\n            'timestamp': datetime.now().isoformat(),\n            'mode': mode,\n            'limit_value': cls._safe_float(limit_value) if limit_value is not None else None,\n            'total_stars': int(total_stars),\n            'temp_valid': int(temp_valid),\n            'temp_missing': int(temp_missing),\n            'lum_valid': int(lum_valid),\n            'lum_missing': int(lum_missing),\n            'catalog_counts': catalog_counts,\n            'magnitude_stats': mag_stats,\n            'counts_dict': clean_counts,\n            'processing_times': clean_times\n        }\n        \n        # Save to file\n        try:\n            with open(cls.EXCHANGE_FILE, 'w') as f:\n                json.dump(plot_data, f, indent=2)\n            print(f\"Plot data saved to {cls.EXCHANGE_FILE}\")\n        except Exception as e:\n            print(f\"Error saving plot data: {e}\")\n            # Try to save a minimal version\n            try:\n                minimal_data = {\n                    'timestamp': datetime.now().isoformat(),\n                    'mode': mode,\n                    'limit_value': limit_value,\n                    'total_stars': total_stars,\n                    'error': str(e)\n                }\n                with open(cls.EXCHANGE_FILE, 'w') as f:\n                    json.dump(minimal_data, f, indent=2)\n                print(f\"Saved minimal plot data due to error\")\n            except:\n                print(f\"Could not save any plot data\")\n\n    @classmethod\n    def _safe_float(cls, value):\n        \"\"\"Convert float to JSON-safe value, handling NaN and Inf.\"\"\"\n        if value is None:\n            return None\n        if isinstance(value, (np.integer, np.floating)):\n            value = float(value)\n        if isinstance(value, float):\n            if np.isnan(value):\n                return None  # Or use 0.0 or a placeholder\n            elif np.isinf(value):\n                return None  # Or use a large number like 1e308\n            else:\n                return value\n        return value\n    \n    @classmethod\n    def _clean_dict_for_json(cls, d):\n        \"\"\"Recursively clean a dictionary for JSON serialization.\"\"\"\n        if not isinstance(d, dict):\n            return d\n        \n        clean = {}\n        for k, v in d.items():\n            if isinstance(v, pd.DataFrame):\n                continue  # Skip DataFrames\n            elif isinstance(v, dict):\n                clean[k] = cls._clean_dict_for_json(v)\n            elif isinstance(v, (np.integer, np.floating)):\n                clean[k] = cls._safe_float(v) if isinstance(v, np.floating) else int(v)\n            elif isinstance(v, float):\n                clean[k] = cls._safe_float(v)\n            else:\n                clean[k] = v\n        return clean\n\n    @classmethod\n    def load_plot_data(cls) -> Dict:\n        \"\"\"Load the last plot data. Called from GUI.\"\"\"\n        if not os.path.exists(cls.EXCHANGE_FILE):\n            print(f\"Plot data file not found: {cls.EXCHANGE_FILE}\")\n            return None\n        \n        try:\n            with open(cls.EXCHANGE_FILE, 'r') as f:\n                data = json.load(f)\n            print(f\"Successfully loaded plot data from {cls.EXCHANGE_FILE}\")\n            return data\n        except json.JSONDecodeError as e:\n            print(f\"Error decoding JSON from {cls.EXCHANGE_FILE}: {e}\")\n            # Try to show what's in the file for debugging\n            try:\n                with open(cls.EXCHANGE_FILE, 'r') as f:\n                    content = f.read()\n                print(f\"File content (first 200 chars): {content[:200]}\")\n            except:\n                pass\n            return None\n        except Exception as e:\n            print(f\"Error loading plot data: {e}\")\n            return None",
    "start_line": 8,
    "end_line": 176,
    "has_docstring": true,
    "docstring": "Exchange plot data between subprocess scripts and GUI.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class PlotDataExchange",
    "component_id": "plot_data_exchange.PlotDataExchange"
  },
  "plot_data_report_widget.PlotDataReportWidget": {
    "id": "plot_data_report_widget.PlotDataReportWidget",
    "name": "PlotDataReportWidget",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\plot_data_report_widget.py",
    "relative_path": "plot_data_report_widget.py",
    "depends_on": [
      "report_manager.ReportManager",
      "object_type_analyzer.ObjectTypeAnalyzer"
    ],
    "source_code": "class PlotDataReportWidget(ttk.Frame):\n    \"\"\"Widget for displaying comprehensive plot data report.\"\"\"\n    \n    \n    def __init__(self, parent, **kwargs):\n        super().__init__(parent, **kwargs)\n        self.setup_ui()\n        self.last_report_data = None\n        self.generation_time = None\n        \n        # Initialize the object type analyzer if available\n        if ANALYZER_AVAILABLE:\n            self.object_analyzer = ObjectTypeAnalyzer()\n        else:\n            self.object_analyzer = None           \n        \n    def setup_ui(self):\n        \"\"\"Set up the UI with scrollable text display.\"\"\"\n        # Main frame with label\n        report_frame = ttk.LabelFrame(self, text=\"Plot Data Report\", padding=5)\n        report_frame.pack(fill='both', expand=True)\n        \n        # Control buttons frame\n        button_frame = ttk.Frame(report_frame)\n        button_frame.pack(fill='x', pady=(0, 5))\n        \n        # Refresh button\n        self.refresh_button = ttk.Button(\n            button_frame, \n            text=\"Refresh Report\",\n            command=self.refresh_report,\n            state='disabled'\n        )\n        self.refresh_button.pack(side='left', padx=(0, 5))\n        \n        # Export button\n        self.export_button = ttk.Button(\n            button_frame,\n            text=\"Export Report\",\n            command=self.export_report,\n            state='disabled'\n        )\n        self.export_button.pack(side='left')\n        \n        # Status label\n        self.status_label = ttk.Label(button_frame, text=\"No plot data available\")\n        self.status_label.pack(side='right')\n        \n        # Scrollable text area\n        text_frame = ttk.Frame(report_frame)\n        text_frame.pack(fill='both', expand=True)\n        \n        v_scroll = ttk.Scrollbar(text_frame, orient='vertical')\n        v_scroll.pack(side='right', fill='y')\n        \n        h_scroll = ttk.Scrollbar(text_frame, orient='horizontal')\n        h_scroll.pack(side='bottom', fill='x')\n        \n        self.report_display = tk.Text(\n            text_frame,\n            height=30,\n            width=60,\n            wrap='word',\n            yscrollcommand=v_scroll.set,\n            xscrollcommand=h_scroll.set,\n            font=('Consolas', 10),\n    #        bg='#f5f5f5',\n    #        bg='gray90',\n            bg='white',\n            state='normal'  \n        )\n        self.report_display.pack(fill='both', expand=True)\n        v_scroll.config(command=self.report_display.yview)\n        h_scroll.config(command=self.report_display.xview)\n        \n        self._add_clipboard_support(self.report_display)\n\n        # Configure text tags for formatting\n        self.report_display.tag_configure('header', font=('Consolas', 12, 'bold'))\n        self.report_display.tag_configure('subheader', font=('Consolas', 11, 'bold'))\n        self.report_display.tag_configure('warning', foreground='#ff6600')\n        self.report_display.tag_configure('error', foreground='red')\n        self.report_display.tag_configure('success', foreground='green')\n        self.report_display.tag_configure('info', foreground='blue')\n        \n        # Initial message\n        self.report_display.insert('1.0', \n            \"Plot Data Report\\n\"\n            \"================\\n\\n\"\n            \"Generate a plot to view the data report.\\n\\n\"\n            \"This report will include:\\n\"\n            \"* Data completeness metrics\\n\"\n            \"* Quality indicators and anomalies\\n\"\n            \"* Catalog coverage analysis\\n\"\n            \"* Processing diagnostics\\n\"\n            \"* Notable features and warnings\")\n        \n\n    def _add_clipboard_support(self, widget):\n        \"\"\"Add clipboard and selection support to text widget.\"\"\"\n        def _copy(event=None):\n            try:\n                sel = widget.get(\"sel.first\", \"sel.last\")\n                widget.clipboard_clear()\n                widget.clipboard_append(sel)\n            except tk.TclError:\n                pass\n            return \"break\"\n        \n        def _select_all(event=None):\n            widget.tag_add(tk.SEL, \"1.0\", tk.END)\n            widget.mark_set(tk.INSERT, \"1.0\")\n            widget.see(\"insert\")\n            return \"break\"\n        \n        widget.bind(\"<Control-c>\", _copy)\n        widget.bind(\"<Control-a>\", _select_all)\n        menu = tk.Menu(widget, tearoff=0)\n        menu.add_command(label=\"Copy\", command=_copy)\n        menu.add_command(label=\"Select All\", command=_select_all)\n        widget.bind(\"<Button-3>\", lambda e: menu.post(e.x_root, e.y_root))        \n        \n    def generate_report(self, combined_df: pd.DataFrame, counts_dict: Dict, \n                       processing_times: Optional[Dict] = None,\n                       mode: str = 'magnitude', limit_value: float = None) -> str:\n        \"\"\"\n        Generate comprehensive plot data report.\n        \n        Parameters:\n            combined_df: The dataframe with all star data\n            counts_dict: Dictionary with star counts and statistics\n            processing_times: Optional timing information\n            mode: 'magnitude' or 'distance'\n            limit_value: The limiting magnitude or distance\n        \"\"\"\n        self.last_report_data = {\n            'combined_df': combined_df,\n            'counts_dict': counts_dict,\n            'processing_times': processing_times,\n            'mode': mode,\n            'limit_value': limit_value\n        }\n        self.generation_time = datetime.now()\n        \n        report_lines = []\n        report_lines.append(\"=\" * 46)\n        report_lines.append(\"PLOT DATA REPORT\")\n        report_lines.append(\"=\" * 46)\n        report_lines.append(f\"Generated: {self.generation_time.strftime('%Y-%m-%d %H:%M:%S')}\")\n        report_lines.append(f\"Plot Mode: {mode.capitalize()}-based\")\n        \n        if mode == 'magnitude':\n            report_lines.append(f\"Limiting Magnitude: {limit_value}\")\n        else:\n            report_lines.append(f\"Distance Limit: {limit_value} light-years\")\n        \n        report_lines.append(\"\")\n        \n        # Section 1: Basic Statistics\n        report_lines.append(\"-\" * 52)\n        report_lines.append(\"1. BASIC PLOT STATISTICS\")\n        report_lines.append(\"-\" * 52)\n        \n        total_stars = counts_dict.get('total_stars', len(combined_df))\n        report_lines.append(f\"Total Stars in Dataset: {total_stars:,d}\")\n        \n        # Catalog breakdown\n        hip_bright = counts_dict.get('hip_bright_count', 0)\n        hip_mid = counts_dict.get('hip_mid_count', 0)\n        gaia_mid = counts_dict.get('gaia_mid_count', 0)\n        gaia_faint = counts_dict.get('gaia_faint_count', 0)\n        \n        report_lines.append(\"\\nCatalog Distribution:\")\n        report_lines.append(f\"  Hipparcos Bright (Vmag <= 1.73): {hip_bright:,d}\")\n        report_lines.append(f\"  Hipparcos Mid (1.73 < Vmag <= 4.0): {hip_mid:,d}\")\n        report_lines.append(f\"  Gaia Mid (1.73 < Vmag <= 4.0): {gaia_mid:,d}\")\n        report_lines.append(f\"  Gaia Faint (Vmag > 4.0): {gaia_faint:,d}\")\n        \n        # Section 2: Data Completeness\n        report_lines.append(\"\\n\" + \"-\" * 52)\n        report_lines.append(\"2. DATA COMPLETENESS METRICS\")\n        report_lines.append(\"-\" * 52)\n        \n        # Temperature completeness\n        temp_valid = (combined_df['Temperature'] > 0).sum() if 'Temperature' in combined_df else 0\n        temp_missing = total_stars - temp_valid\n        temp_percent = (temp_valid / total_stars * 100) if total_stars > 0 else 0\n        \n        report_lines.append(\"\\nTemperature Data:\")\n        report_lines.append(f\"  Valid temperatures: {temp_valid:,d} ({temp_percent:.1f}%)\")\n        report_lines.append(f\"  Missing temperatures: {temp_missing:,d}\")\n        \n        # Temperature source breakdown\n        source_counts = counts_dict.get('source_counts', {})\n        if source_counts:\n            report_lines.append(\"\\n  Temperature Sources:\")\n            report_lines.append(f\"    B-V color matched: {source_counts.get('bv_matched', 0):,d}\")\n            report_lines.append(f\"    B-V only: {source_counts.get('bv_only', 0):,d}\")\n            report_lines.append(f\"    Spectral type (hot): {source_counts.get('spectral_type_hot', 0):,d}\")\n            report_lines.append(f\"    Spectral type (cool): {source_counts.get('spectral_type_cool', 0):,d}\")\n            report_lines.append(f\"    Spectral type only: {source_counts.get('spectral_type_only', 0):,d}\")\n            report_lines.append(f\"    Disagreement: {source_counts.get('spectral_type_disagreement', 0):,d}\")\n            report_lines.append(f\"    No source: {source_counts.get('none', 0):,d}\")\n        \n        # Luminosity completeness\n        lum_valid = (combined_df['Luminosity'] > 0).sum() if 'Luminosity' in combined_df else 0\n        lum_missing = total_stars - lum_valid\n        lum_percent = (lum_valid / total_stars * 100) if total_stars > 0 else 0\n        \n        report_lines.append(\"\\nLuminosity Data:\")\n        report_lines.append(f\"  Valid luminosities: {lum_valid:,d} ({lum_percent:.1f}%)\")\n        report_lines.append(f\"  Missing luminosities: {lum_missing:,d}\")\n        \n        # Estimation results\n        estimation_results = counts_dict.get('estimation_results', {})\n        if estimation_results:\n            bright_estimates = estimation_results.get('bright_star_estimates', 0)\n            if bright_estimates > 0:\n                report_lines.append(f\"  Estimated (bright stars): {bright_estimates:,d}\")\n        \n        # Plottability\n        plottable = counts_dict.get('plottable_count', 0)\n        plottable_percent = (plottable / total_stars * 100) if total_stars > 0 else 0\n        not_plottable = total_stars - plottable\n        \n        report_lines.append(\"\\nPlottable Stars:\")\n        report_lines.append(f\"  Total plottable: {plottable:,d} ({plottable_percent:.1f}%)\")\n\n        if not_plottable > 0:\n            report_lines.append(f\"  Not plottable: {not_plottable:,d} (missing temperature or luminosity)\")\n        else:\n            report_lines.append(f\"  Not plottable: 0\")        \n        \n        # Section 3: Data Quality Indicators\n        report_lines.append(\"\\n\" + \"-\" * 52)\n        report_lines.append(\"3. DATA QUALITY INDICATORS\")\n        report_lines.append(\"-\" * 52)\n        \n        # Check for anomalies\n        anomalies = []\n        \n        # Temperature anomalies\n        if 'Temperature' in combined_df:\n            temp_array = combined_df['Temperature'].dropna()\n            if len(temp_array) > 0:\n                temp_outliers_low = (temp_array < 2000).sum()\n                temp_outliers_high = (temp_array > 50000).sum()\n                if temp_outliers_high > 0:\n                    anomalies.append(f\"  Warning: {temp_outliers_high} stars with T > 50000K (Wolf-Rayet stars or data errors)\")\n        \n        # Luminosity anomalies\n        if 'Luminosity' in combined_df:\n            lum_array = combined_df['Luminosity'].dropna()\n            if len(lum_array) > 0:\n                lum_negative = (lum_array <= 0).sum()\n                lum_extreme_low = (lum_array < 0.00001).sum()\n                lum_extreme_high = (lum_array > 100000).sum()\n                \n                if lum_negative > 0:\n                    anomalies.append(f\"  Warning: {lum_negative} stars with L <= 0 (impossible - calculation errors)\")\n                if lum_extreme_low > 0:\n                    anomalies.append(f\"  Warning: {lum_extreme_low} stars with L < 0.00001 Lsun (very faint white dwarfs or errors)\")\n                if lum_extreme_high > 0:\n                    anomalies.append(f\"  Warning: {lum_extreme_high} stars with L > 100000 Lsun (hypergiants or calculation errors)\")\n        \n        # Distance/parallax quality\n        if 'Distance_pc' in combined_df:\n            dist_array = combined_df['Distance_pc'].dropna()\n            if len(dist_array) > 0:\n                dist_negative = (dist_array <= 0).sum()\n                if dist_negative > 0:\n                    anomalies.append(f\"  Warning: {dist_negative} stars with invalid distance (parallax calculation errors)\")\n        \n        if anomalies:\n            report_lines.append(\"\\nAnomalies Detected:\")\n            report_lines.extend(anomalies)\n        else:\n            report_lines.append(\"\\nOK No significant anomalies detected\")\n        \n        # Check for duplicates\n        if 'HIP' in combined_df:\n            hip_duplicates = combined_df['HIP'].duplicated().sum()\n            if hip_duplicates > 0:\n                report_lines.append(f\"\\n  Warning: {hip_duplicates} duplicate HIP entries (database integrity issue)\")\n        \n        # Section 4: Catalog Coverage\n        report_lines.append(\"\\n\" + \"-\" * 52)\n        report_lines.append(\"4. CATALOG COVERAGE ANALYSIS\")\n        report_lines.append(\"-\" * 52)\n        \n        if 'Source_Catalog' in combined_df:\n            catalog_counts = combined_df['Source_Catalog'].value_counts()\n            report_lines.append(\"\\nSource Distribution:\")\n            for catalog, count in catalog_counts.items():\n                percent = (count / total_stars * 100) if total_stars > 0 else 0\n                report_lines.append(f\"  {catalog}: {count:,d} ({percent:.1f}%)\")\n                \n        report_lines.append(\"\\n\" + \"-\" * 52)  # Shortened by 1\n        report_lines.append(\"5. PROCESSING DIAGNOSTICS\")\n        report_lines.append(\"-\" * 52)  # Shortened by 1\n        \n        if processing_times and isinstance(processing_times, dict) and processing_times:\n            for key, value in processing_times.items():\n                if isinstance(value, (int, float)):\n                    report_lines.append(f\"  {key.replace('_', ' ').title()}: {value:.2f} seconds\")\n                else:\n                    report_lines.append(f\"  {key.replace('_', ' ').title()}: {value}\")\n        else:\n            report_lines.append(\"  Processing times include:\")\n            report_lines.append(\"    - Data acquisition (catalog queries)\")\n            report_lines.append(\"    - Parameter calculations (temperature, luminosity)\")\n            report_lines.append(\"    - Data preparation and validation\")\n            report_lines.append(\"    - Visualization generation\")\n            report_lines.append(\"  (Times shown when available)\")\n\n    \n        # Section 6: Object Type Analysis\n        report_lines.append(\"\\n\" + \"-\" * 52)\n        report_lines.append(\"6. OBJECT TYPE ANALYSIS\")\n        report_lines.append(\"-\" * 52)\n\n        # DEBUG: See what columns we actually have\n        print(\"\\n\" + \"=\"*60)\n        print(\"DEBUG: Object Type Analysis\")\n        print(\"=\"*60)\n        print(f\"Total columns in dataframe: {len(combined_df.columns)}\")\n        print(f\"All columns: {combined_df.columns.tolist()}\")\n\n        # Check for any column with 'type' in name\n        type_cols = [col for col in combined_df.columns if 'type' in col.lower()]\n        print(f\"Columns with 'type' in name: {type_cols}\")\n\n        # Check for any column with 'object' in name  \n        obj_cols = [col for col in combined_df.columns if 'object' in col.lower()]\n        print(f\"Columns with 'object' in name: {obj_cols}\")\n\n        # Try to find the actual column\n        type_column = None\n        possible_names = ['Object_Type_Desc', 'Object_Type', 'object_type', 'Object Type', \n                        'object_type_desc', 'ObjectType', 'otype']\n\n        for name in possible_names:\n            if name in combined_df.columns:\n                type_column = name\n                non_null = combined_df[name].notna().sum()\n                print(f\"Found '{name}' with {non_null} non-null values\")\n                if non_null > 0:\n                    print(f\"Sample values: {combined_df[name].dropna().head(3).tolist()}\")\n                    break\n\n        print(\"=\"*60)\n\n        # Now run the analysis if we found the column\n        if type_column and combined_df[type_column].notna().any():\n            if self.object_analyzer:\n                analysis_results = self.object_analyzer.analyze_distribution(combined_df[type_column])\n                analysis_lines = self.object_analyzer.format_report_section(analysis_results)\n                report_lines.extend(analysis_lines)\n                self.last_analysis_results = analysis_results\n            else:\n                # Simple fallback\n                object_types = combined_df[type_column].value_counts()\n                report_lines.append(f\"\\nFound {len(object_types)} unique object types\")\n                for obj_type, count in object_types.head(5).items():\n                    report_lines.append(f\"  * {obj_type}: {count}\")\n        else:\n            report_lines.append(\"\\n  Object type information not available in dataset\")\n            if type_column:\n                report_lines.append(f\"  Column '{type_column}' found but all values are null\")\n            else:\n                report_lines.append(f\"  No object type column found\")\n                report_lines.append(f\"  Searched for: {', '.join(possible_names[:3])}\")\n\n        # Section 7: Warnings and Recommendations\n        report_lines.append(\"\\n\" + \"-\" * 52)\n        report_lines.append(\"7. WARNINGS AND RECOMMENDATIONS\")\n        report_lines.append(\"-\" * 52)\n        \n        warnings = []\n        \n        # Check completeness thresholds\n        if temp_percent < 90:\n            warnings.append(f\"Warning: Temperature completeness is {temp_percent:.1f}% (< 90%)\")\n        if lum_percent < 90:\n            warnings.append(f\"Warning: Luminosity completeness is {lum_percent:.1f}% (< 90%)\")\n        if plottable_percent < 80:\n            warnings.append(f\"Warning: Only {plottable_percent:.1f}% of stars are plottable\")\n        \n        # Check for significant missing data\n        if temp_missing > 100:\n            warnings.append(f\"Warning: {temp_missing:,d} stars missing temperature data\")\n        if lum_missing > 100:\n            warnings.append(f\"Warning: {lum_missing:,d} stars missing luminosity data\")\n        \n        if warnings:\n            report_lines.append(\"\\nWarnings:\")\n            report_lines.extend([\"  \" + w for w in warnings])\n            \n            # Add recommendations\n            report_lines.append(\"\\nRecommendations:\")\n            if temp_percent < 90 or lum_percent < 90:\n                report_lines.append(\"  * Consider adjusting search parameters for better data coverage\")\n            if mode == 'magnitude' and limit_value and limit_value > 6:\n                report_lines.append(\"  * Large magnitude range may include incomplete Gaia data\")\n            if mode == 'distance' and limit_value and limit_value > 50:\n                report_lines.append(\"  * Large distance range may have increased parallax uncertainties\")\n        else:\n            report_lines.append(\"\\nOK No warnings - data quality appears good\")\n        \n        report_lines.append(\"\\n\" + \"=\" * 46)\n        report_lines.append(\"END OF REPORT\")\n        report_lines.append(\"=\" * 46)\n        \n        return \"\\n\".join(report_lines)\n    \n    def update_report(self, combined_df: pd.DataFrame, counts_dict: Dict,\n                     processing_times: Optional[Dict] = None,\n                     mode: str = 'magnitude', limit_value: float = None):\n        \"\"\"Update the report display with new data.\"\"\"\n        # Generate the report\n        report_text = self.generate_report(\n            combined_df, counts_dict, processing_times, mode, limit_value\n        )\n        \n        # Update display\n        self.report_display.delete('1.0', tk.END)\n        \n        # Add formatted text\n        lines = report_text.split('\\n')\n        for line in lines:\n            if line.startswith('='):\n                self.report_display.insert(tk.END, line + '\\n', 'header')\n            elif line.startswith('-'):\n                self.report_display.insert(tk.END, line + '\\n', 'subheader')\n            elif line.startswith('  Warning:'):\n                self.report_display.insert(tk.END, line + '\\n', 'warning')\n            elif line.startswith('  OK') or line.startswith('OK'):\n                self.report_display.insert(tk.END, line + '\\n', 'success')\n            elif line.startswith('1.') or line.startswith('2.') or line.startswith('3.') or \\\n                 line.startswith('4.') or line.startswith('5.') or line.startswith('6.') or \\\n                 line.startswith('7.'):\n                self.report_display.insert(tk.END, line + '\\n', 'subheader')\n            else:\n                self.report_display.insert(tk.END, line + '\\n')\n        \n        self.report_display.config(state='normal')\n\n        # Update status\n        self.status_label.config(text=f\"Report updated: {datetime.now().strftime('%H:%M:%S')}\")\n        self.refresh_button.config(state='normal')\n        self.export_button.config(state='normal')\n    \n\n    def refresh_report(self):\n        \"\"\"Refresh the report with the last data.\"\"\"\n        if self.last_report_data:\n            if isinstance(self.last_report_data, dict) and 'metadata' in self.last_report_data:\n                # New format\n                self.display_report(self.last_report_data)\n            else:\n                # Old format\n                self.update_report(**self.last_report_data)            \n    \n    def export_report(self):\n        \"\"\"Export the report to a text file.\"\"\"\n        if not self.last_report_data:\n            return\n        \n        from tkinter import filedialog\n        \n        # Generate filename with timestamp\n        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n        mode = self.last_report_data.get('mode', 'unknown')\n        default_name = f\"plot_report_{mode}_{timestamp}.txt\"\n        \n#        filename = filedialog.asksaveasfilename(\n#            defaultextension=\".txt\",\n#            filetypes=[(\"Text files\", \"*.txt\"), (\"All files\", \"*.*\")],\n#            initialfile=default_name\n#        )\n        \n        filename = filedialog.asksaveasfilename(\n            defaultextension=\".txt\",\n            filetypes=[(\"Text files\", \"*.txt\"), (\"All files\", \"*.*\")],\n            initialfile=default_name,\n            initialdir=\"reports\"\n        )\n\n        if filename:\n            try:\n                report_text = self.report_display.get('1.0', tk.END)\n                with open(filename, 'w') as f:\n                    f.write(report_text)\n                self.status_label.config(text=f\"Report exported successfully\")\n            except Exception as e:\n                self.status_label.config(text=f\"Export failed: {str(e)}\")\n\n    def display_report(self, report_data: Dict):\n        \"\"\"Display pre-generated report from visualization script.\"\"\"\n        self.last_report_data = report_data\n        self.generation_time = datetime.now()\n        \n        self.report_display.config(state='normal')\n        self.report_display.delete('1.0', tk.END)\n        \n        # Use the analyzer to format the complete report\n        if self.object_analyzer:\n            report_lines = self.object_analyzer.format_complete_report(report_data)\n        else:\n            # Fallback if analyzer not available\n            report_lines = self._format_basic_report(report_data)\n        \n        # Display with formatting\n        for line in report_lines:\n            if line.startswith(\"=\"):\n                self.report_display.insert(tk.END, line + '\\n', 'header')\n            elif line.startswith(\"-\"):\n                self.report_display.insert(tk.END, line + '\\n', 'subheader')\n            elif any(line.startswith(f\"{i}.\") for i in range(1, 8)):\n                self.report_display.insert(tk.END, line + '\\n', 'subheader')\n            elif \"WARNING\" in line or \"CRITICAL\" in line:\n                self.report_display.insert(tk.END, line + '\\n', 'warning')\n            elif line.startswith(\"[OK]\") or \"OK\" in line:\n                self.report_display.insert(tk.END, line + '\\n', 'success')\n            elif line.startswith(\"[OK]\"):\n                self.report_display.insert(tk.END, line + '\\n', 'info')\n            else:\n                self.report_display.insert(tk.END, line + '\\n')\n        \n        self.report_display.config(state='disabled')\n        self.status_label.config(text=f\"Report updated: {datetime.now().strftime('%H:%M:%S')}\")\n        self.refresh_button.config(state='normal')\n        self.export_button.config(state='normal')\n\n    def update_report_from_exchange(self, exchange_data: Dict):\n        \"\"\"Update report from exchange data - handles both old and new formats.\"\"\"\n        if 'report_data' in exchange_data:\n            # New format with pre-generated report\n            self.display_report(exchange_data['report_data'])\n        elif 'plot_stats' in exchange_data:\n            # Handle intermediate format\n            self._handle_plot_stats(exchange_data['plot_stats'])\n        else:\n            # Old format - create pseudo dataframe and use old method\n            self._handle_legacy_format(exchange_data)\n\n    def _handle_plot_stats(self, plot_stats: Dict):\n        \"\"\"Handle plot statistics format (intermediate).\"\"\"\n        # Create a minimal dataframe for backward compatibility\n        import pandas as pd\n        \n        total_stars = plot_stats.get('total_stars', 0)\n        temp_valid = plot_stats.get('temp_valid', 0)\n        lum_valid = plot_stats.get('lum_valid', 0)\n        \n        if total_stars > 0:\n            pseudo_df = pd.DataFrame({\n                'Temperature': [1] * temp_valid + [0] * (total_stars - temp_valid),\n                'Luminosity': [1] * lum_valid + [0] * (total_stars - lum_valid),\n                'Source_Catalog': ['Unknown'] * total_stars,\n                'Apparent_Magnitude': [0] * total_stars\n            })\n        else:\n            pseudo_df = pd.DataFrame()\n        \n        counts_dict = plot_stats.get('catalog_counts', {})\n        processing_times = plot_stats.get('processing_times', {})\n        mode = plot_stats.get('mode', 'unknown')\n        limit_value = plot_stats.get('limit_value', 0)\n        \n        self.update_report(pseudo_df, counts_dict, processing_times, mode, limit_value)\n\n    def _handle_legacy_format(self, exchange_data: Dict):\n        \"\"\"Handle the original format for backward compatibility.\"\"\"\n        # Similar to _handle_plot_stats but directly from exchange_data\n        import pandas as pd\n        \n        total_stars = exchange_data.get('total_stars', 0)\n        temp_valid = exchange_data.get('temp_valid', 0)\n        lum_valid = exchange_data.get('lum_valid', 0)\n        \n        if total_stars > 0:\n            pseudo_df = pd.DataFrame({\n                'Temperature': [1] * temp_valid + [0] * (total_stars - temp_valid),\n                'Luminosity': [1] * lum_valid + [0] * (total_stars - lum_valid)\n            })\n        else:\n            pseudo_df = pd.DataFrame()\n        \n        self.update_report(\n            pseudo_df,\n            exchange_data.get('counts_dict', {}),\n            exchange_data.get('processing_times', {}),\n            exchange_data.get('mode', 'unknown'),\n            exchange_data.get('limit_value', 0)\n        )\n\n    def _format_basic_report(self, report_data: Dict) -> List[str]:\n        \"\"\"Fallback formatter if ObjectTypeAnalyzer is not available.\"\"\"\n        lines = []\n        lines.append(\"=\" * 46)\n        lines.append(\"PLOT DATA REPORT\")\n        lines.append(\"=\" * 46)\n        \n        metadata = report_data.get('metadata', {})\n        lines.append(f\"Generated: {metadata.get('generation_time', 'Unknown')}\")\n        lines.append(f\"Mode: {metadata.get('mode', 'Unknown')}\")\n        lines.append(f\"Limit: {metadata.get('limit_value', 'Unknown')}\")\n        lines.append(\"\")\n        \n        lines.append(\"Note: Full analysis requires ObjectTypeAnalyzer module\")\n        \n        return lines               \n\n\n    def refresh_from_file(self):\n        \"\"\"Load and display the latest report from file.\"\"\"\n        try:\n            from report_manager import ReportManager\n            report_mgr = ReportManager()\n            report_data = report_mgr.load_last_report()\n            \n            if report_data:\n                self.display_report(report_data)\n                print(\"Report refreshed from file\")\n            else:\n                print(\"No report file found\")\n        except ImportError:\n            print(\"ReportManager not available\")",
    "start_line": 19,
    "end_line": 647,
    "has_docstring": true,
    "docstring": "Widget for displaying comprehensive plot data report.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "ttk.Frame"
    ],
    "class_name": null,
    "display_name": "class PlotDataReportWidget",
    "component_id": "plot_data_report_widget.PlotDataReportWidget"
  },
  "plot_data_report_widget.add_plot_report_to_gui": {
    "id": "plot_data_report_widget.add_plot_report_to_gui",
    "name": "add_plot_report_to_gui",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\plot_data_report_widget.py",
    "relative_path": "plot_data_report_widget.py",
    "depends_on": [
      "plot_data_report_widget.PlotDataReportWidget"
    ],
    "source_code": "def add_plot_report_to_gui(parent_frame, column=1, row=1):\n    \"\"\"\n    Add the plot report widget to the star visualization GUI.\n    \n    This should be called in the setup_ui method of StarVisualizationGUI\n    to add the report widget below the status window.\n    \"\"\"\n    # Create the report widget\n    report_widget = PlotDataReportWidget(parent_frame)\n    report_widget.grid(row=row, column=column, sticky='nsew', padx=5, pady=(10, 0))\n    \n    return report_widget",
    "start_line": 650,
    "end_line": 661,
    "has_docstring": true,
    "docstring": "Add the plot report widget to the star visualization GUI.\n\nThis should be called in the setup_ui method of StarVisualizationGUI\nto add the report widget below the status window.",
    "parameters": [
      "parent_frame",
      "column",
      "row"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_plot_report_to_gui",
    "component_id": "plot_data_report_widget.add_plot_report_to_gui"
  },
  "pluto_visualization_shells.create_pluto_core_shell": {
    "id": "pluto_visualization_shells.create_pluto_core_shell",
    "name": "create_pluto_core_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\pluto_visualization_shells.py",
    "relative_path": "pluto_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_pluto_core_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates pluto's core shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.70,  \n        'color': 'rgb(255, 56, 0)',  # This represents a color that is strongly biased towards red with very little green and no blue.\n        'opacity': 1.0,\n        'name': 'Core',\n        'description': (\n            \"Pluto core: Scientists believe Pluto has a dense, rocky core, likely composed of silicates and iron. The core's diameter <br>\" \n            \"is hypothesized to be about 1700 km, which is approximately 70% of Pluto's total diameter. Heat generated from the decay <br>\" \n            \"of radioactive elements within the core may still be present today.<br>\" \n            \"* Radioactive Isotopes: Based on theoretical models and our understanding of its composition and formation, scientists have made <br>\" \n            \"  estimations. Pluto's density suggests it differentiated early in its history, forming a rocky core and an icy mantle. <br>\" \n            \"  This differentiation process itself would have released heat. Like other rocky bodies in our solar system, Pluto's core <br>\" \n            \"  likely contains radioactive isotopes such as Uranium-238, Uranium-235, Thorium-232, and Potassium-40. The decay of these <br>\" \n            \"  elements over billions of years generates heat within the core. This is considered a primary source of its internal heat.<br>\" \n            \"* Initial Accretional Heat: The heat generated from the collisions of smaller bodies that accreted to form Pluto would have <br>\" \n            \"  also contributed to its initial core temperature. While much of this heat would have dissipated over time, some likely remains.<br>\" \n            \"* Subsurface Ocean Evidence: The potential presence of a subsurface liquid water ocean beneath Pluto's icy mantle suggests that <br>\" \n            \"  the core is warm enough to prevent this ocean from completely freezing. The heat flow from the core would be crucial for <br>\" \n            \"  maintaining this liquid layer.<br>\" \n            \"* Estimated Temperature: The estimated temperature of Pluto's core is around 1000 K. This estimate comes from models that <br>\" \n            \"  consider the heat generated by radioactive decay within a rocky core. These models also need to account for the heat transfer <br>\" \n            \"  through the icy mantle. Future research and more detailed data could refine this value. The exact temperature would depend on <br>\" \n            \"  the precise composition of the core and the efficiency of heat transfer through the mantle. In comparison, the surface <br>\" \n            \"  temperature of Pluto is extremely cold, around 40 K. The significant difference highlights the internal heating processes at <br>\" \n            \"  work within the dwarf planet. \"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * PLUTO_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=4.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Pluto: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Pluto: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 16,
    "end_line": 76,
    "has_docstring": true,
    "docstring": "Creates pluto's core shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_pluto_core_shell",
    "component_id": "pluto_visualization_shells.create_pluto_core_shell"
  },
  "pluto_visualization_shells.create_pluto_mantle_shell": {
    "id": "pluto_visualization_shells.create_pluto_mantle_shell",
    "name": "create_pluto_mantle_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\pluto_visualization_shells.py",
    "relative_path": "pluto_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_pluto_mantle_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates pluto's mantle shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.99,  \n        'color': 'rgb(150, 0, 0)',  # These still represent red but with a lower intensity,  \n        'opacity': 0.9,\n        'name': 'mantle',\n        'description': (\n            \"mantle: Surrounding the rocky core is a mantle made of water ice. There's a compelling theory that a subsurface ocean <br>\" \n            \"of liquid water, possibly mixed with ammonia, exists at the boundary between the core and the ice mantle. This ocean <br>\" \n            \"could be 100 to 180 km thick. The presence of this ocean is supported by geological features observed on Pluto's surface.<br>\" \n            \"* This layer is primarily water ice. Within this icy mantle, there is strong evidence for a subsurface ocean of liquid <br>\" \n            \"  water, potentially mixed with ammonia, located above the rocky core.<br>\" \n            \"* Inner Icy Layer (if ocean exists): A layer of solid water ice may exist directly above the rocky core, potentially <br>\" \n            \"  forming the bottom of the ocean.<br>\" \n            \"* Subsurface Ocean: A layer of liquid water (possibly with dissolved substances). The thickness of this ocean is estimated <br>\" \n            \"  to be potentially 100 to 180 kilometers.<br>\" \n            \"* Outer Icy Layer (Lithosphere): A rigid outer shell of water ice above the potential ocean (or the main icy mantle if no <br>\" \n            \"  ocean is present). This layer is thought to be significant in thickness, potentially ranging from 45 to several hundred <br>\" \n            \"  kilometers.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * PLUTO_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.5,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Pluto: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Pluto: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 85,
    "end_line": 138,
    "has_docstring": true,
    "docstring": "Creates pluto's mantle shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_pluto_mantle_shell",
    "component_id": "pluto_visualization_shells.create_pluto_mantle_shell"
  },
  "pluto_visualization_shells.create_pluto_crust_shell": {
    "id": "pluto_visualization_shells.create_pluto_crust_shell",
    "name": "create_pluto_crust_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\pluto_visualization_shells.py",
    "relative_path": "pluto_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_pluto_crust_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates pluto's cloud layer shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.0,  # the top of the troposphere is actually 1.002\n        'color': 'rgb(83, 68, 55)',  # optical brownish\n        'opacity': 1.0,\n        'name': 'Crust',\n        'description': (\n            \"Pluto Crust<br>\" \n            \"(Note: toggle off the cloud layer in the legend to better see the interior structure.)<br><br>\"\n            \"Crust (Surface Layer): This is the outermost layer, composed of more volatile ices: primarily nitrogen ice, with smaller <br>\" \n            \"amounts of methane and carbon monoxide ice. The thickness of this layer likely varies but is estimated to be relatively <br>\" \n            \"thin in many regions, perhaps ranging from a few to tens of kilometers. In the deep Sputnik Planitia basin, the nitrogen <br>\" \n            \"ice layer is estimated to be several kilometers thick and overlies the water-ice lithosphere.<br>\" \n            \"* Pluto's surface, or crust, is composed of various ices, primarily nitrogen ice (over 98%). It also contains smaller <br>\" \n            \"  amounts of methane and carbon monoxide ices.<br>\" \n            \"* Interestingly, mountains on Pluto can reach heights comparable to the Rocky Mountains on Earth and are believed to be <br>\" \n            \"  made of water ice, which is strong enough to support such structures at Pluto's frigid temperatures. These water-ice <br>\" \n            \"  mountains likely \\\"float\\\" in the denser nitrogen ice.<br>\" \n            \"* The surface exhibits a wide range of colors and brightness, with features like the bright \\\"heart\\\" (Tombaugh Regio) and <br>\" \n            \"  dark regions like Cthulhu Macula (\\\"the Whale\\\").<bR>\" \n            \"* Sputnik Planitia, the western lobe of the \\\"heart,\\\" is a vast basin of nitrogen and carbon monoxide ices showing <br>\" \n            \"  evidence of convection cells and glacial flow. The lack of impact craters in this region suggests it's geologically <br>\" \n            \"  young (possibly less than 10 million years old).\"\n            )\n    }\n    \n    # Calculate radius in AU\n    radius = layer_info['radius_fraction'] * PLUTO_RADIUS_AU\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Create mesh with reasonable resolution for performance\n    resolution = 24  # Reduced from typical 50 for markers\n    \n    # Create a UV sphere\n    phi = np.linspace(0, 2*np.pi, resolution)\n    theta = np.linspace(-np.pi/2, np.pi/2, resolution)\n    phi, theta = np.meshgrid(phi, theta)\n    \n    x = radius * np.cos(theta) * np.cos(phi)\n    y = radius * np.cos(theta) * np.sin(phi)\n    z = radius * np.sin(theta)\n    \n    # Apply center position offset\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    # Create triangulation\n    indices = []\n    for i in range(resolution-1):\n        for j in range(resolution-1):\n            p1 = i * resolution + j\n            p2 = i * resolution + (j + 1)\n            p3 = (i + 1) * resolution + j\n            p4 = (i + 1) * resolution + (j + 1)\n            \n            indices.append([p1, p2, p4])\n            indices.append([p1, p4, p3])\n    \n    # Create main surface\n    surface_trace = go.Mesh3d(\n        x=x.flatten(), \n        y=y.flatten(), \n        z=z.flatten(),\n        i=[idx[0] for idx in indices],\n        j=[idx[1] for idx in indices],\n        k=[idx[2] for idx in indices],\n        color=layer_info['color'],\n        opacity=layer_info['opacity'],\n        name=f\"Pluto: {layer_info['name']}\",\n        showlegend=True,\n        hoverinfo='none',  # Disable hover on mesh surface\n        # Add these new parameters to make hover text invisible\n        hovertemplate=' ',  # Empty template instead of None\n        hoverlabel=dict(\n    #        bgcolor='rgba(0,0,0,0)',  # Transparent background\n            font=dict(\n                color='rgba(0,0,0,0)',  # Transparent text\n    #            size=0                  # Zero font size\n            ),\n            bordercolor='rgba(0,0,0,0)'  # Transparent border\n        ), \n        # Add these new parameters to eliminate shading\n        flatshading=True,  # Use flat shading instead of smooth\n        lighting=dict(\n            ambient=1.0,     # Set to maximum (1.0)\n            diffuse=0.0,     # Turn off diffuse lighting\n            specular=0.0,    # Turn off specular highlights\n            roughness=1.0,   # Maximum roughness\n            fresnel=0.0      # Turn off fresnel effect\n        ),\n        lightposition=dict(\n            x=0,  # Centered light\n            y=0,  # Centered light\n            z=10000  # Light from very far above to minimize shadows\n        )       \n    )\n        \n    # Use the Fibonacci sphere algorithm for more even point distribution\n    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points\n    \n    # Generate fibonacci sphere points\n    fib_points = fibonacci_sphere(samples=50)  # Originally, 50 hover points evenly distributed\n    \n    # Scale and offset the points\n    x_hover = [p[0] * radius + center_x for p in fib_points]\n    y_hover = [p[1] * radius + center_y for p in fib_points]\n    z_hover = [p[2] * radius + center_z for p in fib_points]\n        \n    # Create a list of repeated descriptions for each point\n    # This is crucial - we need exactly one text entry per point\n    hover_texts = [layer_info['description']] * len(x_hover)\n\n    # Just the name for \"Object Names Only\" mode\n    layer_name = f\"Pluto: {layer_info['name']}\"\n    minimal_hover_texts = [layer_name] * len(x_hover)\n\n    # Create hover trace with direct text assignment\n    hover_trace = go.Scatter3d(\n        x=x_hover, \n        y=y_hover, \n        z=z_hover,\n        mode='markers',\n        marker=dict(\n            size=2,  # originally 5\n            color='rgb(83, 68, 55)',  # brownish\n            opacity=1.0,  # originally 0.8\n            line=dict(  # Add a contrasting outline\n                width=1,\n                color='black'\n            )\n        ),\n        name=f\"Pluto: {layer_info['name']} (Info)\",\n        text=hover_texts,  # IMPORTANT: Matching length with coordinate arrays\n        customdata=minimal_hover_texts,  # For \"Object Names Only\" mode\n        hovertemplate='%{text}<extra></extra>',  # Use the standard hover template\n        showlegend=False  # Don't show in legend since it's just for hover\n    )\n\n    return [surface_trace, hover_trace]",
    "start_line": 149,
    "end_line": 307,
    "has_docstring": true,
    "docstring": "Creates pluto's cloud layer shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_pluto_crust_shell",
    "component_id": "pluto_visualization_shells.create_pluto_crust_shell"
  },
  "pluto_visualization_shells.fibonacci_sphere": {
    "id": "pluto_visualization_shells.fibonacci_sphere",
    "name": "fibonacci_sphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\pluto_visualization_shells.py",
    "relative_path": "pluto_visualization_shells.py",
    "depends_on": [],
    "source_code": "    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points",
    "start_line": 252,
    "end_line": 267,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "samples"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fibonacci_sphere",
    "component_id": "pluto_visualization_shells.fibonacci_sphere"
  },
  "pluto_visualization_shells.create_pluto_haze_layer_shell": {
    "id": "pluto_visualization_shells.create_pluto_haze_layer_shell",
    "name": "create_pluto_haze_layer_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\pluto_visualization_shells.py",
    "relative_path": "pluto_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_pluto_haze_layer_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates pluto's haze layer shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.17,  \n        'color': 'rgb(135, 206, 235)',  # optical pale blue\n        'opacity': 0.5,\n        'name': 'Haze Layer',\n        'description': (\n            \"Haze Layer: Pluto has a very thin atmosphere, about 1/100,000th the surface pressure of Earth's. It's primarily composed <br>\" \n            \"of nitrogen (N2), with smaller amounts of methane (CH4) and carbon monoxide (CO). This atmosphere is dynamic and changes <br>\" \n            \"with Pluto's orbit around the Sun. As Pluto moves farther away, the atmosphere freezes and falls to the surface as ice. <br>\" \n            \"When it's closer to the Sun, the surface ice sublimates, forming a gaseous atmosphere. The atmosphere contains layers of <br>\" \n            \"haze, extending up to 200 km above the surface, likely formed from the interaction of the atmospheric gases with high-energy <br>\" \n            \"radiation. Counterintuitively, Pluto's upper atmosphere is significantly warmer than its surface due to a temperature <br>\" \n            \"inversion, possibly caused by the presence of methane.<br>\" \n            \"* Composition and Formation: Pluto's atmosphere is primarily nitrogen (N2) with smaller amounts of methane (CH4) and <br>\" \n            \"  carbon monoxide (CO). The haze is thought to form when ultraviolet sunlight and high-energy radiation (like cosmic <br>\" \n            \"  rays) break apart methane molecules in the upper atmosphere. This breakdown leads to the formation of more complex <br>\" \n            \"  hydrocarbon gases, such as acetylene (C2H2) and ethylene (C2H4), as well as heavier compounds called tholins. As these <br>\" \n            \"  hydrocarbons drift to the lower, colder parts of the atmosphere, they condense into tiny ice particles, forming the haze. <br>\" \n            \"  Continued exposure to ultraviolet sunlight then chemically converts these haze particles into the dark, reddish-brown tholins <br>\" \n            \"  that contribute to the color of Pluto's surface.<br>\" \n            \"* Structure and Extent: The New Horizons mission revealed a surprisingly complex, multi-layered haze extending up to 200 km or <br>\" \n            \"  more above Pluto's surface. Scientists have observed as many as 20 distinct layers of haze. These layers can extend <br>\" \n            \"  horizontally for hundreds of kilometers and are not always perfectly parallel to the surface. There can be variations in haze <br>\" \n            \"  density and layer structure with altitude and even geographic location on Pluto.<br>\" \n            \"* Color: The haze has a blue tint when viewed in backlit images (like those taken as New Horizons sped away). This blue color <br>\" \n            \"  arises because the small haze particles efficiently scatter blue light from the sun.<br>\" \n            \"* Particle Settling: The haze particles eventually settle out of the atmosphere and onto Pluto's surface, contributing to the <br>\" \n            \"  surface composition and color over time.<br>\" \n            \"* Condensation and Coagulation: As particles descend, they can grow through condensation of atmospheric gases onto them and by <br>\" \n            \"  sticking together (coagulation).<br>\" \n            \"* Temperature Regulation: By absorbing infrared light, the haze can influence the atmospheric temperature profile, potentially <br>\" \n            \"  keeping the upper atmosphere cooler than it otherwise would be.<br>\" \n            \"* Haze Layers: Within the lower atmosphere, haze layers extend up to about 200 km altitude. This is approximately: ~0.17 So, <br>\" \n            \"  the distinct haze layers reach about 0.17 Pluto radii above the surface.\" \n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * PLUTO_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Pluto: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Pluto: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n        \n    return traces",
    "start_line": 320,
    "end_line": 389,
    "has_docstring": true,
    "docstring": "Creates pluto's haze layer shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_pluto_haze_layer_shell",
    "component_id": "pluto_visualization_shells.create_pluto_haze_layer_shell"
  },
  "pluto_visualization_shells.create_pluto_atmosphere_shell": {
    "id": "pluto_visualization_shells.create_pluto_atmosphere_shell",
    "name": "create_pluto_atmosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\pluto_visualization_shells.py",
    "relative_path": "pluto_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_pluto_atmosphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates pluto's atmosphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.43,  \n        'color': 'rgb(240, 245, 250)',  # optical pale blue\n        'opacity': 0.3,\n        'name': 'Atmosphere',\n        'description': (\n            \"Atmosphere: Pluto has a very thin atmosphere, about 1/100,000th the surface pressure of Earth's. It's primarily composed <br>\" \n            \"of nitrogen (N2), with smaller amounts of methane (CH4) and carbon monoxide (CO). This atmosphere is dynamic and changes <br>\" \n            \"with Pluto's orbit around the Sun. As Pluto moves farther away, the atmosphere freezes and falls to the surface as ice. <br>\" \n            \"When it's closer to the Sun, the surface ice sublimates, forming a gaseous atmosphere. The atmosphere contains layers of <br>\" \n            \"haze, extending up to 200 km above the surface, likely formed from the interaction of the atmospheric gases with high-energy <br>\" \n            \"radiation. Counterintuitively, Pluto's upper atmosphere is significantly warmer than its surface due to a temperature <br>\" \n            \"inversion, possibly caused by the presence of methane.<br>\" \n            \"The extent of Pluto's atmosphere is surprisingly large relative to the dwarf planet itself. While it's very thin in terms <br>\" \n            \"of density compared to Earth's, it stretches far out into space. Here's a breakdown in terms of Pluto's radius <br>\" \n            \"(approximately 1188 km):<br>\" \n            \"* Significant Atmosphere: The atmosphere, composed primarily of nitrogen with traces of methane and carbon monoxide, has <br>\" \n            \"  been detected extending up to 1700 km above the surface (the exobase).<br>\" \n            \"* In Pluto radii: To express this as a fraction of Pluto's radius: ~1.43.<br>\" \n            \"* Outer Limits: Some research suggests that the outer, most tenuous parts of Pluto's atmosphere might extend even further, <br>\" \n            \"  perhaps to several times Pluto's radius, gradually merging with the vacuum of space. One New Horizons science brief even <br>\" \n            \"  mentioned an outer limit potentially as far as seven times Pluto's radius, although this is very ill-defined.<br>\" \n            \"* Haze Layers: Within the lower atmosphere, haze layers extend up to about 200 km altitude. This is approximately: ~0.17 So, <br>\" \n            \"  the distinct haze layers reach about 0.17 Pluto radii above the surface.<br>\" \n            \"In summary, while the bulk of Pluto's atmosphere is very thin, its outer reaches are quite extended. For a general extent, <br>\" \n            \"considering the exobase, the atmosphere reaches about 0.43 Pluto radii above the surface, or 1.43 Pluto radii from the center. <br>\" \n            \"If you consider the more diffuse outer limits, it could be even larger.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * PLUTO_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Pluto: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Pluto: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=layer_radius\n    )\n    for trace in sun_traces:\n        traces.append(trace) \n\n    return traces",
    "start_line": 402,
    "end_line": 471,
    "has_docstring": true,
    "docstring": "Creates pluto's atmosphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_pluto_atmosphere_shell",
    "component_id": "pluto_visualization_shells.create_pluto_atmosphere_shell"
  },
  "pluto_visualization_shells.create_pluto_hill_sphere_shell": {
    "id": "pluto_visualization_shells.create_pluto_hill_sphere_shell",
    "name": "create_pluto_hill_sphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\pluto_visualization_shells.py",
    "relative_path": "pluto_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_pluto_hill_sphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates pluto's Hill sphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 4685, \n        'color': 'rgb(0, 255, 0)',  # Green for Hill sphere\n        'opacity': 0.25,\n        'name': 'Hill Sphere',\n        'description': (\n            \"SET MANUAL SCALE OF AT LEAST 0.05 AU TO VISUALIZE.<br><br>\"\n            \"Hill Sphere: Pluto's Hill sphere, or Roche sphere, is the region around it where its gravitational influence dominates <br>\" \n            \"over the Sun's. The radius of Pluto's Hill sphere is quite large, approximately 5.99 million kilometers (0.04 AU). This is <br>\" \n            \"significantly larger than Earth's Hill sphere in terms of volume. Any moon orbiting Pluto within this sphere is <br>\" \n            \"gravitationally bound to it. Pluto has five known moons: Charon, Styx, Nix, Kerberos, and Hydra, all of which reside within <br>\" \n            \"its Hill sphere.\"          \n            )\n    }\n        \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * PLUTO_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Pluto: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Pluto: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=layer_radius\n    )\n    for trace in sun_traces:\n        traces.append(trace) \n\n    return traces",
    "start_line": 484,
    "end_line": 538,
    "has_docstring": true,
    "docstring": "Creates pluto's Hill sphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_pluto_hill_sphere_shell",
    "component_id": "pluto_visualization_shells.create_pluto_hill_sphere_shell"
  },
  "refined_orbits.RefinedOrbitSystem": {
    "id": "refined_orbits.RefinedOrbitSystem",
    "name": "RefinedOrbitSystem",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\refined_orbits.py",
    "relative_path": "refined_orbits.py",
    "depends_on": [
      "idealized_orbits.rotate_points",
      "orbit_data_manager.load_orbit_paths",
      "idealized_orbits.calculate_mars_satellite_elements"
    ],
    "source_code": "class RefinedOrbitSystem:\n    \"\"\"System for creating refined satellite orbits using ephemeris data.\"\"\"\n    \n    def __init__(self, ephemeris_file: str = \"satellite_ephemerides.json\"):\n        \"\"\"Initialize with ephemeris database.\"\"\"\n        self.ephemeris_file = ephemeris_file\n        self.ephemeris_data = self._load_ephemeris_data()\n        self._orbit_cache = {}  # Cache refined orbits\n        \n    def _load_ephemeris_data(self) -> Dict:\n        \"\"\"Load ephemeris data from JSON file.\"\"\"\n        if os.path.exists(self.ephemeris_file):\n            with open(self.ephemeris_file, 'r') as f:\n                return json.load(f)\n        else:\n            print(f\"Warning: {self.ephemeris_file} not found. Using idealized orbits only.\")\n            return {\"satellites\": {}}\n    \n    def get_orbit_function(self, satellite: str, primary: str) -> Callable:\n        \"\"\"\n        Get refined orbit function for a satellite.\n        Falls back to idealized orbit if no ephemeris data available.\n        \"\"\"\n        cache_key = f\"{primary}_{satellite}\".lower()\n        \n        # Check cache first\n        if cache_key in self._orbit_cache:\n            return self._orbit_cache[cache_key]\n        \n        # Try to create refined orbit\n        if cache_key in self.ephemeris_data.get(\"satellites\", {}):\n            refined_func = self._create_refined_orbit(satellite, primary)\n            self._orbit_cache[cache_key] = refined_func\n            return refined_func\n        \n        # Fall back to idealized orbit\n        idealized_func = self._get_idealized_orbit(satellite, primary)\n        if idealized_func:\n            print(f\"Using idealized orbit for {satellite} (no ephemeris data)\")\n            self._orbit_cache[cache_key] = idealized_func\n            return idealized_func\n        \n        # Last resort: simple circular orbit\n        print(f\"Warning: No orbit data for {satellite}. Using default circular orbit.\")\n        default_func = self._create_default_orbit(satellite, primary)\n        self._orbit_cache[cache_key] = default_func\n        return default_func\n    \n    def _create_refined_orbit(self, satellite: str, primary: str) -> Callable:\n        \"\"\"Create refined orbit by comparing actual vs idealized orbit normals.\"\"\"\n        sat_key = f\"{primary}_{satellite}\".lower()\n        \n        # First, we MUST have an idealized orbit to refine\n        idealized = self._get_idealized_orbit(satellite, primary)\n        if not idealized:\n            print(f\"Warning: No idealized orbit found for {satellite}. Cannot create refined orbit.\")\n            return self._create_default_orbit(satellite, primary)\n        \n        # Try to get actual orbit positions from the main program's orbit cache\n        correction = None\n        try:\n            # Check if we're in special fetch mode and have temp cache\n            from palomas_orrery import special_fetch_var, temp_cache\n            \n            orbit_key = f\"{satellite}_{primary}\"\n            \n            # Try temp cache first if in special mode\n            if special_fetch_var.get() == 1 and temp_cache and orbit_key in temp_cache:\n                print(f\"Found actual orbit data in temp cache for {satellite}\")\n                actual_orbit_data = temp_cache[orbit_key]\n            else:\n                # Try main cache\n                import orbit_data_manager\n                orbit_paths = orbit_data_manager.load_orbit_paths()\n                \n                if orbit_key in orbit_paths:\n                    print(f\"Found cached actual orbit data for {satellite}\")\n                    actual_orbit_data = orbit_paths[orbit_key]\n                else:\n                    actual_orbit_data = None\n            \n            if actual_orbit_data:\n                # Extract positions (they should be in AU already)\n                actual_x = np.array(actual_orbit_data['x'])\n                actual_y = np.array(actual_orbit_data['y'])\n                actual_z = np.array(actual_orbit_data['z'])\n                \n                # Sample enough points to calculate normal vector reliably\n                num_points = min(len(actual_x), 100)\n                if num_points >= 3:\n                    # Take evenly spaced points\n                    indices = np.linspace(0, len(actual_x)-1, num_points, dtype=int)\n                    actual_positions = np.column_stack((\n                        actual_x[indices],\n                        actual_y[indices],\n                        actual_z[indices]\n                    ))\n                    \n                    # Calculate actual orbit normal from positions\n                    r1 = actual_positions[0]\n                    r2 = actual_positions[num_points//4]  # ~90 degrees\n                    r3 = actual_positions[num_points//2]  # ~180 degrees\n                    \n                    v1 = r2 - r1\n                    v2 = r3 - r1\n                    n_actual = np.cross(v1, v2)\n                    n_actual = n_actual / np.linalg.norm(n_actual)\n                    \n                    print(f\"Calculated actual orbit normal: [{n_actual[0]:.4f}, {n_actual[1]:.4f}, {n_actual[2]:.4f}]\")\n                    \n                    # Calculate idealized orbit normal\n                    t_sample = np.linspace(0, 2*np.pi, 100)\n                    ideal_positions = np.array([idealized(t) for t in t_sample])\n                    \n                    # Make sure ideal positions are in AU\n                    if np.max(np.abs(ideal_positions)) > 10:  # Likely in km\n                        ideal_positions = ideal_positions / 149597870.7\n                    \n                    r1_ideal = ideal_positions[0]\n                    r2_ideal = ideal_positions[25]  # 90 degrees\n                    r3_ideal = ideal_positions[50]  # 180 degrees\n                    \n                    v1_ideal = r2_ideal - r1_ideal\n                    v2_ideal = r3_ideal - r1_ideal\n                    n_ideal = np.cross(v1_ideal, v2_ideal)\n                    n_ideal = n_ideal / np.linalg.norm(n_ideal)\n                    \n                    print(f\"Calculated ideal orbit normal: [{n_ideal[0]:.4f}, {n_ideal[1]:.4f}, {n_ideal[2]:.4f}]\")\n                    \n                    # Calculate rotation to align ideal normal with actual normal\n                    axis = np.cross(n_ideal, n_actual)\n                    if np.linalg.norm(axis) > 1e-10:  # If normals aren't already aligned\n                        axis = axis / np.linalg.norm(axis)\n                        angle = np.arccos(np.clip(np.dot(n_ideal, n_actual), -1, 1))\n                        \n                        # Create rotation\n                        correction = Rotation.from_rotvec(angle * axis)\n                        print(f\"Refined orbit for {satellite}: applying {np.degrees(angle):.2f} correction\")\n                    else:\n                        print(f\"Refined orbit for {satellite}: normals already aligned\")\n                else:\n                    print(f\"Not enough actual orbit points for {satellite}\")\n            else:\n                print(f\"No actual orbit data found for {satellite}\")\n                \n        except Exception as e:\n            print(f\"Could not load actual orbit data for {satellite}: {e}\")\n            import traceback\n            traceback.print_exc()\n        \n        def refined_orbit(t):\n            \"\"\"Refined orbit function that applies correction to idealized orbit.\"\"\"\n            # Get position from idealized orbit\n            pos = idealized(t)\n            \n            # Apply correction if available\n            if correction is not None:\n                if isinstance(pos, np.ndarray) and pos.ndim == 2:\n                    # Multiple positions\n                    pos = np.array([correction.apply(p) for p in pos])\n                else:\n                    # Single position\n                    pos = correction.apply(pos)\n            \n            return pos\n        \n        return refined_orbit\n    \n    def _get_idealized_orbit(self, satellite: str, primary: str) -> Optional[Callable]:\n        \"\"\"Get idealized orbit function if available.\"\"\"\n        if not IDEALIZED_ORBITS_AVAILABLE or not ORBITAL_PARAMS:\n            return None\n        \n        # Check if we have orbital parameters for this satellite\n        if satellite not in ORBITAL_PARAMS:\n            return None\n            \n        params = ORBITAL_PARAMS[satellite]\n        \n        # For Mars satellites, use time-varying elements with special transformation\n        if primary.lower() == 'mars' and hasattr(idealized_orbits, 'calculate_mars_satellite_elements'):\n            def mars_satellite_orbit(t):\n                \"\"\"Generate Mars satellite orbit with proper transformations.\"\"\"\n                # Get current date for time-varying elements\n                current_date = datetime.now()\n                elements = idealized_orbits.calculate_mars_satellite_elements(current_date, satellite)\n                \n                a = elements['a']  # Already in AU\n                e = elements['e']\n                i = np.radians(elements['i'])\n                omega = np.radians(elements['omega'])\n                Omega = np.radians(elements['Omega'])\n                \n                # Handle both scalar and array inputs\n                t_array = np.atleast_1d(t)\n                scalar_input = np.isscalar(t)\n                \n                # Calculate radius for each point\n                r = a * (1 - e**2) / (1 + e * np.cos(t_array))\n                \n                # Convert to Cartesian in orbital plane\n                x_orbit = r * np.cos(t_array)\n                y_orbit = r * np.sin(t_array)\n                z_orbit = np.zeros_like(t_array)\n                \n                # Apply orbital element rotations\n                if hasattr(idealized_orbits, 'rotate_points'):\n                    # 1. Longitude of ascending node\n                    x1, y1, z1 = idealized_orbits.rotate_points(x_orbit, y_orbit, z_orbit, Omega, 'z')\n                    # 2. Inclination\n                    x2, y2, z2 = idealized_orbits.rotate_points(x1, y1, z1, i, 'x')\n                    # 3. Argument of periapsis\n                    x3, y3, z3 = idealized_orbits.rotate_points(x2, y2, z2, omega, 'z')\n                    \n                    # 4. Apply Mars equatorial to ecliptic transformation (Y-axis rotation by Mars tilt)\n                    mars_tilt = np.radians(25.19)\n                    x_final, y_final, z_final = idealized_orbits.rotate_points(x3, y3, z3, mars_tilt, 'y')\n                    \n                    # Return in AU (no conversion needed)\n                    if scalar_input:\n                        return np.array([x_final[0], y_final[0], z_final[0]])\n                    else:\n                        return np.column_stack((x_final, y_final, z_final))\n                else:\n                    # Fallback without the Mars transformation\n                    if scalar_input:\n                        return np.array([x_orbit[0], y_orbit[0], z_orbit[0]])\n                    else:\n                        return np.column_stack((x_orbit, y_orbit, z_orbit))\n            \n            return mars_satellite_orbit\n        \n        # For Saturn's Phoebe, use special handling for Laplace plane reference\n        elif primary.lower() == 'saturn' and satellite.lower() == 'phoebe':\n            def phoebe_orbit(t):\n                \"\"\"Generate Phoebe's orbit with Laplace plane transformation.\"\"\"\n                a = params.get('a', 0.08655)  # Semi-major axis in AU\n                e = params.get('e', 0.1635)\n                i = np.radians(params.get('i', 175.986))  # Retrograde inclination\n                omega = np.radians(params.get('omega', 240.3))\n                Omega = np.radians(params.get('Omega', 192.7))\n                \n                # Handle both scalar and array inputs\n                t_array = np.atleast_1d(t)\n                scalar_input = np.isscalar(t)\n                \n                # Calculate radius for each point\n                r = a * (1 - e**2) / (1 + e * np.cos(t_array))\n                \n                # Convert to Cartesian in orbital plane\n                x_orbit = r * np.cos(t_array)\n                y_orbit = r * np.sin(t_array)\n                z_orbit = np.zeros_like(t_array)\n                \n                # Apply orbital element rotations\n                if hasattr(idealized_orbits, 'rotate_points'):\n                    # Standard rotation sequence\n                    x1, y1, z1 = idealized_orbits.rotate_points(x_orbit, y_orbit, z_orbit, Omega, 'z')\n                    x2, y2, z2 = idealized_orbits.rotate_points(x1, y1, z1, i, 'x')\n                    x3, y3, z3 = idealized_orbits.rotate_points(x2, y2, z2, omega, 'z')\n                    \n                    # Transform from Laplace plane to ecliptic\n                    laplace_tilt = np.radians(15.0)\n                    saturn_orbit_inc = np.radians(2.485)\n                    saturn_orbit_node = np.radians(113.665)\n                    \n                    x4, y4, z4 = idealized_orbits.rotate_points(x3, y3, z3, -laplace_tilt, 'x')\n                    x5, y5, z5 = idealized_orbits.rotate_points(x4, y4, z4, -saturn_orbit_node, 'z')\n                    x_final, y_final, z_final = idealized_orbits.rotate_points(x5, y5, z5, -saturn_orbit_inc, 'x')\n                    \n                    if scalar_input:\n                        return np.array([x_final[0], y_final[0], z_final[0]])\n                    else:\n                        return np.column_stack((x_final, y_final, z_final))\n                else:\n                    # Fallback without transformation\n                    if scalar_input:\n                        return np.array([x_orbit[0], y_orbit[0], z_orbit[0]])\n                    else:\n                        return np.column_stack((x_orbit, y_orbit, z_orbit))\n            \n            return phoebe_orbit\n        \n        else:\n            # Generic satellite orbit (all parameters in AU)\n            a = params.get('a', 0.1)  # Semi-major axis already in AU\n            e = params.get('e', 0)\n            i = np.radians(params.get('i', 0))\n            omega = np.radians(params.get('omega', 0))\n            Omega = np.radians(params.get('Omega', 0))\n            \n            def generic_orbit(t):\n                \"\"\"Generate generic satellite orbit.\"\"\"\n                # Handle both scalar and array inputs\n                t_array = np.atleast_1d(t)\n                scalar_input = np.isscalar(t)\n                \n                # Solve Kepler's equation\n                M = t_array  # Mean anomaly\n                E = M.copy()\n                for _ in range(10):\n                    E = M + e * np.sin(E)\n                \n                # True anomaly\n                nu = 2 * np.arctan2(np.sqrt(1 + e) * np.sin(E/2), \n                                  np.sqrt(1 - e) * np.cos(E/2))\n                \n                # Radius in AU\n                r = a * (1 - e * np.cos(E))\n                \n                # Position in orbital plane (AU)\n                x_orbital = r * np.cos(nu)\n                y_orbital = r * np.sin(nu)\n                z_orbital = np.zeros_like(t_array)\n                \n                # Apply rotations using idealized_orbits functions if available\n                if hasattr(idealized_orbits, 'rotate_points'):\n                    # Standard rotation sequence\n                    x1, y1, z1 = idealized_orbits.rotate_points(x_orbital, y_orbital, z_orbital, Omega, 'z')\n                    x2, y2, z2 = idealized_orbits.rotate_points(x1, y1, z1, i, 'x')\n                    x3, y3, z3 = idealized_orbits.rotate_points(x2, y2, z2, omega, 'z')\n                    \n                    # Check if this satellite needs special planet-specific transformation\n                    if hasattr(idealized_orbits, 'planet_tilts') and primary in idealized_orbits.planet_tilts:\n                        tilt = np.radians(idealized_orbits.planet_tilts[primary])\n                        # Apply the same transformation idealized orbits uses\n                        if primary.lower() == 'pluto':\n                            # Pluto uses a complex transformation\n                            x4, y4, z4 = idealized_orbits.rotate_points(x3, y3, z3, tilt, 'x')\n                            x5, y5, z5 = idealized_orbits.rotate_points(x4, y4, z4, tilt, 'y')\n                            z_angle = np.radians(-105)\n                            x_final, y_final, z_final = idealized_orbits.rotate_points(x5, y5, z5, z_angle, 'z')\n                        else:\n                            # Other planets use simple X-axis tilt\n                            x_final, y_final, z_final = idealized_orbits.rotate_points(x3, y3, z3, tilt, 'x')\n                    else:\n                        x_final, y_final, z_final = x3, y3, z3\n                    \n                    # Return in AU\n                    if scalar_input:\n                        return np.array([x_final[0], y_final[0], z_final[0]])\n                    else:\n                        return np.column_stack((x_final, y_final, z_final))\n                else:\n                    # Fallback: simple rotation matrices\n                    positions = np.column_stack((x_orbital, y_orbital, z_orbital))\n                    \n                    # Apply rotations\n                    r_node = Rotation.from_euler('z', Omega)\n                    r_inc = Rotation.from_euler('x', i)\n                    r_peri = Rotation.from_euler('z', omega)\n                    \n                    positions = r_node.apply(positions)\n                    positions = r_inc.apply(positions)\n                    positions = r_peri.apply(positions)\n                    \n                    # Return in AU\n                    if scalar_input:\n                        return positions[0]\n                    else:\n                        return positions\n            \n            return generic_orbit\n    \n    def _create_default_orbit(self, satellite: str, primary: str) -> Callable:\n        \"\"\"Create simple default orbit when no data available.\"\"\"\n        # Default radii for common satellites (in AU)\n        default_radii_km = {\n            (\"phobos\", \"mars\"): 9377,\n            (\"deimos\", \"mars\"): 23463,\n            (\"io\", \"jupiter\"): 421800,\n            (\"europa\", \"jupiter\"): 671100,\n            (\"ganymede\", \"jupiter\"): 1070400,\n            (\"callisto\", \"jupiter\"): 1882700,\n        }\n        \n        key = (satellite.lower(), primary.lower())\n        radius_km = default_radii_km.get(key, 10000)  # Default 10,000 km\n        radius_au = radius_km / 149597870.7  # Convert to AU\n        \n        def default_orbit(t):\n            \"\"\"Simple circular orbit in AU.\"\"\"\n            t = np.asarray(t)\n            return np.array([\n                radius_au * np.cos(t),\n                radius_au * np.sin(t),\n                np.zeros_like(t)\n            ]).T.squeeze()\n        \n        return default_orbit\n    \n    def _calculate_normal(self, positions: np.ndarray) -> np.ndarray:\n        \"\"\"Calculate orbit normal from positions.\"\"\"\n        # Use first three non-collinear points\n        r1, r2, r3 = positions[0], positions[1], positions[2]\n        v1 = r2 - r1\n        v2 = r3 - r1\n        n = np.cross(v1, v2)\n        return n / np.linalg.norm(n)",
    "start_line": 34,
    "end_line": 432,
    "has_docstring": true,
    "docstring": "System for creating refined satellite orbits using ephemeris data.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class RefinedOrbitSystem",
    "component_id": "refined_orbits.RefinedOrbitSystem"
  },
  "refined_orbits.get_refined_system": {
    "id": "refined_orbits.get_refined_system",
    "name": "get_refined_system",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\refined_orbits.py",
    "relative_path": "refined_orbits.py",
    "depends_on": [
      "refined_orbits.RefinedOrbitSystem"
    ],
    "source_code": "def get_refined_system(ephemeris_file: str = \"satellite_ephemerides.json\") -> RefinedOrbitSystem:\n    \"\"\"Get or create the refined orbit system.\"\"\"\n    global _refined_system\n    if _refined_system is None:\n        _refined_system = RefinedOrbitSystem(ephemeris_file)\n    return _refined_system",
    "start_line": 438,
    "end_line": 443,
    "has_docstring": true,
    "docstring": "Get or create the refined orbit system.",
    "parameters": [
      "ephemeris_file"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_refined_system",
    "component_id": "refined_orbits.get_refined_system"
  },
  "refined_orbits.create_refined_phobos_orbit": {
    "id": "refined_orbits.create_refined_phobos_orbit",
    "name": "create_refined_phobos_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\refined_orbits.py",
    "relative_path": "refined_orbits.py",
    "depends_on": [
      "refined_orbits.get_refined_system",
      "orrery_integration.get_orbit_function"
    ],
    "source_code": "def create_refined_phobos_orbit():\n    \"\"\"Create refined Phobos orbit function.\"\"\"\n    system = get_refined_system()\n    return system.get_orbit_function(\"Phobos\", \"Mars\")",
    "start_line": 447,
    "end_line": 450,
    "has_docstring": true,
    "docstring": "Create refined Phobos orbit function.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_refined_phobos_orbit",
    "component_id": "refined_orbits.create_refined_phobos_orbit"
  },
  "refined_orbits.create_refined_deimos_orbit": {
    "id": "refined_orbits.create_refined_deimos_orbit",
    "name": "create_refined_deimos_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\refined_orbits.py",
    "relative_path": "refined_orbits.py",
    "depends_on": [
      "refined_orbits.get_refined_system",
      "orrery_integration.get_orbit_function"
    ],
    "source_code": "def create_refined_deimos_orbit():\n    \"\"\"Create refined Deimos orbit function.\"\"\"\n    system = get_refined_system()\n    return system.get_orbit_function(\"Deimos\", \"Mars\")",
    "start_line": 453,
    "end_line": 456,
    "has_docstring": true,
    "docstring": "Create refined Deimos orbit function.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_refined_deimos_orbit",
    "component_id": "refined_orbits.create_refined_deimos_orbit"
  },
  "refined_orbits.create_refined_moon_orbit": {
    "id": "refined_orbits.create_refined_moon_orbit",
    "name": "create_refined_moon_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\refined_orbits.py",
    "relative_path": "refined_orbits.py",
    "depends_on": [
      "refined_orbits.get_refined_system",
      "orrery_integration.get_orbit_function"
    ],
    "source_code": "def create_refined_moon_orbit():\n    \"\"\"Create refined Moon orbit function.\"\"\"\n    system = get_refined_system()\n    return system.get_orbit_function(\"Moon\", \"Earth\")",
    "start_line": 459,
    "end_line": 462,
    "has_docstring": true,
    "docstring": "Create refined Moon orbit function.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_refined_moon_orbit",
    "component_id": "refined_orbits.create_refined_moon_orbit"
  },
  "refined_orbits.create_refined_io_orbit": {
    "id": "refined_orbits.create_refined_io_orbit",
    "name": "create_refined_io_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\refined_orbits.py",
    "relative_path": "refined_orbits.py",
    "depends_on": [
      "refined_orbits.get_refined_system",
      "orrery_integration.get_orbit_function"
    ],
    "source_code": "def create_refined_io_orbit():\n    \"\"\"Create refined Io orbit function.\"\"\"\n    system = get_refined_system()\n    return system.get_orbit_function(\"Io\", \"Jupiter\")",
    "start_line": 465,
    "end_line": 468,
    "has_docstring": true,
    "docstring": "Create refined Io orbit function.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_refined_io_orbit",
    "component_id": "refined_orbits.create_refined_io_orbit"
  },
  "refined_orbits.create_refined_europa_orbit": {
    "id": "refined_orbits.create_refined_europa_orbit",
    "name": "create_refined_europa_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\refined_orbits.py",
    "relative_path": "refined_orbits.py",
    "depends_on": [
      "refined_orbits.get_refined_system",
      "orrery_integration.get_orbit_function"
    ],
    "source_code": "def create_refined_europa_orbit():\n    \"\"\"Create refined Europa orbit function.\"\"\"\n    system = get_refined_system()\n    return system.get_orbit_function(\"Europa\", \"Jupiter\")",
    "start_line": 471,
    "end_line": 474,
    "has_docstring": true,
    "docstring": "Create refined Europa orbit function.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_refined_europa_orbit",
    "component_id": "refined_orbits.create_refined_europa_orbit"
  },
  "refined_orbits.create_refined_ganymede_orbit": {
    "id": "refined_orbits.create_refined_ganymede_orbit",
    "name": "create_refined_ganymede_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\refined_orbits.py",
    "relative_path": "refined_orbits.py",
    "depends_on": [
      "refined_orbits.get_refined_system",
      "orrery_integration.get_orbit_function"
    ],
    "source_code": "def create_refined_ganymede_orbit():\n    \"\"\"Create refined Ganymede orbit function.\"\"\"\n    system = get_refined_system()\n    return system.get_orbit_function(\"Ganymede\", \"Jupiter\")",
    "start_line": 477,
    "end_line": 480,
    "has_docstring": true,
    "docstring": "Create refined Ganymede orbit function.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_refined_ganymede_orbit",
    "component_id": "refined_orbits.create_refined_ganymede_orbit"
  },
  "refined_orbits.create_refined_callisto_orbit": {
    "id": "refined_orbits.create_refined_callisto_orbit",
    "name": "create_refined_callisto_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\refined_orbits.py",
    "relative_path": "refined_orbits.py",
    "depends_on": [
      "refined_orbits.get_refined_system",
      "orrery_integration.get_orbit_function"
    ],
    "source_code": "def create_refined_callisto_orbit():\n    \"\"\"Create refined Callisto orbit function.\"\"\"\n    system = get_refined_system()\n    return system.get_orbit_function(\"Callisto\", \"Jupiter\")",
    "start_line": 483,
    "end_line": 486,
    "has_docstring": true,
    "docstring": "Create refined Callisto orbit function.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_refined_callisto_orbit",
    "component_id": "refined_orbits.create_refined_callisto_orbit"
  },
  "refined_orbits.create_refined_orbit": {
    "id": "refined_orbits.create_refined_orbit",
    "name": "create_refined_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\refined_orbits.py",
    "relative_path": "refined_orbits.py",
    "depends_on": [
      "refined_orbits.get_refined_system",
      "orrery_integration.get_orbit_function"
    ],
    "source_code": "def create_refined_orbit(satellite: str, primary: str) -> Callable:\n    \"\"\"Create refined orbit for any satellite.\"\"\"\n    system = get_refined_system()\n    return system.get_orbit_function(satellite, primary)",
    "start_line": 490,
    "end_line": 493,
    "has_docstring": true,
    "docstring": "Create refined orbit for any satellite.",
    "parameters": [
      "satellite",
      "primary"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_refined_orbit",
    "component_id": "refined_orbits.create_refined_orbit"
  },
  "refined_orbits.validate_all_orbits": {
    "id": "refined_orbits.validate_all_orbits",
    "name": "validate_all_orbits",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\refined_orbits.py",
    "relative_path": "refined_orbits.py",
    "depends_on": [
      "refined_orbits.get_refined_system",
      "orrery_integration.get_orbit_function"
    ],
    "source_code": "def validate_all_orbits():\n    \"\"\"Validate all available refined orbits.\"\"\"\n    system = get_refined_system()\n    \n    print(\"Refined Orbits Status Report\")\n    print(\"=\" * 60)\n    \n    satellites = [\n        (\"Phobos\", \"Mars\"),\n        (\"Deimos\", \"Mars\"),\n        (\"Moon\", \"Earth\"),\n        (\"Io\", \"Jupiter\"),\n        (\"Europa\", \"Jupiter\"),\n        (\"Ganymede\", \"Jupiter\"),\n        (\"Callisto\", \"Jupiter\"),\n    ]\n    \n    for satellite, primary in satellites:\n        key = f\"{primary}_{satellite}\".lower()\n        has_ephemeris = key in system.ephemeris_data.get(\"satellites\", {})\n        has_idealized = satellite in ORBITAL_PARAMS if ORBITAL_PARAMS else False\n        \n        if has_ephemeris and has_idealized:\n            status = \" Refined\"\n        elif has_idealized:\n            status = \" Idealized only\"\n        else:\n            status = \" Default only\"\n        \n        orbit_func = system.get_orbit_function(satellite, primary)\n        test_pos = orbit_func(0)\n        radius = np.linalg.norm(test_pos)\n        \n        # Check if it's returning km or AU\n        if radius < 100:  # Likely in AU\n            radius_km = radius * 149597870.7  # Convert to km\n            print(f\"{satellite:<12} ({primary:<8}): {status}  r = {radius:.6f} AU ({radius_km:,.0f} km)\")\n        else:\n            radius_au = radius / 149597870.7  # Convert to AU\n            print(f\"{satellite:<12} ({primary:<8}): {status}  r = {radius:,.0f} km ({radius_au:.6f} AU)\")\n    \n    print(\"=\" * 60)\n    print(\" = Refined (idealized + correction),  = Idealized only,  = Default circular\")",
    "start_line": 497,
    "end_line": 539,
    "has_docstring": true,
    "docstring": "Validate all available refined orbits.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function validate_all_orbits",
    "component_id": "refined_orbits.validate_all_orbits"
  },
  "report_manager.ReportManager": {
    "id": "report_manager.ReportManager",
    "name": "ReportManager",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\report_manager.py",
    "relative_path": "report_manager.py",
    "depends_on": [],
    "source_code": "class ReportManager:\n    \"\"\"Manages scientific reports for astronomical data analysis.\"\"\"\n    \n    def __init__(self, reports_dir: str = \"reports\"):\n        \"\"\"\n        Initialize the ReportManager.\n        \n        Args:\n            reports_dir: Directory to store archived reports\n        \"\"\"\n        self.reports_dir = Path(reports_dir)\n        self.reports_dir.mkdir(exist_ok=True)\n    #    self.last_report_file = \"last_plot_report.json\"\n        self.last_report_file = str(self.reports_dir / \"last_plot_report.json\")\n    \n    def save_report(self, report_data: Dict, archive: bool = True) -> str:\n        \"\"\"\n        Save report to last_plot_report.json and optionally archive.\n        \n        Args:\n            report_data: Report dictionary from ObjectTypeAnalyzer\n            archive: If True, also save timestamped copy\n            \n        Returns:\n            Path to saved report file\n        \"\"\"\n        try:\n            # Always save as \"last\" report for GUI\n            with open(self.last_report_file, 'w') as f:\n                json.dump(report_data, f, indent=2, default=str)\n            print(f\"Report saved to {self.last_report_file}\")\n            \n            # Optionally archive with timestamp\n            if archive and 'metadata' in report_data:\n                meta = report_data['metadata']\n                timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n                mode = meta.get('mode', 'unknown')\n                limit = meta.get('limit_value', 0)\n                \n                # Format limit value for filename\n                if mode == 'distance':\n                    limit_str = f\"{limit}ly\"\n                else:\n                    limit_str = f\"mag{limit}\"\n                \n                filename = f\"report_{timestamp}_{mode}_{limit_str}.json\"\n                filepath = self.reports_dir / filename\n                \n                with open(filepath, 'w') as f:\n                    json.dump(report_data, f, indent=2, default=str)\n                \n                print(f\"Report archived to {filepath}\")\n                return str(filepath)\n            \n            return self.last_report_file\n            \n        except Exception as e:\n            print(f\"Error saving report: {e}\")\n            return None\n    \n    def load_last_report(self) -> Optional[Dict]:\n        \"\"\"\n        Load the most recent report.\n        \n        Returns:\n            Report data dictionary or None if not found\n        \"\"\"\n        if os.path.exists(self.last_report_file):\n            try:\n                with open(self.last_report_file, 'r') as f:\n                    return json.load(f)\n            except Exception as e:\n                print(f\"Error loading last report: {e}\")\n                return None\n        return None\n    \n    def load_report(self, filepath: str) -> Optional[Dict]:\n        \"\"\"\n        Load a specific archived report.\n        \n        Args:\n            filepath: Path to report file\n            \n        Returns:\n            Report data dictionary or None if error\n        \"\"\"\n        try:\n            with open(filepath, 'r') as f:\n                return json.load(f)\n        except Exception as e:\n            print(f\"Error loading report {filepath}: {e}\")\n            return None\n    \n    def list_archived_reports(self, mode: str = None, limit: int = 10) -> List[Path]:\n        \"\"\"\n        List available archived reports.\n        \n        Args:\n            mode: Filter by mode ('distance' or 'magnitude')\n            limit: Maximum number of reports to return\n            \n        Returns:\n            List of report file paths, newest first\n        \"\"\"\n        reports = []\n        try:\n            for file in self.reports_dir.glob(\"report_*.json\"):\n                if mode and f\"_{mode}_\" not in file.name:\n                    continue\n                reports.append(file)\n            \n            # Sort by modification time, newest first\n            reports.sort(key=lambda x: x.stat().st_mtime, reverse=True)\n            return reports[:limit]\n        except Exception as e:\n            print(f\"Error listing reports: {e}\")\n            return []\n    \n    def get_report_summary(self, filepath: str) -> Optional[Dict]:\n        \"\"\"\n        Get summary information about a report without loading full data.\n        \n        Args:\n            filepath: Path to report file\n            \n        Returns:\n            Summary dict with metadata or None\n        \"\"\"\n        report = self.load_report(filepath)\n        if report and 'metadata' in report:\n            return {\n                'file': os.path.basename(filepath),\n                'mode': report['metadata'].get('mode'),\n                'limit': report['metadata'].get('limit_value'),\n                'stars': report['metadata'].get('total_stars'),\n                'generated': report['metadata'].get('generation_time')\n            }\n        return None",
    "start_line": 13,
    "end_line": 150,
    "has_docstring": true,
    "docstring": "Manages scientific reports for astronomical data analysis.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class ReportManager",
    "component_id": "report_manager.ReportManager"
  },
  "saturn_visualization_shells.create_ring_points_saturn": {
    "id": "saturn_visualization_shells.create_ring_points_saturn",
    "name": "create_ring_points_saturn",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\saturn_visualization_shells.py",
    "relative_path": "saturn_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_ring_points_saturn (inner_radius, outer_radius, n_points, thickness=0):\n    \"\"\"\n    Create points for a ring with inner and outer radius.\n    \n    Parameters:\n        inner_radius (float): Inner radius of the ring\n        outer_radius (float): Outer radius of the ring\n        n_points (int): Number of points to generate\n        thickness (float): Thickness of the ring in z-direction\n        \n    Returns:\n        tuple: (x, y, z) arrays of coordinates\n    \"\"\"\n    # Generate angular positions\n    theta = np.linspace(0, 2*np.pi, n_points)\n    \n    # Calculate radial positions\n    r = np.linspace(inner_radius, outer_radius, int(n_points/10))\n    \n    # Create a meshgrid for combinations\n    theta_grid, r_grid = np.meshgrid(theta, r)\n    \n    # Convert to cartesian coordinates\n    x = r_grid.flatten() * np.cos(theta_grid.flatten())\n    y = r_grid.flatten() * np.sin(theta_grid.flatten())\n    \n    # Add some thickness in z-direction if specified\n    if thickness > 0:\n        z = np.random.uniform(-thickness/2, thickness/2, size=x.shape)\n    else:\n        z = np.zeros_like(x)\n    \n    return x, y, z",
    "start_line": 7,
    "end_line": 39,
    "has_docstring": true,
    "docstring": "Create points for a ring with inner and outer radius.\n\nParameters:\n    inner_radius (float): Inner radius of the ring\n    outer_radius (float): Outer radius of the ring\n    n_points (int): Number of points to generate\n    thickness (float): Thickness of the ring in z-direction\n    \nReturns:\n    tuple: (x, y, z) arrays of coordinates",
    "parameters": [
      "inner_radius",
      "outer_radius",
      "n_points",
      "thickness"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_ring_points_saturn",
    "component_id": "saturn_visualization_shells.create_ring_points_saturn"
  },
  "saturn_visualization_shells.create_saturn_core_shell": {
    "id": "saturn_visualization_shells.create_saturn_core_shell",
    "name": "create_saturn_core_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\saturn_visualization_shells.py",
    "relative_path": "saturn_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_saturn_core_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates saturn's core shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.6,  # Approximately 10% of saturn's radius\n        'color': 'rgb(240, 240, 255)',  # estimated black body color at about 11,000 K\n        'opacity': 1.0,\n        'name': 'Core',\n        'description': (\n            \"Saturn likely has a dense core composed of metallic elements like iron and nickel, surrounded by rocky material and <br>\" \n            \"other compounds solidified by immense pressure and heat. This core is estimated to be about 10 to 15 times the mass <br>\" \n            \"of Earth. It's smaller relative to the planet's overall size compared to Jupiter's core.<br><br>\" \n            \"The core's size and the planet's overall radius are not precisely defined and are subject to ongoing research and <br>\" \n            \"modeling. However, based on current scientific understanding and models of Saturn's interior, we can provide an <br>\" \n            \"estimated range.<br>\" \n            \"* Saturn's Mean Radius is approximately 58,232 kilometers. This is often used as the reference radius.<br>\" \n            \"* Core Radius Estimates: Scientific studies suggest that Saturn's core is not sharply defined and likely consists of a <br>\" \n            \"  dense, sloshy mix of ice, rock, and metallic hydrogen that gradually transitions into the overlying layers. One recent <br>\" \n            \"  study, analyzing waves in Saturn's rings, indicated that the fuzzy core extends out to about 60% of Saturn's radius. <br>\" \n            \"* This core mass would contain about 17 Earth masses of rock and ice, but mixed with hydrogen and helium, the total mass <br>\" \n            \"  of this region is about 55 Earth masses. Earlier estimates often suggested a more compact core, but the \\\"fuzzy core\\\" <br>\" \n            \"  model, where the core material is more dispersed into the inner envelope, is gaining acceptance.<br>\" \n            \"It's important to note that 60% is an estimate based on current models and interpretations of data. The precise nature and <br>\" \n            \"extent of Saturn's core remain areas of active research.<br>\" \n            \"* Approximate Temperature: Estimated to be around 12,000 K. Some sources suggest even higher temperatures.<br>\" \n            \"* Approximate Color: At these extreme temperatures, if we could observe it directly, it would likely appear white-hot to <br>\" \n            \"  bluish-white, based on black body radiation principles. Given the extreme white-hot to bluish-white temperature, <br>\" \n            \"  slightly blue-tinted white.<br>\" \n            \"  * RGB: (255, 255, 255) (pure white) or perhaps something very slightly blue like (240, 240, 255).\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * SATURN_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=4.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Saturn: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Saturn: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 50,
    "end_line": 111,
    "has_docstring": true,
    "docstring": "Creates saturn's core shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_saturn_core_shell",
    "component_id": "saturn_visualization_shells.create_saturn_core_shell"
  },
  "saturn_visualization_shells.create_saturn_metallic_hydrogen_shell": {
    "id": "saturn_visualization_shells.create_saturn_metallic_hydrogen_shell",
    "name": "create_saturn_metallic_hydrogen_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\saturn_visualization_shells.py",
    "relative_path": "saturn_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_saturn_metallic_hydrogen_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Saturn's liquid metallic hydrogen shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.9,  # Up to about 90% of Saturn's radius\n        'color': 'rgb(225, 225, 220)',  # estimated black body color at about 6,000 K\n        'opacity': 0.9,\n        'name': 'Metallic Hydrogen Layer',\n        'description': (\n            \"Metallic Hydrogen Layer:<br>\" \n            \"Surrounding the core is a thick layer of liquid metallic hydrogen, similar to Jupiter. Above this is a layer of liquid <br>\" \n            \"hydrogen and helium, which gradually transitions to a gaseous atmosphere with increasing altitude. Due to lower pressure <br>\" \n            \"and a smaller metallic hydrogen zone, Saturn's magnetic field is weaker than Jupiter's.<br>\" \n            \"The transition to metallic hydrogen is thought to begin around 0.4 - 0.5 R and extends outwards to about 0.9 R.<br>\" \n            \"* Approximate Temperature: Temperatures in this layer would range from thousands of degrees Kelvin, increasing with depth. <br>\" \n            \"  Estimates around the transition to metallic hydrogen are around ~6,000 K and increase significantly deeper.<br>\" \n            \"* Approximate Color: Similar to the core, if visible, it would likely glow with a yellowish-white to white color due to its <br>\" \n            \"  high temperature.<br>\" \n            \"* RGB: (255, 255, 220) (a slightly yellowish white, like cream) to (255, 255, 255) (pure white), depending on how deep <br>\" \n            \"  within the layer you're representing.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * SATURN_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.5,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Saturn: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Saturn: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 120,
    "end_line": 172,
    "has_docstring": true,
    "docstring": "Creates Saturn's liquid metallic hydrogen shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_saturn_metallic_hydrogen_shell",
    "component_id": "saturn_visualization_shells.create_saturn_metallic_hydrogen_shell"
  },
  "saturn_visualization_shells.create_saturn_molecular_hydrogen_shell": {
    "id": "saturn_visualization_shells.create_saturn_molecular_hydrogen_shell",
    "name": "create_saturn_molecular_hydrogen_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\saturn_visualization_shells.py",
    "relative_path": "saturn_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_saturn_molecular_hydrogen_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Saturn's molecular hydrogen shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.99,  # Up to about 99+% of Saturn's radius\n        'color': 'rgb(220, 230, 240)',   \n        'opacity': 0.5,\n        'name': 'Molecular Hydrogen Layer',\n        'description': (\n            \"Molecular Hydrogen Layer:<br>\" \n            \"Liquid Molecular Hydrogen Layer: Approximately 0.8 - 0.9 R to around 1.0 R, at the level where the atmosphere is <br>\" \n            \"considered mostly gaseous. This layer lies above the metallic hydrogen and gradually transitions into the gaseous <br>\" \n            \"atmosphere. The 1.0 R here is a nominal boundary often taken at the cloud tops, which are a distinct layer.<br>\" \n            \"* Approximate Temperature: The temperature decreases as you move outwards in this layer, ranging from thousands of <br>\" \n            \"  degrees Kelvin at the boundary with the metallic hydrogen layer to around -130  degC at the upper boundary near the <br>\" \n            \"  atmosphere.<br>\" \n            \"* Approximate Color: This layer is primarily composed of hydrogen, which is transparent. We wouldn't see a black body <br>\" \n            \"  color associated with its temperature in the visible spectrum at these lower ranges.<br>\" \n            \"* RGB (for visual representation only): (240, 240, 240) (light grey) or (220, 230, 240) (very light blue-grey).\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * SATURN_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Saturn: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Saturn: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 181,
    "end_line": 232,
    "has_docstring": true,
    "docstring": "Creates Saturn's molecular hydrogen shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_saturn_molecular_hydrogen_shell",
    "component_id": "saturn_visualization_shells.create_saturn_molecular_hydrogen_shell"
  },
  "saturn_visualization_shells.create_saturn_cloud_layer_shell": {
    "id": "saturn_visualization_shells.create_saturn_cloud_layer_shell",
    "name": "create_saturn_cloud_layer_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\saturn_visualization_shells.py",
    "relative_path": "saturn_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_saturn_cloud_layer_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Saturn's cloud layer shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.0,  # The visible \"surface\" - 100% of Saturn's radius\n        'color': 'rgb(210, 180, 140)',  # optical\n        'opacity': 1.0,\n        'name': 'Cloud Layer',\n        'description': (\n            \"Saturn Cloud Layer<br>\" \n            \"(Note: toggle off the cloud layer in the legend to better see the interior structure.)<br><br>\"\n            \"Saturn's atmosphere is primarily hydrogen (about 75%) and helium (about 25%), with trace amounts of methane, ammonia, <br>\" \n            \"and water ice. Like Jupiter, it exhibits banded structures due to strong east-west winds, but these bands are much <br>\" \n            \"fainter and less distinct due to a hazy upper atmosphere. Saturn is one of the windiest places in the Solar System, <br>\" \n            \"with equatorial wind speeds reaching up to 1,800 kilometers per hour. A unique feature is a long-lasting hexagonal <br>\" \n            \"jet stream at its north pole. Cloud layers exist at different depths, composed of ammonia ice (uppermost), ammonium <br>\" \n            \"hydrosulfide, and water ice (lowest).<br>\" \n            \"* Atmosphere: The outermost layer, which transitions from a gaseous to a liquid state with increasing depth, starts <br>\" \n            \"  at the visible clouds and extends inwards.<br>\" \n            \"* Liquid Molecular Hydrogen transitioning to gaseous hydrogen in the atmosphere. There isn't a solid surface or a <br>\" \n            \"  distinct \\\"cloud layer atmosphere\\\" that we would definitively consider the surface of Saturn in the same way we <br>\" \n            \"  think of the surface of a rocky planet like Earth.<br>\" \n            \"* Gradual Transition: Saturn's atmosphere transitions gradually from a gaseous state in the upper layers to a denser, <br>\" \n            \"  liquid state deeper within the planet. There's no sharp boundary or interface where you'd suddenly go from atmosphere <br>\" \n            \"  to a solid or liquid \\\"surface.\\\"<br>\" \n            \"* Increasing Pressure and Density: As you descend into Saturn's atmosphere, the pressure and density increase dramatically. <br>\" \n            \"  The gases become compressed until they behave more like a fluid. Eventually, the pressure becomes so immense that <br>\" \n            \"  hydrogen transitions into a liquid metallic state.<br>\" \n            \"* No Solid Ground: Unlike Earth or Mars, Saturn doesn't have a rocky or icy crust. If you were to descend into Saturn, you <br>\" \n            \"  would never reach a solid surface to stand on. You would simply experience increasingly extreme temperatures and <br>\" \n            \"  pressures. What we often refer to as the \\\"visible surface\\\" of Saturn are the uppermost cloud layers. These are the layers <br>\" \n            \"  that reflect sunlight and are what we see through telescopes.<br>\" \n            \"* Vertical Structure: Similar to Jupiter, Saturn's upper troposphere contains three main cloud layers, composed of <br>\" \n            \"  different chemicals at varying depths:<br>\" \n            \"  * Ammonia ice clouds: These are the highest and coldest clouds.<br>\" \n            \"  * Ammonium hydrosulfide clouds: Below the ammonia clouds.<br>\" \n            \"  * Water ice clouds: Thought to be the deepest layer of clouds.<br>\" \n            \"* Thickness: Estimates suggest the total thickness of these three cloud layers on Saturn could be around 200 kilometers, <br>\" \n            \"  * Haze Layer: Above the ammonia ice clouds, Saturn has a more prominent haze layer formed by photochemical reactions in <br>\" \n            \"    its upper atmosphere. This haze layer further obscures the deeper, potentially more colorful, cloud layers.<br>\" \n            \"  * Visibility: Because Saturn's clouds are thicker and overlaid by a more substantial haze, we rarely get clear views of <br>\" \n            \"    the deeper cloud layers with their distinct colors, as we do on Jupiter. This is why Saturn appears more uniformly <br>\" \n            \"    pale yellow or butterscotch in color. The contrast between the bands and zones is much less pronounced on Saturn. So, <br>\" \n            \"    while Saturn does have distinct cloud layers with different chemical compositions, they are not as sharply defined or <br>\" \n            \"    visually apparent as Jupiter's due to their greater thickness and the overlying haze. Therefore, while you could <br>\" \n            \"    consider this region of clouds as a distinct layer within Saturn's atmosphere, its characteristics (thickness, visibility) <br>\" \n            \"    differ noticeably from Jupiter's more vibrant and thinner cloud bands.<br>\" \n            \"  * To put a rough estimate on the thickness relative to Saturn's radius, a 200 km thick cloud layer would be approximately <br>\" \n            \"    ~0.0034R.<br>\"\n            \"  * Visualization: It is the primary visual feature we observe and therefore should be represented as a distinct layer.<br>\"\n            \"    * Visual Boundary: The cloud tops are effectively the limit of what we can directly see with telescopes (in visible <br>\" \n            \"      light). While the atmosphere extends far above and the molecular hydrogen layer lies deep below, the cloud layer is <br>\" \n            \"      the \\\"face\\\" Saturn presents to us.<br>\" \n            \"    * Saturn's cloud layer exhibits dynamic features like bands, storms (including the polar hexagon), and variations in <br>\" \n            \"      haze. These are important aspects of Saturn's atmospheric activity. The cloud layer marks a visually and physically <br>\" \n            \"      significant region within that transition.<br>\" \n            \"* Approximate Temperature: Varies with altitude within the cloud layers:<br>\" \n            \"  * Ammonia ice clouds (highest): Around -173  degC (-280  degF).<br>\" \n            \"  * Ammonium hydrosulfide clouds: Warmer than the ammonia clouds.<br>\" \n            \"  * Water ice clouds (deepest): Ranging from -88  degC (-127  degF) to -3  degC (26  degF).<br>\"\n            \"* Approximate Color: The overall visible color of Saturn's clouds is a pale yellow to butterscotch. This color is <br>\" \n            \"  thought to be due to photochemical haze in the upper atmosphere interacting with sunlight, potentially involving <br>\" \n            \"  hydrocarbons. Trace amounts of other elements might contribute subtle hues.<br>\"\n            \"In summary, while the cloud layers are a prominent and visible feature of Saturn, they are not a surface. Saturn is a fluid <br>\" \n            \"planet that becomes increasingly dense with depth, without a distinct solid or liquid surface.\"       \n            )\n    }\n    \n    # Calculate radius in AU\n    radius = layer_info['radius_fraction'] * SATURN_RADIUS_AU\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Create mesh with reasonable resolution for performance\n    resolution = 24  # Reduced from typical 50 for markers\n    \n    # Create a UV sphere\n    phi = np.linspace(0, 2*np.pi, resolution)\n    theta = np.linspace(-np.pi/2, np.pi/2, resolution)\n    phi, theta = np.meshgrid(phi, theta)\n    \n    x = radius * np.cos(theta) * np.cos(phi)\n    y = radius * np.cos(theta) * np.sin(phi)\n    z = radius * np.sin(theta)\n    \n    # Apply center position offset\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    # Create triangulation\n    indices = []\n    for i in range(resolution-1):\n        for j in range(resolution-1):\n            p1 = i * resolution + j\n            p2 = i * resolution + (j + 1)\n            p3 = (i + 1) * resolution + j\n            p4 = (i + 1) * resolution + (j + 1)\n            \n            indices.append([p1, p2, p4])\n            indices.append([p1, p4, p3])\n    \n    # Create main surface\n    surface_trace = go.Mesh3d(\n        x=x.flatten(), \n        y=y.flatten(), \n        z=z.flatten(),\n        i=[idx[0] for idx in indices],\n        j=[idx[1] for idx in indices],\n        k=[idx[2] for idx in indices],\n        color=layer_info['color'],\n        opacity=layer_info['opacity'],\n        name=f\"Saturn: {layer_info['name']}\",\n        showlegend=True,\n        hoverinfo='none',  # Disable hover on mesh surface\n        # Add these new parameters to make hover text invisible\n        hovertemplate=' ',  # Empty template instead of None\n        hoverlabel=dict(\n    #        bgcolor='rgba(0,0,0,0)',  # Transparent background\n            font=dict(\n                color='rgba(0,0,0,0)',  # Transparent text\n    #            size=0                  # Zero font size\n            ),\n            bordercolor='rgba(0,0,0,0)'  # Transparent border\n        ), \n        # Add these new parameters to eliminate shading\n        flatshading=True,  # Use flat shading instead of smooth\n        lighting=dict(\n            ambient=1.0,     # Set to maximum (1.0)\n            diffuse=0.0,     # Turn off diffuse lighting\n            specular=0.0,    # Turn off specular highlights\n            roughness=1.0,   # Maximum roughness\n            fresnel=0.0      # Turn off fresnel effect\n        ),\n        lightposition=dict(\n            x=0,  # Centered light\n            y=0,  # Centered light\n            z=10000  # Light from very far above to minimize shadows\n        )       \n    )\n        \n    # Use the Fibonacci sphere algorithm for more even point distribution\n    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points\n    \n    # Generate fibonacci sphere points\n    fib_points = fibonacci_sphere(samples=50)  # Originally, 50 hover points evenly distributed\n    \n    # Scale and offset the points\n    x_hover = [p[0] * radius + center_x for p in fib_points]\n    y_hover = [p[1] * radius + center_y for p in fib_points]\n    z_hover = [p[2] * radius + center_z for p in fib_points]\n        \n    # Create a list of repeated descriptions for each point\n    # This is crucial - we need exactly one text entry per point\n    hover_texts = [layer_info['description']] * len(x_hover)\n\n    # Just the name for \"Object Names Only\" mode\n    layer_name = f\"Saturn: {layer_info['name']}\"\n    minimal_hover_texts = [layer_name] * len(x_hover)\n\n    # Create hover trace with direct text assignment\n    hover_trace = go.Scatter3d(\n        x=x_hover, \n        y=y_hover, \n        z=z_hover,\n        mode='markers',\n        marker=dict(\n            size=2,  # originally 5\n            color='rgb(210, 180, 140)',  # Layer color, originally 'white'\n            opacity=1.0,  # originally 0.8\n            line=dict(  # Add a contrasting outline\n                width=1,\n                color='black'\n            )\n        ),\n        name=f\"Saturn: {layer_info['name']} (Info)\",\n        text=hover_texts,  # IMPORTANT: Matching length with coordinate arrays\n        customdata=minimal_hover_texts,  # For \"Object Names Only\" mode\n        hovertemplate='%{text}<extra></extra>',  # Use the standard hover template\n        showlegend=False  # Don't show in legend since it's just for hover\n    )\n\n    return [surface_trace, hover_trace]",
    "start_line": 245,
    "end_line": 443,
    "has_docstring": true,
    "docstring": "Creates Saturn's cloud layer shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_saturn_cloud_layer_shell",
    "component_id": "saturn_visualization_shells.create_saturn_cloud_layer_shell"
  },
  "saturn_visualization_shells.fibonacci_sphere": {
    "id": "saturn_visualization_shells.fibonacci_sphere",
    "name": "fibonacci_sphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\saturn_visualization_shells.py",
    "relative_path": "saturn_visualization_shells.py",
    "depends_on": [],
    "source_code": "    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points",
    "start_line": 388,
    "end_line": 403,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "samples"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fibonacci_sphere",
    "component_id": "saturn_visualization_shells.fibonacci_sphere"
  },
  "saturn_visualization_shells.create_saturn_upper_atmosphere_shell": {
    "id": "saturn_visualization_shells.create_saturn_upper_atmosphere_shell",
    "name": "create_saturn_upper_atmosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\saturn_visualization_shells.py",
    "relative_path": "saturn_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_saturn_upper_atmosphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Saturn's upper atmosphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.1,  # Extends about 10% beyond the visible radius\n        'color': 'rgb(240, 245, 250)',  # optical pale blue\n        'opacity': 0.5,\n        'name': 'Upper Atmosphere',\n        'description': (\n            \"Saturn definitely has an upper atmosphere above its cloud layers. Similar to Earth, Jupiter, and other planets with <br>\" \n            \"atmospheres, Saturn's atmosphere doesn't just abruptly end at the visible clouds. It extends far beyond.<br>\" \n            \"Here's a breakdown of the regions above the main cloud layer in Saturn's atmosphere:<br>\" \n            \"* Troposphere: This is the lowest layer, where the visible clouds reside and where most of the planet's weather occurs. <br>\" \n            \"  The temperature generally decreases with altitude in this layer.<br>\" \n            \"* Tropopause: This is a transition layer above the troposphere where the temperature stops decreasing and starts to become <br>\" \n            \"  stable. It marks the upper boundary of the troposphere.<br>\" \n            \"* Stratosphere: Above the tropopause, the temperature generally increases with altitude as this layer absorbs ultraviolet (UV) <br>\" \n            \"  radiation from the Sun. In Saturn's stratosphere, hydrocarbons like methane, ethane, and acetylene are formed through <br>\" \n            \"  photochemical reactions driven by sunlight.<br>\" \n            \"* Mesosphere: Above the stratosphere, the temperature generally decreases with altitude again. This layer is less well-studied <br>\" \n            \"  in Saturn compared to its lower atmosphere.<br>\" \n            \"* Thermosphere: In this upper layer, the atmosphere becomes very thin, and the temperature increases significantly with altitude <br>\" \n            \"  due to absorption of high-energy solar radiation. Saturn's thermosphere is heated by auroral electric currents, similar to <br>\" \n            \"  how Earth's thermosphere is heated.<br>\" \n            \"* Exosphere: This is the outermost and most tenuous layer of Saturn's atmosphere, where the gas molecules are so far apart that <br>\" \n            \"  they can escape into space. There is no clear upper boundary to the exosphere. It extends far beyond the denser parts <br>\" \n            \"  of the upper atmosphere<br>\" \n            \"So, while the colorful cloud bands are the most visually prominent feature of Saturn, there's a significant and complex <br>\" \n            \"structure of gases extending far above them, each layer with its own characteristics and processes. The Cassini mission <br>\" \n            \"provided a wealth of information about these upper atmospheric layers. These layers are all part of the gaseous <br>\" \n            \"atmosphere above the cloud layers. They are characterized by different temperature profiles and chemical compositions <br>\" \n            \"as altitude increases. Their exact outer boundaries are not defined by a specific fraction of Saturn's radius in a simple <br>\" \n            \"way, as they gradually thin out.<br>\" \n            \"* Gradual Transitions: The boundaries between these layers are not sharp lines but rather zones of transition where the <br>\" \n            \"  physical properties of the material change.<br>\" \n            \"* Atmospheric Extent: The atmosphere doesn't have a clear \\\"top\\\" in terms of a specific radial fraction in the same way <br>\" \n            \"  the internal layers do. It thins out gradually into space.<br>\" \n            \"* Modeling: These fractions are based on current scientific models, which are continually being refined. The atmosphere <br>\" \n            \"  extends outwards from what we typically consider the \\\"surface\\\" at 1 R (the cloud tops).<br>\" \n            \"* Approximate Temperature: The temperature generally decreases with altitude in the troposphere (below the tropopause). <br>\" \n            \"  Above the tropopause, in the stratosphere, it increases due to absorption of UV radiation. The thermosphere, the upper <br>\" \n            \"  part of the atmosphere, becomes surprisingly hot, reaching hundreds of degrees Celsius (e.g., 300  degC near the poles) <br>\" \n            \"  due to auroral heating.<br>\" \n            \"* Approximate Color: The upper atmosphere is primarily composed of hydrogen and helium, which are transparent. We don't <br>\" \n            \"  associate a specific visible \\\"color\\\" with these gases at these temperatures. Auroras in the polar regions would emit <br>\" \n            \"  light, similar to Earth's auroras, with colors depending on the excited gases (e.g., greens and reds from oxygen, blues <br>\" \n            \"  from nitrogen).<br>\" \n            \"* Exosphere: Temperatures in the exosphere are very high, reaching hundreds to thousands of degrees Kelvin. However, <br>\" \n            \"  the gas density is extremely low, so this heat wouldn't feel like anything to a spacecraft. The exosphere is extremely <br>\" \n            \"  tenuous and doesn't have a visible color in the same way as the denser layers or hot objects. Individual atoms and <br>\" \n            \"  molecules might emit light at specific wavelengths if excited, but the overall appearance is essentially transparent.<br>\" \n            \"* Defining a precise upper boundary for the \\\"upper atmosphere\\\" is challenging because it gradually thins out. The main <br>\" \n            \"  cloud layers extend up to a few hundred kilometers above the 1-bar pressure level (which is often considered the \\\"top\\\" <br>\" \n            \"  of the troposphere and roughly 1 R. Sources suggest the cloud layers are spread over about 300 km in altitude. The <br>\" \n            \"  stratosphere and mesosphere extend further outwards, but their density decreases significantly with altitude. The <br>\" \n            \"  thermosphere, where temperatures rise again due to solar radiation and auroral activity, is even more tenuous. <br>\" \n            \"  Considering these factors, a rough estimate for the outermost extent before it significantly transitions into the exosphere <br>\" \n            \"  could be a few thousand kilometers above the 1-bar level. ~0.086R. The edge around 1.05 to 1.1 R. However, the atmosphere <br>\" \n            \"  continues to thin out gradually beyond this.<br>\" \n            \"* Exosphere Extent: The exosphere of Saturn, like other planets, is primarily influenced by Saturn's gravitational pull. <br>\" \n            \"  While it's the outermost layer of the atmosphere, its density decreases exponentially with distance.\" \n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * SATURN_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Saturn: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Saturn: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=layer_radius\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 453,
    "end_line": 553,
    "has_docstring": true,
    "docstring": "Creates Saturn's upper atmosphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_saturn_upper_atmosphere_shell",
    "component_id": "saturn_visualization_shells.create_saturn_upper_atmosphere_shell"
  },
  "saturn_visualization_shells.create_saturn_magnetosphere": {
    "id": "saturn_visualization_shells.create_saturn_magnetosphere",
    "name": "create_saturn_magnetosphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\saturn_visualization_shells.py",
    "relative_path": "saturn_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_magnetosphere_shape",
      "shared_utilities.create_sun_direction_indicator"
    ],
    "source_code": "def create_saturn_magnetosphere(center_position=(0, 0, 0)):\n    \"\"\"Creates Saturn's main magnetosphere structure.\"\"\"\n    # Parameters for magnetosphere components (in Saturn radii)\n    params = {\n        # Compressed sunward side\n        'sunward_distance': 22,  # Compressed toward the sun, ranges from 20-25 Rs\n        \n        # Equatorial extension (wider than polar)\n        'equatorial_radius': 45,   # ranges from 40-50 Rs\n        'polar_radius': 35,         # ranges from 30-40 Rs\n        \n        # Magnetotail parameters\n        'tail_length': 500,  # Length of visible magnetotail, ranges from 400-600 Rs\n        'tail_base_radius': 75,  # Radius at the base of the tail, ranges from 50-100 Rs\n        'tail_end_radius': 100,  # Radius at the end of the tail, ranges from 75-125 Rs\n    }\n    \n    # Scale everything by Saturn's radius in AU\n    for key in params:\n        params[key] *= SATURN_RADIUS_AU\n    \n    # Create magnetosphere main shape\n    x, y, z = create_magnetosphere_shape(params)\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Apply center position offset\n    x = np.array(x) + center_x\n    y = np.array(y) + center_y\n    z = np.array(z) + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.0,\n                color='rgb(200, 200, 255)', # Light blue for magnetic field\n                opacity=0.25\n            ),\n            name='Saturn: Magnetosphere',\n            text=[\"Saturn has a large magnetosphere, the region of space dominated by its magnetic field. Saturn's magnetic field is <br>\" \n                  \"unique because its magnetic axis is almost perfectly aligned with its rotational axis. The magnetosphere deflects <br>\" \n                  \"the solar wind and traps charged particles, leading to auroras at the poles.<br>\" \n                  \"Material from Enceladus's plumes contributes plasma to Saturn's magnetosphere and its E ring.<br>\" \n                  \"The Bow Shock points towards the Sun along the X-axis. The XY plane is the ecliptic.\"] * len(x),\n            customdata=['Saturn: Magnetosphere'] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=500 * SATURN_RADIUS_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 555,
    "end_line": 615,
    "has_docstring": true,
    "docstring": "Creates Saturn's main magnetosphere structure.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_saturn_magnetosphere",
    "component_id": "saturn_visualization_shells.create_saturn_magnetosphere"
  },
  "saturn_visualization_shells.create_saturn_enceladus_plasma_torus": {
    "id": "saturn_visualization_shells.create_saturn_enceladus_plasma_torus",
    "name": "create_saturn_enceladus_plasma_torus",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\saturn_visualization_shells.py",
    "relative_path": "saturn_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.rotate_points"
    ],
    "source_code": "def create_saturn_enceladus_plasma_torus(center_position=(0, 0, 0)):\n    \"\"\"Creates Saturn's Enceladus plasma torus.\"\"\"\n    # Parameters\n    enceladus_torus_distance = 3.95 * SATURN_RADIUS_AU  \n    enceladus_torus_thickness = 1 * SATURN_RADIUS_AU\n    enceladus_torus_width = 2 * SATURN_RADIUS_AU\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n\n    # Saturn's axial tilt in radians (-26.73 degrees)\n    saturn_tilt = np.radians(-26.73)\n    \n    # Create the Io plasma torus points\n    enceladus_torus_x = []\n    enceladus_torus_y = []\n    enceladus_torus_z = []\n    \n    n_points = 100\n    n_rings = 8\n    \n    for i_ring in range(n_rings):\n        # Vary the radius slightly to create thickness\n        radius_offset = (i_ring / (n_rings-1) - 0.5) * enceladus_torus_thickness\n        torus_radius = enceladus_torus_distance + radius_offset\n        \n        for i in range(n_points):\n            angle = (i / n_points) * 2 * np.pi\n\n            # Position in x-y plane (equatorial)\n            x = torus_radius * np.cos(angle)\n            y = torus_radius * np.sin(angle)\n            z = 0  # In the equatorial plane    \n            \n            # Add some thickness variation\n            jitter = (np.random.random() - 0.5) * enceladus_torus_width\n            \n            enceladus_torus_x.append(x)\n            enceladus_torus_y.append(y)\n            enceladus_torus_z.append(z + jitter)     # Apply jitter to z axis\n    \n    # Apply center position offset\n    enceladus_torus_x = np.array(enceladus_torus_x) \n    enceladus_torus_y = np.array(enceladus_torus_y) \n    enceladus_torus_z = np.array(enceladus_torus_z) \n\n    # Apply Saturn's axial tilt (rotate around x-axis)\n    enceladus_torus_x_tilted, enceladus_torus_y_tilted, enceladus_torus_z_tilted = rotate_points(\n        enceladus_torus_x, enceladus_torus_y, enceladus_torus_z, saturn_tilt, 'x'\n    )\n\n    # Apply center position offset\n    enceladus_torus_x_final = enceladus_torus_x_tilted + center_x\n    enceladus_torus_y_final = enceladus_torus_y_tilted + center_y\n    enceladus_torus_z_final = enceladus_torus_z_tilted + center_z\n\n    # Create the enceladus plasma torus hover text and customdata arrays\n    enceladus_text = [\"Enceladus plasma torus: Primarily sourced by water vapor and icy particles vented from the geysers on the <br>\" \n                      \"south pole of Enceladus. These geysers release hundreds of kilograms of water vapor per second.<br>\" \n                      \"* Composition: Dominated by water group ions and also contains hydrogen ions.<br>\" \n                      \"* Location: Forms a torus centered around Enceladus's orbit, which is within Saturn's vast E ring. The E ring <br>\" \n                      \"  itself is largely composed of icy particles ejected from Enceladus.<br>\" \n                      \"* Influence: The Enceladus plasma torus is a significant source of plasma for Saturn's inner magnetosphere. <br>\" \n                      \"  This plasma is crucial for populating Saturn's magnetosphere with water-group ions. The mass loading from <br>\" \n                      \"  Enceladus is estimated to be around 100 kg/s. This plasma gradually moves outward and eventually escapes <br>\" \n                      \"  through Saturn's magnetotail.<br>\" \n                      \"* Ionization: Ionization of the water vapor is driven by UV radiation and electron bombardment within the torus.<br>\"\n                      \"* Color: Neutral gases like water vapor are colorless and transparent. Any visible color would arise from the scattering of <br>\" \n                      \"  light by the ice particles within the torus. Pure water ice is typically white or very light blue due to scattering.\"\n                      ] * len(enceladus_torus_x_final)\n    enceladus_customdata = ['Saturn: Enceladus Plasma Torus'] * len(enceladus_torus_x_final)\n    \n    \n    traces = [\n        go.Scatter3d(\n            x=enceladus_torus_x_final,\n            y=enceladus_torus_y_final,\n            z=enceladus_torus_z_final,\n            mode='markers',\n            marker=dict(\n                size=1.5,\n                color='rgb(200, 220, 255)',  # a very subtle blue tint for plasma torus\n                opacity=0.3\n            ),\n            name='Saturn: Enceladus Plasma Torus',\n            text=enceladus_text,\n            customdata=enceladus_customdata,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=enceladus_torus_distance\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 620,
    "end_line": 719,
    "has_docstring": true,
    "docstring": "Creates Saturn's Enceladus plasma torus.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_saturn_enceladus_plasma_torus",
    "component_id": "saturn_visualization_shells.create_saturn_enceladus_plasma_torus"
  },
  "saturn_visualization_shells.create_saturn_radiation_belts": {
    "id": "saturn_visualization_shells.create_saturn_radiation_belts",
    "name": "create_saturn_radiation_belts",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\saturn_visualization_shells.py",
    "relative_path": "saturn_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.rotate_points"
    ],
    "source_code": "def create_saturn_radiation_belts(center_position=(0, 0, 0)):\n    \"\"\"Creates Saturn's radiation belts.\"\"\"\n    belt_colors = ['rgb(255, 255, 100)', 'rgb(100, 255, 150)', 'rgb(100, 200, 255)',\n                  'rgb(255, 100, 100)', 'rgb(100, 100, 255)', 'rgb(255, 200, 100)']\n    belt_names = ['Belt from A-Ring to Mimas', 'Belt from Mimas to Enceladus', 'Belt from Enceladus to Tethys', \n                  'Belt from Tethys to Dione', 'Belt from Dione to Rhea', 'Belt outward of Rhea']\n    belt_texts = [\n        \"Belt from A-Ring to Mimas: Saturn radiation belts, regions where charged particles are trapped by the planet's magnetic <br>\" \n        \"field. They are heavily influenced by Saturn's rings and moons, which absorb many of the charged particles, creating gaps <br>\" \n        \"in the belts. The primary source of high-energy particles is the collision of galactic cosmic rays.\",\n\n        \"Belt from Mimas to Enceladus: Saturn radiation belts, regions where charged particles are trapped by the planet's magnetic <br>\" \n        \"field. They are heavily influenced by Saturn's rings and moons, which absorb many of the charged particles, creating gaps <br>\" \n        \"in the belts. The primary source of high-energy particles is the collision of galactic cosmic rays.\",\n\n        \"Belt from Enceladus to Tethys: Saturn radiation belts, regions where charged particles are trapped by the planet's magnetic <br>\" \n        \"field. They are heavily influenced by Saturn's rings and moons, which absorb many of the charged particles, creating gaps <br>\" \n        \"in the belts. The primary source of high-energy particles is the collision of galactic cosmic rays.\",\n\n        \"Belt from Tethys to Dione: Saturn radiation belts, regions where charged particles are trapped by the planet's magnetic <br>\" \n        \"field. They are heavily influenced by Saturn's rings and moons, which absorb many of the charged particles, creating gaps <br>\" \n        \"in the belts. The primary source of high-energy particles is the collision of galactic cosmic rays.\",\n\n        \"Belt from Dione to Rhea: Saturn radiation belts, regions where charged particles are trapped by the planet's magnetic <br>\" \n        \"field. They are heavily influenced by Saturn's rings and moons, which absorb many of the charged particles, creating gaps <br>\" \n        \"in the belts. The primary source of high-energy particles is the collision of galactic cosmic rays. Rhea's influence on <br>\" \n        \"sharply defining a gap might be less pronounced than the inner moons.\",\n\n        \"Belt outward of Rhea: Saturn radiation belts, regions where charged particles are trapped by the planet's magnetic <br>\" \n        \"field. They are heavily influenced by Saturn's rings and moons, which absorb many of the charged particles, creating gaps <br>\" \n        \"in the belts. The primary source of high-energy particles is the collision of galactic cosmic rays. The radiation <br>\" \n        \"environment beyond Rhea becomes more variable and less clearly defined into stable, distinct belts solely by moon orbits.\"\n    ]\n    \n    # Belt distances in Saturn radii\n    belt_distances = [2.7, 3.5, 4.4, 5.6, 7.4, 9.0]\n    belt_thickness = 0.5 * SATURN_RADIUS_AU\n    \n    # Scale distances by Saturn's radius in AU\n    belt_distances = [d * SATURN_RADIUS_AU for d in belt_distances]\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n\n    # Saturn's axial tilt in radians (-26.73 degrees)\n    saturn_tilt = np.radians(-26.73)\n    \n    traces = []\n    \n    for i, belt_distance in enumerate(belt_distances):\n        belt_x = []\n        belt_y = []\n        belt_z = []\n        \n        n_points = 80\n        n_rings = 5\n        \n        for i_ring in range(n_rings):\n            # Vary the radius slightly to create thickness\n            radius_offset = (i_ring / (n_rings-1) - 0.5) * belt_thickness\n            belt_radius = belt_distance + radius_offset\n            \n            for j in range(n_points):\n                angle = (j / n_points) * 2 * np.pi\n                \n                # Create a belt around Saturn's rotational axis\n                x = belt_radius * np.cos(angle)\n                y = belt_radius * np.sin(angle)\n                \n                # Add some z variation based on angle to create the shape of a belt\n                # rather than a perfect torus (thinner near poles)\n                z_scale = 0.2 * belt_radius  # Controls how flat the belts are\n                z = z_scale * np.sin(2 * angle)\n                \n                belt_x.append(x)\n                belt_y.append(y)\n                belt_z.append(z)\n        \n        # Apply center position offset\n        belt_x = np.array(belt_x) + center_x\n        belt_y = np.array(belt_y) + center_y\n        belt_z = np.array(belt_z) + center_z\n        \n        # Create the radiation belt hover text and customdata arrays\n        belt_text = [belt_texts[i]] * len(belt_x)\n        belt_customdata = [belt_names[i]] * len(belt_x)\n\n        # Apply center position offset\n        belt_x = np.array(belt_x)\n        belt_y = np.array(belt_y)\n        belt_z = np.array(belt_z)\n        \n        # Apply Saturn's axial tilt (rotate around x-axis)\n        belt_x_tilted, belt_y_tilted, belt_z_tilted = rotate_points(belt_x, belt_y, belt_z, saturn_tilt, 'x')\n        \n        # Apply center position offset\n        belt_x_final = belt_x_tilted + center_x\n        belt_y_final = belt_y_tilted + center_y\n        belt_z_final = belt_z_tilted + center_z\n\n        traces.append(\n            go.Scatter3d(\n                x=belt_x_final,\n                y=belt_y_final,\n                z=belt_z_final,\n                mode='markers',\n                marker=dict(\n                    size=1.5,\n                    color=belt_colors[i],\n                    opacity=0.3\n                ),\n                name=belt_names[i],\n                text=belt_text,\n                customdata=belt_customdata,\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            )\n        )\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius= 9.0 * SATURN_RADIUS_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 726,
    "end_line": 852,
    "has_docstring": true,
    "docstring": "Creates Saturn's radiation belts.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_saturn_radiation_belts",
    "component_id": "saturn_visualization_shells.create_saturn_radiation_belts"
  },
  "saturn_visualization_shells.create_saturn_hill_sphere_shell": {
    "id": "saturn_visualization_shells.create_saturn_hill_sphere_shell",
    "name": "create_saturn_hill_sphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\saturn_visualization_shells.py",
    "relative_path": "saturn_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_saturn_hill_sphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Saturn's Hill sphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1120,  \n        'color': 'rgb(0, 255, 0)',  # Green for Hill sphere\n        'opacity': 0.3,\n        'name': 'Hill Sphere',\n        'description': (\n            \"SET MANUAL SCALE OF AT LEAST 0.3 AU TO VISUALIZE.<br><br>\"\n            \"Saturn: Its Hill sphere, the region around the planet where its gravity dominates over the Sun's, has a radius of <br>\" \n            \"approximately 91 million kilometers (about 151 Saturn radii). This is smaller than Jupiter's Hill sphere due to <br>\" \n            \"Saturn's lower mass. The Hill sphere is crucial for determining the maximum distance at which a moon can stably orbit <br>\" \n            \"Saturn.<br><br>\"\n                \"The Hill sphere is the region around a where its own gravity is the dominant force in attracting satellites. For <br>\" \n                \"a planet orbiting a star, it's the region where the planet's gravity is stronger than the star's tidal forces.<br><br>\" \n                \"The Hill Sphere radius can be described in words as follows: it is equal to the planet's average distance from the <br>\" \n                \"Sun (its orbital semi-major axis) multiplied by the cube root of the ratio between the planet's mass and three times <br>\" \n                \"the Sun's mass. In other words, you take how far the planet orbits out from the Sun, then scale that distance by the <br>\" \n                \"cube root of (planet mass / [3 x solar mass]) to find the boundary within which the planet's gravity dominates over the Sun's.\"        \n        )\n    }\n        \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * SATURN_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Saturn: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Saturn: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    # Add sun direction indicator scaled to this shell's radius\n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=layer_radius\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 864,
    "end_line": 924,
    "has_docstring": true,
    "docstring": "Creates Saturn's Hill sphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_saturn_hill_sphere_shell",
    "component_id": "saturn_visualization_shells.create_saturn_hill_sphere_shell"
  },
  "saturn_visualization_shells.create_saturn_ring_system": {
    "id": "saturn_visualization_shells.create_saturn_ring_system",
    "name": "create_saturn_ring_system",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\saturn_visualization_shells.py",
    "relative_path": "saturn_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "saturn_visualization_shells.create_ring_points_saturn",
      "planet_visualization_utilities.rotate_points"
    ],
    "source_code": "def create_saturn_ring_system(center_position=(0, 0, 0)):\n    \"\"\"\n    Creates a visualization of Saturn's ring system.\n    \n    Parameters:\n        center_position (tuple): (x, y, z) position of Saturn's center\n        \n    Returns:\n        list: A list of plotly traces representing the ring components\n    \"\"\"\n    traces = []\n    \n    # Define Saturn's ring parameters in kilometers from Saturn's center\n    # Then convert to Saturn radii, and finally to AU\n    ring_params = {\n        'd_ring': {\n            'inner_radius_km': 66900,  # Inner edge (in km from Saturn's center)\n            'outer_radius_km': 74500,  # Outer edge (in km from Saturn's center)\n            'thickness_km': 10,         # Approximate thickness\n            'color': 'rgb(50, 50, 50)',  # Very dark/grayish\n            'opacity': 0.4,\n            'name': 'D Ring',\n            'description': (\n                \"D Ring: The innermost and faintest of the main rings.<br><br>\" \n                \"Saturn is famous for its spectacular and extensive ring system, composed primarily of water ice particles, with <br>\" \n                \"some rocky debris and dust. The rings are incredibly wide, extending hundreds of thousands of kilometers from the <br>\" \n                \"planet, but are typically only about 10 meters thick. They are divided into several main rings (A, B, C) and <br>\" \n                \"fainter rings (D, E, F, G), with gaps between them, most notably the Cassini Division.\"\n            )\n        },\n        'c_ring': {\n            'inner_radius_km': 74658,  # Inner edge (in km from Saturn's center)\n            'outer_radius_km': 92000,  # Outer edge (in km from Saturn's center)\n            'thickness_km': 10,      # Approximate thickness (thicker than the main ring)\n            'color': 'rgb(100, 100, 100)',  # Darker gray\n            'opacity': 0.5,\n            'name': 'C Ring',\n            'description': (\n                \"C Ring: Wider but fainter than the A and B rings.<br><br>\" \n                \"Saturn is famous for its spectacular and extensive ring system, composed primarily of water ice particles, with <br>\" \n                \"some rocky debris and dust. The rings are incredibly wide, extending hundreds of thousands of kilometers from the <br>\" \n                \"planet, but are typically only about 10 meters thick. They are divided into several main rings (A, B, C) and <br>\" \n                \"fainter rings (D, E, F, G), with gaps between them, most notably the Cassini Division.\"\n            )\n        },\n        'b_ring': {\n            'inner_radius_km': 92000,  # Inner edge (in km from Saturn's center)\n            'outer_radius_km': 117500,  # Outer edge \n            'thickness_km': 10,       # Approximate thickness\n            'color': 'rgb(180, 180, 170)',  # Brightest, whitish-gray with subtle tones\n            'opacity': 0.8,\n            'name': 'B Ring',\n            'description': (\n                \"B Ring: The brightest and most massive ring.<br><br>\" \n                \"Saturn is famous for its spectacular and extensive ring system, composed primarily of water ice particles, with <br>\" \n                \"some rocky debris and dust. The rings are incredibly wide, extending hundreds of thousands of kilometers from the <br>\" \n                \"planet, but are typically only about 10 meters thick. They are divided into several main rings (A, B, C) and <br>\" \n                \"fainter rings (D, E, F, G), with gaps between them, most notably the Cassini Division.\"\n            )\n        },\n        'a_ring': {\n            'inner_radius_km': 122340,  # Inner edge (in km from Saturn's center)\n            'outer_radius_km': 136800,  # Outer edge \n            'thickness_km': 30,       # Approximate thickness\n            'color': 'rgb(160, 160, 150)',  # Slightly darker than B, grayish\n            'opacity': 0.7,\n            'name': 'A Ring',\n            'description': (\n                \"A Ring: The outermost of the bright main rings. Pan orbits within the Encke Gap in the A Ring and is responsible for <br>\"\n                \"keeping it largely clear of ring material. It also creates wavy edges in the gap. Daphnis orbits within the Keeler Gap <br>\" \n                \"in the outer A Ring and creates waves in the edges of the gap.<br><br>\" \n                \"Saturn is famous for its spectacular and extensive ring system, composed primarily of water ice particles, with <br>\" \n                \"some rocky debris and dust. The rings are incredibly wide, extending hundreds of thousands of kilometers from the <br>\" \n                \"planet, but are typically only about 10 meters thick. They are divided into several main rings (A, B, C) and <br>\" \n                \"fainter rings (D, E, F, G), with gaps between them, most notably the Cassini Division.\"\n            )\n        },\n        'f_ring': {\n            'inner_radius_km': 140210,  # Inner edge (in km from Saturn's center)\n            'outer_radius_km': 140420,  # Outer edge \n            'thickness_km': 1,       # Approximate thickness\n            'color': 'rgb(200, 200, 200)',  # Narrow, brightish\n            'opacity': 0.3,\n            'name': 'F Ring',\n            'description': (\n              \"F Ring: A narrow and dynamic ring just outside the A ring, shepherded by the moons Pandora and Prometheus.<br><br>\" \n                \"Saturn is famous for its spectacular and extensive ring system, composed primarily of water ice particles, with <br>\" \n                \"some rocky debris and dust. The rings are incredibly wide, extending hundreds of thousands of kilometers from the <br>\" \n                \"planet, but are typically only about 10 meters thick. They are divided into several main rings (A, B, C) and <br>\" \n                \"fainter rings (D, E, F, G), with gaps between them, most notably the Cassini Division.\"\n            )\n        },\n        'g_ring': {\n            'inner_radius_km': 166000,  # Inner edge (in km from Saturn's center)\n            'outer_radius_km': 175000,  # Outer edge \n            'thickness_km': 100,       # Approximate thickness\n            'color': 'rgb(220, 220, 200)',  # Faint, light gray/dusty\n            'opacity': 0.2,\n            'name': 'G Ring',\n            'description': (\n              \"G Ring: A faint and dusty ring farther out.<br><br>\" \n                \"Saturn is famous for its spectacular and extensive ring system, composed primarily of water ice particles, with <br>\" \n                \"some rocky debris and dust. The rings are incredibly wide, extending hundreds of thousands of kilometers from the <br>\" \n                \"planet, but are typically only about 10 meters thick. They are divided into several main rings (A, B, C) and <br>\" \n                \"fainter rings (D, E, F, G), with gaps between them, most notably the Cassini Division.\"\n            )\n        },\n        'e_ring': {\n            'inner_radius_km': 180000,  # Inner edge (in km from Saturn's center)\n            'outer_radius_km': 480000,  # Outer edge \n            'thickness_km': 1000,       # Approximate thickness\n            'color': 'rgb(230, 230, 250)',  # Very faint, bluish-white due to water ice\n            'opacity': 0.1,\n            'name': 'E Ring',\n            'description': (\n              \"E Ring: A very wide and diffuse ring, extending far beyond the main rings and sourced by icy particles from the moon Enceladus.<br><br>\" \n                \"Saturn is famous for its spectacular and extensive ring system, composed primarily of water ice particles, with <br>\" \n                \"some rocky debris and dust. The rings are incredibly wide, extending hundreds of thousands of kilometers from the <br>\" \n                \"planet, but are typically only about 10 meters thick. They are divided into several main rings (A, B, C) and <br>\" \n                \"fainter rings (D, E, F, G), with gaps between them, most notably the Cassini Division.\"\n            )\n        }\n    }\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Saturn's axial tilt in radians (-26.73)\n    saturn_tilt = np.radians(-26.73)         \n\n    # Create traces for each ring\n    for ring_name, ring_info in ring_params.items():\n        # Convert km to AU\n        inner_radius_au = ring_info['inner_radius_km'] / KM_PER_AU\n        outer_radius_au = ring_info['outer_radius_km'] / KM_PER_AU\n        thickness_au = ring_info['thickness_km'] / KM_PER_AU\n        \n        # Reduce point count for very large rings to improve performance\n        n_points = 100\n        if 'gossamer' in ring_name:\n            n_points = 80  # Fewer points for larger gossamer rings\n        \n        # Create ring points\n        x, y, z = create_ring_points_saturn (inner_radius_au, outer_radius_au, n_points, thickness_au)\n        \n        # Apply Saturn's axial tilt\n        # Rotation around the y-axis by saturn_tilt angle\n        x_tilted, y_tilted, z_tilted = rotate_points(x, y, z, saturn_tilt, 'x')\n\n        # Apply center position offset\n    #    x = np.array(x) + center_x\n    #    y = np.array(y) + center_y\n    #    z = np.array(z) + center_z\n\n        # Apply center position offset\n        x_final = np.array(x_tilted) + center_x\n        y_final = np.array(y_tilted) + center_y\n        z_final = np.array(z_tilted) + center_z\n        \n        # Create a text list for hover information\n        text_array = [ring_info['description'] for _ in range(len(x))]\n        \n        # Add ring trace\n        traces.append(\n            go.Scatter3d(\n    #            x=x, y=y, z=z,\n                x=x_final,\n                y=y_final,\n                z=z_final,\n                mode='markers',\n                marker=dict(\n                    size=1.5,  # Small markers for rings\n                    color=ring_info['color'],\n                    opacity=ring_info['opacity']\n                ),\n                name=f\"Saturn: {ring_info['name']}\",\n                text=text_array,\n                customdata=[f\"Saturn: {ring_info['name']}\"] * len(x),\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            )\n        )\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=480000 / KM_PER_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 943,
    "end_line": 1133,
    "has_docstring": true,
    "docstring": "Creates a visualization of Saturn's ring system.\n\nParameters:\n    center_position (tuple): (x, y, z) position of Saturn's center\n    \nReturns:\n    list: A list of plotly traces representing the ring components",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_saturn_ring_system",
    "component_id": "saturn_visualization_shells.create_saturn_ring_system"
  },
  "save_utils._get_initial_directory": {
    "id": "save_utils._get_initial_directory",
    "name": "_get_initial_directory",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\save_utils.py",
    "relative_path": "save_utils.py",
    "depends_on": [],
    "source_code": "def _get_initial_directory():\n    \"\"\"Get the initial directory for file dialogs.\n    \n    Returns the last used directory if available, otherwise Documents folder.\n    \"\"\"\n    global _last_save_directory\n    \n    if _last_save_directory and os.path.isdir(_last_save_directory):\n        return _last_save_directory\n    \n    # Default to Documents folder\n    if platform.system() == 'Windows':\n        docs = os.path.join(os.path.expanduser('~'), 'Documents')\n    elif platform.system() == 'Darwin':  # macOS\n        docs = os.path.join(os.path.expanduser('~'), 'Documents')\n    else:  # Linux\n        docs = os.path.expanduser('~')\n    \n    if os.path.isdir(docs):\n        return docs\n    return os.getcwd()",
    "start_line": 49,
    "end_line": 69,
    "has_docstring": true,
    "docstring": "Get the initial directory for file dialogs.\n\nReturns the last used directory if available, otherwise Documents folder.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _get_initial_directory",
    "component_id": "save_utils._get_initial_directory"
  },
  "save_utils._update_last_directory": {
    "id": "save_utils._update_last_directory",
    "name": "_update_last_directory",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\save_utils.py",
    "relative_path": "save_utils.py",
    "depends_on": [],
    "source_code": "def _update_last_directory(file_path):\n    \"\"\"Update the remembered directory based on a saved file path.\"\"\"\n    global _last_save_directory\n    if file_path:\n        _last_save_directory = os.path.dirname(file_path)",
    "start_line": 72,
    "end_line": 76,
    "has_docstring": true,
    "docstring": "Update the remembered directory based on a saved file path.",
    "parameters": [
      "file_path"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _update_last_directory",
    "component_id": "save_utils._update_last_directory"
  },
  "save_utils._is_main_thread": {
    "id": "save_utils._is_main_thread",
    "name": "_is_main_thread",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\save_utils.py",
    "relative_path": "save_utils.py",
    "depends_on": [],
    "source_code": "def _is_main_thread():\n    \"\"\"Check if we're running in the main thread.\"\"\"\n    return threading.current_thread() is threading.main_thread()",
    "start_line": 79,
    "end_line": 81,
    "has_docstring": true,
    "docstring": "Check if we're running in the main thread.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _is_main_thread",
    "component_id": "save_utils._is_main_thread"
  },
  "save_utils._is_macos": {
    "id": "save_utils._is_macos",
    "name": "_is_macos",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\save_utils.py",
    "relative_path": "save_utils.py",
    "depends_on": [],
    "source_code": "def _is_macos():\n    \"\"\"Check if we're running on macOS.\"\"\"\n    return platform.system() == 'Darwin'",
    "start_line": 84,
    "end_line": 86,
    "has_docstring": true,
    "docstring": "Check if we're running on macOS.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _is_macos",
    "component_id": "save_utils._is_macos"
  },
  "save_utils._write_html": {
    "id": "save_utils._write_html",
    "name": "_write_html",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\save_utils.py",
    "relative_path": "save_utils.py",
    "depends_on": [],
    "source_code": "def _write_html(fig, file_path, offline=False, auto_play=False):\n    \"\"\"Write HTML file with appropriate settings.\n    \n    Parameters:\n        fig: Plotly figure object\n        file_path: Output file path\n        offline: If True, embed Plotly.js (~5MB). If False, use CDN (~10KB)\n        auto_play: If True, start animations automatically\n    \"\"\"\n    include_plotlyjs = True if offline else 'cdn'\n    \n    fig.write_html(\n        file_path,\n        include_plotlyjs=include_plotlyjs,\n        auto_play=auto_play,\n        full_html=True,\n        config={'displayModeBar': True}\n    )",
    "start_line": 89,
    "end_line": 106,
    "has_docstring": true,
    "docstring": "Write HTML file with appropriate settings.\n\nParameters:\n    fig: Plotly figure object\n    file_path: Output file path\n    offline: If True, embed Plotly.js (~5MB). If False, use CDN (~10KB)\n    auto_play: If True, start animations automatically",
    "parameters": [
      "fig",
      "file_path",
      "offline",
      "auto_play"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _write_html",
    "component_id": "save_utils._write_html"
  },
  "save_utils.save_visualization": {
    "id": "save_utils.save_visualization",
    "name": "save_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\save_utils.py",
    "relative_path": "save_utils.py",
    "depends_on": [
      "save_utils._save_with_dialog",
      "save_utils._save_direct",
      "save_utils._save_temp_and_open"
    ],
    "source_code": "def save_visualization(fig, default_name, mode='dialog', output_path=None,\n                       offline=False, auto_play=False, open_browser=False):\n    \"\"\"\n    Unified save function for all Plotly visualizations.\n    \n    Parameters:\n        fig: Plotly figure object\n        default_name: Default filename without extension\n        mode: Save mode\n            - 'dialog': Show save dialog with format choice (default)\n            - 'direct': Save directly to output_path, no dialog\n            - 'temp': Save to temp file and open in browser (no permanent save)\n        output_path: For 'direct' mode, the output file path\n        offline: For 'direct' mode, whether to embed Plotly.js\n        auto_play: Whether to auto-play animations\n        open_browser: Whether to open the saved file in browser\n    \n    Returns:\n        str or None: Path to saved file, or None if cancelled/failed\n    \"\"\"\n    if mode == 'temp':\n        return _save_temp_and_open(fig, auto_play)\n    elif mode == 'direct':\n        return _save_direct(fig, output_path, offline, auto_play, open_browser)\n    else:  # mode == 'dialog'\n        return _save_with_dialog(fig, default_name, auto_play, open_browser)",
    "start_line": 109,
    "end_line": 134,
    "has_docstring": true,
    "docstring": "Unified save function for all Plotly visualizations.\n\nParameters:\n    fig: Plotly figure object\n    default_name: Default filename without extension\n    mode: Save mode\n        - 'dialog': Show save dialog with format choice (default)\n        - 'direct': Save directly to output_path, no dialog\n        - 'temp': Save to temp file and open in browser (no permanent save)\n    output_path: For 'direct' mode, the output file path\n    offline: For 'direct' mode, whether to embed Plotly.js\n    auto_play: Whether to auto-play animations\n    open_browser: Whether to open the saved file in browser\n\nReturns:\n    str or None: Path to saved file, or None if cancelled/failed",
    "parameters": [
      "fig",
      "default_name",
      "mode",
      "output_path",
      "offline",
      "auto_play",
      "open_browser"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function save_visualization",
    "component_id": "save_utils.save_visualization"
  },
  "save_utils._save_temp_and_open": {
    "id": "save_utils._save_temp_and_open",
    "name": "_save_temp_and_open",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\save_utils.py",
    "relative_path": "save_utils.py",
    "depends_on": [
      "save_utils._write_html"
    ],
    "source_code": "def _save_temp_and_open(fig, auto_play=False):\n    \"\"\"Save to temporary file and open in browser.\"\"\"\n    try:\n        with tempfile.NamedTemporaryFile(suffix='.html', delete=False, mode='w') as tmp:\n            temp_path = tmp.name\n        \n        # Use CDN for temp files (faster to create)\n        _write_html(fig, temp_path, offline=False, auto_play=auto_play)\n        webbrowser.open(f'file://{os.path.abspath(temp_path)}')\n        print(f\"Visualization opened in browser: {temp_path}\")\n        \n        # Schedule cleanup after delay\n        def cleanup():\n            try:\n                if os.path.exists(temp_path):\n                    os.unlink(temp_path)\n            except Exception as e:\n                print(f\"Note: Could not clean up temp file: {e}\")\n        \n        timer = threading.Timer(30.0, cleanup)\n        timer.daemon = True\n        timer.start()\n        \n        return temp_path\n        \n    except Exception as e:\n        print(f\"Error creating temporary visualization: {e}\")\n        return None",
    "start_line": 137,
    "end_line": 164,
    "has_docstring": true,
    "docstring": "Save to temporary file and open in browser.",
    "parameters": [
      "fig",
      "auto_play"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _save_temp_and_open",
    "component_id": "save_utils._save_temp_and_open"
  },
  "save_utils.cleanup": {
    "id": "save_utils.cleanup",
    "name": "cleanup",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\save_utils.py",
    "relative_path": "save_utils.py",
    "depends_on": [],
    "source_code": "            def cleanup():\n                try:\n                    if os.path.exists(temp_path):\n                        os.unlink(temp_path)\n                except:\n                    pass",
    "start_line": 398,
    "end_line": 403,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function cleanup",
    "component_id": "save_utils.cleanup"
  },
  "save_utils._save_direct": {
    "id": "save_utils._save_direct",
    "name": "_save_direct",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\save_utils.py",
    "relative_path": "save_utils.py",
    "depends_on": [
      "save_utils._write_html"
    ],
    "source_code": "def _save_direct(fig, output_path, offline=False, auto_play=False, open_browser=False):\n    \"\"\"Save directly to specified path without dialog.\"\"\"\n    if not output_path:\n        print(\"Error: output_path required for direct mode\")\n        return None\n    \n    try:\n        # Determine format from extension\n        ext = os.path.splitext(output_path)[1].lower()\n        \n        if ext == '.html':\n            _write_html(fig, output_path, offline=offline, auto_play=auto_play)\n            print(f\"Saved HTML to: {output_path}\")\n        elif ext in ['.png', '.jpg', '.jpeg', '.svg', '.pdf']:\n            fig.write_image(output_path)\n            print(f\"Saved image to: {output_path}\")\n        else:\n            # Default to HTML\n            if not output_path.endswith('.html'):\n                output_path += '.html'\n            _write_html(fig, output_path, offline=offline, auto_play=auto_play)\n            print(f\"Saved HTML to: {output_path}\")\n        \n        if open_browser and ext == '.html':\n            webbrowser.open(f'file://{os.path.abspath(output_path)}')\n        \n        return output_path\n        \n    except ImportError:\n        print(\"Error: kaleido package required for image export.\")\n        print(\"Install with: pip install kaleido\")\n        return None\n    except Exception as e:\n        print(f\"Error saving visualization: {e}\")\n        return None",
    "start_line": 167,
    "end_line": 201,
    "has_docstring": true,
    "docstring": "Save directly to specified path without dialog.",
    "parameters": [
      "fig",
      "output_path",
      "offline",
      "auto_play",
      "open_browser"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _save_direct",
    "component_id": "save_utils._save_direct"
  },
  "save_utils._save_with_dialog": {
    "id": "save_utils._save_with_dialog",
    "name": "_save_with_dialog",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\save_utils.py",
    "relative_path": "save_utils.py",
    "depends_on": [
      "save_utils._is_macos",
      "save_utils._is_main_thread",
      "save_utils._save_temp_and_open"
    ],
    "source_code": "def _save_with_dialog(fig, default_name, auto_play=False, open_browser=False):\n    \"\"\"Save with interactive dialog for format selection.\"\"\"\n    \n    # Check for macOS thread safety issue\n    if _is_macos() and not _is_main_thread():\n        print(\"Save dialog skipped (macOS thread safety)\")\n        print(\"Use File > Save As in your browser to save the visualization\")\n        return _save_temp_and_open(fig, auto_play)\n    \n    root = None\n    saved_path = None\n    \n    try:\n        # Create root window for dialogs\n        root = tk.Tk()\n        root.withdraw()\n        root.attributes('-topmost', True)\n        \n        # Ask if user wants to save\n        save_response = messagebox.askyesno(\n            \"Save Visualization\",\n            \"Would you like to save this visualization?\",\n            parent=root\n        )\n        \n        if not save_response:\n            print(\"User chose not to save\")\n            return None\n        \n        # Format selection dialog\n        format_window = tk.Toplevel(root)\n        format_window.title(\"Save Format\")\n        format_window.attributes('-topmost', True)\n        format_window.grab_set()\n        \n        # Center the window\n        format_window.geometry(\"350x200\")\n        format_window.resizable(False, False)\n        \n        # Variable to store selection\n        format_var = tk.StringVar(value=\"html_cdn\")\n        \n        tk.Label(format_window, text=\"Choose save format:\", \n                 font=('TkDefaultFont', 10, 'bold')).pack(pady=(15, 10))\n        \n        tk.Radiobutton(format_window, text=\"Interactive HTML - Standard (~10 KB, needs internet)\",\n                       variable=format_var, value=\"html_cdn\").pack(anchor='w', padx=20)\n        tk.Radiobutton(format_window, text=\"Interactive HTML - Offline (~5 MB, works anywhere)\",\n                       variable=format_var, value=\"html_offline\").pack(anchor='w', padx=20)\n        tk.Radiobutton(format_window, text=\"Static PNG image\",\n                       variable=format_var, value=\"png\").pack(anchor='w', padx=20)\n        \n        # Result holder\n        result = {'confirmed': False}\n        \n        def on_ok():\n            result['confirmed'] = True\n            format_window.destroy()\n        \n        def on_cancel():\n            format_window.destroy()\n        \n        button_frame = tk.Frame(format_window)\n        button_frame.pack(pady=20)\n        tk.Button(button_frame, text=\"OK\", command=on_ok, width=10).pack(side='left', padx=5)\n        tk.Button(button_frame, text=\"Cancel\", command=on_cancel, width=10).pack(side='left', padx=5)\n        \n        # Wait for dialog\n        format_window.wait_window()\n        \n        if not result['confirmed']:\n            print(\"User cancelled format selection\")\n            return None\n        \n        format_choice = format_var.get()\n        initial_dir = _get_initial_directory()\n        \n        # File save dialog based on format\n        if format_choice == \"png\":\n            file_path = filedialog.asksaveasfilename(\n                parent=root,\n                initialdir=initial_dir,\n                initialfile=f\"{default_name}.png\",\n                defaultextension=\".png\",\n                filetypes=[(\"PNG files\", \"*.png\")]\n            )\n            if file_path:\n                try:\n                    print(f\"Saving PNG to {file_path}...\")\n                    fig.write_image(file_path)\n                    print(\"PNG saved successfully.\")\n                    _update_last_directory(file_path)\n                    saved_path = file_path\n                except ImportError:\n                    messagebox.showerror(\n                        \"Missing Dependency\",\n                        \"The kaleido package is required for PNG export.\\n\"\n                        \"Install with: pip install kaleido\",\n                        parent=root\n                    )\n                except Exception as e:\n                    messagebox.showerror(\"Save Error\", f\"Error saving PNG:\\n{str(e)}\", parent=root)\n        \n        else:  # HTML (CDN or offline)\n            offline = (format_choice == \"html_offline\")\n            size_note = \"~5 MB, works offline\" if offline else \"~10 KB, needs internet\"\n            \n            file_path = filedialog.asksaveasfilename(\n                parent=root,\n                initialdir=initial_dir,\n                initialfile=f\"{default_name}.html\",\n                defaultextension=\".html\",\n                filetypes=[(\"HTML files\", \"*.html\")]\n            )\n            if file_path:\n                try:\n                    print(f\"Saving HTML ({size_note}) to {file_path}...\")\n                    _write_html(fig, file_path, offline=offline, auto_play=auto_play)\n                    print(\"HTML saved successfully.\")\n                    _update_last_directory(file_path)\n                    saved_path = file_path\n                    \n                    if open_browser:\n                        webbrowser.open(f'file://{os.path.abspath(file_path)}')\n                        \n                except Exception as e:\n                    messagebox.showerror(\"Save Error\", f\"Error saving HTML:\\n{str(e)}\", parent=root)\n        \n        return saved_path\n        \n    except Exception as e:\n        print(f\"Error during save operation: {e}\")\n        if root:\n            try:\n                messagebox.showerror(\"Save Error\", f\"An error occurred:\\n{str(e)}\", parent=root)\n            except:\n                pass\n        return None\n    \n    finally:\n        try:\n            if root:\n                root.destroy()\n        except:\n            pass",
    "start_line": 204,
    "end_line": 348,
    "has_docstring": true,
    "docstring": "Save with interactive dialog for format selection.",
    "parameters": [
      "fig",
      "default_name",
      "auto_play",
      "open_browser"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _save_with_dialog",
    "component_id": "save_utils._save_with_dialog"
  },
  "save_utils.on_ok": {
    "id": "save_utils.on_ok",
    "name": "on_ok",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\save_utils.py",
    "relative_path": "save_utils.py",
    "depends_on": [],
    "source_code": "        def on_ok():\n            result['confirmed'] = True\n            format_window.destroy()",
    "start_line": 259,
    "end_line": 261,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function on_ok",
    "component_id": "save_utils.on_ok"
  },
  "save_utils.on_cancel": {
    "id": "save_utils.on_cancel",
    "name": "on_cancel",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\save_utils.py",
    "relative_path": "save_utils.py",
    "depends_on": [],
    "source_code": "        def on_cancel():\n            format_window.destroy()",
    "start_line": 263,
    "end_line": 264,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function on_cancel",
    "component_id": "save_utils.on_cancel"
  },
  "save_utils.show_and_save": {
    "id": "save_utils.show_and_save",
    "name": "show_and_save",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\save_utils.py",
    "relative_path": "save_utils.py",
    "depends_on": [
      "save_utils._save_with_dialog",
      "save_utils._save_temp_and_open",
      "save_utils._is_macos",
      "save_utils._is_main_thread",
      "save_utils._write_html"
    ],
    "source_code": "def show_and_save(fig, default_name, auto_play=False):\n    \"\"\"\n    Show visualization in browser, then offer save dialog.\n    \n    This is the recommended function for GUI applications that want to\n    display the visualization immediately and optionally save it.\n    \n    Parameters:\n        fig: Plotly figure object\n        default_name: Default filename without extension\n        auto_play: Whether to auto-play animations\n    \n    Returns:\n        str or None: Path to saved file, or None if not saved\n    \"\"\"\n    # Check for macOS thread safety issue\n    if _is_macos() and not _is_main_thread():\n        print(\"Opening in browser (save dialog skipped for macOS thread safety)\")\n        print(\"Use File > Save As in your browser to save\")\n        return _save_temp_and_open(fig, auto_play)\n    \n    temp_path = None\n    root = None\n    \n    try:\n        # First, create and display temp file\n        with tempfile.NamedTemporaryFile(suffix='.html', delete=False, mode='w') as tmp:\n            temp_path = tmp.name\n        \n        _write_html(fig, temp_path, offline=False, auto_play=auto_play)\n        webbrowser.open(f'file://{os.path.abspath(temp_path)}')\n        print(\"Visualization opened in browser\")\n        \n        # Now offer save dialog\n        saved_path = _save_with_dialog(fig, default_name, auto_play, open_browser=False)\n        \n        return saved_path\n        \n    except Exception as e:\n        print(f\"Error during show_and_save: {e}\")\n        import traceback\n        traceback.print_exc()\n        return None\n    \n    finally:\n        # Schedule cleanup of temp file\n        if temp_path:\n            def cleanup():\n                try:\n                    if os.path.exists(temp_path):\n                        os.unlink(temp_path)\n                except:\n                    pass\n            \n            timer = threading.Timer(30.0, cleanup)\n            timer.daemon = True\n            timer.start()",
    "start_line": 351,
    "end_line": 407,
    "has_docstring": true,
    "docstring": "Show visualization in browser, then offer save dialog.\n\nThis is the recommended function for GUI applications that want to\ndisplay the visualization immediately and optionally save it.\n\nParameters:\n    fig: Plotly figure object\n    default_name: Default filename without extension\n    auto_play: Whether to auto-play animations\n\nReturns:\n    str or None: Path to saved file, or None if not saved",
    "parameters": [
      "fig",
      "default_name",
      "auto_play"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function show_and_save",
    "component_id": "save_utils.show_and_save"
  },
  "save_utils.save_plot": {
    "id": "save_utils.save_plot",
    "name": "save_plot",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\save_utils.py",
    "relative_path": "save_utils.py",
    "depends_on": [
      "save_utils.save_visualization"
    ],
    "source_code": "def save_plot(fig, default_name):\n    \"\"\"\n    Legacy function for backward compatibility.\n    \n    Equivalent to save_visualization(fig, default_name, mode='dialog')\n    \n    Parameters:\n        fig: Plotly figure object\n        default_name: Default filename without extension\n    \n    Returns:\n        bool: True if save was successful or user declined, False on error\n    \"\"\"\n    result = save_visualization(fig, default_name, mode='dialog')\n    # Return True if saved or user cancelled (not an error), False on error\n    return result is not None or result is None  # Always True for backward compat",
    "start_line": 415,
    "end_line": 430,
    "has_docstring": true,
    "docstring": "Legacy function for backward compatibility.\n\nEquivalent to save_visualization(fig, default_name, mode='dialog')\n\nParameters:\n    fig: Plotly figure object\n    default_name: Default filename without extension\n\nReturns:\n    bool: True if save was successful or user declined, False on error",
    "parameters": [
      "fig",
      "default_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function save_plot",
    "component_id": "save_utils.save_plot"
  },
  "save_utils.handle_save": {
    "id": "save_utils.handle_save",
    "name": "handle_save",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\save_utils.py",
    "relative_path": "save_utils.py",
    "depends_on": [
      "save_utils.save_visualization"
    ],
    "source_code": "def handle_save(fig, default_name):\n    \"\"\"\n    Legacy function for backward compatibility.\n    \n    Note: This function is deprecated. Use save_visualization() instead.\n    \"\"\"\n    save_visualization(fig, default_name, mode='dialog')",
    "start_line": 433,
    "end_line": 439,
    "has_docstring": true,
    "docstring": "Legacy function for backward compatibility.\n\nNote: This function is deprecated. Use save_visualization() instead.",
    "parameters": [
      "fig",
      "default_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function handle_save",
    "component_id": "save_utils.handle_save"
  },
  "save_utils.show_animation_safely": {
    "id": "save_utils.show_animation_safely",
    "name": "show_animation_safely",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\save_utils.py",
    "relative_path": "save_utils.py",
    "depends_on": [
      "save_utils.show_and_save"
    ],
    "source_code": "def show_animation_safely(fig, default_name):\n    \"\"\"\n    Show and optionally save an animation.\n    \n    This is a convenience wrapper for animations that sets auto_play=False\n    (letting the user control playback) and handles the show+save flow.\n    \n    Parameters:\n        fig: Plotly figure object with animation\n        default_name: Default filename without extension\n    \n    Returns:\n        str or None: Path to saved file, or None if not saved\n    \"\"\"\n    return show_and_save(fig, default_name, auto_play=False)",
    "start_line": 446,
    "end_line": 460,
    "has_docstring": true,
    "docstring": "Show and optionally save an animation.\n\nThis is a convenience wrapper for animations that sets auto_play=False\n(letting the user control playback) and handles the show+save flow.\n\nParameters:\n    fig: Plotly figure object with animation\n    default_name: Default filename without extension\n\nReturns:\n    str or None: Path to saved file, or None if not saved",
    "parameters": [
      "fig",
      "default_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function show_animation_safely",
    "component_id": "save_utils.show_animation_safely"
  },
  "save_utils.save_html": {
    "id": "save_utils.save_html",
    "name": "save_html",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\save_utils.py",
    "relative_path": "save_utils.py",
    "depends_on": [
      "save_utils.save_visualization"
    ],
    "source_code": "def save_html(fig, filename, offline=False, open_browser=True):\n    \"\"\"\n    Simple direct save for scripts that don't need dialogs.\n    \n    Parameters:\n        fig: Plotly figure object\n        filename: Output filename (will add .html if missing)\n        offline: If True, embed Plotly.js for offline viewing\n        open_browser: If True, open the file in browser after saving\n    \n    Returns:\n        str: Path to saved file\n    \n    Example:\n        from save_utils import save_html\n        fig = create_my_figure()\n        save_html(fig, \"my_output\", open_browser=True)\n    \"\"\"\n    if not filename.endswith('.html'):\n        filename += '.html'\n    \n    return save_visualization(\n        fig, \n        os.path.splitext(filename)[0],\n        mode='direct',\n        output_path=filename,\n        offline=offline,\n        open_browser=open_browser\n    )",
    "start_line": 467,
    "end_line": 495,
    "has_docstring": true,
    "docstring": "Simple direct save for scripts that don't need dialogs.\n\nParameters:\n    fig: Plotly figure object\n    filename: Output filename (will add .html if missing)\n    offline: If True, embed Plotly.js for offline viewing\n    open_browser: If True, open the file in browser after saving\n\nReturns:\n    str: Path to saved file\n\nExample:\n    from save_utils import save_html\n    fig = create_my_figure()\n    save_html(fig, \"my_output\", open_browser=True)",
    "parameters": [
      "fig",
      "filename",
      "offline",
      "open_browser"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function save_html",
    "component_id": "save_utils.save_html"
  },
  "sgr_a_grand_tour.generate_rosette_trace": {
    "id": "sgr_a_grand_tour.generate_rosette_trace",
    "name": "generate_rosette_trace",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_grand_tour.py",
    "relative_path": "sgr_a_grand_tour.py",
    "depends_on": [
      "sgr_a_star_data.get_star_data",
      "sgr_a_star_data.calculate_schwarzschild_precession_per_orbit",
      "sgr_a_visualization_core_arcs.generate_orbit_points"
    ],
    "source_code": "def generate_rosette_trace(star_name, num_orbits, points_per_orbit=80):\n    \"\"\"\n    Generate the relativistic spirograph trace for a star.\n    \n    The trace shows how the orbit precesses over many cycles,\n    creating Einstein's \"rosette\" pattern.\n    \"\"\"\n    star = data.get_star_data(star_name)\n    \n    # Calculate Schwarzschild precession rate\n    precession_deg_per_orbit = data.calculate_schwarzschild_precession_per_orbit(\n        star['a_au'], star['e']\n    )\n    \n    all_x, all_y, all_z = [], [], []\n    time_fractions = []\n    \n    for n in range(num_orbits):\n        # Each orbit is shifted by accumulated precession\n        accumulated_precession = n * precession_deg_per_orbit\n        \n        x, y, z = core.generate_orbit_points(\n            star,\n            num_points=points_per_orbit,\n            precession_offset_deg=accumulated_precession\n        )\n        \n        all_x.extend(x)\n        all_y.extend(y)\n        all_z.extend(z)\n        \n        # Normalize time 0.0 (now) -> 1.0 (far future)\n        time_fractions.extend([n / num_orbits] * len(x))\n    \n    total_precession = precession_deg_per_orbit * num_orbits\n    time_span_years = num_orbits * star['period_yrs']\n    \n    return (np.array(all_x), np.array(all_y), np.array(all_z),\n            np.array(time_fractions), precession_deg_per_orbit, \n            total_precession, time_span_years)",
    "start_line": 68,
    "end_line": 107,
    "has_docstring": true,
    "docstring": "Generate the relativistic spirograph trace for a star.\n\nThe trace shows how the orbit precesses over many cycles,\ncreating Einstein's \"rosette\" pattern.",
    "parameters": [
      "star_name",
      "num_orbits",
      "points_per_orbit"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate_rosette_trace",
    "component_id": "sgr_a_grand_tour.generate_rosette_trace"
  },
  "sgr_a_grand_tour.get_phase_offset": {
    "id": "sgr_a_grand_tour.get_phase_offset",
    "name": "get_phase_offset",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_grand_tour.py",
    "relative_path": "sgr_a_grand_tour.py",
    "depends_on": [],
    "source_code": "def get_phase_offset(star_data, reference_year=REFERENCE_YEAR):\n    \"\"\"\n    Calculate orbital phase offset from observed periapsis times.\n    \n    This ensures the animation shows stars at their ACTUAL positions\n    based on real astronomical observations, not arbitrary phases.\n    \n    The t_periapsis values come from:\n    - S2: GRAVITY Collaboration (2018.38 periapsis observed)\n    - S62: Peissker et al. (2003.33)\n    - S4711, S4714: Peissker et al. (2020)\n    \"\"\"\n    dt = reference_year - star_data['t_periapsis']\n    orbit_fraction = (dt % star_data['period_yrs']) / star_data['period_yrs']\n    return orbit_fraction * 2 * np.pi",
    "start_line": 109,
    "end_line": 123,
    "has_docstring": true,
    "docstring": "Calculate orbital phase offset from observed periapsis times.\n\nThis ensures the animation shows stars at their ACTUAL positions\nbased on real astronomical observations, not arbitrary phases.\n\nThe t_periapsis values come from:\n- S2: GRAVITY Collaboration (2018.38 periapsis observed)\n- S62: Peissker et al. (2003.33)\n- S4711, S4714: Peissker et al. (2020)",
    "parameters": [
      "star_data",
      "reference_year"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_phase_offset",
    "component_id": "sgr_a_grand_tour.get_phase_offset"
  },
  "sgr_a_grand_tour.get_current_position_info": {
    "id": "sgr_a_grand_tour.get_current_position_info",
    "name": "get_current_position_info",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_grand_tour.py",
    "relative_path": "sgr_a_grand_tour.py",
    "depends_on": [
      "sgr_a_star_data.get_star_data",
      "sgr_a_star_data.eccentric_to_true_anomaly",
      "sgr_a_star_data.calculate_orbital_velocity",
      "sgr_a_star_data.radius_from_true_anomaly",
      "sgr_a_star_data.solve_kepler_equation"
    ],
    "source_code": "def get_current_position_info(star_name, reference_year=REFERENCE_YEAR):\n    \"\"\"Get descriptive info about a star's current orbital position.\"\"\"\n    star = data.get_star_data(star_name)\n    \n    dt = reference_year - star['t_periapsis']\n    orbit_fraction = (dt % star['period_yrs']) / star['period_yrs']\n    \n    # Calculate actual position\n    M = orbit_fraction * 2 * np.pi\n    E = data.solve_kepler_equation(M, star['e'])\n    nu = data.eccentric_to_true_anomaly(E, star['e'])\n    r = data.radius_from_true_anomaly(star['a_au'], star['e'], nu)\n    v = data.calculate_orbital_velocity(star['a_au'], r)\n    \n    # Position description\n    if orbit_fraction < 0.1 or orbit_fraction > 0.9:\n        position = \"near periapsis\"\n    elif 0.4 < orbit_fraction < 0.6:\n        position = \"near apoapsis\"\n    elif orbit_fraction < 0.5:\n        position = \"outbound\"\n    else:\n        position = \"inbound\"\n    \n    return {\n        'distance': r,\n        'velocity': v,\n        'position': position,\n        'orbit_fraction': orbit_fraction\n    }",
    "start_line": 125,
    "end_line": 154,
    "has_docstring": true,
    "docstring": "Get descriptive info about a star's current orbital position.",
    "parameters": [
      "star_name",
      "reference_year"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_current_position_info",
    "component_id": "sgr_a_grand_tour.get_current_position_info"
  },
  "sgr_a_grand_tour.create_grand_tour_dashboard": {
    "id": "sgr_a_grand_tour.create_grand_tour_dashboard",
    "name": "create_grand_tour_dashboard",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_grand_tour.py",
    "relative_path": "sgr_a_grand_tour.py",
    "depends_on": [
      "sgr_a_visualization_core_arcs.generate_orbit_points",
      "sgr_a_grand_tour.get_current_position_info",
      "sgr_a_visualization_core_arcs.generate_position_at_true_anomaly",
      "sgr_a_star_data.get_star_data",
      "sgr_a_grand_tour.generate_rosette_trace",
      "sgr_a_star_data.get_star_color",
      "sgr_a_visualization_core_arcs.create_sgr_a_marker",
      "sgr_a_star_data.eccentric_to_true_anomaly",
      "sgr_a_grand_tour.get_phase_offset",
      "sgr_a_star_data.format_velocity",
      "sgr_a_star_data.get_orbit_color",
      "sgr_a_star_data.calculate_periapsis_velocity",
      "sgr_a_star_data.calculate_orbital_velocity",
      "sgr_a_star_data.solve_kepler_equation",
      "sgr_a_star_data.calculate_periapsis_au",
      "sgr_a_star_data.create_star_hover_text"
    ],
    "source_code": "def create_grand_tour_dashboard():\n    \"\"\"\n    Build the complete Grand Tour dashboard with unified color spectrum\n    and observationally faithful orbital positions.\n    \"\"\"\n    print(\"=\" * 70)\n    print(\"ASSEMBLING THE GRAND TOUR (FINAL - UNIFIED SPECTRUM EDITION)\")\n    print(\"=\" * 70)\n    print(f\"Reference year: {REFERENCE_YEAR}\")\n    print(f\"Featuring: {', '.join(STARS_TO_SHOW)}\")\n    print()\n    \n    # Report current positions\n    print(\"Current orbital positions (observationally derived):\")\n    for star_name in STARS_TO_SHOW:\n        info = get_current_position_info(star_name)\n        print(f\"  {star_name}: {info['distance']:.0f} AU, {info['position']}, {data.format_velocity(info['velocity'])}\")\n    print()\n    \n    fig = go.Figure()\n    \n    # Registry for visibility toggling\n    trace_registry = {\n        'sgr_a': [],        # Always visible\n        'dynamics': [],     # View 1: Animation mode\n        'relativity': []    # View 2: Rosette mode\n    }\n    \n    current_idx = 0\n    \n    # =========================================================================\n    # 1. SGR A* (The Monster at the Center)\n    # =========================================================================\n    print(\"Adding Sgr A*...\")\n    sgr_a_traces = core.create_sgr_a_marker(scale_factor=40)\n    for trace in sgr_a_traces:\n        fig.add_trace(trace)\n        trace_registry['sgr_a'].append(current_idx)\n        current_idx += 1\n    \n    # =========================================================================\n    # 2. VIEW 1: ORBITAL DYNAMICS (Keplerian Animation)\n    # =========================================================================\n    print(\"Building Dynamics View...\")\n    \n    for star_name in STARS_TO_SHOW:\n        star = data.get_star_data(star_name)\n        star_color = get_star_color(star)    # Temperature-based color for star marker\n        orbit_color = get_orbit_color(star)  # Distinct color for orbit trace and label\n        \n        # A. Static orbit ellipse (use orbit_color for readability)\n        x_orbit, y_orbit, z_orbit = core.generate_orbit_points(star)\n        fig.add_trace(go.Scatter3d(\n            x=x_orbit, y=y_orbit, z=z_orbit,\n            mode='lines',\n            line=dict(color=orbit_color, width=2),\n            name=f\"{star_name} Orbit\",\n            visible=True,\n            hoverinfo='name'\n        ))\n        trace_registry['dynamics'].append(current_idx)\n        current_idx += 1\n        \n        # B. Star marker at current position (from observations)\n        phase = get_phase_offset(star)\n        E = data.solve_kepler_equation(phase, star['e'])\n        nu = data.eccentric_to_true_anomaly(E, star['e'])\n        x_pos, y_pos, z_pos, r = core.generate_position_at_true_anomaly(star, nu)\n        v = data.calculate_orbital_velocity(star['a_au'], r)\n        \n        # Create rich hover text (like exoplanet host stars)\n        hover_text = create_star_hover_text(star_name, star, r, v)\n        \n        fig.add_trace(go.Scatter3d(\n            x=[x_pos], y=[y_pos], z=[z_pos],\n            mode='markers+text',\n            marker=dict(\n                size=10,\n                color=star_color,  # Temperature-based color for star\n                line=dict(color='white', width=2)\n            ),\n            text=[star_name],\n            textposition='top center',\n            textfont=dict(size=10, color=orbit_color),  # Label uses orbit color for readability\n            name=star_name,\n            visible=True,\n            hovertext=[hover_text],\n            hoverinfo='text'\n        ))\n        trace_registry['dynamics'].append(current_idx)\n        current_idx += 1\n    \n    # =========================================================================\n    # 3. VIEW 2: EINSTEIN'S LABORATORY (Relativistic Rosettes)\n    # =========================================================================\n    print(\"Building Relativity View (Unified Spectrum)...\")\n    \n    for star_name in STARS_TO_SHOW:\n        star = data.get_star_data(star_name)\n        n_orbits = ROSETTE_ORBIT_COUNTS.get(star_name, 40)\n        \n        print(f\"  {star_name}: {n_orbits} orbits...\")\n        x, y, z, t_vals, rate, total, time_span = generate_rosette_trace(\n            star_name, n_orbits, POINTS_PER_ORBIT\n        )\n        \n        fig.add_trace(go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='lines',\n            line=dict(\n                width=3,\n                color=t_vals,\n                colorscale=UNIFIED_ROSETTE_COLORSCALE,\n                showscale=False\n            ),\n            name=f\"{star_name} ({rate:.2f} deg/orbit)\",\n            visible=False,  # Hidden by default\n            hovertemplate=(\n                f\"<b>{star['name']} - Relativistic Rosette</b><br><br>\"\n                f\"<b>Schwarzschild Precession:</b><br>\"\n                f\"Orbits never close due to General Relativity.<br>\"\n                f\"Spacetime curvature near the black hole shifts<br>\"\n                f\"periapsis forward each orbit.<br><br>\"\n                f\"<b>What determines precession rate:</b><br>\"\n                f\"- Black hole mass (more mass = more curvature)<br>\"\n                f\"- How close the orbit gets (1/a dependence)<br>\"\n                f\"- Eccentricity (elongated orbits dip closer)<br><br>\"\n                f\"<b>This star:</b><br>\"\n                f\"Precession rate: {rate:.3f} deg/orbit<br>\"\n                f\"Total shown: {total:.1f} deg over {time_span:.0f} years<br><br>\"\n                f\"<b>Color:</b> Purple (now) to Yellow (future)<br>\"\n                f\"<extra></extra>\"\n            )\n        ))\n        trace_registry['relativity'].append(current_idx)\n        current_idx += 1\n    \n    total_traces = current_idx\n    \n    # =========================================================================\n    # 4. ANIMATION FRAMES (The \"Whoosh\")\n    # =========================================================================\n    print(f\"Generating {ANIMATION_FRAMES} animation frames...\")\n    \n    frames = []\n    mean_anomalies = np.linspace(0, 2*np.pi, ANIMATION_FRAMES, endpoint=False)\n    \n    # Identify marker trace indices (every 2nd trace in dynamics group)\n    marker_indices = [trace_registry['dynamics'][i] \n                      for i in range(1, len(trace_registry['dynamics']), 2)]\n    \n    for k, M_base in enumerate(mean_anomalies):\n        frame_data = []\n        \n        for star_name in STARS_TO_SHOW:\n            star = data.get_star_data(star_name)\n            \n            # Apply observationally-derived phase offset\n            phase = get_phase_offset(star)\n            M = (M_base + phase) % (2 * np.pi)\n            \n            # Solve Kepler's equation\n            E = data.solve_kepler_equation(M, star['e'])\n            nu = data.eccentric_to_true_anomaly(E, star['e'])\n            \n            # Get position and velocity\n            x, y, z, r = core.generate_position_at_true_anomaly(star, nu)\n            v = data.calculate_orbital_velocity(star['a_au'], r)\n            \n            # Temperature-based color for star marker, orbit color for label\n            star_color = get_star_color(star)\n            orbit_color = get_orbit_color(star)\n            \n            # Rich hover text (like exoplanet host stars)\n            hover_text = create_star_hover_text(star_name, star, r, v)\n            \n            frame_data.append(go.Scatter3d(\n                x=[x], y=[y], z=[z],\n                mode='markers+text',\n                marker=dict(\n                    size=10,\n                    color=star_color,\n                    line=dict(color='white', width=2)\n                ),\n                text=[star_name],\n                textposition='top center',\n                textfont=dict(size=10, color=orbit_color),\n                hovertext=[hover_text],\n                hoverinfo='text'\n            ))\n        \n        frames.append(go.Frame(\n            data=frame_data,\n            traces=marker_indices,\n            name=f\"fr{k}\"\n        ))\n    \n    fig.frames = frames\n    \n    # =========================================================================\n    # 4b. SPECIAL PERIAPSIS FRAMES (for zoom menu)\n    # =========================================================================\n    # Create a frame showing each star at its periapsis position\n    # Other stars shown at their relative positions at that moment\n    \n    print(\"Generating special periapsis frames...\")\n    \n    periapsis_frames = {}\n    \n    for target_star in STARS_TO_SHOW:\n        target_data = data.get_star_data(target_star)\n        \n        # Calculate M_base needed to put target star at periapsis (M=0 for target)\n        # Since M = M_base + phase_offset, we need M_base = -phase_offset\n        target_phase = get_phase_offset(target_data)\n        M_base_for_periapsis = (2 * np.pi - target_phase) % (2 * np.pi)\n        \n        frame_data = []\n        \n        for star_name in STARS_TO_SHOW:\n            star = data.get_star_data(star_name)\n            \n            # Apply phase offset\n            phase = get_phase_offset(star)\n            M = (M_base_for_periapsis + phase) % (2 * np.pi)\n            \n            # Solve Kepler's equation\n            E = data.solve_kepler_equation(M, star['e'])\n            nu = data.eccentric_to_true_anomaly(E, star['e'])\n            \n            # Get position and velocity\n            x, y, z, r = core.generate_position_at_true_anomaly(star, nu)\n            v = data.calculate_orbital_velocity(star['a_au'], r)\n            \n            # Temperature-based color for star marker, orbit color for label\n            star_color = get_star_color(star)\n            orbit_color = get_orbit_color(star)\n            \n            # Rich hover text\n            hover_text = create_star_hover_text(star_name, star, r, v)\n            \n            frame_data.append(go.Scatter3d(\n                x=[x], y=[y], z=[z],\n                mode='markers+text',\n                marker=dict(\n                    size=10,\n                    color=star_color,\n                    line=dict(color='white', width=2)\n                ),\n                text=[star_name],\n                textposition='top center',\n                textfont=dict(size=10, color=orbit_color),\n                hovertext=[hover_text],\n                hoverinfo='text'\n            ))\n        \n        frame_name = f\"peri_{target_star}\"\n        periapsis_frames[target_star] = frame_name\n        \n        frames.append(go.Frame(\n            data=frame_data,\n            traces=marker_indices,\n            name=frame_name\n        ))\n        \n        # Calculate periapsis distance and velocity for this star\n        peri_dist = data.calculate_periapsis_au(target_data['a_au'], target_data['e'])\n        peri_vel = data.calculate_periapsis_velocity(target_data['a_au'], target_data['e'])\n        print(f\"  {target_star}: periapsis frame '{frame_name}' - {peri_dist:.1f} AU, {data.format_velocity(peri_vel)}\")\n    \n    # Update frames with periapsis frames added\n    fig.frames = frames\n    \n    # =========================================================================\n    # 5. VISIBILITY ARRAYS FOR MODE SWITCHING\n    # =========================================================================\n    \n    def get_visibility_array(mode):\n        \"\"\"Generate visibility array for a given view mode.\"\"\"\n        vis = [False] * total_traces\n        # Always show Sgr A*\n        for i in trace_registry['sgr_a']:\n            vis[i] = True\n        # Show mode-specific traces\n        for i in trace_registry[mode]:\n            vis[i] = True\n        return vis\n    \n    # =========================================================================\n    # 6. UI CONTROLS\n    # =========================================================================\n    \n    updatemenus = [\n        # VIEW SWITCHER (Top-left dropdown)\n        dict(\n            type=\"dropdown\",\n            direction=\"down\",\n            x=0.01,\n            y=0.99,\n            xanchor=\"left\",\n            yanchor=\"top\",\n            bgcolor='rgba(20,20,40,0.9)',\n            bordercolor='#FFD700',\n            borderwidth=1,\n            font=dict(color='white', size=11),\n            showactive=False,  # Disable white highlight on active selection\n            buttons=[\n                dict(\n                    label=\"View: Orbital Dynamics (Animation)\",\n                    method=\"update\",\n                    args=[\n                        {\"visible\": get_visibility_array('dynamics')},\n                        {\"title\": dict(\n                            text=\"<b>Galactic Center: Orbital Dynamics</b><br>\"\n                                 \"<sup>Keplerian Motion - Watch the 'whoosh' at periapsis!</sup>\",\n                            x=0.5\n                        )}\n                    ]\n                ),\n                dict(\n                    label=\"View: Einstein's Laboratory (Rosette)\",\n                    method=\"update\",\n                    args=[\n                        {\"visible\": get_visibility_array('relativity')},\n                        {\"title\": dict(\n                            text=\"<b>Galactic Center: Einstein's Laboratory</b><br>\"\n                                 \"<sup>Schwarzschild Precession - Unified Time Spectrum</sup>\",\n                            x=0.5\n                        )}\n                    ]\n                )\n            ]\n        ),\n        \n        # ANIMATION CONTROLS (Bottom center)\n        dict(\n            type=\"buttons\",\n            direction=\"left\",\n            x=0.5,\n            y=-0.08,\n            xanchor=\"center\",\n            bgcolor='rgba(20,20,40,0.9)',\n            bordercolor='#FFD700',\n            borderwidth=1,\n            font=dict(color='white'),\n            showactive=False,  # Disable white highlight on active selection\n            buttons=[\n                dict(\n                    label=\"Play\",\n                    method=\"animate\",\n                    args=[\n                        None,\n                        dict(\n                            frame=dict(duration=20, redraw=True),\n                            fromcurrent=True,\n                            mode='immediate',\n                            transition=dict(duration=0)\n                        )\n                    ]\n                ),\n                dict(\n                    label=\"Pause\",\n                    method=\"animate\",\n                    args=[\n                        [None],\n                        dict(\n                            frame=dict(duration=0, redraw=True),\n                            mode=\"immediate\"\n                        )\n                    ]\n                )\n            ]\n        ),\n        \n        # JUMP TO EVENT (Bottom-right dropdown)\n        dict(\n            type=\"dropdown\",\n            direction=\"up\",\n            x=0.99,\n            y=-0.08,\n            xanchor=\"right\",\n            bgcolor='rgba(50,20,20,0.9)',\n            bordercolor='#FFD700',\n            borderwidth=1,\n            font=dict(color='white', size=10),\n            showactive=False,  # Disable white highlight on active selection\n            buttons=[\n                dict(\n                    label=\"Zoom to Region...\",\n                    method=\"skip\",\n                    args=[\"None\"]\n                ),\n                dict(\n                    label=\"Sgr A* Black Hole (4x zoom)\",\n                    method=\"relayout\",\n                    args=[{\n                        \"scene.camera.eye\": dict(x=0.3125, y=0.3125, z=0.3125),\n                        \"scene.xaxis.range\": [-100, 100],\n                        \"scene.yaxis.range\": [-100, 100],\n                        \"scene.zaxis.range\": [-100, 100]\n                    }]\n                ),\n                dict(\n                    label=\"S4714 at Periapsis (12 AU, 8% c)\",\n                    method=\"animate\",\n                    args=[\n                        [\"peri_S4714\"],\n                        {\n                            \"mode\": \"immediate\",\n                            \"frame\": {\"duration\": 0, \"redraw\": True},\n                            \"transition\": {\"duration\": 0}\n                        }\n                    ]\n                ),\n                dict(\n                    label=\"S62 at Periapsis (18 AU, 6.7% c)\",\n                    method=\"animate\",\n                    args=[\n                        [\"peri_S62\"],\n                        {\n                            \"mode\": \"immediate\",\n                            \"frame\": {\"duration\": 0, \"redraw\": True},\n                            \"transition\": {\"duration\": 0}\n                        }\n                    ]\n                ),\n                dict(\n                    label=\"S2 at Periapsis (120 AU, 2.5% c)\",\n                    method=\"animate\",\n                    args=[\n                        [\"peri_S2\"],\n                        {\n                            \"mode\": \"immediate\",\n                            \"frame\": {\"duration\": 0, \"redraw\": True},\n                            \"transition\": {\"duration\": 0}\n                        }\n                    ]\n                ),\n                dict(\n                    label=\"S4711 at Periapsis (133 AU, 4.5% c)\",\n                    method=\"animate\",\n                    args=[\n                        [\"peri_S4711\"],\n                        {\n                            \"mode\": \"immediate\",\n                            \"frame\": {\"duration\": 0, \"redraw\": True},\n                            \"transition\": {\"duration\": 0}\n                        }\n                    ]\n                ),\n                dict(\n                    label=\"Zoom: +/-50 AU (S4714, S62)\",\n                    method=\"relayout\",\n                    args=[{\n                        \"scene.camera.eye\": dict(x=1.25, y=1.25, z=1.25),\n                        \"scene.xaxis.range\": [-50, 50],\n                        \"scene.yaxis.range\": [-50, 50],\n                        \"scene.zaxis.range\": [-50, 50]\n                    }]\n                ),\n                dict(\n                    label=\"Zoom: +/-100 AU (S2)\",\n                    method=\"relayout\",\n                    args=[{\n                        \"scene.camera.eye\": dict(x=1.25, y=1.25, z=1.25),\n                        \"scene.xaxis.range\": [-100, 100],\n                        \"scene.yaxis.range\": [-100, 100],\n                        \"scene.zaxis.range\": [-100, 100]\n                    }]\n                ),\n                dict(\n                    label=\"Zoom: +/-150 AU (S4711)\",\n                    method=\"relayout\",\n                    args=[{\n                        \"scene.camera.eye\": dict(x=1.25, y=1.25, z=1.25),\n                        \"scene.xaxis.range\": [-150, 150],\n                        \"scene.yaxis.range\": [-150, 150],\n                        \"scene.zaxis.range\": [-150, 150]\n                    }]\n                ),\n                dict(\n                    label=\"Full System View\",\n                    method=\"relayout\",\n                    args=[{\n                        \"scene.camera.eye\": dict(x=1.25, y=1.25, z=1.25),\n                        \"scene.xaxis.autorange\": True,\n                        \"scene.yaxis.autorange\": True,\n                        \"scene.zaxis.autorange\": True\n                    }]\n                )\n            ]\n        )\n    ]\n    \n    # Animation slider\n    sliders = [dict(\n        active=0,\n        yanchor=\"top\",\n        y=-0.12,\n        xanchor=\"left\",\n        x=0.1,\n        len=0.8,\n        pad=dict(b=10, t=30),\n        bgcolor='rgba(30,30,50,0.5)',\n        font=dict(color='white', size=9),\n        currentvalue=dict(\n            font=dict(size=11, color='white'),\n            prefix=\"Orbital Phase: \",\n            suffix=\" deg\",\n            visible=True,\n            xanchor=\"center\"\n        ),\n        steps=[\n            dict(\n                method='animate',\n                args=[\n                    [f'fr{k}'],\n                    dict(\n                        mode='immediate',\n                        frame=dict(duration=0, redraw=True),\n                        transition=dict(duration=0)\n                    )\n                ],\n                label=f'{int(k * 360 / ANIMATION_FRAMES)}'\n            )\n            for k in range(ANIMATION_FRAMES)\n        ]\n    )]\n    \n    # =========================================================================\n    # 7. LAYOUT\n    # =========================================================================\n    \n    # Calculate axis range\n    max_range = 0\n    for star_name in STARS_TO_SHOW:\n        star = data.get_star_data(star_name)\n        apoapsis = data.calculate_apoapsis_au(star['a_au'], star['e'])\n        max_range = max(max_range, apoapsis)\n    axis_range = max_range * 1.1\n    \n    fig.update_layout(\n        title=dict(\n            text=\"<b>Galactic Center: Grand Tour</b><br>\"\n                 \"<sup>S-Stars Orbiting Sagittarius A* - Positions as of 2025</sup>\",\n            x=0.5,\n            font=dict(size=16, color='white')\n        ),\n        scene=dict(\n            xaxis=dict(\n                title='X (AU)',\n                range=[-axis_range, axis_range],\n                backgroundcolor='rgb(8,8,18)',\n                gridcolor='rgb(35,35,55)',\n                showbackground=True\n            ),\n            yaxis=dict(\n                title='Y (AU)',\n                range=[-axis_range, axis_range],\n                backgroundcolor='rgb(8,8,18)',\n                gridcolor='rgb(35,35,55)',\n                showbackground=True\n            ),\n            zaxis=dict(\n                title='Z (AU)',\n                range=[-axis_range, axis_range],\n                backgroundcolor='rgb(8,8,18)',\n                gridcolor='rgb(35,35,55)',\n                showbackground=True\n            ),\n            aspectmode='cube',\n            camera=dict(\n                eye=dict(x=1.2, y=1.2, z=0.6)\n            )\n        ),\n        paper_bgcolor='rgb(8,8,18)',\n        plot_bgcolor='rgb(8,8,18)',\n        font=dict(color='white'),\n        legend=dict(\n            yanchor=\"top\",\n            y=0.85,\n            xanchor=\"left\",\n            x=0.01,\n            bgcolor='rgba(0,0,0,0.6)',\n            font=dict(size=10)\n        ),\n        margin=dict(l=0, r=0, t=80, b=130),\n        updatemenus=updatemenus,\n        sliders=sliders,\n        # Start with animation paused\n        transition=dict(duration=0),\n    )\n    \n    # Explicitly set to first frame without playing\n    fig.update(frames=fig.frames)\n    \n    # Annotations - Note: \"Unified Time Spectrum\" only applies to Einstein's Laboratory view\n    # so we don't add it as a global annotation (it's shown in the view title instead)\n    \n    # Top annotation - what we're showing\n    fig.add_annotation(\n        text=\"Four representative S-stars from the ~50 known stars with measured orbits around Sgr A*\",\n        xref=\"paper\", yref=\"paper\",\n        x=0.5, y=0.92,\n        showarrow=False,\n        font=dict(size=10, color='white'),\n        opacity=0.9\n    )\n    \n    # Animation explanation (left side, white text)\n    fig.add_annotation(\n        text=\"Animation cycles orbits by phase angle (asynchronous) | Each star completes one orbit per cycle<br>\"\n            \"Actual positions in time shown for 2025 and for periapsis (Zoom menu)<br>\"\n            \"About 50 S-stars have measured orbits | Stars shown here are in stable orbits<br>\"\n             \"Toggle off 'Sgr A* (Black Hole)' to see actual-scale object illustrated as a \\\"red\\\" sphere<br>\"\n             \"Data: GRAVITY Collaboration, Peissker et al. | Visualization: Paloma's Orrery\"        ,\n        xref=\"paper\", yref=\"paper\",\n        x=0.01, y=-0.2,\n        xanchor=\"left\",\n        showarrow=False,\n        font=dict(size=9, color='white'),\n        align=\"left\"\n    )\n    \n    # Source attribution and S-star context (left side, white text)\n    # Positioned higher to avoid being covered by slider\n#    fig.add_annotation(\n#        text=\"~50 S-stars have measured orbits; all shown here are in stable orbits | \"\n#             \"Toggle off 'Sgr A* (Black Hole)' to see actual-scale red sphere<br>\"\n#             \"Data: GRAVITY Collaboration, Peissker et al. | Visualization: Paloma's Orrery\",\n#        xref=\"paper\", yref=\"paper\",\n#        x=0.01, y=-0.15,\n#        xanchor=\"left\",\n#        showarrow=False,\n#        font=dict(size=8, color='white'),\n#        align=\"left\"\n#    )\n    \n    print(\"\\nDashboard assembly complete!\")\n    return fig",
    "start_line": 160,
    "end_line": 799,
    "has_docstring": true,
    "docstring": "Build the complete Grand Tour dashboard with unified color spectrum\nand observationally faithful orbital positions.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_grand_tour_dashboard",
    "component_id": "sgr_a_grand_tour.create_grand_tour_dashboard"
  },
  "sgr_a_grand_tour.get_visibility_array": {
    "id": "sgr_a_grand_tour.get_visibility_array",
    "name": "get_visibility_array",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_grand_tour.py",
    "relative_path": "sgr_a_grand_tour.py",
    "depends_on": [],
    "source_code": "    def get_visibility_array(mode):\n        \"\"\"Generate visibility array for a given view mode.\"\"\"\n        vis = [False] * total_traces\n        # Always show Sgr A*\n        for i in trace_registry['sgr_a']:\n            vis[i] = True\n        # Show mode-specific traces\n        for i in trace_registry[mode]:\n            vis[i] = True\n        return vis",
    "start_line": 437,
    "end_line": 446,
    "has_docstring": true,
    "docstring": "Generate visibility array for a given view mode.",
    "parameters": [
      "mode"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_visibility_array",
    "component_id": "sgr_a_grand_tour.get_visibility_array"
  },
  "sgr_a_star_data.estimate_temperature_fallback": {
    "id": "sgr_a_star_data.estimate_temperature_fallback",
    "name": "estimate_temperature_fallback",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [],
    "source_code": "def estimate_temperature_fallback(spectral_type):\n    \"\"\"\n    Fallback temperature estimation for B-type stars.\n    Used when stellar_parameters module is not available.\n    \"\"\"\n    if spectral_type is None:\n        return 20000  # Default for B-type\n    \n    sp = spectral_type.upper().strip()\n    \n    # Try exact match first\n    for key in B_STAR_TEMPERATURES:\n        if sp.startswith(key):\n            return B_STAR_TEMPERATURES[key]\n    \n    # Handle ranges like \"B0-2V\"\n    match = re.match(r'B(\\d)', sp)\n    if match:\n        subclass = int(match.group(1))\n        return B_STAR_TEMPERATURES.get(f'B{subclass}', 20000)\n    \n    return 20000  # Default B-type temperature",
    "start_line": 52,
    "end_line": 73,
    "has_docstring": true,
    "docstring": "Fallback temperature estimation for B-type stars.\nUsed when stellar_parameters module is not available.",
    "parameters": [
      "spectral_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function estimate_temperature_fallback",
    "component_id": "sgr_a_star_data.estimate_temperature_fallback"
  },
  "sgr_a_star_data.get_temperature_color_fallback": {
    "id": "sgr_a_star_data.get_temperature_color_fallback",
    "name": "get_temperature_color_fallback",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [],
    "source_code": "def get_temperature_color_fallback(temperature_k):\n    \"\"\"\n    Fallback temperature-to-color conversion.\n    Uses simplified blackbody color approximation.\n    \"\"\"\n    if temperature_k is None or np.isnan(temperature_k):\n        return 'rgb(180, 180, 255)'  # Default blue-white\n    \n    # B-type stars (10,000-30,000 K) are blue to blue-white\n    if temperature_k >= 30000:\n        return 'rgb(155, 176, 255)'  # Deep blue-white (O-type)\n    elif temperature_k >= 20000:\n        return 'rgb(170, 191, 255)'  # Blue-white (early B)\n    elif temperature_k >= 15000:\n        return 'rgb(185, 206, 255)'  # Light blue-white (mid B)\n    elif temperature_k >= 10000:\n        return 'rgb(200, 220, 255)'  # Pale blue-white (late B)\n    else:\n        return 'rgb(220, 235, 255)'  # Nearly white",
    "start_line": 76,
    "end_line": 94,
    "has_docstring": true,
    "docstring": "Fallback temperature-to-color conversion.\nUses simplified blackbody color approximation.",
    "parameters": [
      "temperature_k"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_temperature_color_fallback",
    "component_id": "sgr_a_star_data.get_temperature_color_fallback"
  },
  "sgr_a_star_data.get_star_temperature": {
    "id": "sgr_a_star_data.get_star_temperature",
    "name": "get_star_temperature",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [
      "sgr_a_star_data.estimate_temperature_fallback",
      "stellar_parameters.estimate_temperature_from_spectral_type"
    ],
    "source_code": "def get_star_temperature(star_data):\n    \"\"\"\n    Get temperature for a star, using best available method.\n    \"\"\"\n    spectral_type = star_data.get('spectral_type', 'B')\n    \n    if STELLAR_PROPS_AVAILABLE:\n        temp = estimate_temperature_from_spectral_type(spectral_type)\n        if not np.isnan(temp):\n            return temp\n    \n    return estimate_temperature_fallback(spectral_type)",
    "start_line": 97,
    "end_line": 108,
    "has_docstring": true,
    "docstring": "Get temperature for a star, using best available method.",
    "parameters": [
      "star_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_star_temperature",
    "component_id": "sgr_a_star_data.get_star_temperature"
  },
  "sgr_a_star_data.get_star_color": {
    "id": "sgr_a_star_data.get_star_color",
    "name": "get_star_color",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [
      "exoplanet_stellar_properties.get_temperature_color",
      "sgr_a_star_data.get_star_temperature",
      "sgr_a_star_data.get_temperature_color_fallback"
    ],
    "source_code": "def get_star_color(star_data):\n    \"\"\"\n    Get display color for a star based on its temperature.\n    Uses blackbody colors consistent with exoplanet host stars.\n    \"\"\"\n    temperature = get_star_temperature(star_data)\n    \n    if STELLAR_PROPS_AVAILABLE:\n        return get_temperature_color(temperature)\n    \n    return get_temperature_color_fallback(temperature)",
    "start_line": 111,
    "end_line": 121,
    "has_docstring": true,
    "docstring": "Get display color for a star based on its temperature.\nUses blackbody colors consistent with exoplanet host stars.",
    "parameters": [
      "star_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_star_color",
    "component_id": "sgr_a_star_data.get_star_color"
  },
  "sgr_a_star_data.get_orbit_color": {
    "id": "sgr_a_star_data.get_orbit_color",
    "name": "get_orbit_color",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [],
    "source_code": "def get_orbit_color(star_data):\n    \"\"\"\n    Get distinct color for orbit trace and labels.\n    Separate from star marker color for better readability.\n    \"\"\"\n    return star_data.get('orbit_color', star_data.get('color', '#FFFFFF'))",
    "start_line": 124,
    "end_line": 129,
    "has_docstring": true,
    "docstring": "Get distinct color for orbit trace and labels.\nSeparate from star marker color for better readability.",
    "parameters": [
      "star_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_orbit_color",
    "component_id": "sgr_a_star_data.get_orbit_color"
  },
  "sgr_a_star_data.get_star_data": {
    "id": "sgr_a_star_data.get_star_data",
    "name": "get_star_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [],
    "source_code": "def get_star_data(star_name):\n    \"\"\"Returns the dictionary for a specific star.\"\"\"\n    return S_STAR_CATALOG.get(star_name)",
    "start_line": 249,
    "end_line": 251,
    "has_docstring": true,
    "docstring": "Returns the dictionary for a specific star.",
    "parameters": [
      "star_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_star_data",
    "component_id": "sgr_a_star_data.get_star_data"
  },
  "sgr_a_star_data.list_stars": {
    "id": "sgr_a_star_data.list_stars",
    "name": "list_stars",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [],
    "source_code": "def list_stars():\n    \"\"\"Returns list of available star keys.\"\"\"\n    return list(S_STAR_CATALOG.keys())",
    "start_line": 253,
    "end_line": 255,
    "has_docstring": true,
    "docstring": "Returns list of available star keys.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function list_stars",
    "component_id": "sgr_a_star_data.list_stars"
  },
  "sgr_a_star_data.get_all_stars": {
    "id": "sgr_a_star_data.get_all_stars",
    "name": "get_all_stars",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [],
    "source_code": "def get_all_stars():\n    \"\"\"Returns the complete catalog dictionary.\"\"\"\n    return S_STAR_CATALOG",
    "start_line": 257,
    "end_line": 259,
    "has_docstring": true,
    "docstring": "Returns the complete catalog dictionary.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_all_stars",
    "component_id": "sgr_a_star_data.get_all_stars"
  },
  "sgr_a_star_data.get_spectral_class_description": {
    "id": "sgr_a_star_data.get_spectral_class_description",
    "name": "get_spectral_class_description",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [],
    "source_code": "def get_spectral_class_description(spectral_type):\n    \"\"\"Get human-readable description of spectral type.\"\"\"\n    if spectral_type is None:\n        return \"Unknown\"\n    \n    sp = spectral_type.upper()\n    \n    # Luminosity class descriptions\n    if 'V' in sp:\n        lum_class = \"Main-sequence\"\n    elif 'III' in sp:\n        lum_class = \"Giant\"\n    elif 'I' in sp:\n        lum_class = \"Supergiant\"\n    else:\n        lum_class = \"Main-sequence\"  # Assume MS for S-stars\n    \n    # Spectral type descriptions\n    if sp.startswith('O'):\n        type_desc = \"Blue supergiant\"\n    elif sp.startswith('B0') or sp.startswith('B1') or sp.startswith('B2'):\n        type_desc = \"Early B-type (hot blue)\"\n    elif sp.startswith('B'):\n        type_desc = \"B-type (blue-white)\"\n    else:\n        type_desc = \"Unknown type\"\n    \n    return f\"{type_desc}, {lum_class}\"",
    "start_line": 265,
    "end_line": 292,
    "has_docstring": true,
    "docstring": "Get human-readable description of spectral type.",
    "parameters": [
      "spectral_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_spectral_class_description",
    "component_id": "sgr_a_star_data.get_spectral_class_description"
  },
  "sgr_a_star_data.calculate_next_periapsis": {
    "id": "sgr_a_star_data.calculate_next_periapsis",
    "name": "calculate_next_periapsis",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [],
    "source_code": "def calculate_next_periapsis(star_data, reference_year=2025):\n    \"\"\"\n    Calculate the next periapsis passage date for a star.\n    \n    Args:\n        star_data: Star data dictionary with t_periapsis and period_yrs\n        reference_year: Current reference year\n        \n    Returns:\n        float: Year of next periapsis\n    \"\"\"\n    t_peri = star_data['t_periapsis']\n    period = star_data['period_yrs']\n    \n    # Find next periapsis after reference year\n    next_peri = t_peri\n    while next_peri < reference_year:\n        next_peri += period\n    \n    return next_peri",
    "start_line": 295,
    "end_line": 314,
    "has_docstring": true,
    "docstring": "Calculate the next periapsis passage date for a star.\n\nArgs:\n    star_data: Star data dictionary with t_periapsis and period_yrs\n    reference_year: Current reference year\n    \nReturns:\n    float: Year of next periapsis",
    "parameters": [
      "star_data",
      "reference_year"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_next_periapsis",
    "component_id": "sgr_a_star_data.calculate_next_periapsis"
  },
  "sgr_a_star_data.create_star_hover_text": {
    "id": "sgr_a_star_data.create_star_hover_text",
    "name": "create_star_hover_text",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [
      "sgr_a_star_data.get_star_temperature",
      "sgr_a_star_data.get_spectral_class_description",
      "sgr_a_star_data.calculate_apoapsis_au",
      "sgr_a_star_data.format_velocity",
      "sgr_a_star_data.calculate_periapsis_velocity",
      "sgr_a_star_data.calculate_next_periapsis",
      "sgr_a_star_data.calculate_periapsis_au"
    ],
    "source_code": "def create_star_hover_text(star_name, star_data, current_distance_au=None, current_velocity_km_s=None):\n    \"\"\"\n    Create rich hover text for S-star markers.\n    \n    Matches the style and information density of exoplanet host star hovers.\n    \n    Args:\n        star_name: Key from catalog\n        star_data: Star data dictionary\n        current_distance_au: Current distance from Sgr A* (optional)\n        current_velocity_km_s: Current orbital velocity (optional)\n        \n    Returns:\n        str: HTML-formatted hover text\n    \"\"\"\n    # Header\n    hover = f\"<b>{star_data['name']}</b><br><br>\"\n    \n    # Temperature and spectral type\n    temperature = get_star_temperature(star_data)\n    spectral_type = star_data.get('spectral_type', 'B')\n    hover += f\"Temperature: {temperature:,.0f} K<br>\"\n    hover += f\"Spectral Type: {spectral_type}<br>\"\n    hover += f\"Classification: {get_spectral_class_description(spectral_type)}<br>\"\n    \n    # Physical properties\n    mass = star_data.get('mass_solar')\n    if mass:\n        hover += f\"Mass: {mass:.1f} M_sun<br>\"\n    \n    hover += \"<br>\"\n    \n    # Orbital properties\n    hover += f\"<b>Orbit around Sgr A*:</b><br>\"\n    hover += f\"Period: {star_data['period_yrs']:.1f} years<br>\"\n    hover += f\"Semi-major axis: {star_data['a_au']:,.0f} AU<br>\"\n    hover += f\"Eccentricity: {star_data['e']:.4f}<br>\"\n    \n    # Periapsis/apoapsis\n    periapsis = calculate_periapsis_au(star_data['a_au'], star_data['e'])\n    apoapsis = calculate_apoapsis_au(star_data['a_au'], star_data['e'])\n    hover += f\"Periapsis: {periapsis:.1f} AU<br>\"\n    hover += f\"Apoapsis: {apoapsis:,.0f} AU<br>\"\n    \n    # Next periapsis\n    next_peri = calculate_next_periapsis(star_data)\n    hover += f\"Next periapsis: ~{next_peri:.1f}<br>\"\n    \n    # Current state (if provided)\n    if current_distance_au is not None and current_velocity_km_s is not None:\n        hover += \"<br>\"\n        hover += f\"<b>Current State:</b><br>\"\n        hover += f\"Distance: {current_distance_au:.1f} AU<br>\"\n        hover += f\"Velocity: {format_velocity(current_velocity_km_s)}<br>\"\n    \n    # Maximum velocity (at periapsis)\n    v_peri = calculate_periapsis_velocity(star_data['a_au'], star_data['e'])\n    hover += \"<br>\"\n    hover += f\"<b>Max velocity (periapsis):</b><br>\"\n    hover += f\"{format_velocity(v_peri)}<br>\"\n    \n    # Notes with squeezar explanation\n    notes = star_data.get('notes', '')\n    if notes:\n        # Expand \"squeezar\" if mentioned\n        if 'squeezar' in notes.lower():\n            notes = notes.replace(\n                'squeezar',\n                'squeezar (star squeezed by tidal forces)'\n            ).replace(\n                'Squeezar',\n                'Squeezar (star squeezed by tidal forces)'\n            )\n        hover += f\"<br><i>{notes}</i>\"\n    \n    return hover",
    "start_line": 317,
    "end_line": 392,
    "has_docstring": true,
    "docstring": "Create rich hover text for S-star markers.\n\nMatches the style and information density of exoplanet host star hovers.\n\nArgs:\n    star_name: Key from catalog\n    star_data: Star data dictionary\n    current_distance_au: Current distance from Sgr A* (optional)\n    current_velocity_km_s: Current orbital velocity (optional)\n    \nReturns:\n    str: HTML-formatted hover text",
    "parameters": [
      "star_name",
      "star_data",
      "current_distance_au",
      "current_velocity_km_s"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_star_hover_text",
    "component_id": "sgr_a_star_data.create_star_hover_text"
  },
  "sgr_a_star_data.calculate_periapsis_au": {
    "id": "sgr_a_star_data.calculate_periapsis_au",
    "name": "calculate_periapsis_au",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [],
    "source_code": "def calculate_periapsis_au(a_au, e):\n    \"\"\"\n    Calculate periapsis distance (closest approach to black hole).\n    q = a * (1 - e)\n    \"\"\"\n    return a_au * (1 - e)",
    "start_line": 398,
    "end_line": 403,
    "has_docstring": true,
    "docstring": "Calculate periapsis distance (closest approach to black hole).\nq = a * (1 - e)",
    "parameters": [
      "a_au",
      "e"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_periapsis_au",
    "component_id": "sgr_a_star_data.calculate_periapsis_au"
  },
  "sgr_a_star_data.calculate_apoapsis_au": {
    "id": "sgr_a_star_data.calculate_apoapsis_au",
    "name": "calculate_apoapsis_au",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [],
    "source_code": "def calculate_apoapsis_au(a_au, e):\n    \"\"\"\n    Calculate apoapsis distance (farthest point from black hole).\n    Q = a * (1 + e)\n    \"\"\"\n    return a_au * (1 + e)",
    "start_line": 405,
    "end_line": 410,
    "has_docstring": true,
    "docstring": "Calculate apoapsis distance (farthest point from black hole).\nQ = a * (1 + e)",
    "parameters": [
      "a_au",
      "e"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_apoapsis_au",
    "component_id": "sgr_a_star_data.calculate_apoapsis_au"
  },
  "sgr_a_star_data.calculate_orbital_velocity": {
    "id": "sgr_a_star_data.calculate_orbital_velocity",
    "name": "calculate_orbital_velocity",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [],
    "source_code": "def calculate_orbital_velocity(a_au, r_au, M_solar=SGR_A_MASS_SOLAR):\n    \"\"\"\n    Calculate orbital velocity at distance r using vis-viva equation.\n    v^2 = GM * (2/r - 1/a)\n    \n    Returns velocity in km/s.\n    \"\"\"\n    # Convert to SI units\n    a_m = a_au * AU_TO_METERS\n    r_m = r_au * AU_TO_METERS\n    M_kg = M_solar * SOLAR_MASS_KG\n    \n    # Vis-viva equation\n    v_squared = G_CONST * M_kg * (2/r_m - 1/a_m)\n    v_m_s = math.sqrt(v_squared)\n    \n    return v_m_s / 1000.0  # Convert to km/s",
    "start_line": 412,
    "end_line": 428,
    "has_docstring": true,
    "docstring": "Calculate orbital velocity at distance r using vis-viva equation.\nv^2 = GM * (2/r - 1/a)\n\nReturns velocity in km/s.",
    "parameters": [
      "a_au",
      "r_au",
      "M_solar"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_orbital_velocity",
    "component_id": "sgr_a_star_data.calculate_orbital_velocity"
  },
  "sgr_a_star_data.calculate_periapsis_velocity": {
    "id": "sgr_a_star_data.calculate_periapsis_velocity",
    "name": "calculate_periapsis_velocity",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [
      "sgr_a_star_data.calculate_orbital_velocity",
      "sgr_a_star_data.calculate_periapsis_au"
    ],
    "source_code": "def calculate_periapsis_velocity(a_au, e, M_solar=SGR_A_MASS_SOLAR):\n    \"\"\"Calculate velocity at periapsis (maximum velocity).\"\"\"\n    r_periapsis = calculate_periapsis_au(a_au, e)\n    return calculate_orbital_velocity(a_au, r_periapsis, M_solar)",
    "start_line": 430,
    "end_line": 433,
    "has_docstring": true,
    "docstring": "Calculate velocity at periapsis (maximum velocity).",
    "parameters": [
      "a_au",
      "e",
      "M_solar"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_periapsis_velocity",
    "component_id": "sgr_a_star_data.calculate_periapsis_velocity"
  },
  "sgr_a_star_data.calculate_apoapsis_velocity": {
    "id": "sgr_a_star_data.calculate_apoapsis_velocity",
    "name": "calculate_apoapsis_velocity",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [
      "sgr_a_star_data.calculate_apoapsis_au",
      "sgr_a_star_data.calculate_orbital_velocity"
    ],
    "source_code": "def calculate_apoapsis_velocity(a_au, e, M_solar=SGR_A_MASS_SOLAR):\n    \"\"\"Calculate velocity at apoapsis (minimum velocity).\"\"\"\n    r_apoapsis = calculate_apoapsis_au(a_au, e)\n    return calculate_orbital_velocity(a_au, r_apoapsis, M_solar)",
    "start_line": 435,
    "end_line": 438,
    "has_docstring": true,
    "docstring": "Calculate velocity at apoapsis (minimum velocity).",
    "parameters": [
      "a_au",
      "e",
      "M_solar"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_apoapsis_velocity",
    "component_id": "sgr_a_star_data.calculate_apoapsis_velocity"
  },
  "sgr_a_star_data.velocity_as_fraction_of_c": {
    "id": "sgr_a_star_data.velocity_as_fraction_of_c",
    "name": "velocity_as_fraction_of_c",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [],
    "source_code": "def velocity_as_fraction_of_c(v_km_s):\n    \"\"\"Convert velocity to fraction of speed of light.\"\"\"\n    return v_km_s / SPEED_OF_LIGHT_KM_S",
    "start_line": 440,
    "end_line": 442,
    "has_docstring": true,
    "docstring": "Convert velocity to fraction of speed of light.",
    "parameters": [
      "v_km_s"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function velocity_as_fraction_of_c",
    "component_id": "sgr_a_star_data.velocity_as_fraction_of_c"
  },
  "sgr_a_star_data.format_velocity": {
    "id": "sgr_a_star_data.format_velocity",
    "name": "format_velocity",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [
      "sgr_a_star_data.velocity_as_fraction_of_c"
    ],
    "source_code": "def format_velocity(v_km_s):\n    \"\"\"Format velocity as 'X km/s (Y% c)'.\"\"\"\n    percent_c = velocity_as_fraction_of_c(v_km_s) * 100\n    return f\"{v_km_s:,.0f} km/s ({percent_c:.1f}% c)\"",
    "start_line": 444,
    "end_line": 447,
    "has_docstring": true,
    "docstring": "Format velocity as 'X km/s (Y% c)'.",
    "parameters": [
      "v_km_s"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function format_velocity",
    "component_id": "sgr_a_star_data.format_velocity"
  },
  "sgr_a_star_data.calculate_schwarzschild_precession_per_orbit": {
    "id": "sgr_a_star_data.calculate_schwarzschild_precession_per_orbit",
    "name": "calculate_schwarzschild_precession_per_orbit",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [],
    "source_code": "def calculate_schwarzschild_precession_per_orbit(a_au, e, M_solar=SGR_A_MASS_SOLAR):\n    \"\"\"\n    Calculate the Schwarzschild (GR) precession per orbit.\n    \n    Formula: delta_phi = 6 * pi * G * M / (c^2 * a * (1 - e^2))\n             = 3 * pi * Rs / (a * (1 - e^2))\n    \n    Returns precession in degrees per orbit.\n    \n    For S2: ~0.2 degrees (~12 arcminutes) per 16-year orbit.\n    \"\"\"\n    # Use Schwarzschild radius form for numerical stability\n    Rs_au = SCHWARZSCHILD_RADIUS_AU\n    \n    # Precession in radians\n    precession_rad = 3 * math.pi * Rs_au / (a_au * (1 - e**2))\n    \n    # Convert to degrees\n    return math.degrees(precession_rad)",
    "start_line": 453,
    "end_line": 471,
    "has_docstring": true,
    "docstring": "Calculate the Schwarzschild (GR) precession per orbit.\n\nFormula: delta_phi = 6 * pi * G * M / (c^2 * a * (1 - e^2))\n         = 3 * pi * Rs / (a * (1 - e^2))\n\nReturns precession in degrees per orbit.\n\nFor S2: ~0.2 degrees (~12 arcminutes) per 16-year orbit.",
    "parameters": [
      "a_au",
      "e",
      "M_solar"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_schwarzschild_precession_per_orbit",
    "component_id": "sgr_a_star_data.calculate_schwarzschild_precession_per_orbit"
  },
  "sgr_a_star_data.calculate_gravitational_redshift": {
    "id": "sgr_a_star_data.calculate_gravitational_redshift",
    "name": "calculate_gravitational_redshift",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [],
    "source_code": "def calculate_gravitational_redshift(r_au, M_solar=SGR_A_MASS_SOLAR):\n    \"\"\"\n    Calculate gravitational redshift factor at distance r.\n    \n    z = 1 / sqrt(1 - Rs/r) - 1\n    \n    For S2 at periapsis (~120 AU): z ~ 0.0003 (detected in 2018!)\n    \"\"\"\n    Rs_au = SCHWARZSCHILD_RADIUS_AU\n    r_au = max(r_au, Rs_au * 1.001)  # Avoid singularity\n    \n    factor = 1 - (Rs_au / r_au)\n    if factor <= 0:\n        return float('inf')  # Inside event horizon\n    \n    return 1 / math.sqrt(factor) - 1",
    "start_line": 473,
    "end_line": 488,
    "has_docstring": true,
    "docstring": "Calculate gravitational redshift factor at distance r.\n\nz = 1 / sqrt(1 - Rs/r) - 1\n\nFor S2 at periapsis (~120 AU): z ~ 0.0003 (detected in 2018!)",
    "parameters": [
      "r_au",
      "M_solar"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_gravitational_redshift",
    "component_id": "sgr_a_star_data.calculate_gravitational_redshift"
  },
  "sgr_a_star_data.mean_anomaly_at_time": {
    "id": "sgr_a_star_data.mean_anomaly_at_time",
    "name": "mean_anomaly_at_time",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [],
    "source_code": "def mean_anomaly_at_time(t_current, t_periapsis, period_yrs):\n    \"\"\"\n    Calculate mean anomaly M at a given time.\n    M = 2*pi * (t - t_periapsis) / P\n    \n    Returns mean anomaly in radians, normalized to [0, 2*pi).\n    \"\"\"\n    dt = t_current - t_periapsis\n    M = 2 * math.pi * dt / period_yrs\n    return M % (2 * math.pi)",
    "start_line": 494,
    "end_line": 503,
    "has_docstring": true,
    "docstring": "Calculate mean anomaly M at a given time.\nM = 2*pi * (t - t_periapsis) / P\n\nReturns mean anomaly in radians, normalized to [0, 2*pi).",
    "parameters": [
      "t_current",
      "t_periapsis",
      "period_yrs"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function mean_anomaly_at_time",
    "component_id": "sgr_a_star_data.mean_anomaly_at_time"
  },
  "sgr_a_star_data.solve_kepler_equation": {
    "id": "sgr_a_star_data.solve_kepler_equation",
    "name": "solve_kepler_equation",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [],
    "source_code": "def solve_kepler_equation(M, e, tolerance=1e-10, max_iterations=100):\n    \"\"\"\n    Solve Kepler's equation: M = E - e*sin(E)\n    \n    Uses Newton-Raphson iteration.\n    \n    Args:\n        M: Mean anomaly (radians)\n        e: Eccentricity\n        \n    Returns:\n        E: Eccentric anomaly (radians)\n    \"\"\"\n    # Initial guess\n    if e < 0.8:\n        E = M\n    else:\n        E = math.pi  # Better starting point for high eccentricity\n    \n    for _ in range(max_iterations):\n        f = E - e * math.sin(E) - M\n        f_prime = 1 - e * math.cos(E)\n        \n        if abs(f_prime) < 1e-12:\n            break\n            \n        E_new = E - f / f_prime\n        \n        if abs(E_new - E) < tolerance:\n            return E_new\n        E = E_new\n    \n    return E",
    "start_line": 505,
    "end_line": 537,
    "has_docstring": true,
    "docstring": "Solve Kepler's equation: M = E - e*sin(E)\n\nUses Newton-Raphson iteration.\n\nArgs:\n    M: Mean anomaly (radians)\n    e: Eccentricity\n    \nReturns:\n    E: Eccentric anomaly (radians)",
    "parameters": [
      "M",
      "e",
      "tolerance",
      "max_iterations"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function solve_kepler_equation",
    "component_id": "sgr_a_star_data.solve_kepler_equation"
  },
  "sgr_a_star_data.eccentric_to_true_anomaly": {
    "id": "sgr_a_star_data.eccentric_to_true_anomaly",
    "name": "eccentric_to_true_anomaly",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [],
    "source_code": "def eccentric_to_true_anomaly(E, e):\n    \"\"\"\n    Convert eccentric anomaly to true anomaly.\n    \n    tan(nu/2) = sqrt((1+e)/(1-e)) * tan(E/2)\n    \n    Returns true anomaly in radians.\n    \"\"\"\n    beta = e / (1 + math.sqrt(1 - e**2))\n    nu = E + 2 * math.atan2(beta * math.sin(E), 1 - beta * math.cos(E))\n    return nu",
    "start_line": 539,
    "end_line": 549,
    "has_docstring": true,
    "docstring": "Convert eccentric anomaly to true anomaly.\n\ntan(nu/2) = sqrt((1+e)/(1-e)) * tan(E/2)\n\nReturns true anomaly in radians.",
    "parameters": [
      "E",
      "e"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function eccentric_to_true_anomaly",
    "component_id": "sgr_a_star_data.eccentric_to_true_anomaly"
  },
  "sgr_a_star_data.true_anomaly_at_time": {
    "id": "sgr_a_star_data.true_anomaly_at_time",
    "name": "true_anomaly_at_time",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [
      "sgr_a_star_data.mean_anomaly_at_time",
      "sgr_a_star_data.solve_kepler_equation",
      "sgr_a_star_data.eccentric_to_true_anomaly"
    ],
    "source_code": "def true_anomaly_at_time(t_current, t_periapsis, period_yrs, e):\n    \"\"\"\n    Calculate true anomaly at a given time.\n    Combines mean anomaly calculation and Kepler equation solution.\n    \"\"\"\n    M = mean_anomaly_at_time(t_current, t_periapsis, period_yrs)\n    E = solve_kepler_equation(M, e)\n    nu = eccentric_to_true_anomaly(E, e)\n    return nu",
    "start_line": 551,
    "end_line": 559,
    "has_docstring": true,
    "docstring": "Calculate true anomaly at a given time.\nCombines mean anomaly calculation and Kepler equation solution.",
    "parameters": [
      "t_current",
      "t_periapsis",
      "period_yrs",
      "e"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function true_anomaly_at_time",
    "component_id": "sgr_a_star_data.true_anomaly_at_time"
  },
  "sgr_a_star_data.radius_from_true_anomaly": {
    "id": "sgr_a_star_data.radius_from_true_anomaly",
    "name": "radius_from_true_anomaly",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [],
    "source_code": "def radius_from_true_anomaly(a_au, e, nu):\n    \"\"\"\n    Calculate orbital radius at true anomaly nu.\n    r = a * (1 - e^2) / (1 + e*cos(nu))\n    \"\"\"\n    return a_au * (1 - e**2) / (1 + e * math.cos(nu))",
    "start_line": 561,
    "end_line": 566,
    "has_docstring": true,
    "docstring": "Calculate orbital radius at true anomaly nu.\nr = a * (1 - e^2) / (1 + e*cos(nu))",
    "parameters": [
      "a_au",
      "e",
      "nu"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function radius_from_true_anomaly",
    "component_id": "sgr_a_star_data.radius_from_true_anomaly"
  },
  "sgr_a_star_data.get_star_summary": {
    "id": "sgr_a_star_data.get_star_summary",
    "name": "get_star_summary",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [
      "sgr_a_star_data.calculate_apoapsis_velocity",
      "sgr_a_star_data.get_star_data",
      "sgr_a_star_data.calculate_schwarzschild_precession_per_orbit",
      "sgr_a_star_data.calculate_apoapsis_au",
      "sgr_a_star_data.format_velocity",
      "sgr_a_star_data.calculate_periapsis_velocity",
      "sgr_a_star_data.calculate_periapsis_au"
    ],
    "source_code": "def get_star_summary(star_name):\n    \"\"\"\n    Get a formatted summary of a star's orbital characteristics.\n    \"\"\"\n    star = get_star_data(star_name)\n    if star is None:\n        return f\"Star '{star_name}' not found in catalog.\"\n    \n    a = star['a_au']\n    e = star['e']\n    \n    periapsis = calculate_periapsis_au(a, e)\n    apoapsis = calculate_apoapsis_au(a, e)\n    v_peri = calculate_periapsis_velocity(a, e)\n    v_apo = calculate_apoapsis_velocity(a, e)\n    precession = calculate_schwarzschild_precession_per_orbit(a, e)\n    \n    lines = [\n        f\"=== {star['name']} ===\",\n        f\"Spectral Type: {star['spectral_type']}\",\n        f\"Mass: {star['mass_solar']} solar masses\",\n        f\"\",\n        f\"Orbital Period: {star['period_yrs']:.2f} years\",\n        f\"Semi-major axis: {a:,.0f} AU\",\n        f\"Eccentricity: {e:.4f}\",\n        f\"\",\n        f\"Periapsis: {periapsis:,.1f} AU ({periapsis/SCHWARZSCHILD_RADIUS_AU:,.0f} Rs)\",\n        f\"Apoapsis: {apoapsis:,.1f} AU\",\n        f\"\",\n        f\"Velocity at periapsis: {format_velocity(v_peri)}\",\n        f\"Velocity at apoapsis: {format_velocity(v_apo)}\",\n        f\"\",\n        f\"GR Precession: {precession:.4f} deg/orbit ({precession*60:.1f} arcmin/orbit)\",\n        f\"\",\n        f\"Notes: {star['notes']}\"\n    ]\n    \n    return \"\\n\".join(lines)",
    "start_line": 572,
    "end_line": 609,
    "has_docstring": true,
    "docstring": "Get a formatted summary of a star's orbital characteristics.",
    "parameters": [
      "star_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_star_summary",
    "component_id": "sgr_a_star_data.get_star_summary"
  },
  "sgr_a_star_data.print_catalog_summary": {
    "id": "sgr_a_star_data.print_catalog_summary",
    "name": "print_catalog_summary",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_star_data.py",
    "relative_path": "sgr_a_star_data.py",
    "depends_on": [
      "sgr_a_star_data.list_stars",
      "sgr_a_star_data.get_star_summary"
    ],
    "source_code": "def print_catalog_summary():\n    \"\"\"Print summary for all stars in the catalog.\"\"\"\n    print(\"=\" * 60)\n    print(\"S-STAR CATALOG - Stars Orbiting Sagittarius A*\")\n    print(f\"Black Hole Mass: {SGR_A_MASS_SOLAR/1e6:.3f} million solar masses\")\n    print(f\"Schwarzschild Radius: {SCHWARZSCHILD_RADIUS_AU:.4f} AU ({SCHWARZSCHILD_RADIUS_KM/1e6:.1f} million km)\")\n    print(\"=\" * 60)\n    \n    for star_name in list_stars():\n        print()\n        print(get_star_summary(star_name))\n        print()",
    "start_line": 611,
    "end_line": 622,
    "has_docstring": true,
    "docstring": "Print summary for all stars in the catalog.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function print_catalog_summary",
    "component_id": "sgr_a_star_data.print_catalog_summary"
  },
  "sgr_a_visualization_animation.calculate_star_position_at_mean_anomaly": {
    "id": "sgr_a_visualization_animation.calculate_star_position_at_mean_anomaly",
    "name": "calculate_star_position_at_mean_anomaly",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_animation.py",
    "relative_path": "sgr_a_visualization_animation.py",
    "depends_on": [
      "sgr_a_star_data.calculate_orbital_velocity",
      "sgr_a_visualization_core_arcs.generate_position_at_true_anomaly",
      "sgr_a_star_data.solve_kepler_equation",
      "sgr_a_star_data.eccentric_to_true_anomaly"
    ],
    "source_code": "def calculate_star_position_at_mean_anomaly(star_data, mean_anomaly_rad):\n    \"\"\"\n    Given a mean anomaly M, calculate the star's 3D position and velocity.\n    \n    Returns:\n        x, y, z: Position in AU\n        r: Distance from Sgr A* in AU  \n        v: Velocity in km/s\n    \"\"\"\n    # Solve Kepler's equation: M -> E (Eccentric Anomaly)\n    E = data.solve_kepler_equation(mean_anomaly_rad, star_data['e'])\n    \n    # Convert E -> nu (True Anomaly)\n    nu = data.eccentric_to_true_anomaly(E, star_data['e'])\n    \n    # Get 3D position\n    x, y, z, r = core.generate_position_at_true_anomaly(star_data, nu)\n    \n    # Calculate velocity at this distance\n    v = data.calculate_orbital_velocity(star_data['a_au'], r)\n    \n    return x, y, z, r, v, nu",
    "start_line": 36,
    "end_line": 57,
    "has_docstring": true,
    "docstring": "Given a mean anomaly M, calculate the star's 3D position and velocity.\n\nReturns:\n    x, y, z: Position in AU\n    r: Distance from Sgr A* in AU  \n    v: Velocity in km/s",
    "parameters": [
      "star_data",
      "mean_anomaly_rad"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_star_position_at_mean_anomaly",
    "component_id": "sgr_a_visualization_animation.calculate_star_position_at_mean_anomaly"
  },
  "sgr_a_visualization_animation.get_phase_offset": {
    "id": "sgr_a_visualization_animation.get_phase_offset",
    "name": "get_phase_offset",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_animation.py",
    "relative_path": "sgr_a_visualization_animation.py",
    "depends_on": [],
    "source_code": "def get_phase_offset(star_data, reference_year=2024.0):\n    \"\"\"\n    Calculate phase offset so stars start at their actual orbital positions\n    relative to a reference year.\n    \n    This prevents all stars from hitting periapsis at the same animation frame.\n    \"\"\"\n    # Time since periapsis\n    dt = reference_year - star_data['t_periapsis']\n    \n    # Fraction of orbit completed\n    orbit_fraction = (dt % star_data['period_yrs']) / star_data['period_yrs']\n    \n    # Convert to radians\n    return orbit_fraction * 2 * np.pi",
    "start_line": 59,
    "end_line": 73,
    "has_docstring": true,
    "docstring": "Calculate phase offset so stars start at their actual orbital positions\nrelative to a reference year.\n\nThis prevents all stars from hitting periapsis at the same animation frame.",
    "parameters": [
      "star_data",
      "reference_year"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_phase_offset",
    "component_id": "sgr_a_visualization_animation.get_phase_offset"
  },
  "sgr_a_visualization_animation.format_velocity_display": {
    "id": "sgr_a_visualization_animation.format_velocity_display",
    "name": "format_velocity_display",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_animation.py",
    "relative_path": "sgr_a_visualization_animation.py",
    "depends_on": [],
    "source_code": "def format_velocity_display(v_km_s):\n    \"\"\"Format velocity for display in animation.\"\"\"\n    percent_c = (v_km_s / data.SPEED_OF_LIGHT_KM_S) * 100\n    if percent_c >= 1.0:\n        return f\"{v_km_s:,.0f} km/s ({percent_c:.1f}% c)\"\n    else:\n        return f\"{v_km_s:,.0f} km/s\"",
    "start_line": 75,
    "end_line": 81,
    "has_docstring": true,
    "docstring": "Format velocity for display in animation.",
    "parameters": [
      "v_km_s"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function format_velocity_display",
    "component_id": "sgr_a_visualization_animation.format_velocity_display"
  },
  "sgr_a_visualization_animation.create_animation": {
    "id": "sgr_a_visualization_animation.create_animation",
    "name": "create_animation",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_animation.py",
    "relative_path": "sgr_a_visualization_animation.py",
    "depends_on": [
      "sgr_a_visualization_core_arcs.generate_orbit_points",
      "sgr_a_star_data.get_star_data",
      "sgr_a_star_data.calculate_apoapsis_au",
      "sgr_a_star_data.get_star_color",
      "sgr_a_visualization_core_arcs.create_sgr_a_marker",
      "sgr_a_visualization_animation.calculate_star_position_at_mean_anomaly",
      "sgr_a_star_data.get_orbit_color",
      "sgr_a_visualization_animation.get_phase_offset",
      "sgr_a_visualization_animation.format_velocity_display"
    ],
    "source_code": "def create_animation(stars_to_show=None, reference_year=2024.0):\n    \"\"\"\n    Create animated visualization of S-stars orbiting Sgr A*.\n    \n    Args:\n        stars_to_show: List of star names. Default: all four main stars.\n        reference_year: Year for initial orbital positions.\n    \n    Returns:\n        Plotly Figure with animation frames.\n    \"\"\"\n    print(\"Initializing S-Star Animation...\")\n    \n    if stars_to_show is None:\n        stars_to_show = ['S2', 'S62', 'S4711', 'S4714']\n    \n    num_frames = ANIMATION_CONFIG['num_frames']\n    frame_duration = ANIMATION_CONFIG['frame_duration_ms']\n    marker_size = ANIMATION_CONFIG['star_marker_size']\n    \n    # =========================================================================\n    # 1. CREATE BASE FIGURE (Static Elements)\n    # =========================================================================\n    \n    # Start fresh - we'll build our own traces\n    traces = []\n    \n    # Add Sgr A* (black hole marker)\n    traces.extend(core.create_sgr_a_marker())\n    \n    # Add static orbit paths (no current position markers - animation will handle those)\n    for star_name in stars_to_show:\n        star_data = data.get_star_data(star_name)\n        if star_data:\n            # Get orbit color for trace (distinct from star marker)\n            orbit_color = get_orbit_color(star_data)\n            \n            # Generate orbit path\n            x_orbit, y_orbit, z_orbit = core.generate_orbit_points(star_data)\n            \n            # Add orbit trace\n            traces.append(go.Scatter3d(\n                x=x_orbit, y=y_orbit, z=z_orbit,\n                mode='lines',\n                line=dict(color=orbit_color, width=2, dash='solid'),\n                name=star_data['name'],\n                hoverinfo='name',\n                opacity=0.6\n            ))\n    \n    # Add placeholder traces for moving star markers (one per star)\n    # These will be updated by animation frames\n    star_marker_start_index = len(traces)\n    \n    for star_name in stars_to_show:\n        star_data = data.get_star_data(star_name)\n        star_color = get_star_color(star_data)    # Temperature-based for marker\n        orbit_color = get_orbit_color(star_data)  # Distinct for label\n        phase_offset = get_phase_offset(star_data, reference_year)\n        x, y, z, r, v, nu = calculate_star_position_at_mean_anomaly(star_data, phase_offset)\n        \n        traces.append(go.Scatter3d(\n            x=[x], y=[y], z=[z],\n            mode='markers+text',\n            marker=dict(\n                size=marker_size,\n                color=star_color,\n                line=dict(color='white', width=2),\n                symbol='circle'\n            ),\n            text=[star_name],\n            textposition='top center',\n            textfont=dict(size=10, color=orbit_color),\n            name=f\"{star_name} (moving)\",\n            hovertemplate=(\n                f\"<b>{star_data['name']}</b><br>\"\n                f\"Distance: {r:.1f} AU<br>\"\n                f\"Velocity: {format_velocity_display(v)}<br>\"\n                \"<extra></extra>\"\n            ),\n            showlegend=False\n        ))\n    \n    # =========================================================================\n    # 2. GENERATE ANIMATION FRAMES\n    # =========================================================================\n    \n    print(f\"Generating {num_frames} frames for {len(stars_to_show)} stars...\")\n    \n    # Mean anomaly steps (0 to 2*pi)\n    mean_anomalies = np.linspace(0, 2*np.pi, num_frames, endpoint=False)\n    \n    frames = []\n    \n    for k, M_base in enumerate(mean_anomalies):\n        frame_traces = []\n        \n        for i, star_name in enumerate(stars_to_show):\n            star_data = data.get_star_data(star_name)\n            \n            # Apply phase offset so stars are at correct relative positions\n            phase_offset = get_phase_offset(star_data, reference_year)\n            M = (M_base + phase_offset) % (2 * np.pi)\n            \n            # Calculate position\n            x, y, z, r, v, nu = calculate_star_position_at_mean_anomaly(star_data, M)\n            \n            # Get temperature-based color for marker, orbit color for label\n            star_color = get_star_color(star_data)\n            orbit_color = get_orbit_color(star_data)\n            \n            # Create marker trace for this frame\n            frame_traces.append(go.Scatter3d(\n                x=[x], y=[y], z=[z],\n                mode='markers+text',\n                marker=dict(\n                    size=marker_size,\n                    color=star_color,\n                    line=dict(color='white', width=2)\n                ),\n                text=[star_name],\n                textposition='top center',\n                textfont=dict(size=10, color=orbit_color),\n                hovertemplate=(\n                    f\"<b>{star_data['name']}</b><br>\"\n                    f\"Distance: {r:.1f} AU<br>\"\n                    f\"Velocity: {format_velocity_display(v)}<br>\"\n                    \"<extra></extra>\"\n                )\n            ))\n        \n        # Create frame - specify which trace indices to update\n        frames.append(go.Frame(\n            data=frame_traces,\n            traces=list(range(star_marker_start_index, star_marker_start_index + len(stars_to_show))),\n            name=f\"frame_{k}\"\n        ))\n    \n    # =========================================================================\n    # 3. ASSEMBLE FIGURE\n    # =========================================================================\n    \n    # Calculate axis range\n    max_range = 0\n    for star_name in stars_to_show:\n        star_data = data.get_star_data(star_name)\n        apoapsis = data.calculate_apoapsis_au(star_data['a_au'], star_data['e'])\n        max_range = max(max_range, apoapsis)\n    axis_range = max_range * 1.1\n    \n    fig = go.Figure(data=traces, frames=frames)\n    \n    # Layout\n    fig.update_layout(\n        title=dict(\n            text=\"<b>S-Stars Orbiting Sagittarius A*</b><br><sup>Animation: Mean Anomaly Stepping (Kepler's Second Law in Action)</sup>\",\n            x=0.5,\n            font=dict(size=16, color='white')\n        ),\n        scene=dict(\n            xaxis=dict(\n                title='X (AU)',\n                range=[-axis_range, axis_range],\n                backgroundcolor='rgb(5,5,15)',\n                gridcolor='rgb(40,40,60)',\n                showbackground=True\n            ),\n            yaxis=dict(\n                title='Y (AU)',\n                range=[-axis_range, axis_range],\n                backgroundcolor='rgb(5,5,15)',\n                gridcolor='rgb(40,40,60)',\n                showbackground=True\n            ),\n            zaxis=dict(\n                title='Z (AU)',\n                range=[-axis_range, axis_range],\n                backgroundcolor='rgb(5,5,15)',\n                gridcolor='rgb(40,40,60)',\n                showbackground=True\n            ),\n            aspectmode='cube',\n            camera=dict(\n                eye=dict(x=1.2, y=1.2, z=0.6)\n            )\n        ),\n        paper_bgcolor='rgb(5,5,15)',\n        plot_bgcolor='rgb(5,5,15)',\n        font=dict(color='white'),\n        legend=dict(\n            yanchor=\"top\",\n            y=0.99,\n            xanchor=\"left\",\n            x=0.01,\n            bgcolor='rgba(0,0,0,0.7)',\n            font=dict(size=11)\n        ),\n        margin=dict(l=0, r=0, t=80, b=100),\n        \n        # Animation controls\n        updatemenus=[dict(\n            type=\"buttons\",\n            showactive=True,\n            y=-0.05,\n            x=0.5,\n            xanchor=\"center\",\n            buttons=[\n                dict(\n                    label=\"Play\",\n                    method=\"animate\",\n                    args=[\n                        None,\n                        dict(\n                            frame=dict(duration=frame_duration, redraw=True),\n                            fromcurrent=True,\n                            mode='immediate',\n                            transition=dict(duration=0)\n                        )\n                    ]\n                ),\n                dict(\n                    label=\"Pause\",\n                    method=\"animate\",\n                    args=[\n                        [None],\n                        dict(\n                            frame=dict(duration=0, redraw=False),\n                            mode=\"immediate\",\n                            transition=dict(duration=0)\n                        )\n                    ]\n                )\n            ]\n        )],\n        \n        # Slider for manual scrubbing\n        sliders=[dict(\n            active=0,\n            yanchor=\"top\",\n            y=-0.1,\n            xanchor=\"left\",\n            x=0.1,\n            len=0.8,\n            pad=dict(b=10, t=50),\n            currentvalue=dict(\n                font=dict(size=12, color='white'),\n                prefix=\"Orbit Phase: \",\n                suffix=\" deg\",\n                visible=True,\n                xanchor=\"center\"\n            ),\n            steps=[\n                dict(\n                    method='animate',\n                    args=[\n                        [f'frame_{k}'],\n                        dict(\n                            mode='immediate',\n                            frame=dict(duration=0, redraw=True),\n                            transition=dict(duration=0)\n                        )\n                    ],\n                    label=f'{int(k * 360 / num_frames)}'\n                )\n                for k in range(num_frames)\n            ]\n        )]\n    )\n    \n    # Add annotation\n    fig.add_annotation(\n        text=\"Watch S4714 (red): hangs at apoapsis, then SNAPS through periapsis at 10% light speed!\",\n        xref=\"paper\", yref=\"paper\",\n        x=0.5, y=1.02,\n        showarrow=False,\n        font=dict(size=11, color='yellow'),\n        bgcolor='rgba(0,0,0,0.5)'\n    )\n    \n    print(\"Animation ready!\")\n    return fig",
    "start_line": 87,
    "end_line": 367,
    "has_docstring": true,
    "docstring": "Create animated visualization of S-stars orbiting Sgr A*.\n\nArgs:\n    stars_to_show: List of star names. Default: all four main stars.\n    reference_year: Year for initial orbital positions.\n\nReturns:\n    Plotly Figure with animation frames.",
    "parameters": [
      "stars_to_show",
      "reference_year"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_animation",
    "component_id": "sgr_a_visualization_animation.create_animation"
  },
  "sgr_a_visualization_animation.create_single_star_animation": {
    "id": "sgr_a_visualization_animation.create_single_star_animation",
    "name": "create_single_star_animation",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_animation.py",
    "relative_path": "sgr_a_visualization_animation.py",
    "depends_on": [
      "sgr_a_visualization_animation.create_animation"
    ],
    "source_code": "def create_single_star_animation(star_name, num_orbits=3):\n    \"\"\"\n    Create animation focused on a single star, showing multiple orbits\n    to demonstrate precession (Stage 3 preview).\n    \"\"\"\n    return create_animation(stars_to_show=[star_name])",
    "start_line": 373,
    "end_line": 378,
    "has_docstring": true,
    "docstring": "Create animation focused on a single star, showing multiple orbits\nto demonstrate precession (Stage 3 preview).",
    "parameters": [
      "star_name",
      "num_orbits"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_single_star_animation",
    "component_id": "sgr_a_visualization_animation.create_single_star_animation"
  },
  "sgr_a_visualization_core.generate_orbit_points": {
    "id": "sgr_a_visualization_core.generate_orbit_points",
    "name": "generate_orbit_points",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_core.py",
    "relative_path": "sgr_a_visualization_core.py",
    "depends_on": [],
    "source_code": "def generate_orbit_points(star_data, num_points=360, precession_offset_deg=0.0):\n    \"\"\"\n    Generate 3D orbit points for a star.\n    \n    Args:\n        star_data: Dictionary with orbital elements\n        num_points: Number of points around the orbit\n        precession_offset_deg: Additional rotation to argument of periapsis (for GR precession)\n    \n    Returns:\n        x, y, z: Arrays of orbit coordinates in AU (centered on Sgr A*)\n    \"\"\"\n    # Extract orbital elements\n    a = star_data['a_au']\n    e = star_data['e']\n    i = np.radians(star_data['inclination_deg'])\n    omega = np.radians(star_data['arg_periapsis_deg'] + precession_offset_deg)  # Argument of periapsis\n    Omega = np.radians(star_data['asc_node_deg'])  # Longitude of ascending node\n    \n    # Generate true anomaly values (0 to 2*pi)\n    nu_values = np.linspace(0, 2*np.pi, num_points)\n    \n    # Calculate radius at each true anomaly\n    # r = a(1-e^2) / (1 + e*cos(nu))\n    p = a * (1 - e**2)  # Semi-latus rectum\n    r_values = p / (1 + e * np.cos(nu_values))\n    \n    # Position in orbital plane (x' along periapsis, y' perpendicular)\n    x_orbital = r_values * np.cos(nu_values)\n    y_orbital = r_values * np.sin(nu_values)\n    \n    # Rotation matrices to convert from orbital plane to 3D space\n    # 1. Rotate by argument of periapsis (omega)\n    # 2. Rotate by inclination (i)\n    # 3. Rotate by longitude of ascending node (Omega)\n    \n    # Combined rotation (standard orbital mechanics convention)\n    cos_omega = np.cos(omega)\n    sin_omega = np.sin(omega)\n    cos_i = np.cos(i)\n    sin_i = np.sin(i)\n    cos_Omega = np.cos(Omega)\n    sin_Omega = np.sin(Omega)\n    \n    # Rotation matrix elements\n    # x = (cos_Omega*cos_omega - sin_Omega*sin_omega*cos_i)*x' + (-cos_Omega*sin_omega - sin_Omega*cos_omega*cos_i)*y'\n    # y = (sin_Omega*cos_omega + cos_Omega*sin_omega*cos_i)*x' + (-sin_Omega*sin_omega + cos_Omega*cos_omega*cos_i)*y'\n    # z = (sin_omega*sin_i)*x' + (cos_omega*sin_i)*y'\n    \n    Px = cos_Omega * cos_omega - sin_Omega * sin_omega * cos_i\n    Qx = -cos_Omega * sin_omega - sin_Omega * cos_omega * cos_i\n    \n    Py = sin_Omega * cos_omega + cos_Omega * sin_omega * cos_i\n    Qy = -sin_Omega * sin_omega + cos_Omega * cos_omega * cos_i\n    \n    Pz = sin_omega * sin_i\n    Qz = cos_omega * sin_i\n    \n    # Transform to 3D coordinates\n    x = Px * x_orbital + Qx * y_orbital\n    y = Py * x_orbital + Qy * y_orbital\n    z = Pz * x_orbital + Qz * y_orbital\n    \n    return x, y, z",
    "start_line": 36,
    "end_line": 99,
    "has_docstring": true,
    "docstring": "Generate 3D orbit points for a star.\n\nArgs:\n    star_data: Dictionary with orbital elements\n    num_points: Number of points around the orbit\n    precession_offset_deg: Additional rotation to argument of periapsis (for GR precession)\n\nReturns:\n    x, y, z: Arrays of orbit coordinates in AU (centered on Sgr A*)",
    "parameters": [
      "star_data",
      "num_points",
      "precession_offset_deg"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate_orbit_points",
    "component_id": "sgr_a_visualization_core.generate_orbit_points"
  },
  "sgr_a_visualization_core.generate_position_at_true_anomaly": {
    "id": "sgr_a_visualization_core.generate_position_at_true_anomaly",
    "name": "generate_position_at_true_anomaly",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_core.py",
    "relative_path": "sgr_a_visualization_core.py",
    "depends_on": [],
    "source_code": "def generate_position_at_true_anomaly(star_data, true_anomaly_rad, precession_offset_deg=0.0):\n    \"\"\"\n    Generate 3D position for a star at a specific true anomaly.\n    \n    Returns:\n        x, y, z: Position in AU\n        r: Distance from Sgr A* in AU\n    \"\"\"\n    a = star_data['a_au']\n    e = star_data['e']\n    i = np.radians(star_data['inclination_deg'])\n    omega = np.radians(star_data['arg_periapsis_deg'] + precession_offset_deg)\n    Omega = np.radians(star_data['asc_node_deg'])\n    \n    nu = true_anomaly_rad\n    \n    # Radius\n    p = a * (1 - e**2)\n    r = p / (1 + e * np.cos(nu))\n    \n    # Position in orbital plane\n    x_orbital = r * np.cos(nu)\n    y_orbital = r * np.sin(nu)\n    \n    # Rotation (same as above)\n    cos_omega = np.cos(omega)\n    sin_omega = np.sin(omega)\n    cos_i = np.cos(i)\n    sin_i = np.sin(i)\n    cos_Omega = np.cos(Omega)\n    sin_Omega = np.sin(Omega)\n    \n    Px = cos_Omega * cos_omega - sin_Omega * sin_omega * cos_i\n    Qx = -cos_Omega * sin_omega - sin_Omega * cos_omega * cos_i\n    Py = sin_Omega * cos_omega + cos_Omega * sin_omega * cos_i\n    Qy = -sin_Omega * sin_omega + cos_Omega * cos_omega * cos_i\n    Pz = sin_omega * sin_i\n    Qz = cos_omega * sin_i\n    \n    x = Px * x_orbital + Qx * y_orbital\n    y = Py * x_orbital + Qy * y_orbital\n    z = Pz * x_orbital + Qz * y_orbital\n    \n    return x, y, z, r",
    "start_line": 101,
    "end_line": 144,
    "has_docstring": true,
    "docstring": "Generate 3D position for a star at a specific true anomaly.\n\nReturns:\n    x, y, z: Position in AU\n    r: Distance from Sgr A* in AU",
    "parameters": [
      "star_data",
      "true_anomaly_rad",
      "precession_offset_deg"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate_position_at_true_anomaly",
    "component_id": "sgr_a_visualization_core.generate_position_at_true_anomaly"
  },
  "sgr_a_visualization_core.create_sgr_a_marker": {
    "id": "sgr_a_visualization_core.create_sgr_a_marker",
    "name": "create_sgr_a_marker",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_core.py",
    "relative_path": "sgr_a_visualization_core.py",
    "depends_on": [],
    "source_code": "def create_sgr_a_marker(scale_factor=50):\n    \"\"\"\n    Create the Sagittarius A* black hole marker.\n    \n    Since the actual Schwarzschild radius (~0.08 AU) would be invisible\n    at orbit scales (~1000 AU), we create an artistic representation.\n    \n    Accretion disk based on observations:\n    - Bright inner ring: ~5.2x Schwarzschild radius (EHT 2022)\n    - Cool outer disk: extends to ~1000 AU (ALMA 2019, Murchikova et al.)\n    \n    Trace order matters for rendering:\n    - Lensing traces added FIRST (render behind)\n    - Black hole sphere added LAST (render in front)\n    \n    Args:\n        scale_factor: How much larger than Rs to draw the marker\n    \n    Returns:\n        List of Plotly traces for Sgr A*\n    \"\"\"\n    traces = []\n    \n    # Effective visual radius (not to physical scale)\n    visual_radius = SCHWARZSCHILD_RADIUS_AU * scale_factor\n    \n    # Disk dimensions (needed for lensing)\n    disk_inner = visual_radius * 1.2\n    disk_outer = visual_radius * 6\n    \n    # Photon sphere radius (where light orbits)\n    photon_sphere = visual_radius * 1.5\n    \n    # ==========================================================================\n    # GRAVITATIONAL LENSING EFFECT - Added FIRST so it renders BEHIND\n    # ==========================================================================\n    # Light from the back of the accretion disk bends around the black hole.\n    # We create a dome of rings above and below the disk that represent\n    # lensed light. This looks similar from any horizontal viewing angle.\n    \n    n_dome_rings = 10\n    lensing_hover = \"Gravitational lensing: light from far side of disk bent around the black hole\"\n    \n    # First lensing ring gets the legend entry\n    first_lensing = True\n    \n    for i in range(n_dome_rings):\n        t = (i + 1) / (n_dome_rings + 1)\n        \n        height = visual_radius * 1.8 * (1 - np.cos(t * np.pi / 2))\n        ring_radius = photon_sphere + (disk_outer - photon_sphere) * (1 - t * 0.7)\n        \n        brightness = 0.4 + 0.6 * t\n        r_col = int(255 * brightness)\n        g_col = int(180 * brightness)\n        b_col = int(80 * brightness)\n        alpha = 0.3 + 0.4 * t\n        width = 1.5 + 2 * t\n        \n        theta_ring = np.linspace(0, 2*np.pi, 60)\n        \n        # Ring ABOVE the disk\n        traces.append(go.Scatter3d(\n            x=ring_radius * np.cos(theta_ring),\n            y=ring_radius * np.sin(theta_ring),\n            z=np.full_like(theta_ring, height),\n            mode='lines',\n            line=dict(\n                color=f'rgba({r_col},{g_col},{b_col},{alpha})',\n                width=width\n            ),\n            hovertext=lensing_hover,\n            hoverinfo='text',\n            name='Gravitational Lensing' if first_lensing else None,\n            legendgroup='lensing',\n            showlegend=first_lensing\n        ))\n        first_lensing = False\n        \n        # Ring BELOW the disk (mirror)\n        traces.append(go.Scatter3d(\n            x=ring_radius * np.cos(theta_ring),\n            y=ring_radius * np.sin(theta_ring),\n            z=np.full_like(theta_ring, -height),\n            mode='lines',\n            line=dict(\n                color=f'rgba({r_col},{g_col},{b_col},{alpha})',\n                width=width\n            ),\n            hovertext=lensing_hover,\n            hoverinfo='text',\n            legendgroup='lensing',\n            showlegend=False\n        ))\n    \n    # ==========================================================================\n    # ACCRETION DISK - Based on observations\n    # ==========================================================================\n    r_disk = np.linspace(disk_inner, disk_outer, 30)\n    theta_disk = np.linspace(0, 2*np.pi, 60)\n    R, Theta = np.meshgrid(r_disk, theta_disk)\n    \n    X_disk = R * np.cos(Theta)\n    Y_disk = R * np.sin(Theta)\n    Z_disk = np.zeros_like(R)\n    \n    color_values = 1 - (R - disk_inner) / (disk_outer - disk_inner)\n    \n    disk_hover = (\n        \"<b>Accretion Disk</b><br><br>\"\n        \"<b>Observed Properties:</b><br>\"\n        \"Inner bright ring: ~5x Schwarzschild radius<br>\"\n        \"Cool outer disk: extends to ~1000 AU<br>\"\n        \"Temperature: 10,000 K (outer) to millions K (inner)<br>\"\n        \"Mass: ~0.1 Jupiter masses of hydrogen gas<br><br>\"\n        \"<b>Physics:</b><br>\"\n        \"Gas spirals inward, losing angular momentum<br>\"\n        \"Friction heats gas to millions of degrees<br>\"\n        \"Emits X-rays, radio, and infrared light<br><br>\"\n        \"<b>Gravitational Lensing:</b><br>\"\n        \"Light from the far side bends around the black hole<br>\"\n        \"Creates the iconic 'wrapped' appearance<br><br>\"\n        \"<i>First imaged by ALMA 2019 (Murchikova et al.)</i><br>\"\n        \"<i>EHT captured bright inner ring, May 2022</i>\"\n    )\n    \n    traces.append(go.Surface(\n        x=X_disk, y=Y_disk, z=Z_disk,\n        surfacecolor=color_values,\n        colorscale=[\n            [0.0, 'rgba(50,20,0,0.3)'],\n            [0.3, 'rgba(150,60,0,0.5)'],\n            [0.6, 'rgba(255,150,0,0.7)'],\n            [1.0, 'rgba(255,200,100,0.9)']\n        ],\n        showscale=False,\n        opacity=0.7,\n        name='Accretion Disk',\n        text=disk_hover,\n        hoverinfo='text',\n        showlegend=True\n    ))\n    \n    # ==========================================================================\n    # PHOTON RING - at the photon sphere\n    # ==========================================================================\n    photon_ring_theta = np.linspace(0, 2*np.pi, 80)\n    \n    traces.append(go.Scatter3d(\n        x=photon_sphere * np.cos(photon_ring_theta),\n        y=photon_sphere * np.sin(photon_ring_theta),\n        z=np.zeros_like(photon_ring_theta),\n        mode='lines',\n        line=dict(color='rgba(255,230,180,0.9)', width=3),\n        name='Photon Ring',\n        hovertext=(\n            \"Photon Ring: cross-section of the photon sphere at 1.5x Schwarzschild radius. \"\n            \"Light can orbit here, but orbits are unstable - any perturbation sends photons \"\n            \"falling into the black hole or escaping to infinity.\"\n        ),\n        hoverinfo='text',\n        showlegend=True\n    ))\n    \n    # ==========================================================================\n    # BLACK HOLE SPHERE & EVENT HORIZON - Added LAST so it renders IN FRONT\n    # ==========================================================================\n    u = np.linspace(0, 2*np.pi, 30)\n    v = np.linspace(0, np.pi, 20)\n    \n    x = visual_radius * np.outer(np.cos(u), np.sin(v))\n    y = visual_radius * np.outer(np.sin(u), np.sin(v))\n    z = visual_radius * np.outer(np.ones(np.size(u)), np.cos(v))\n    \n    sgr_a_hover = (\n        \"<b>Sagittarius A* (Sgr A*)</b><br><br>\"\n        f\"<b>Supermassive Black Hole</b><br>\"\n        f\"Mass: 4.154 million solar masses<br>\"\n        f\"Schwarzschild Radius: {SCHWARZSCHILD_RADIUS_AU:.4f} AU ({SCHWARZSCHILD_RADIUS_AU * 149597870.7:.0f} km)<br>\"\n        f\"Distance from Earth: 26,670 light-years<br><br>\"\n        f\"<b>Visual Representation (scaled {scale_factor}x):</b><br>\"\n        f\"Black sphere: Event horizon (artistic)<br>\"\n        f\"Red sphere: Actual size to scale<br>\"\n        f\"White ring: Event horizon boundary<br>\"\n        f\"Orange disk: Accretion disk<br><br>\"\n        f\"<i>First imaged by Event Horizon Telescope, May 2022</i>\"\n    )\n    \n    # Black sphere - full opacity to occlude lensing behind it\n    traces.append(go.Surface(\n        x=x, y=y, z=z,\n        colorscale=[[0, 'rgb(10,0,20)'], [1, 'rgb(30,0,50)']],\n        showscale=False,\n        opacity=1.0,  # Full opacity to ensure it occludes\n        name='Sgr A* (Black Hole)',\n        text=sgr_a_hover,\n        hoverinfo='text',\n        showlegend=True\n    ))\n    \n    # Event horizon boundary ring (white for visibility)\n    theta = np.linspace(0, 2*np.pi, 100)\n    traces.append(go.Scatter3d(\n        x=visual_radius * np.cos(theta),\n        y=visual_radius * np.sin(theta),\n        z=np.zeros_like(theta),\n        mode='lines',\n        line=dict(color='white', width=2),\n        name='Event Horizon',\n        hovertext=\"Event Horizon boundary (scaled for visibility)\",\n        hoverinfo='text',\n        showlegend=True\n    ))\n    \n    # ==========================================================================\n    # ACTUAL SIZE BLACK HOLE - True Schwarzschild radius for comparison\n    # ==========================================================================\n    # This tiny sphere shows the real size of the event horizon relative to\n    # the S-star orbits. At ~0.08 AU, it's smaller than Mercury's orbit!\n    # S4714's periapsis of 12.6 AU is still ~150x the Schwarzschild radius.\n    \n    actual_radius = SCHWARZSCHILD_RADIUS_AU  # ~0.0828 AU\n    \n    # Create sphere at actual scale\n    x_actual = actual_radius * np.outer(np.cos(u), np.sin(v))\n    y_actual = actual_radius * np.outer(np.sin(u), np.sin(v))\n    z_actual = actual_radius * np.outer(np.ones(np.size(u)), np.cos(v))\n    \n    actual_hover = (\n        \"<b>Sgr A* - Actual Size</b><br><br>\"\n        f\"<b>True Schwarzschild Radius:</b><br>\"\n        f\"{SCHWARZSCHILD_RADIUS_AU:.4f} AU ({SCHWARZSCHILD_RADIUS_AU * 149597870.7:.0f} km)<br><br>\"\n        f\"<b>For comparison:</b><br>\"\n        f\"Mercury's orbit: 0.39 AU<br>\"\n        f\"Sun's radius: 0.00465 AU<br>\"\n        f\"S4714 periapsis: 12.6 AU (~150x this size)<br>\"\n        f\"S2 periapsis: 120 AU (~1,450x this size)<br><br>\"\n        f\"<i>The artistic representation is {scale_factor}x larger</i><br>\"\n        f\"<i>Red color is for illustration only - black holes emit no visible light</i>\"\n    )\n    \n    # Bright red sphere - stands out against the purple/orange\n    traces.append(go.Surface(\n        x=x_actual, y=y_actual, z=z_actual,\n        colorscale=[[0, 'rgb(200,0,0)'], [1, 'rgb(255,50,50)']],\n        showscale=False,\n        opacity=1.0,\n        name='Sgr A* (Actual Scale)',\n        text=actual_hover,\n        hoverinfo='text',\n        showlegend=True\n    ))\n    \n    return traces",
    "start_line": 150,
    "end_line": 403,
    "has_docstring": true,
    "docstring": "Create the Sagittarius A* black hole marker.\n\nSince the actual Schwarzschild radius (~0.08 AU) would be invisible\nat orbit scales (~1000 AU), we create an artistic representation.\n\nAccretion disk based on observations:\n- Bright inner ring: ~5.2x Schwarzschild radius (EHT 2022)\n- Cool outer disk: extends to ~1000 AU (ALMA 2019, Murchikova et al.)\n\nTrace order matters for rendering:\n- Lensing traces added FIRST (render behind)\n- Black hole sphere added LAST (render in front)\n\nArgs:\n    scale_factor: How much larger than Rs to draw the marker\n\nReturns:\n    List of Plotly traces for Sgr A*",
    "parameters": [
      "scale_factor"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sgr_a_marker",
    "component_id": "sgr_a_visualization_core.create_sgr_a_marker"
  },
  "sgr_a_visualization_core.create_orbit_trace": {
    "id": "sgr_a_visualization_core.create_orbit_trace",
    "name": "create_orbit_trace",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_core.py",
    "relative_path": "sgr_a_visualization_core.py",
    "depends_on": [
      "sgr_a_visualization_core.generate_orbit_points",
      "sgr_a_star_data.get_star_color",
      "sgr_a_visualization_core.generate_position_at_true_anomaly",
      "sgr_a_star_data.format_velocity",
      "sgr_a_star_data.calculate_periapsis_velocity"
    ],
    "source_code": "def create_orbit_trace(star_name, star_data, show_periapsis=True):\n    \"\"\"\n    Create the orbital path trace for a star.\n    \n    Returns:\n        List of Plotly traces\n    \"\"\"\n    traces = []\n    \n    # Get temperature-based color (consistent with exoplanet stars)\n    star_color = get_star_color(star_data)\n    \n    # Generate orbit\n    x, y, z = generate_orbit_points(star_data)\n    \n    # Main orbit line\n    traces.append(go.Scatter3d(\n        x=x, y=y, z=z,\n        mode='lines',\n        line=dict(\n            color=star_color,\n            width=3\n        ),\n        name=star_data['name'],\n        hovertemplate=(\n            f\"<b>{star_data['name']}</b><br>\"\n            f\"Period: {star_data['period_yrs']:.1f} years<br>\"\n            f\"Eccentricity: {star_data['e']:.3f}<br>\"\n            \"<extra></extra>\"\n        )\n    ))\n    \n    if show_periapsis:\n        # Mark periapsis (closest approach) - true anomaly = 0\n        x_peri, y_peri, z_peri, r_peri = generate_position_at_true_anomaly(star_data, 0.0)\n        v_peri = calculate_periapsis_velocity(star_data['a_au'], star_data['e'])\n        \n        traces.append(go.Scatter3d(\n            x=[x_peri], y=[y_peri], z=[z_peri],\n            mode='markers',\n            marker=dict(\n                size=8,\n                color=star_color,\n                symbol='diamond'\n            ),\n            name=f'{star_name} Periapsis',\n            hovertemplate=(\n                f\"<b>{star_data['name']} Periapsis</b><br>\"\n                f\"Distance: {r_peri:.1f} AU<br>\"\n                f\"Velocity: {format_velocity(v_peri)}<br>\"\n                \"<extra></extra>\"\n            ),\n            showlegend=False\n        ))\n        \n        # Mark apoapsis (farthest point) - true anomaly = pi\n        x_apo, y_apo, z_apo, r_apo = generate_position_at_true_anomaly(star_data, np.pi)\n        \n        traces.append(go.Scatter3d(\n            x=[x_apo], y=[y_apo], z=[z_apo],\n            mode='markers',\n            marker=dict(\n                size=5,\n                color=star_color,\n                symbol='circle',\n                opacity=0.5\n            ),\n            name=f'{star_name} Apoapsis',\n            hovertemplate=(\n                f\"<b>{star_data['name']} Apoapsis</b><br>\"\n                f\"Distance: {r_apo:.1f} AU<br>\"\n                \"<extra></extra>\"\n            ),\n            showlegend=False\n        ))\n    \n    return traces",
    "start_line": 405,
    "end_line": 481,
    "has_docstring": true,
    "docstring": "Create the orbital path trace for a star.\n\nReturns:\n    List of Plotly traces",
    "parameters": [
      "star_name",
      "star_data",
      "show_periapsis"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_orbit_trace",
    "component_id": "sgr_a_visualization_core.create_orbit_trace"
  },
  "sgr_a_visualization_core.create_star_marker": {
    "id": "sgr_a_visualization_core.create_star_marker",
    "name": "create_star_marker",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_core.py",
    "relative_path": "sgr_a_visualization_core.py",
    "depends_on": [
      "sgr_a_visualization_core.generate_position_at_true_anomaly",
      "sgr_a_star_data.get_star_color",
      "sgr_a_star_data.calculate_orbital_velocity",
      "sgr_a_star_data.create_star_hover_text"
    ],
    "source_code": "def create_star_marker(star_name, star_data, true_anomaly_rad=0.0, precession_offset_deg=0.0):\n    \"\"\"\n    Create a marker showing the star's current position.\n    \n    Uses temperature-based colors (blackbody) and rich hover text\n    consistent with exoplanet host star visualization.\n    \n    Args:\n        star_name: Key from catalog\n        star_data: Star data dictionary\n        true_anomaly_rad: Current position (radians from periapsis)\n        precession_offset_deg: Accumulated precession\n    \n    Returns:\n        Plotly Scatter3d trace\n    \"\"\"\n    x, y, z, r = generate_position_at_true_anomaly(\n        star_data, true_anomaly_rad, precession_offset_deg\n    )\n    \n    # Calculate current velocity (vis-viva)\n    v = calculate_orbital_velocity(star_data['a_au'], r)\n    \n    # Get temperature-based color (consistent with exoplanet stars)\n    star_color = get_star_color(star_data)\n    \n    # Create rich hover text\n    hover_text = create_star_hover_text(\n        star_name, star_data,\n        current_distance_au=r,\n        current_velocity_km_s=v\n    )\n    \n    return go.Scatter3d(\n        x=[x], y=[y], z=[z],\n        mode='markers',\n        marker=dict(\n            size=12,\n            color=star_color,\n            symbol='circle',\n            line=dict(color='white', width=2)\n        ),\n        name=f'{star_data[\"name\"]} (current)',\n        text=[hover_text],\n        hoverinfo='text',\n        showlegend=False\n    )",
    "start_line": 483,
    "end_line": 529,
    "has_docstring": true,
    "docstring": "Create a marker showing the star's current position.\n\nUses temperature-based colors (blackbody) and rich hover text\nconsistent with exoplanet host star visualization.\n\nArgs:\n    star_name: Key from catalog\n    star_data: Star data dictionary\n    true_anomaly_rad: Current position (radians from periapsis)\n    precession_offset_deg: Accumulated precession\n\nReturns:\n    Plotly Scatter3d trace",
    "parameters": [
      "star_name",
      "star_data",
      "true_anomaly_rad",
      "precession_offset_deg"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_star_marker",
    "component_id": "sgr_a_visualization_core.create_star_marker"
  },
  "sgr_a_visualization_core.create_sgr_a_figure": {
    "id": "sgr_a_visualization_core.create_sgr_a_figure",
    "name": "create_sgr_a_figure",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_core.py",
    "relative_path": "sgr_a_visualization_core.py",
    "depends_on": [
      "sgr_a_star_data.get_star_data",
      "sgr_a_visualization_core.create_star_marker",
      "sgr_a_star_data.calculate_apoapsis_au",
      "sgr_a_visualization_core.create_orbit_trace",
      "sgr_a_star_data.list_stars",
      "sgr_a_visualization_core.create_sgr_a_marker"
    ],
    "source_code": "def create_sgr_a_figure(stars_to_show=None, show_all_stars=False):\n    \"\"\"\n    Create the main Sagittarius A* visualization figure.\n    \n    Args:\n        stars_to_show: List of star names to display. If None, shows S2.\n        show_all_stars: If True, shows all stars in catalog.\n    \n    Returns:\n        Plotly Figure\n    \"\"\"\n    if show_all_stars:\n        stars_to_show = list_stars()\n    elif stars_to_show is None:\n        stars_to_show = ['S2']\n    \n    traces = []\n    \n    # Add Sgr A* (the black hole)\n    traces.extend(create_sgr_a_marker())\n    \n    # Add selected star orbits\n    for star_name in stars_to_show:\n        star_data = get_star_data(star_name)\n        if star_data:\n            traces.extend(create_orbit_trace(star_name, star_data))\n            # Add current position marker (at periapsis for static view)\n            traces.append(create_star_marker(star_name, star_data, true_anomaly_rad=0.0))\n    \n    # Calculate axis range based on largest orbit\n    max_range = 0\n    for star_name in stars_to_show:\n        star_data = get_star_data(star_name)\n        if star_data:\n            apoapsis = calculate_apoapsis_au(star_data['a_au'], star_data['e'])\n            max_range = max(max_range, apoapsis)\n    \n    # Add some padding\n    axis_range = max_range * 1.1\n    \n    # Create figure\n    fig = go.Figure(data=traces)\n    \n    # Layout\n    fig.update_layout(\n        title=dict(\n            text=\"<b>S-Stars Orbiting Sagittarius A*</b><br><sup>The Supermassive Black Hole at the Center of the Milky Way</sup>\",\n            x=0.5,\n            font=dict(size=18)\n        ),\n        scene=dict(\n            xaxis=dict(\n                title='X (AU)',\n                range=[-axis_range, axis_range],\n                backgroundcolor='rgb(10,10,20)',\n                gridcolor='rgb(50,50,70)',\n                showbackground=True\n            ),\n            yaxis=dict(\n                title='Y (AU)',\n                range=[-axis_range, axis_range],\n                backgroundcolor='rgb(10,10,20)',\n                gridcolor='rgb(50,50,70)',\n                showbackground=True\n            ),\n            zaxis=dict(\n                title='Z (AU)',\n                range=[-axis_range, axis_range],\n                backgroundcolor='rgb(10,10,20)',\n                gridcolor='rgb(50,50,70)',\n                showbackground=True\n            ),\n            aspectmode='cube',\n            camera=dict(\n                eye=dict(x=1.5, y=1.5, z=0.8)\n            )\n        ),\n        paper_bgcolor='rgb(10,10,20)',\n        plot_bgcolor='rgb(10,10,20)',\n        font=dict(color='white'),\n        legend=dict(\n            yanchor=\"top\",\n            y=0.99,\n            xanchor=\"left\",\n            x=0.01,\n            bgcolor='rgba(0,0,0,0.5)'\n        ),\n        margin=dict(l=0, r=0, t=80, b=0)\n    )\n    \n    # Add annotation about scale\n    fig.add_annotation(\n        text=f\"Schwarzschild radius: {SCHWARZSCHILD_RADIUS_AU:.2f} AU (black hole marker not to scale)\",\n        xref=\"paper\", yref=\"paper\",\n        x=0.5, y=0.02,\n        showarrow=False,\n        font=dict(size=10, color='gray')\n    )\n    \n    return fig",
    "start_line": 535,
    "end_line": 634,
    "has_docstring": true,
    "docstring": "Create the main Sagittarius A* visualization figure.\n\nArgs:\n    stars_to_show: List of star names to display. If None, shows S2.\n    show_all_stars: If True, shows all stars in catalog.\n\nReturns:\n    Plotly Figure",
    "parameters": [
      "stars_to_show",
      "show_all_stars"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sgr_a_figure",
    "component_id": "sgr_a_visualization_core.create_sgr_a_figure"
  },
  "sgr_a_visualization_core_arcs.generate_orbit_points": {
    "id": "sgr_a_visualization_core_arcs.generate_orbit_points",
    "name": "generate_orbit_points",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_core_arcs.py",
    "relative_path": "sgr_a_visualization_core_arcs.py",
    "depends_on": [],
    "source_code": "def generate_orbit_points(star_data, num_points=360, precession_offset_deg=0.0):\n    \"\"\"\n    Generate 3D orbit points for a star.\n    \n    Args:\n        star_data: Dictionary with orbital elements\n        num_points: Number of points around the orbit\n        precession_offset_deg: Additional rotation to argument of periapsis (for GR precession)\n    \n    Returns:\n        x, y, z: Arrays of orbit coordinates in AU (centered on Sgr A*)\n    \"\"\"\n    # Extract orbital elements\n    a = star_data['a_au']\n    e = star_data['e']\n    i = np.radians(star_data['inclination_deg'])\n    omega = np.radians(star_data['arg_periapsis_deg'] + precession_offset_deg)  # Argument of periapsis\n    Omega = np.radians(star_data['asc_node_deg'])  # Longitude of ascending node\n    \n    # Generate true anomaly values (0 to 2*pi)\n    nu_values = np.linspace(0, 2*np.pi, num_points)\n    \n    # Calculate radius at each true anomaly\n    # r = a(1-e^2) / (1 + e*cos(nu))\n    p = a * (1 - e**2)  # Semi-latus rectum\n    r_values = p / (1 + e * np.cos(nu_values))\n    \n    # Position in orbital plane (x' along periapsis, y' perpendicular)\n    x_orbital = r_values * np.cos(nu_values)\n    y_orbital = r_values * np.sin(nu_values)\n    \n    # Rotation matrices to convert from orbital plane to 3D space\n    # 1. Rotate by argument of periapsis (omega)\n    # 2. Rotate by inclination (i)\n    # 3. Rotate by longitude of ascending node (Omega)\n    \n    # Combined rotation (standard orbital mechanics convention)\n    cos_omega = np.cos(omega)\n    sin_omega = np.sin(omega)\n    cos_i = np.cos(i)\n    sin_i = np.sin(i)\n    cos_Omega = np.cos(Omega)\n    sin_Omega = np.sin(Omega)\n    \n    # Rotation matrix elements\n    # x = (cos_Omega*cos_omega - sin_Omega*sin_omega*cos_i)*x' + (-cos_Omega*sin_omega - sin_Omega*cos_omega*cos_i)*y'\n    # y = (sin_Omega*cos_omega + cos_Omega*sin_omega*cos_i)*x' + (-sin_Omega*sin_omega + cos_Omega*cos_omega*cos_i)*y'\n    # z = (sin_omega*sin_i)*x' + (cos_omega*sin_i)*y'\n    \n    Px = cos_Omega * cos_omega - sin_Omega * sin_omega * cos_i\n    Qx = -cos_Omega * sin_omega - sin_Omega * cos_omega * cos_i\n    \n    Py = sin_Omega * cos_omega + cos_Omega * sin_omega * cos_i\n    Qy = -sin_Omega * sin_omega + cos_Omega * cos_omega * cos_i\n    \n    Pz = sin_omega * sin_i\n    Qz = cos_omega * sin_i\n    \n    # Transform to 3D coordinates\n    x = Px * x_orbital + Qx * y_orbital\n    y = Py * x_orbital + Qy * y_orbital\n    z = Pz * x_orbital + Qz * y_orbital\n    \n    return x, y, z",
    "start_line": 35,
    "end_line": 98,
    "has_docstring": true,
    "docstring": "Generate 3D orbit points for a star.\n\nArgs:\n    star_data: Dictionary with orbital elements\n    num_points: Number of points around the orbit\n    precession_offset_deg: Additional rotation to argument of periapsis (for GR precession)\n\nReturns:\n    x, y, z: Arrays of orbit coordinates in AU (centered on Sgr A*)",
    "parameters": [
      "star_data",
      "num_points",
      "precession_offset_deg"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate_orbit_points",
    "component_id": "sgr_a_visualization_core_arcs.generate_orbit_points"
  },
  "sgr_a_visualization_core_arcs.generate_position_at_true_anomaly": {
    "id": "sgr_a_visualization_core_arcs.generate_position_at_true_anomaly",
    "name": "generate_position_at_true_anomaly",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_core_arcs.py",
    "relative_path": "sgr_a_visualization_core_arcs.py",
    "depends_on": [],
    "source_code": "def generate_position_at_true_anomaly(star_data, true_anomaly_rad, precession_offset_deg=0.0):\n    \"\"\"\n    Generate 3D position for a star at a specific true anomaly.\n    \n    Returns:\n        x, y, z: Position in AU\n        r: Distance from Sgr A* in AU\n    \"\"\"\n    a = star_data['a_au']\n    e = star_data['e']\n    i = np.radians(star_data['inclination_deg'])\n    omega = np.radians(star_data['arg_periapsis_deg'] + precession_offset_deg)\n    Omega = np.radians(star_data['asc_node_deg'])\n    \n    nu = true_anomaly_rad\n    \n    # Radius\n    p = a * (1 - e**2)\n    r = p / (1 + e * np.cos(nu))\n    \n    # Position in orbital plane\n    x_orbital = r * np.cos(nu)\n    y_orbital = r * np.sin(nu)\n    \n    # Rotation (same as above)\n    cos_omega = np.cos(omega)\n    sin_omega = np.sin(omega)\n    cos_i = np.cos(i)\n    sin_i = np.sin(i)\n    cos_Omega = np.cos(Omega)\n    sin_Omega = np.sin(Omega)\n    \n    Px = cos_Omega * cos_omega - sin_Omega * sin_omega * cos_i\n    Qx = -cos_Omega * sin_omega - sin_Omega * cos_omega * cos_i\n    Py = sin_Omega * cos_omega + cos_Omega * sin_omega * cos_i\n    Qy = -sin_Omega * sin_omega + cos_Omega * cos_omega * cos_i\n    Pz = sin_omega * sin_i\n    Qz = cos_omega * sin_i\n    \n    x = Px * x_orbital + Qx * y_orbital\n    y = Py * x_orbital + Qy * y_orbital\n    z = Pz * x_orbital + Qz * y_orbital\n    \n    return x, y, z, r",
    "start_line": 100,
    "end_line": 143,
    "has_docstring": true,
    "docstring": "Generate 3D position for a star at a specific true anomaly.\n\nReturns:\n    x, y, z: Position in AU\n    r: Distance from Sgr A* in AU",
    "parameters": [
      "star_data",
      "true_anomaly_rad",
      "precession_offset_deg"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate_position_at_true_anomaly",
    "component_id": "sgr_a_visualization_core_arcs.generate_position_at_true_anomaly"
  },
  "sgr_a_visualization_core_arcs.create_sgr_a_marker": {
    "id": "sgr_a_visualization_core_arcs.create_sgr_a_marker",
    "name": "create_sgr_a_marker",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_core_arcs.py",
    "relative_path": "sgr_a_visualization_core_arcs.py",
    "depends_on": [],
    "source_code": "def create_sgr_a_marker(scale_factor=50):\n    \"\"\"\n    Create the Sagittarius A* black hole marker.\n    \n    Since the actual Schwarzschild radius (~0.08 AU) would be invisible\n    at orbit scales (~1000 AU), we create an artistic representation.\n    \n    Accretion disk based on observations:\n    - Bright inner ring: ~5.2x Schwarzschild radius (EHT 2022)\n    - Cool outer disk: extends to ~1000 AU (ALMA 2019, Murchikova et al.)\n    \n    Args:\n        scale_factor: How much larger than Rs to draw the marker\n    \n    Returns:\n        List of Plotly traces for Sgr A*\n    \"\"\"\n    traces = []\n    \n    # Effective visual radius (not to physical scale)\n    visual_radius = SCHWARZSCHILD_RADIUS_AU * scale_factor\n    \n    # Create a sphere for the \"event horizon\" (artistic)\n    u = np.linspace(0, 2*np.pi, 30)\n    v = np.linspace(0, np.pi, 20)\n    \n    x = visual_radius * np.outer(np.cos(u), np.sin(v))\n    y = visual_radius * np.outer(np.sin(u), np.sin(v))\n    z = visual_radius * np.outer(np.ones(np.size(u)), np.cos(v))\n    \n    # Rich hover text for the black hole\n    sgr_a_hover = (\n        \"<b>Sagittarius A* (Sgr A*)</b><br><br>\"\n        f\"<b>Supermassive Black Hole</b><br>\"\n        f\"Mass: 4.154 million solar masses<br>\"\n        f\"Schwarzschild Radius: {SCHWARZSCHILD_RADIUS_AU:.4f} AU ({SCHWARZSCHILD_RADIUS_AU * 149597870.7:.0f} km)<br>\"\n        f\"Distance from Earth: 26,670 light-years<br><br>\"\n        f\"<b>Visual Representation (scaled {scale_factor}x):</b><br>\"\n        f\"Black sphere: Event horizon<br>\"\n        f\"White ring: Event horizon boundary<br>\"\n        f\"Orange disk: Accretion disk<br><br>\"\n        f\"<i>First imaged by Event Horizon Telescope, May 2022</i>\"\n    )\n    \n    # Black sphere with slight purple tint (artistic choice)\n    traces.append(go.Surface(\n        x=x, y=y, z=z,\n        colorscale=[[0, 'rgb(10,0,20)'], [1, 'rgb(30,0,50)']],\n        showscale=False,\n        opacity=0.9,\n        name='Sgr A* (Black Hole)',\n        text=sgr_a_hover,\n        hoverinfo='text',\n        showlegend=True\n    ))\n    \n    # Event horizon boundary ring (white for visibility)\n    theta = np.linspace(0, 2*np.pi, 100)\n    traces.append(go.Scatter3d(\n        x=visual_radius * np.cos(theta),\n        y=visual_radius * np.sin(theta),\n        z=np.zeros_like(theta),\n        mode='lines',\n        line=dict(color='white', width=2),\n        name='Event Horizon',\n        hovertext=\"Event Horizon boundary (scaled for visibility)\",\n        hoverinfo='text',\n        showlegend=True\n    ))\n    \n    # ==========================================================================\n    # ACCRETION DISK - Based on observations\n    # ==========================================================================\n    # EHT 2022: Bright ring at ~5.2x Schwarzschild radius\n    # ALMA 2019 (Murchikova et al.): Cool disk extends to ~1000 AU\n    \n    # Create continuous accretion disk surface (like Saturn's rings)\n    # Inner edge: just outside event horizon visual\n    # Outer edge: scaled representation (actual ~1000 AU would be too large)\n    disk_inner = visual_radius * 1.2   # Just outside event horizon\n    disk_outer = visual_radius * 6     # Artistic outer edge\n    \n    # Create disk as a surface with radial gradient\n    r_disk = np.linspace(disk_inner, disk_outer, 30)\n    theta_disk = np.linspace(0, 2*np.pi, 60)\n    R, Theta = np.meshgrid(r_disk, theta_disk)\n    \n    X_disk = R * np.cos(Theta)\n    Y_disk = R * np.sin(Theta)\n    Z_disk = np.zeros_like(R)\n    \n    # Color intensity decreases with radius (hotter near center)\n    color_values = 1 - (R - disk_inner) / (disk_outer - disk_inner)\n    \n    # Accretion disk hover text\n    disk_hover = (\n        \"<b>Accretion Disk</b><br><br>\"\n        \"<b>Observed Properties:</b><br>\"\n        \"Inner bright ring: ~5x Schwarzschild radius<br>\"\n        \"Cool outer disk: extends to ~1000 AU<br>\"\n        \"Temperature: 10,000 K (outer) to millions K (inner)<br>\"\n        \"Mass: ~0.1 Jupiter masses of hydrogen gas<br><br>\"\n        \"<b>Physics:</b><br>\"\n        \"Gas spirals inward, losing angular momentum<br>\"\n        \"Friction heats gas to millions of degrees<br>\"\n        \"Emits X-rays, radio, and infrared light<br><br>\"\n        \"<b>Gravitational Lensing:</b><br>\"\n        \"Light from the far side bends around the black hole<br>\"\n        \"Creates the iconic 'wrapped' appearance<br><br>\"\n        \"<i>First imaged by ALMA 2019 (Murchikova et al.)</i><br>\"\n        \"<i>EHT captured bright inner ring, May 2022</i>\"\n    )\n    \n    traces.append(go.Surface(\n        x=X_disk, y=Y_disk, z=Z_disk,\n        surfacecolor=color_values,\n        colorscale=[\n            [0.0, 'rgba(50,20,0,0.3)'],      # Outer edge - dim\n            [0.3, 'rgba(150,60,0,0.5)'],     # Mid - orange\n            [0.6, 'rgba(255,150,0,0.7)'],    # Inner-mid - bright orange\n            [1.0, 'rgba(255,200,100,0.9)']   # Inner edge - hot yellow-white\n        ],\n        showscale=False,\n        opacity=0.7,\n        name='Accretion Disk',\n        text=disk_hover,\n        hoverinfo='text',\n        showlegend=True\n    ))\n    \n    # ==========================================================================\n    # GRAVITATIONAL LENSING EFFECT\n    # ==========================================================================\n    # Light from the back of the accretion disk bends around the black hole\n    # due to extreme spacetime curvature. This creates the iconic \"photon ring\"\n    # visible in EHT images - light appears to wrap over the top and bottom.\n    #\n    # Physics: At the photon sphere (1.5 Rs), light orbits the black hole.\n    # Light from behind gets bent around, creating arcs above/below the disk.\n    \n    # Photon sphere radius (where light orbits)\n    photon_sphere = visual_radius * 1.5\n    \n    # Create lensed arcs - these represent light from the far side of the disk\n    # that bends around the black hole and reaches the observer\n    \n    # Number of lensed rings (more = smoother, but larger file)\n    n_lensed_rings = 8\n    \n    for i in range(n_lensed_rings):\n        # Each ring represents light from a different radius of the back disk\n        # Inner rings bend more (closer to photon sphere)\n        t = (i + 1) / (n_lensed_rings + 1)  # 0 to 1, inner to outer\n        \n        # Source radius on the far side of the disk\n        source_r = disk_inner + t * (disk_outer - disk_inner) * 0.7\n        \n        # The apparent radius of the lensed light (appears closer to photon sphere)\n        # Light from farther out appears at larger radii\n        apparent_r = photon_sphere + t * (visual_radius * 2)\n        \n        # Height above/below the disk plane - creates the \"wrapped\" arc\n        # Maximum height is roughly proportional to how much bending occurs\n        # More bending for light passing closer to the photon sphere\n        max_height = visual_radius * (1.5 - t * 0.8)\n        \n        # Create arc going over the TOP of the black hole\n        # This is the \"far side\" of the disk lensed over the top\n        arc_theta = np.linspace(-np.pi * 0.8, np.pi * 0.8, 40)  # Partial arc\n        \n        # Parametric arc that goes up and over\n        arc_x_top = apparent_r * np.cos(arc_theta)\n        arc_y_top = apparent_r * np.sin(arc_theta)\n        # Height follows a smooth curve - highest in the middle\n        arc_z_top = max_height * np.cos(arc_theta / 1.6) ** 2\n        \n        # Color fades from bright (inner) to dim (outer)\n        brightness = 1.0 - t * 0.7\n        r_col = int(255 * brightness)\n        g_col = int(150 * brightness)\n        b_col = int(50 * brightness)\n        alpha = 0.6 - t * 0.3\n        \n        traces.append(go.Scatter3d(\n            x=arc_x_top, y=arc_y_top, z=arc_z_top,\n            mode='lines',\n            line=dict(\n                color=f'rgba({r_col},{g_col},{b_col},{alpha})',\n                width=3 - t * 1.5\n            ),\n            hovertext=\"Gravitational lensing: light from far side of disk bent over the black hole\",\n            hoverinfo='text',\n            showlegend=False\n        ))\n        \n        # Create arc going UNDER the black hole (mirror image)\n        arc_z_bottom = -arc_z_top\n        \n        traces.append(go.Scatter3d(\n            x=arc_x_top, y=arc_y_top, z=arc_z_bottom,\n            mode='lines',\n            line=dict(\n                color=f'rgba({r_col},{g_col},{b_col},{alpha})',\n                width=3 - t * 1.5\n            ),\n            hovertext=\"Gravitational lensing: light from far side of disk bent under the black hole\",\n            hoverinfo='text',\n            showlegend=False\n        ))\n    \n    # Add a bright \"photon ring\" at the photon sphere\n    # This is where light can orbit the black hole\n    photon_ring_theta = np.linspace(0, 2*np.pi, 80)\n    \n    # Photon ring wraps around at a slight tilt to show 3D effect\n    traces.append(go.Scatter3d(\n        x=photon_sphere * np.cos(photon_ring_theta),\n        y=photon_sphere * np.sin(photon_ring_theta),\n        z=visual_radius * 0.3 * np.sin(photon_ring_theta * 2),  # Slight wobble for 3D\n        mode='lines',\n        line=dict(color='rgba(255,220,150,0.8)', width=2),\n        name='Photon Ring',\n        hovertext=\"Photon Ring: at 1.5x Schwarzschild radius, light can orbit the black hole\",\n        hoverinfo='text',\n        showlegend=True\n    ))\n    \n    return traces",
    "start_line": 149,
    "end_line": 376,
    "has_docstring": true,
    "docstring": "Create the Sagittarius A* black hole marker.\n\nSince the actual Schwarzschild radius (~0.08 AU) would be invisible\nat orbit scales (~1000 AU), we create an artistic representation.\n\nAccretion disk based on observations:\n- Bright inner ring: ~5.2x Schwarzschild radius (EHT 2022)\n- Cool outer disk: extends to ~1000 AU (ALMA 2019, Murchikova et al.)\n\nArgs:\n    scale_factor: How much larger than Rs to draw the marker\n\nReturns:\n    List of Plotly traces for Sgr A*",
    "parameters": [
      "scale_factor"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sgr_a_marker",
    "component_id": "sgr_a_visualization_core_arcs.create_sgr_a_marker"
  },
  "sgr_a_visualization_core_arcs.create_orbit_trace": {
    "id": "sgr_a_visualization_core_arcs.create_orbit_trace",
    "name": "create_orbit_trace",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_core_arcs.py",
    "relative_path": "sgr_a_visualization_core_arcs.py",
    "depends_on": [
      "sgr_a_visualization_core_arcs.generate_orbit_points",
      "sgr_a_star_data.get_star_color",
      "sgr_a_star_data.format_velocity",
      "sgr_a_star_data.calculate_periapsis_velocity",
      "sgr_a_visualization_core_arcs.generate_position_at_true_anomaly"
    ],
    "source_code": "def create_orbit_trace(star_name, star_data, show_periapsis=True):\n    \"\"\"\n    Create the orbital path trace for a star.\n    \n    Returns:\n        List of Plotly traces\n    \"\"\"\n    traces = []\n    \n    # Get temperature-based color (consistent with exoplanet stars)\n    star_color = get_star_color(star_data)\n    \n    # Generate orbit\n    x, y, z = generate_orbit_points(star_data)\n    \n    # Main orbit line\n    traces.append(go.Scatter3d(\n        x=x, y=y, z=z,\n        mode='lines',\n        line=dict(\n            color=star_color,\n            width=3\n        ),\n        name=star_data['name'],\n        hovertemplate=(\n            f\"<b>{star_data['name']}</b><br>\"\n            f\"Period: {star_data['period_yrs']:.1f} years<br>\"\n            f\"Eccentricity: {star_data['e']:.3f}<br>\"\n            \"<extra></extra>\"\n        )\n    ))\n    \n    if show_periapsis:\n        # Mark periapsis (closest approach) - true anomaly = 0\n        x_peri, y_peri, z_peri, r_peri = generate_position_at_true_anomaly(star_data, 0.0)\n        v_peri = calculate_periapsis_velocity(star_data['a_au'], star_data['e'])\n        \n        traces.append(go.Scatter3d(\n            x=[x_peri], y=[y_peri], z=[z_peri],\n            mode='markers',\n            marker=dict(\n                size=8,\n                color=star_color,\n                symbol='diamond'\n            ),\n            name=f'{star_name} Periapsis',\n            hovertemplate=(\n                f\"<b>{star_data['name']} Periapsis</b><br>\"\n                f\"Distance: {r_peri:.1f} AU<br>\"\n                f\"Velocity: {format_velocity(v_peri)}<br>\"\n                \"<extra></extra>\"\n            ),\n            showlegend=False\n        ))\n        \n        # Mark apoapsis (farthest point) - true anomaly = pi\n        x_apo, y_apo, z_apo, r_apo = generate_position_at_true_anomaly(star_data, np.pi)\n        \n        traces.append(go.Scatter3d(\n            x=[x_apo], y=[y_apo], z=[z_apo],\n            mode='markers',\n            marker=dict(\n                size=5,\n                color=star_color,\n                symbol='circle',\n                opacity=0.5\n            ),\n            name=f'{star_name} Apoapsis',\n            hovertemplate=(\n                f\"<b>{star_data['name']} Apoapsis</b><br>\"\n                f\"Distance: {r_apo:.1f} AU<br>\"\n                \"<extra></extra>\"\n            ),\n            showlegend=False\n        ))\n    \n    return traces",
    "start_line": 378,
    "end_line": 454,
    "has_docstring": true,
    "docstring": "Create the orbital path trace for a star.\n\nReturns:\n    List of Plotly traces",
    "parameters": [
      "star_name",
      "star_data",
      "show_periapsis"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_orbit_trace",
    "component_id": "sgr_a_visualization_core_arcs.create_orbit_trace"
  },
  "sgr_a_visualization_core_arcs.create_star_marker": {
    "id": "sgr_a_visualization_core_arcs.create_star_marker",
    "name": "create_star_marker",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_core_arcs.py",
    "relative_path": "sgr_a_visualization_core_arcs.py",
    "depends_on": [
      "sgr_a_visualization_core_arcs.generate_position_at_true_anomaly",
      "sgr_a_star_data.calculate_orbital_velocity",
      "sgr_a_star_data.get_star_color",
      "sgr_a_star_data.create_star_hover_text"
    ],
    "source_code": "def create_star_marker(star_name, star_data, true_anomaly_rad=0.0, precession_offset_deg=0.0):\n    \"\"\"\n    Create a marker showing the star's current position.\n    \n    Uses temperature-based colors (blackbody) and rich hover text\n    consistent with exoplanet host star visualization.\n    \n    Args:\n        star_name: Key from catalog\n        star_data: Star data dictionary\n        true_anomaly_rad: Current position (radians from periapsis)\n        precession_offset_deg: Accumulated precession\n    \n    Returns:\n        Plotly Scatter3d trace\n    \"\"\"\n    x, y, z, r = generate_position_at_true_anomaly(\n        star_data, true_anomaly_rad, precession_offset_deg\n    )\n    \n    # Calculate current velocity (vis-viva)\n    v = calculate_orbital_velocity(star_data['a_au'], r)\n    \n    # Get temperature-based color (consistent with exoplanet stars)\n    star_color = get_star_color(star_data)\n    \n    # Create rich hover text\n    hover_text = create_star_hover_text(\n        star_name, star_data,\n        current_distance_au=r,\n        current_velocity_km_s=v\n    )\n    \n    return go.Scatter3d(\n        x=[x], y=[y], z=[z],\n        mode='markers',\n        marker=dict(\n            size=12,\n            color=star_color,\n            symbol='circle',\n            line=dict(color='white', width=2)\n        ),\n        name=f'{star_data[\"name\"]} (current)',\n        text=[hover_text],\n        hoverinfo='text',\n        showlegend=False\n    )",
    "start_line": 456,
    "end_line": 502,
    "has_docstring": true,
    "docstring": "Create a marker showing the star's current position.\n\nUses temperature-based colors (blackbody) and rich hover text\nconsistent with exoplanet host star visualization.\n\nArgs:\n    star_name: Key from catalog\n    star_data: Star data dictionary\n    true_anomaly_rad: Current position (radians from periapsis)\n    precession_offset_deg: Accumulated precession\n\nReturns:\n    Plotly Scatter3d trace",
    "parameters": [
      "star_name",
      "star_data",
      "true_anomaly_rad",
      "precession_offset_deg"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_star_marker",
    "component_id": "sgr_a_visualization_core_arcs.create_star_marker"
  },
  "sgr_a_visualization_core_arcs.create_sgr_a_figure": {
    "id": "sgr_a_visualization_core_arcs.create_sgr_a_figure",
    "name": "create_sgr_a_figure",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_core_arcs.py",
    "relative_path": "sgr_a_visualization_core_arcs.py",
    "depends_on": [
      "sgr_a_star_data.get_star_data",
      "sgr_a_visualization_core_arcs.create_orbit_trace",
      "sgr_a_star_data.calculate_apoapsis_au",
      "sgr_a_visualization_core_arcs.create_star_marker",
      "sgr_a_visualization_core_arcs.create_sgr_a_marker",
      "sgr_a_star_data.list_stars"
    ],
    "source_code": "def create_sgr_a_figure(stars_to_show=None, show_all_stars=False):\n    \"\"\"\n    Create the main Sagittarius A* visualization figure.\n    \n    Args:\n        stars_to_show: List of star names to display. If None, shows S2.\n        show_all_stars: If True, shows all stars in catalog.\n    \n    Returns:\n        Plotly Figure\n    \"\"\"\n    if show_all_stars:\n        stars_to_show = list_stars()\n    elif stars_to_show is None:\n        stars_to_show = ['S2']\n    \n    traces = []\n    \n    # Add Sgr A* (the black hole)\n    traces.extend(create_sgr_a_marker())\n    \n    # Add selected star orbits\n    for star_name in stars_to_show:\n        star_data = get_star_data(star_name)\n        if star_data:\n            traces.extend(create_orbit_trace(star_name, star_data))\n            # Add current position marker (at periapsis for static view)\n            traces.append(create_star_marker(star_name, star_data, true_anomaly_rad=0.0))\n    \n    # Calculate axis range based on largest orbit\n    max_range = 0\n    for star_name in stars_to_show:\n        star_data = get_star_data(star_name)\n        if star_data:\n            apoapsis = calculate_apoapsis_au(star_data['a_au'], star_data['e'])\n            max_range = max(max_range, apoapsis)\n    \n    # Add some padding\n    axis_range = max_range * 1.1\n    \n    # Create figure\n    fig = go.Figure(data=traces)\n    \n    # Layout\n    fig.update_layout(\n        title=dict(\n            text=\"<b>S-Stars Orbiting Sagittarius A*</b><br><sup>The Supermassive Black Hole at the Center of the Milky Way</sup>\",\n            x=0.5,\n            font=dict(size=18)\n        ),\n        scene=dict(\n            xaxis=dict(\n                title='X (AU)',\n                range=[-axis_range, axis_range],\n                backgroundcolor='rgb(10,10,20)',\n                gridcolor='rgb(50,50,70)',\n                showbackground=True\n            ),\n            yaxis=dict(\n                title='Y (AU)',\n                range=[-axis_range, axis_range],\n                backgroundcolor='rgb(10,10,20)',\n                gridcolor='rgb(50,50,70)',\n                showbackground=True\n            ),\n            zaxis=dict(\n                title='Z (AU)',\n                range=[-axis_range, axis_range],\n                backgroundcolor='rgb(10,10,20)',\n                gridcolor='rgb(50,50,70)',\n                showbackground=True\n            ),\n            aspectmode='cube',\n            camera=dict(\n                eye=dict(x=1.5, y=1.5, z=0.8)\n            )\n        ),\n        paper_bgcolor='rgb(10,10,20)',\n        plot_bgcolor='rgb(10,10,20)',\n        font=dict(color='white'),\n        legend=dict(\n            yanchor=\"top\",\n            y=0.99,\n            xanchor=\"left\",\n            x=0.01,\n            bgcolor='rgba(0,0,0,0.5)'\n        ),\n        margin=dict(l=0, r=0, t=80, b=0)\n    )\n    \n    # Add annotation about scale\n    fig.add_annotation(\n        text=f\"Schwarzschild radius: {SCHWARZSCHILD_RADIUS_AU:.2f} AU (black hole marker not to scale)\",\n        xref=\"paper\", yref=\"paper\",\n        x=0.5, y=0.02,\n        showarrow=False,\n        font=dict(size=10, color='gray')\n    )\n    \n    return fig",
    "start_line": 508,
    "end_line": 607,
    "has_docstring": true,
    "docstring": "Create the main Sagittarius A* visualization figure.\n\nArgs:\n    stars_to_show: List of star names to display. If None, shows S2.\n    show_all_stars: If True, shows all stars in catalog.\n\nReturns:\n    Plotly Figure",
    "parameters": [
      "stars_to_show",
      "show_all_stars"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sgr_a_figure",
    "component_id": "sgr_a_visualization_core_arcs.create_sgr_a_figure"
  },
  "sgr_a_visualization_precession.apply_accuracy_patches": {
    "id": "sgr_a_visualization_precession.apply_accuracy_patches",
    "name": "apply_accuracy_patches",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_precession.py",
    "relative_path": "sgr_a_visualization_precession.py",
    "depends_on": [
      "sgr_a_star_data.get_star_data",
      "sgr_a_star_data.calculate_periapsis_au",
      "sgr_a_star_data.format_velocity",
      "sgr_a_star_data.calculate_periapsis_velocity"
    ],
    "source_code": "def apply_accuracy_patches():\n    \"\"\"Apply literature-based corrections to orbital elements.\"\"\"\n    # Patch S4714\n    for key, value in S4714_ACCURACY_PATCH.items():\n        data.S_STAR_CATALOG['S4714'][key] = value\n    \n    # Verify the patch\n    star = data.get_star_data('S4714')\n    peri = data.calculate_periapsis_au(star['a_au'], star['e'])\n    v_peri = data.calculate_periapsis_velocity(star['a_au'], star['e'])\n    print(f\"S4714 patched: periapsis = {peri:.1f} AU, velocity = {data.format_velocity(v_peri)}\")",
    "start_line": 36,
    "end_line": 46,
    "has_docstring": true,
    "docstring": "Apply literature-based corrections to orbital elements.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function apply_accuracy_patches",
    "component_id": "sgr_a_visualization_precession.apply_accuracy_patches"
  },
  "sgr_a_visualization_precession.generate_rosette_trace": {
    "id": "sgr_a_visualization_precession.generate_rosette_trace",
    "name": "generate_rosette_trace",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_precession.py",
    "relative_path": "sgr_a_visualization_precession.py",
    "depends_on": [
      "sgr_a_star_data.get_star_data",
      "sgr_a_star_data.calculate_schwarzschild_precession_per_orbit",
      "sgr_a_visualization_core_arcs.generate_orbit_points"
    ],
    "source_code": "def generate_rosette_trace(star_name, num_orbits=50, points_per_orbit=120):\n    \"\"\"\n    Generate a continuous 3D trace of a precessing orbit over many cycles.\n    \n    This creates the famous \"rosette\" or \"spirograph\" pattern that proves\n    General Relativity - the orbit doesn't close on itself, it rotates.\n    \n    Args:\n        star_name: Name of star in catalog\n        num_orbits: Number of orbital cycles to trace\n        points_per_orbit: Resolution of each orbit\n    \n    Returns:\n        x, y, z: Arrays of coordinates\n        time_fraction: Array for color mapping (0 = now, 1 = far future)\n        precession_rate: Degrees per orbit\n        total_precession: Total rotation over all orbits\n    \"\"\"\n    star = data.get_star_data(star_name)\n    \n    # Calculate precession rate (degrees per orbit)\n    precession_deg_per_orbit = data.calculate_schwarzschild_precession_per_orbit(\n        star['a_au'], star['e']\n    )\n    \n    total_precession = precession_deg_per_orbit * num_orbits\n    \n    print(f\"Generating rosette for {star['name']}:\")\n    print(f\"  Semi-major axis: {star['a_au']:.0f} AU\")\n    print(f\"  Eccentricity: {star['e']:.4f}\")\n    print(f\"  Precession rate: {precession_deg_per_orbit:.4f} deg/orbit ({precession_deg_per_orbit*60:.1f} arcmin/orbit)\")\n    print(f\"  Simulating {num_orbits} orbits = {total_precession:.1f} deg total rotation\")\n    print(f\"  Time span: {num_orbits * star['period_yrs']:.0f} years\")\n    \n    all_x, all_y, all_z = [], [], []\n    time_fractions = []\n    \n    # Generate each orbit with accumulated precession\n    for n in range(num_orbits):\n        # Accumulated precession for this orbit\n        accumulated_precession = n * precession_deg_per_orbit\n        \n        # Generate orbit points with this precession offset\n        x, y, z = core.generate_orbit_points(\n            star,\n            num_points=points_per_orbit,\n            precession_offset_deg=accumulated_precession\n        )\n        \n        all_x.extend(x)\n        all_y.extend(y)\n        all_z.extend(z)\n        \n        # Time fraction for color gradient (0 = start, 1 = end)\n        time_fractions.extend([n / num_orbits] * len(x))\n    \n    return (np.array(all_x), np.array(all_y), np.array(all_z), \n            np.array(time_fractions), precession_deg_per_orbit, total_precession)",
    "start_line": 55,
    "end_line": 112,
    "has_docstring": true,
    "docstring": "Generate a continuous 3D trace of a precessing orbit over many cycles.\n\nThis creates the famous \"rosette\" or \"spirograph\" pattern that proves\nGeneral Relativity - the orbit doesn't close on itself, it rotates.\n\nArgs:\n    star_name: Name of star in catalog\n    num_orbits: Number of orbital cycles to trace\n    points_per_orbit: Resolution of each orbit\n\nReturns:\n    x, y, z: Arrays of coordinates\n    time_fraction: Array for color mapping (0 = now, 1 = far future)\n    precession_rate: Degrees per orbit\n    total_precession: Total rotation over all orbits",
    "parameters": [
      "star_name",
      "num_orbits",
      "points_per_orbit"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate_rosette_trace",
    "component_id": "sgr_a_visualization_precession.generate_rosette_trace"
  },
  "sgr_a_visualization_precession.generate_single_orbit_trace": {
    "id": "sgr_a_visualization_precession.generate_single_orbit_trace",
    "name": "generate_single_orbit_trace",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_precession.py",
    "relative_path": "sgr_a_visualization_precession.py",
    "depends_on": [
      "sgr_a_star_data.get_star_data",
      "sgr_a_visualization_core_arcs.generate_orbit_points"
    ],
    "source_code": "def generate_single_orbit_trace(star_name, precession_offset_deg=0.0):\n    \"\"\"Generate a single orbit for comparison/overlay.\"\"\"\n    star = data.get_star_data(star_name)\n    x, y, z = core.generate_orbit_points(star, precession_offset_deg=precession_offset_deg)\n    return x, y, z",
    "start_line": 114,
    "end_line": 118,
    "has_docstring": true,
    "docstring": "Generate a single orbit for comparison/overlay.",
    "parameters": [
      "star_name",
      "precession_offset_deg"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate_single_orbit_trace",
    "component_id": "sgr_a_visualization_precession.generate_single_orbit_trace"
  },
  "sgr_a_visualization_precession.create_rosette_visualization": {
    "id": "sgr_a_visualization_precession.create_rosette_visualization",
    "name": "create_rosette_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_precession.py",
    "relative_path": "sgr_a_visualization_precession.py",
    "depends_on": [
      "sgr_a_visualization_precession.generate_single_orbit_trace",
      "sgr_a_visualization_precession.generate_rosette_trace",
      "sgr_a_star_data.get_star_data",
      "sgr_a_star_data.calculate_apoapsis_au",
      "sgr_a_visualization_core_arcs.create_sgr_a_marker"
    ],
    "source_code": "def create_rosette_visualization(stars_to_show=None):\n    \"\"\"\n    Create the rosette visualization showing Schwarzschild precession.\n    \n    Args:\n        stars_to_show: List of star names. Default: S2 and S4714 (the contrast is dramatic)\n    \n    Returns:\n        Plotly Figure\n    \"\"\"\n    if stars_to_show is None:\n        stars_to_show = ['S2', 'S4714']\n    \n    fig = go.Figure()\n    \n    # =========================================================================\n    # 1. Add Sgr A* (Black Hole)\n    # =========================================================================\n    fig.add_traces(core.create_sgr_a_marker(scale_factor=30))\n    \n    # =========================================================================\n    # 2. Generate Rosette for Each Star\n    # =========================================================================\n    \n    # Color schemes for different stars\n    colorscales = {\n        'S2': 'Viridis',      # Blue -> Green -> Yellow\n        'S62': 'Cividis',     # Blue -> Yellow\n        'S4711': 'Blues',     # Light -> Dark Blue\n        'S4714': 'Plasma',    # Purple -> Orange -> Yellow\n    }\n    \n    # Number of orbits to simulate (more for slower precession)\n    orbit_counts = {\n        'S2': 100,      # 0.2 deg/orbit -> need many to see pattern\n        'S62': 40,      # 1.3 deg/orbit -> faster precession\n        'S4711': 80,    # 0.19 deg/orbit -> similar to S2\n        'S4714': 50,    # 2.9 deg/orbit -> very fast, dramatic rosette\n    }\n    \n    max_range = 0\n    colorbar_positions = [0.85, 0.15]  # Alternate positions for multiple colorbars\n    \n    for i, star_name in enumerate(stars_to_show):\n        star = data.get_star_data(star_name)\n        if star is None:\n            continue\n        \n        n_orbits = orbit_counts.get(star_name, 50)\n        \n        # Generate the rosette trace\n        x, y, z, time_vals, rate, total = generate_rosette_trace(\n            star_name, \n            num_orbits=n_orbits\n        )\n        \n        # Update max range for axis scaling\n        apoapsis = data.calculate_apoapsis_au(star['a_au'], star['e'])\n        max_range = max(max_range, apoapsis)\n        \n        # Add the rosette trace\n        fig.add_trace(go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='lines',\n            line=dict(\n                width=2,\n                color=time_vals,\n                colorscale=colorscales.get(star_name, 'Viridis'),\n                showscale=True,\n                cmin=0,\n                cmax=1,\n                colorbar=dict(\n                    title=dict(\n                        text=f\"{star_name}<br>Time\",\n                        font=dict(size=10)\n                    ),\n                    ticktext=['Now', 'Future'],\n                    tickvals=[0, 1],\n                    len=0.3,\n                    y=colorbar_positions[i % len(colorbar_positions)],\n                    x=1.02\n                )\n            ),\n            name=f\"{star['name']} ({rate:.2f} deg/orbit)\",\n            hovertemplate=(\n                f\"<b>{star['name']}</b><br>\"\n                f\"Precession: {rate:.3f} deg/orbit<br>\"\n                f\"Total rotation: {total:.1f} deg over {n_orbits} orbits<br>\"\n                \"<extra></extra>\"\n            )\n        ))\n        \n        # Add a highlighted \"current\" orbit (first orbit, no precession)\n        x0, y0, z0 = generate_single_orbit_trace(star_name, precession_offset_deg=0)\n        fig.add_trace(go.Scatter3d(\n            x=x0, y=y0, z=z0,\n            mode='lines',\n            line=dict(\n                width=4,\n                color='white',\n                dash='solid'\n            ),\n            name=f\"{star_name} (current orbit)\",\n            opacity=0.8,\n            showlegend=True\n        ))\n    \n    # =========================================================================\n    # 3. Layout\n    # =========================================================================\n    \n    axis_range = max_range * 1.15\n    \n    fig.update_layout(\n        title=dict(\n            text=\"<b>General Relativity in Action: Schwarzschild Precession</b><br>\"\n                 \"<sup>Orbits don't close - they rotate, tracing a 'rosette' pattern over time</sup>\",\n            x=0.5,\n            font=dict(size=16, color='white')\n        ),\n        scene=dict(\n            xaxis=dict(\n                title='X (AU)',\n                range=[-axis_range, axis_range],\n                backgroundcolor='rgb(5,5,15)',\n                gridcolor='rgb(30,30,50)',\n                showbackground=True,\n                gridwidth=1\n            ),\n            yaxis=dict(\n                title='Y (AU)',\n                range=[-axis_range, axis_range],\n                backgroundcolor='rgb(5,5,15)',\n                gridcolor='rgb(30,30,50)',\n                showbackground=True,\n                gridwidth=1\n            ),\n            zaxis=dict(\n                title='Z (AU)',\n                range=[-axis_range, axis_range],\n                backgroundcolor='rgb(5,5,15)',\n                gridcolor='rgb(30,30,50)',\n                showbackground=True,\n                gridwidth=1\n            ),\n            aspectmode='cube',\n            camera=dict(\n                eye=dict(x=1.5, y=0.5, z=0.8)  # Angled view to see rosette structure\n            )\n        ),\n        paper_bgcolor='rgb(5,5,15)',\n        plot_bgcolor='rgb(5,5,15)',\n        font=dict(color='white'),\n        legend=dict(\n            yanchor=\"top\",\n            y=0.99,\n            xanchor=\"left\",\n            x=0.01,\n            bgcolor='rgba(0,0,0,0.7)',\n            font=dict(size=10)\n        ),\n        margin=dict(l=0, r=100, t=80, b=0)\n    )\n    \n    # Add explanatory annotations\n    fig.add_annotation(\n        text=\"White line = current orbit | Colored spiral = future path as orbit precesses\",\n        xref=\"paper\", yref=\"paper\",\n        x=0.5, y=-0.02,\n        showarrow=False,\n        font=dict(size=11, color='lightgray')\n    )\n    \n    fig.add_annotation(\n        text=\"S4714: ~3 deg/orbit precession (dramatic spiral)<br>\"\n             \"S2: ~0.2 deg/orbit (subtle - what GRAVITY measured for 27 years)\",\n        xref=\"paper\", yref=\"paper\",\n        x=0.02, y=0.02,\n        showarrow=False,\n        font=dict(size=10, color='yellow'),\n        align='left',\n        bgcolor='rgba(0,0,0,0.5)'\n    )\n    \n    return fig",
    "start_line": 124,
    "end_line": 308,
    "has_docstring": true,
    "docstring": "Create the rosette visualization showing Schwarzschild precession.\n\nArgs:\n    stars_to_show: List of star names. Default: S2 and S4714 (the contrast is dramatic)\n\nReturns:\n    Plotly Figure",
    "parameters": [
      "stars_to_show"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_rosette_visualization",
    "component_id": "sgr_a_visualization_precession.create_rosette_visualization"
  },
  "sgr_a_visualization_precession.create_single_star_rosette": {
    "id": "sgr_a_visualization_precession.create_single_star_rosette",
    "name": "create_single_star_rosette",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_precession.py",
    "relative_path": "sgr_a_visualization_precession.py",
    "depends_on": [
      "sgr_a_visualization_precession.create_rosette_visualization"
    ],
    "source_code": "def create_single_star_rosette(star_name, num_orbits=None):\n    \"\"\"\n    Create a focused rosette visualization for a single star.\n    Useful for educational deep-dives.\n    \"\"\"\n    return create_rosette_visualization(stars_to_show=[star_name])",
    "start_line": 310,
    "end_line": 315,
    "has_docstring": true,
    "docstring": "Create a focused rosette visualization for a single star.\nUseful for educational deep-dives.",
    "parameters": [
      "star_name",
      "num_orbits"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_single_star_rosette",
    "component_id": "sgr_a_visualization_precession.create_single_star_rosette"
  },
  "sgr_a_visualization_precession.create_newton_vs_einstein_comparison": {
    "id": "sgr_a_visualization_precession.create_newton_vs_einstein_comparison",
    "name": "create_newton_vs_einstein_comparison",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\sgr_a_visualization_precession.py",
    "relative_path": "sgr_a_visualization_precession.py",
    "depends_on": [
      "sgr_a_visualization_core_arcs.generate_orbit_points",
      "sgr_a_star_data.get_star_data",
      "sgr_a_star_data.calculate_schwarzschild_precession_per_orbit",
      "sgr_a_star_data.calculate_apoapsis_au",
      "sgr_a_visualization_core_arcs.create_sgr_a_marker"
    ],
    "source_code": "def create_newton_vs_einstein_comparison(star_name='S2'):\n    \"\"\"\n    Create a side-by-side comparison showing:\n    - Newton: Orbit closes perfectly (same ellipse forever)\n    - Einstein: Orbit precesses (rosette pattern)\n    \n    This is THE visualization that proves General Relativity.\n    \"\"\"\n    fig = go.Figure()\n    \n    star = data.get_star_data(star_name)\n    precession_rate = data.calculate_schwarzschild_precession_per_orbit(star['a_au'], star['e'])\n    \n    # Exaggerate precession for visual clarity (10x)\n    # In reality S2's precession is subtle, but this shows the CONCEPT\n    exaggeration_factor = 10\n    \n    print(f\"\\nNewton vs Einstein comparison for {star['name']}\")\n    print(f\"  Actual precession: {precession_rate:.3f} deg/orbit\")\n    print(f\"  Exaggerated (10x): {precession_rate * exaggeration_factor:.3f} deg/orbit\")\n    \n    # Newton's prediction: same orbit forever\n    x_newton, y_newton, z_newton = core.generate_orbit_points(star)\n    \n    fig.add_trace(go.Scatter3d(\n        x=x_newton, y=y_newton, z=z_newton,\n        mode='lines',\n        line=dict(width=4, color='red'),\n        name=\"Newton's Prediction (orbit closes)\",\n        opacity=0.8\n    ))\n    \n    # Einstein's prediction: orbits precess\n    num_orbits = 20\n    all_x, all_y, all_z = [], [], []\n    \n    for n in range(num_orbits):\n        offset = n * precession_rate * exaggeration_factor\n        x, y, z = core.generate_orbit_points(star, precession_offset_deg=offset)\n        all_x.extend(x)\n        all_y.extend(y)\n        all_z.extend(z)\n    \n    fig.add_trace(go.Scatter3d(\n        x=all_x, y=all_y, z=all_z,\n        mode='lines',\n        line=dict(width=2, color='cyan'),\n        name=\"Einstein's Prediction (orbit precesses)\",\n        opacity=0.6\n    ))\n    \n    # Add Sgr A*\n    fig.add_traces(core.create_sgr_a_marker(scale_factor=30))\n    \n    # Layout\n    apoapsis = data.calculate_apoapsis_au(star['a_au'], star['e'])\n    axis_range = apoapsis * 1.15\n    \n    fig.update_layout(\n        title=dict(\n            text=f\"<b>Newton vs Einstein: {star['name']}'s Orbit</b><br>\"\n                 f\"<sup>Precession exaggerated 10x for visibility (actual: {precession_rate:.2f} deg/orbit)</sup>\",\n            x=0.5,\n            font=dict(size=16, color='white')\n        ),\n        scene=dict(\n            xaxis=dict(title='X (AU)', range=[-axis_range, axis_range], backgroundcolor='rgb(5,5,15)'),\n            yaxis=dict(title='Y (AU)', range=[-axis_range, axis_range], backgroundcolor='rgb(5,5,15)'),\n            zaxis=dict(title='Z (AU)', range=[-axis_range, axis_range], backgroundcolor='rgb(5,5,15)'),\n            aspectmode='cube',\n            camera=dict(eye=dict(x=0, y=0, z=2.5))  # Top-down view\n        ),\n        paper_bgcolor='rgb(5,5,15)',\n        font=dict(color='white'),\n        legend=dict(\n            yanchor=\"top\", y=0.99,\n            xanchor=\"left\", x=0.01,\n            bgcolor='rgba(0,0,0,0.7)'\n        )\n    )\n    \n    fig.add_annotation(\n        text=\"Red = Newton (same ellipse forever)<br>Cyan = Einstein (ellipse rotates)\",\n        xref=\"paper\", yref=\"paper\",\n        x=0.98, y=0.02,\n        showarrow=False,\n        font=dict(size=11, color='white'),\n        align='right',\n        bgcolor='rgba(0,0,0,0.5)'\n    )\n    \n    return fig",
    "start_line": 321,
    "end_line": 412,
    "has_docstring": true,
    "docstring": "Create a side-by-side comparison showing:\n- Newton: Orbit closes perfectly (same ellipse forever)\n- Einstein: Orbit precesses (rosette pattern)\n\nThis is THE visualization that proves General Relativity.",
    "parameters": [
      "star_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_newton_vs_einstein_comparison",
    "component_id": "sgr_a_visualization_precession.create_newton_vs_einstein_comparison"
  },
  "shared_utilities.create_sun_direction_indicator": {
    "id": "shared_utilities.create_sun_direction_indicator",
    "name": "create_sun_direction_indicator",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\shared_utilities.py",
    "relative_path": "shared_utilities.py",
    "depends_on": [],
    "source_code": "def create_sun_direction_indicator(center_position=(0, 0, 0), axis_range=None, shell_radius=None, \n                              object_type=None, center_object=None):\n    \"\"\"\n    Creates a visual indicator showing the direction to the Sun (along negative X-axis).\n    Scale automatically adjusts based on the plot's axis range or provided shell radius.\n    Conditionally shows the indicator based on the object type and center object.\n    \n    Parameters:\n        center_position (tuple): (x, y, z) position of the body's center\n        axis_range (list): The axis range [min, max] used in the plot\n        shell_radius (float): Radius of the shell being displayed, to scale indicator appropriately\n        object_type (str): Type of object being visualized ('Sun' or a planet name)\n        center_object (str): Name of the object at the center of the plot\n    \"\"\"\n    # Check conditions for showing the sun direction indicator\n    # Case 1: If this is a Sun shell, don't show indicator (Sun doesn't need direction to itself)\n    if object_type == 'Sun':\n        print(f\"Sun direction indicator: Not showing for Sun shells\")\n        return []\n        \n    # Case 2: For planet shells, only show when that planet is the center object\n    if object_type is not None and center_object is not None and object_type != center_object:\n        print(f\"Sun direction indicator: Not showing for {object_type} shells when {center_object} is at center\")\n        return []\n    \n    # Case 3: When center_object is 'Sun' and this is a planet shell, don't show the indicator\n    if center_object == 'Sun' and object_type is not None and object_type != 'Sun':\n        print(f\"Sun direction indicator: Not showing planetary shell indicators when Sun is the center object\")\n        return []\n\n    center_x, center_y, center_z = center_position\n    \n    # First priority: Use shell_radius if provided\n    if shell_radius is not None and isinstance(shell_radius, (int, float)) and shell_radius > 0:\n        # Use a fraction of the shell radius for the indicator length\n        plot_scale = shell_radius * 1.15  # 110% of shell radius\n        print(f\"Sun direction indicator: Using shell radius {shell_radius}, scale = {plot_scale:.5f} AU\")\n    else:\n        # Second priority: Try to extract plot scale from axis_range\n        try:\n            if axis_range is not None and isinstance(axis_range, (list, tuple)) and len(axis_range) >= 2:\n                # Extract min and max values and ensure they're floats\n                min_val = float(axis_range[0])\n                max_val = float(axis_range[1])\n                \n                # Calculate total scale range and distance to negative X boundary\n                scale_range = abs(max_val - min_val)\n                distance_to_neg_x = abs(center_x - min_val)\n                \n                # Use 10% of total range as the scale\n                plot_scale = scale_range * 0.1\n                print(f\"Sun direction indicator: Using 10% of range, scale = {plot_scale:.5f} AU\")\n            \n            # If axis_range is invalid, use fallback scale based on plot size\n            else:\n                # Determine appropriate scale based on plot content\n                if center_position != (0, 0, 0):\n                    # For non-center objects, use 1/20th of the distance from origin\n                    pos_distance = np.sqrt(center_x**2 + center_y**2 + center_z**2)\n                    plot_scale = pos_distance / 20.0\n                    print(f\"Sun direction indicator: Using 1/20 of position distance, scale = {plot_scale:.5f} AU\")\n                else:\n                    # For center objects, use a reasonable default based on URL or filename\n                    import os\n                    filename = os.path.basename(os.path.abspath(__file__))\n                    \n                    # Default scale based on common planet scales\n                    if \"mercury\" in filename.lower() or \"0.02\" in str(globals()):\n                        plot_scale = 0.01  # Mercury hill sphere\n                    elif \"jupiter\" in filename.lower() or \"0.5\" in str(globals()):\n                        plot_scale = 0.05  # Jupiter hill sphere\n                    elif \"saturn\" in filename.lower():\n                        plot_scale = 0.1   # Saturn\n                    elif \"neptune\" in filename.lower() or \"uranus\" in filename.lower():\n                        plot_scale = 0.5   # Outer planets\n                    else:\n                        # General fallback - use a reasonable value that works for most plots\n                        plot_scale = 0.05\n                    \n                    print(f\"Sun direction indicator: Using content-based default, scale = {plot_scale:.5f} AU\")\n        except Exception as e:\n            # Last resort fallback\n            print(f\"Sun direction indicator: Error calculating scale: {e}\")\n            plot_scale = 0.05\n    \n    # Ensure minimum indicator size for visibility\n    min_scale = 0.001  # 0.001 AU minimum size for visibility\n    if plot_scale < min_scale:\n        plot_scale = min_scale\n        print(f\"Sun direction indicator: Adjusted to minimum scale = {plot_scale:.5f} AU\")\n    \n    # Create a line pointing in the POSITIVE X direction (toward vernal equinox)\n    # +X points toward the vernal equinox ([ARIES]) - the direction from Earth to Sun on March 20\n    sun_direction_x = [center_x, center_x + plot_scale]  # Line points in +X direction\n    sun_direction_y = [center_y, center_y]\n    sun_direction_z = [center_z, center_z]\n\n    # Format the scale value for display - use scientific notation for very large values\n    if plot_scale >= 1000:\n        scale_text = f\"{plot_scale:.2e} AU\"\n    else:\n        # Show more decimal places for smaller values\n        decimal_places = 5 if plot_scale < 0.1 else 2\n        scale_text = f\"{plot_scale:.{decimal_places}f} AU\"\n\n    # Info text for the hover\n    info_text = \"Vernal Equinox Direction (+X): Points toward the First Point of Aries ([ARIES]).<br>\" \\\n                \"This is the direction from Earth to the Sun at the vernal equinox (around March 20).<br>\" \\\n                \"The +X axis defines celestial longitude 0 deg in the J2000 ecliptic coordinate system.<br>\" \\\n                f\"Current indicator length: {scale_text}\"\n\n    # Create the vernal equinox direction indicator line\n    indicator_trace = go.Scatter3d(\n        x=sun_direction_x,\n        y=sun_direction_y,\n        z=sun_direction_z,\n        mode='lines',\n        line=dict(\n            color='yellow',\n            width=3,\n            dash='dash'\n        ),\n\n        name='Vernal Equinox Direction (+X)',\n        text=[info_text] * len(sun_direction_x),  # Add hover text\n        hovertemplate='%{text}<extra></extra>',    # Enable hover with template\n        showlegend=True\n    )\n\n    return [indicator_trace]",
    "start_line": 9,
    "end_line": 138,
    "has_docstring": true,
    "docstring": "Creates a visual indicator showing the direction to the Sun (along negative X-axis).\nScale automatically adjusts based on the plot's axis range or provided shell radius.\nConditionally shows the indicator based on the object type and center object.\n\nParameters:\n    center_position (tuple): (x, y, z) position of the body's center\n    axis_range (list): The axis range [min, max] used in the plot\n    shell_radius (float): Radius of the shell being displayed, to scale indicator appropriately\n    object_type (str): Type of object being visualized ('Sun' or a planet name)\n    center_object (str): Name of the object at the center of the plot",
    "parameters": [
      "center_position",
      "axis_range",
      "shell_radius",
      "object_type",
      "center_object"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_direction_indicator",
    "component_id": "shared_utilities.create_sun_direction_indicator"
  },
  "shutdown_handler.PlotlyShutdownHandler": {
    "id": "shutdown_handler.PlotlyShutdownHandler",
    "name": "PlotlyShutdownHandler",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\shutdown_handler.py",
    "relative_path": "shutdown_handler.py",
    "depends_on": [
      "social_media_export.cleanup"
    ],
    "source_code": "class PlotlyShutdownHandler:\n    \"\"\"Handles graceful shutdown for Plotly visualizations and associated threads.\"\"\"\n    \n    def __init__(self):\n        self.active_threads = set()\n        self.is_shutting_down = False\n        \n        # Register shutdown handlers\n        atexit.register(self.cleanup)\n        signal.signal(signal.SIGINT, self.handle_interrupt)\n        \n    def register_thread(self, thread):\n        \"\"\"Register a thread to be monitored during shutdown.\"\"\"\n        self.active_threads.add(thread)\n        \n    def remove_thread(self, thread):\n        \"\"\"Remove a completed thread from monitoring.\"\"\"\n        self.active_threads.discard(thread)\n        \n    def cleanup(self):\n        \"\"\"Clean up resources during shutdown.\"\"\"\n        if self.is_shutting_down:\n            return\n            \n        self.is_shutting_down = True\n        print(\"\\nCleaning up visualization resources...\")\n        \n        # Wait for active threads to complete\n        active_threads = [t for t in self.active_threads if t.is_alive()]\n        if active_threads:\n            print(f\"Waiting for {len(active_threads)} active tasks to complete...\")\n            for thread in active_threads:\n                thread.join(timeout=5.0)\n        \n        self.active_threads.clear()\n        print(\"Cleanup complete.\")\n        \n    def handle_interrupt(self, signum, frame):\n        \"\"\"Handle keyboard interrupts.\"\"\"\n        print(\"\\nInterrupt received, initiating cleanup...\")\n        self.cleanup()",
    "start_line": 15,
    "end_line": 55,
    "has_docstring": true,
    "docstring": "Handles graceful shutdown for Plotly visualizations and associated threads.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class PlotlyShutdownHandler",
    "component_id": "shutdown_handler.PlotlyShutdownHandler"
  },
  "shutdown_handler.create_monitored_thread": {
    "id": "shutdown_handler.create_monitored_thread",
    "name": "create_monitored_thread",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\shutdown_handler.py",
    "relative_path": "shutdown_handler.py",
    "depends_on": [],
    "source_code": "def create_monitored_thread(handler, target_func, *args, **kwargs):\n    \"\"\"Create a thread that's monitored by the shutdown handler.\"\"\"\n    def wrapper():\n        try:\n            target_func(*args, **kwargs)\n        finally:\n            handler.remove_thread(threading.current_thread())\n    \n    thread = threading.Thread(target=wrapper)\n    handler.register_thread(thread)\n    return thread",
    "start_line": 57,
    "end_line": 67,
    "has_docstring": true,
    "docstring": "Create a thread that's monitored by the shutdown handler.",
    "parameters": [
      "handler",
      "target_func"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_monitored_thread",
    "component_id": "shutdown_handler.create_monitored_thread"
  },
  "shutdown_handler.wrapper": {
    "id": "shutdown_handler.wrapper",
    "name": "wrapper",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\shutdown_handler.py",
    "relative_path": "shutdown_handler.py",
    "depends_on": [],
    "source_code": "    def wrapper():\n        try:\n            target_func(*args, **kwargs)\n        finally:\n            handler.remove_thread(threading.current_thread())",
    "start_line": 59,
    "end_line": 63,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function wrapper",
    "component_id": "shutdown_handler.wrapper"
  },
  "shutdown_handler.show_figure_safely": {
    "id": "shutdown_handler.show_figure_safely",
    "name": "show_figure_safely",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\shutdown_handler.py",
    "relative_path": "shutdown_handler.py",
    "depends_on": [],
    "source_code": "def show_figure_safely(fig, default_name):\n    \"\"\"\n    Show and optionally save a Plotly figure with proper cleanup.\n    \n    This function now delegates to the consolidated save_utils module\n    while maintaining backward compatibility.\n    \n    Parameters:\n        fig: Plotly figure object\n        default_name: Default filename without extension\n    \n    Returns:\n        str or None: Path to saved file, or None if not saved\n    \"\"\"\n    return _show_and_save_impl(fig, default_name)",
    "start_line": 69,
    "end_line": 83,
    "has_docstring": true,
    "docstring": "Show and optionally save a Plotly figure with proper cleanup.\n\nThis function now delegates to the consolidated save_utils module\nwhile maintaining backward compatibility.\n\nParameters:\n    fig: Plotly figure object\n    default_name: Default filename without extension\n\nReturns:\n    str or None: Path to saved file, or None if not saved",
    "parameters": [
      "fig",
      "default_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function show_figure_safely",
    "component_id": "shutdown_handler.show_figure_safely"
  },
  "simbad_manager.SimbadConfig": {
    "id": "simbad_manager.SimbadConfig",
    "name": "SimbadConfig",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\simbad_manager.py",
    "relative_path": "simbad_manager.py",
    "depends_on": [],
    "source_code": "class SimbadConfig:\n    \"\"\"Configuration for SIMBAD queries with user-adjustable parameters.\"\"\"\n    \n    # Rate limiting parameters\n    queries_per_second: float = 5.0  # Default 5 queries/second (200ms between queries)\n    batch_size: int = 50\n    \n    # Timeout and retry parameters\n    timeout: int = 300  # 5 minutes\n    max_retries: int = 3\n    retry_delay: float = 1.0  # Base delay for exponential backoff\n    \n    # Query configuration\n    row_limit: int = 1\n    votable_fields: List[str] = field(default_factory=lambda: ['ids', 'sp', 'flux(V)', 'flux(B)', 'otype'])\n    \n    # Progress saving\n    save_progress_interval: int = 10  # Save after every N queries\n    \n    # User preferences\n    show_detailed_progress: bool = True\n    pause_on_error: bool = False\n    \n    @classmethod\n    def from_dict(cls, config_dict: Dict[str, Any]) -> 'SimbadConfig':\n        \"\"\"Create config from dictionary (e.g., from GUI).\"\"\"\n        return cls(**{k: v for k, v in config_dict.items() if k in cls.__annotations__})\n    \n    @classmethod\n    def load_from_file(cls, filepath: str = 'simbad_config.pkl') -> 'SimbadConfig':\n        \"\"\"Load saved configuration from file.\"\"\"\n        if os.path.exists(filepath):\n            try:\n                with open(filepath, 'rb') as f:\n                    config_dict = pickle.load(f)\n                return cls.from_dict(config_dict)\n            except Exception as e:\n                logger.warning(f\"Could not load config from {filepath}: {e}\")\n        return cls()  # Return default config\n    \n    def save_to_file(self, filepath: str = 'simbad_config.pkl'):\n        \"\"\"Save configuration to file.\"\"\"\n        config_dict = {\n            k: getattr(self, k) for k in self.__annotations__\n        }\n        with open(filepath, 'wb') as f:\n            pickle.dump(config_dict, f)",
    "start_line": 26,
    "end_line": 72,
    "has_docstring": true,
    "docstring": "Configuration for SIMBAD queries with user-adjustable parameters.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class SimbadConfig",
    "component_id": "simbad_manager.SimbadConfig"
  },
  "simbad_manager.RateLimiter": {
    "id": "simbad_manager.RateLimiter",
    "name": "RateLimiter",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\simbad_manager.py",
    "relative_path": "simbad_manager.py",
    "depends_on": [],
    "source_code": "class RateLimiter:\n    \"\"\"Token bucket rate limiter for SIMBAD queries.\"\"\"\n    \n    def __init__(self, queries_per_second: float = 5.0):\n        \"\"\"Initialize rate limiter with specified queries per second.\"\"\"\n        self.max_tokens = queries_per_second\n        self.tokens = self.max_tokens\n        self.refill_rate = queries_per_second\n        self.last_refill = time.time()\n        self.total_wait_time = 0\n        self.query_count = 0\n    \n    def wait_if_needed(self) -> float:\n        \"\"\"Wait if necessary and return wait time in seconds.\"\"\"\n        now = time.time()\n        \n        # Refill tokens based on elapsed time\n        elapsed = now - self.last_refill\n        self.tokens = min(self.max_tokens, self.tokens + elapsed * self.refill_rate)\n        self.last_refill = now\n        \n        # Check if we need to wait for a token\n        if self.tokens < 1:\n            wait_time = (1 - self.tokens) / self.refill_rate\n            time.sleep(wait_time)\n            self.tokens = 0\n            self.total_wait_time += wait_time\n            return wait_time\n        \n        # Consume a token\n        self.tokens -= 1\n        self.query_count += 1\n        return 0\n    \n    def get_stats(self) -> Dict[str, float]:\n        \"\"\"Get rate limiter statistics.\"\"\"\n        elapsed = time.time() - (self.last_refill - self.total_wait_time)\n        actual_rate = self.query_count / elapsed if elapsed > 0 else 0\n        \n        return {\n            'queries_made': self.query_count,\n            'total_wait_time': self.total_wait_time,\n            'actual_rate': actual_rate,\n            'target_rate': self.refill_rate,\n            'tokens_available': self.tokens\n        }",
    "start_line": 75,
    "end_line": 120,
    "has_docstring": true,
    "docstring": "Token bucket rate limiter for SIMBAD queries.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class RateLimiter",
    "component_id": "simbad_manager.RateLimiter"
  },
  "simbad_manager.QueryStats": {
    "id": "simbad_manager.QueryStats",
    "name": "QueryStats",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\simbad_manager.py",
    "relative_path": "simbad_manager.py",
    "depends_on": [],
    "source_code": "class QueryStats:\n    \"\"\"Track statistics for SIMBAD queries.\"\"\"\n    \n    def __init__(self):\n        self.start_time = time.time()\n        self.successful = 0\n        self.failed = 0\n        self.retried = 0\n        self.cached = 0\n        self.total_time = 0\n        self.error_log = []\n    \n    def log_success(self):\n        self.successful += 1\n    \n    def log_failure(self, obj_name: str, error: str):\n        self.failed += 1\n        self.error_log.append((obj_name, error, time.time()))\n    \n    def log_retry(self):\n        self.retried += 1\n    \n    def log_cached(self):\n        self.cached += 1\n    \n    def get_summary(self) -> str:\n        \"\"\"Get a summary of query statistics.\"\"\"\n        elapsed = time.time() - self.start_time\n        total = self.successful + self.failed\n        \n        if total == 0:\n            return \"No queries performed yet.\"\n        \n        success_rate = (self.successful / total) * 100 if total > 0 else 0\n        queries_per_second = total / elapsed if elapsed > 0 else 0\n        \n        summary = f\"\"\"\nQuery Statistics:\n-----------------\nTotal Queries: {total}\nSuccessful: {self.successful} ({success_rate:.1f}%)\nFailed: {self.failed}\nCached: {self.cached}\nRetried: {self.retried}\nTime Elapsed: {elapsed:.1f}s\nQuery Rate: {queries_per_second:.2f}/s\n\"\"\"\n        return summary",
    "start_line": 123,
    "end_line": 170,
    "has_docstring": true,
    "docstring": "Track statistics for SIMBAD queries.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class QueryStats",
    "component_id": "simbad_manager.QueryStats"
  },
  "simbad_manager.SimbadQueryManager": {
    "id": "simbad_manager.SimbadQueryManager",
    "name": "SimbadQueryManager",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\simbad_manager.py",
    "relative_path": "simbad_manager.py",
    "depends_on": [
      "simbad_manager.RateLimiter",
      "vot_cache_manager.verify_vot_cache_integrity",
      "vot_cache_manager.VOTCacheManager",
      "star_properties.load_existing_properties",
      "simbad_manager.SimbadConfig",
      "simbad_manager.QueryStats"
    ],
    "source_code": "class SimbadQueryManager:\n    \"\"\"Main class for managing SIMBAD queries with rate limiting and error handling.\"\"\"\n    \n    def __init__(self, config: Optional[SimbadConfig] = None, \n                 progress_callback: Optional[callable] = None):\n        \"\"\"\n        Initialize the SIMBAD Query Manager.\n        \n        Args:\n            config: Configuration object for query parameters\n            progress_callback: Optional callback function for progress updates\n                              Should accept (current, total, message) parameters\n        \"\"\"\n        self.config = config or SimbadConfig()\n        self.progress_callback = progress_callback\n        self.rate_limiter = RateLimiter(self.config.queries_per_second)\n        self.stats = QueryStats()\n        self.simbad = self._create_simbad_instance()\n\n        # ADD THIS LINE - Initialize VOT cache manager\n#        self.vot_manager = VOTCacheManager()\n        self.vot_manager = VOTCacheManager(cache_dir='star_data')\n        \n        # ADD THIS LOG MESSAGE (optional)\n        logger.info(f\"VOT cache protection enabled\")        \n        \n    def protect_all_caches(self):\n        \"\"\"\n        Protect both PKL and VOT cache files.\n        Creates timestamped backups of all critical cache files.\n        \"\"\"\n        protected_files = []\n        \n        # Protect PKL files\n        pkl_files = [\n            'star_data/star_properties_distance.pkl',\n            'star_data/star_properties_magnitude.pkl',\n        ]\n        \n        for pkl_file in pkl_files:\n            if os.path.exists(pkl_file):\n                backup_name = pkl_file + '.protected_' + time.strftime('%Y%m%d_%H%M%S')\n                try:\n                    shutil.copy2(pkl_file, backup_name)\n                    protected_files.append(backup_name)\n                    logger.info(f\"Protected PKL: {backup_name}\")\n                except Exception as e:\n                    logger.error(f\"Failed to protect {pkl_file}: {e}\")\n        \n        # Protect VOT files using VOT manager\n        vot_count = 0\n        for vot_file in self.vot_manager.protected_files.keys():\n            filepath = os.path.join(self.vot_manager.cache_dir, vot_file)\n            if os.path.exists(filepath):\n                if self.vot_manager.protect_base_file(filepath):\n                    vot_count += 1\n        \n        logger.info(f\"Protected {len(protected_files)} PKL files and {vot_count} VOT files\")\n        return protected_files\n    \n    def update_calculated_properties(self, combined_df, properties_file: str) -> Dict:\n        \"\"\"\n        Update existing properties with calculated stellar parameters.\n        This replaces the save_enhanced_pickle function.\n        \n        Args:\n            combined_df: DataFrame with calculated properties (Temperature, Luminosity, etc.)\n            properties_file: Path to the properties pickle file\n            \n        Returns:\n            Updated properties dictionary\n        \"\"\"\n        logger.info(f\"Updating {properties_file} with calculated properties...\")\n        \n        # Load existing properties using the standard method\n        if os.path.exists(properties_file):\n            with open(properties_file, 'rb') as f:\n                data = pickle.load(f)\n            \n            # Convert to dictionary format if needed\n            if isinstance(data, dict) and 'unique_ids' in data:\n                # Old list format - convert to dictionary with safe list access\n                existing_properties = {}\n                \n                # Get all lists with safe defaults\n                unique_ids = data.get('unique_ids', [])\n                star_names = data.get('star_names', [])\n                spectral_types = data.get('spectral_types', [])\n                v_magnitudes = data.get('V_magnitudes', [])\n                b_magnitudes = data.get('B_magnitudes', [])\n                object_types = data.get('object_types', [])\n                is_messier_list = data.get('is_messier', [])\n                distance_ly_list = data.get('distance_ly', [])\n                distance_pc_list = data.get('distance_pc', [])\n                temperature_list = data.get('Temperature', [])\n                luminosity_list = data.get('Luminosity', [])\n                abs_mag_list = data.get('Abs_Mag', [])\n                ra_icrs_list = data.get('RA_ICRS', [])\n                de_icrs_list = data.get('DE_ICRS', [])\n                ra_str_list = data.get('ra_str', [])\n                dec_str_list = data.get('dec_str', [])\n                stellar_class_list = data.get('Stellar_Class', [])\n                object_type_desc_list = data.get('Object_Type_Desc', [])\n                source_catalog_list = data.get('Source_Catalog', [])\n                \n                # Process only valid entries\n                for i, uid in enumerate(unique_ids):\n                    if uid:\n                        existing_properties[uid] = {\n                            'star_name': star_names[i] if i < len(star_names) else None,\n                            'spectral_type': spectral_types[i] if i < len(spectral_types) else None,\n                            'V_magnitude': v_magnitudes[i] if i < len(v_magnitudes) else None,\n                            'B_magnitude': b_magnitudes[i] if i < len(b_magnitudes) else None,\n                            'object_type': object_types[i] if i < len(object_types) else None,\n                            'is_messier': is_messier_list[i] if i < len(is_messier_list) else False,\n                            'distance_ly': distance_ly_list[i] if i < len(distance_ly_list) else None,\n                            'distance_pc': distance_pc_list[i] if i < len(distance_pc_list) else None,\n                            'Temperature': temperature_list[i] if i < len(temperature_list) else None,\n                            'Luminosity': luminosity_list[i] if i < len(luminosity_list) else None,\n                            'Abs_Mag': abs_mag_list[i] if i < len(abs_mag_list) else None,\n                            'RA_ICRS': ra_icrs_list[i] if i < len(ra_icrs_list) else None,\n                            'DE_ICRS': de_icrs_list[i] if i < len(de_icrs_list) else None,\n                            'ra_str': ra_str_list[i] if i < len(ra_str_list) else None,\n                            'dec_str': dec_str_list[i] if i < len(dec_str_list) else None,\n                            'Stellar_Class': stellar_class_list[i] if i < len(stellar_class_list) else None,\n                            'Object_Type_Desc': object_type_desc_list[i] if i < len(object_type_desc_list) else None,\n                            'Source_Catalog': source_catalog_list[i] if i < len(source_catalog_list) else None,\n                        }\n            elif isinstance(data, dict):\n                existing_properties = data\n            else:\n                existing_properties = {}\n        else:\n            existing_properties = {}\n        \n        # Track statistics\n        original_count = len(existing_properties)\n        updated_count = 0\n        new_count = 0\n        \n        # Update with calculated properties from DataFrame\n        for _, row in combined_df.iterrows():\n            # Generate unique ID\n            uid = row.get('unique_id', None)\n            if uid is None:\n                if 'HIP' in row and pd.notna(row['HIP']):\n                    uid = f\"HIP {int(row['HIP'])}\"\n                elif 'Source' in row and pd.notna(row['Source']):\n                    uid = f\"Gaia DR3 {int(row['Source'])}\"\n                else:\n                    ra = row.get('RA_ICRS', None)\n                    dec = row.get('DE_ICRS', None)\n                    if ra and dec:\n                        uid = f\"J{ra:.6f}{dec:+.6f}\"\n            \n            if not uid:\n                continue\n            \n            # Check if this is a new star or update\n            if uid in existing_properties:\n                updated_count += 1\n                # Update only the calculated fields (preserve SIMBAD data)\n                props = existing_properties[uid]\n            else:\n                new_count += 1\n                # Create new entry\n                props = {\n                    'star_name': row.get('Star_Name', ''),\n                    'spectral_type': row.get('Spectral_Type', None),\n                    'V_magnitude': row.get('Apparent_Magnitude', row.get('V_mag', None)),\n                    'B_magnitude': row.get('B_mag', None),\n                    'object_type': row.get('Object_Type', None),\n                    'is_messier': row.get('Is_Messier', False),\n                }\n                existing_properties[uid] = props\n            \n            # Update calculated properties (these come from stellar_parameters.py)\n            calculated_fields = {\n                'Temperature': row.get('Temperature', None),\n                'Luminosity': row.get('Luminosity', None),\n                'Abs_Mag': row.get('Abs_Mag', None),\n                'distance_ly': row.get('Distance_ly', None),\n                'distance_pc': row.get('Distance_pc', None),\n                'RA_ICRS': row.get('RA_ICRS', None),\n                'DE_ICRS': row.get('DE_ICRS', None),\n                'ra_str': row.get('ra_str', None),\n                'dec_str': row.get('dec_str', None),\n                'Stellar_Class': row.get('Stellar_Class', None),\n                'Object_Type_Desc': row.get('Object_Type_Desc', None),\n                'Source_Catalog': row.get('Source_Catalog', None),\n            }\n            \n            # Only update non-None calculated values\n            for field, value in calculated_fields.items():\n                if value is not None and (pd.notna(value) if hasattr(pd, 'notna') else True):\n                    props[field] = value\n        \n        # Log statistics\n        self.stats.cached = updated_count  # Reuse cached field for updates\n        logger.info(f\"Updated {updated_count} existing stars, added {new_count} new stars\")\n        logger.info(f\"Total stars: {len(existing_properties)} (was {original_count})\")\n        \n        # Save using the existing _save_properties method with safety checks\n        self._save_properties_with_safety(existing_properties, properties_file)\n        \n        return existing_properties\n\n\n    def _save_properties_with_safety(self, properties: Dict, filepath: str):\n        \"\"\"\n        Enhanced save with safety checks similar to orbit_data_manager.\n        \"\"\"\n        # Check if file exists and get its size\n        original_size = 0\n        original_count = 0\n        if os.path.exists(filepath):\n            original_size = os.path.getsize(filepath)\n            try:\n                with open(filepath, 'rb') as f:\n                    old_data = pickle.load(f)\n                if isinstance(old_data, dict) and 'unique_ids' in old_data:\n                    original_count = len(old_data.get('unique_ids', []))\n                elif isinstance(old_data, dict):\n                    original_count = len(old_data)\n            except:\n                pass\n        \n        new_count = len(properties)\n        \n        # Safety check: Don't allow massive data loss\n        if original_count > 100 and new_count < original_count * 0.1:\n            # Create emergency backup\n            emergency_backup = filepath + '.emergency_' + time.strftime('%Y%m%d_%H%M%S')\n            shutil.copy2(filepath, emergency_backup)\n            logger.error(f\"SAFETY: Blocked save that would reduce {original_count} to {new_count} stars\")\n            logger.info(f\"Emergency backup created: {emergency_backup}\")\n            raise ValueError(f\"Refusing to save: would lose {original_count - new_count} stars\")\n        \n        # Safety check: Suspicious size reduction\n        if original_size > 1024 * 1024 and new_count < 20:\n            emergency_backup = filepath + '.size_warning_' + time.strftime('%Y%m%d_%H%M%S')\n            shutil.copy2(filepath, emergency_backup)\n            logger.error(f\"SAFETY: Large file ({original_size/1024/1024:.1f}MB) -> {new_count} entries\")\n            raise ValueError(\"Refusing to save: suspicious size reduction\")\n        \n        # Use atomic save operation\n        temp_file = filepath + '.tmp'\n        backup_file = filepath + '.backup'\n        \n        try:\n            # Convert to list format for compatibility (existing format)\n            all_unique_ids = list(properties.keys())\n            property_lists = {\n                'unique_ids': all_unique_ids,\n                'star_names': [],\n                'spectral_types': [],\n                'V_magnitudes': [],\n                'B_magnitudes': [],\n                'object_types': [],\n                'is_messier': [],\n                'distance_ly': [],\n                'distance_pc': [],\n                'notes': [],\n                # Add calculated fields to the save format\n                'Temperature': [],\n                'Luminosity': [],\n                'Abs_Mag': [],\n                'RA_ICRS': [],\n                'DE_ICRS': [],\n                'ra_str': [],\n                'dec_str': [],\n                'Stellar_Class': [],\n                'Object_Type_Desc': [],\n                'Source_Catalog': [],\n            }\n            \n            for uid in all_unique_ids:\n                props = properties[uid]\n                property_lists['star_names'].append(props.get('star_name'))\n                property_lists['spectral_types'].append(props.get('spectral_type'))\n                property_lists['V_magnitudes'].append(props.get('V_magnitude'))\n                property_lists['B_magnitudes'].append(props.get('B_magnitude'))\n                property_lists['object_types'].append(props.get('object_type'))\n                property_lists['is_messier'].append(props.get('is_messier', False))\n                property_lists['distance_ly'].append(props.get('distance_ly'))\n                property_lists['distance_pc'].append(props.get('distance_pc'))\n                property_lists['notes'].append(props.get('notes', ''))\n                # Add calculated fields\n                property_lists['Temperature'].append(props.get('Temperature'))\n                property_lists['Luminosity'].append(props.get('Luminosity'))\n                property_lists['Abs_Mag'].append(props.get('Abs_Mag'))\n                property_lists['RA_ICRS'].append(props.get('RA_ICRS'))\n                property_lists['DE_ICRS'].append(props.get('DE_ICRS'))\n                property_lists['ra_str'].append(props.get('ra_str'))\n                property_lists['dec_str'].append(props.get('dec_str'))\n                property_lists['Stellar_Class'].append(props.get('Stellar_Class'))\n                property_lists['Object_Type_Desc'].append(props.get('Object_Type_Desc'))\n                property_lists['Source_Catalog'].append(props.get('Source_Catalog'))\n            \n            # Write to temp file\n            with open(temp_file, 'wb') as f:\n                pickle.dump(property_lists, f)\n            \n            # Verify temp file\n            with open(temp_file, 'rb') as f:\n                verify_data = pickle.load(f)\n                if len(verify_data.get('unique_ids', [])) != len(all_unique_ids):\n                    raise ValueError(\"Verification failed\")\n            \n            # Backup original if it exists\n            if os.path.exists(filepath):\n                if os.path.exists(backup_file):\n                    os.remove(backup_file)\n                shutil.move(filepath, backup_file)\n            \n            # Move temp to final\n            shutil.move(temp_file, filepath)\n            \n            # Clean up backup if successful\n            if os.path.exists(backup_file):\n                os.remove(backup_file)\n            \n            logger.info(f\"Saved {len(properties)} properties to {filepath}\")\n            \n        except Exception as e:\n            logger.error(f\"Error saving properties: {e}\")\n            # Restore from backup if available\n            if os.path.exists(backup_file):\n                shutil.copy2(backup_file, filepath)\n                logger.info(\"Restored from backup after save failure\")\n            # Clean up temp file\n            if os.path.exists(temp_file):\n                try:\n                    os.remove(temp_file)\n                except:\n                    pass\n            raise\n\n    def rebuild_pkl_from_vot_caches(self, mode='distance', force_rebuild=False):\n        \"\"\"\n        Rebuild PKL properties file from VOT caches and SIMBAD.\n        \n        Args:\n            mode: 'distance' or 'magnitude'\n            force_rebuild: If True, rebuild even if PKL exists\n            \n        Returns:\n            Dictionary of star properties\n        \"\"\"\n        if mode == 'distance':\n            properties_file = 'star_data/star_properties_distance.pkl'\n            vot_files = {\n                'hipparcos': 'hipparcos_data_distance.vot',\n                'gaia': 'gaia_data_distance.vot'\n            }\n        else:  # magnitude\n            properties_file = 'star_data/star_properties_magnitude.pkl'\n            vot_files = {\n                'hipparcos': 'hipparcos_data_magnitude.vot',\n                'gaia': 'gaia_data_magnitude.vot'\n            }\n        \n        # Check if rebuild is needed\n        if not force_rebuild and os.path.exists(properties_file):\n            logger.info(f\"{properties_file} already exists. Use force_rebuild=True to rebuild.\")\n            return self.load_existing_properties(properties_file)\n        \n        logger.info(f\"Rebuilding {properties_file} from VOT caches...\")\n        \n        # Step 1: Extract unique IDs from VOT files\n        all_unique_ids = set()\n        catalog_data = {}\n        \n        for catalog, vot_file in vot_files.items():\n            if not os.path.exists(vot_file):\n                logger.warning(f\"VOT file not found: {vot_file}\")\n                continue\n            \n            table = self.vot_manager.safe_load_vot(vot_file)\n            if table is None:\n                continue\n            \n            logger.info(f\"Processing {len(table)} entries from {catalog}\")\n            catalog_data[catalog] = table\n            \n            # Extract identifiers\n            if 'hipparcos' in catalog.lower():\n                for row in table:\n                    if 'HIP' in row.colnames:\n                        all_unique_ids.add(f\"HIP {row['HIP']}\")\n            elif 'gaia' in catalog.lower():\n                for row in table:\n                    if 'Source' in row.colnames:\n                        all_unique_ids.add(f\"Gaia DR3 {row['Source']}\")\n        \n        if not all_unique_ids:\n            logger.error(\"No star IDs found in VOT files\")\n            return {}\n        \n        logger.info(f\"Found {len(all_unique_ids)} unique star IDs from VOT files\")\n        \n        # Step 2: Check existing PKL for any cached SIMBAD data\n        existing_properties = {}\n        if os.path.exists(properties_file):\n            try:\n                existing_properties = self.load_existing_properties(properties_file)\n                logger.info(f\"Loaded {len(existing_properties)} existing properties\")\n            except Exception as e:\n                logger.warning(f\"Could not load existing properties: {e}\")\n        \n        # Step 3: Query SIMBAD for missing properties\n        missing_ids = list(all_unique_ids - set(existing_properties.keys()))\n        \n        if missing_ids:\n            logger.info(f\"Querying SIMBAD for {len(missing_ids)} missing star properties...\")\n            \n            # Query in batches with rate limiting\n            batch_size = self.config.batch_size\n            for i in range(0, len(missing_ids), batch_size):\n                batch = missing_ids[i:i+batch_size]\n                logger.info(f\"Processing batch {i//batch_size + 1}/{(len(missing_ids) + batch_size - 1)//batch_size}\")\n                \n                for star_id in batch:\n                    try:\n                        # Apply rate limiting\n                        self.rate_limiter.wait_if_needed()\n                        \n                        # Query SIMBAD\n                        result = self.simbad.query_object(star_id)\n                        \n                        if result is not None and len(result) > 0:\n                            existing_properties[star_id] = self._extract_properties_from_result(result[0], star_id)\n                        \n                    except Exception as e:\n                        logger.warning(f\"Failed to query {star_id}: {e}\")\n                        continue\n                \n                # Save progress periodically\n                if (i + batch_size) % (batch_size * 5) == 0:\n                    self._save_properties_with_safety(existing_properties, properties_file)\n                    logger.info(f\"Progress saved: {len(existing_properties)} properties\")\n        \n        # Step 4: Merge with catalog data for complete properties\n        final_properties = self._merge_catalog_and_simbad_data(\n            existing_properties, catalog_data, mode\n        )\n        \n        # Step 5: Save final properties\n        self._save_properties_with_safety(final_properties, properties_file)\n        \n        logger.info(f\"Rebuild complete: {len(final_properties)} star properties saved\")\n        return final_properties\n    \n    def _merge_catalog_and_simbad_data(self, simbad_props: Dict, catalog_data: Dict, mode: str) -> Dict:\n        \"\"\"\n        Merge SIMBAD properties with catalog data.\n        \"\"\"\n        merged = simbad_props.copy()\n        \n        # Add catalog-specific data\n        for catalog, table in catalog_data.items():\n            if table is None:\n                continue\n            \n            if 'hipparcos' in catalog.lower():\n                for row in table:\n                    hip_id = f\"HIP {row['HIP']}\"\n                    if hip_id not in merged:\n                        merged[hip_id] = {'unique_id': hip_id}\n                    \n                    # Add/update catalog data\n                    merged[hip_id]['Source_Catalog'] = 'Hipparcos'\n                    \n                    if 'Plx' in row.colnames and row['Plx'] > 0:\n                        merged[hip_id]['distance_pc'] = 1000.0 / row['Plx']\n                        merged[hip_id]['distance_ly'] = (1000.0 / row['Plx']) * 3.26156\n                    \n                    if 'Vmag' in row.colnames:\n                        merged[hip_id]['V_magnitude'] = float(row['Vmag'])\n                    \n                    if 'B-V' in row.colnames and 'Vmag' in row.colnames:\n                        merged[hip_id]['B_magnitude'] = float(row['Vmag'] + row['B-V'])\n            \n            elif 'gaia' in catalog.lower():\n                for row in table:\n                    gaia_id = f\"Gaia DR3 {row['Source']}\"\n                    if gaia_id not in merged:\n                        merged[gaia_id] = {'unique_id': gaia_id}\n                    \n                    merged[gaia_id]['Source_Catalog'] = 'Gaia'\n                    \n                    if 'Plx' in row.colnames and row['Plx'] > 0:\n                        merged[gaia_id]['distance_pc'] = 1000.0 / row['Plx']\n                        merged[gaia_id]['distance_ly'] = (1000.0 / row['Plx']) * 3.26156\n                    \n                    if 'Gmag' in row.colnames:\n                        # Approximate V magnitude from Gaia G magnitude\n                        merged[gaia_id]['V_magnitude'] = float(row['Gmag']) - 0.2\n        \n        return merged\n    \n    def verify_cache_integrity(self) -> Dict:\n        \"\"\"\n        Verify integrity of all cache files (PKL and VOT).\n        \n        Returns:\n            Dictionary with integrity status for each cache file\n        \"\"\"\n        report = {\n            'pkl_files': {},\n            'vot_files': {},\n            'summary': {\n                'total_pkl_entries': 0,\n                'total_vot_entries': 0,\n                'issues_found': []\n            }\n        }\n        \n        # Check PKL files\n        pkl_files = [\n            'star_data/star_properties_distance.pkl',\n            'star_data/star_properties_magnitude.pkl',\n        ]\n        \n        for pkl_file in pkl_files:\n            if os.path.exists(pkl_file):\n                try:\n                    props = self.load_existing_properties(pkl_file)\n                    count = len(props)\n                    report['pkl_files'][pkl_file] = {\n                        'status': 'valid',\n                        'entries': count,\n                        'size_mb': os.path.getsize(pkl_file) / (1024 * 1024)\n                    }\n                    report['summary']['total_pkl_entries'] += count\n                except Exception as e:\n                    report['pkl_files'][pkl_file] = {\n                        'status': 'corrupted',\n                        'error': str(e)\n                    }\n                    report['summary']['issues_found'].append(f\"{pkl_file}: corrupted\")\n            else:\n                report['pkl_files'][pkl_file] = {'status': 'missing'}\n        \n        # Check VOT files using VOT manager\n        vot_integrity = verify_vot_cache_integrity()\n        for vot_file, status in vot_integrity.items():\n            report['vot_files'][vot_file] = status\n            if status.get('status') == 'valid':\n                report['summary']['total_vot_entries'] += status.get('entries', 0)\n            elif status.get('status') != 'missing':\n                report['summary']['issues_found'].append(f\"{vot_file}: {status.get('status')}\")\n        \n        return report\n    \n    def generate_cache_report(self) -> str:\n        \"\"\"\n        Generate human-readable cache status report.\n        \"\"\"\n        integrity = self.verify_cache_integrity()\n        \n        lines = []\n        lines.append(\"=\" * 70)\n        lines.append(\"STAR DATA CACHE STATUS REPORT\")\n        lines.append(\"=\" * 70)\n        lines.append(f\"Generated: {time.strftime('%Y-%m-%d %H:%M:%S')}\")\n        lines.append(\"\")\n        \n        # PKL Files Section\n        lines.append(\"PKL PROPERTY FILES\")\n        lines.append(\"-\" * 40)\n        for file, info in integrity['pkl_files'].items():\n            lines.append(f\"\\n{file}:\")\n            if info['status'] == 'valid':\n                lines.append(f\"  [OK] Status: VALID\")\n                lines.append(f\"  * Entries: {info['entries']:,}\")\n                lines.append(f\"  * Size: {info['size_mb']:.2f} MB\")\n            elif info['status'] == 'missing':\n                lines.append(f\"  [FAIL] Status: MISSING\")\n            else:\n                lines.append(f\"  [WARN] Status: CORRUPTED\")\n                lines.append(f\"  * Error: {info.get('error', 'Unknown')}\")\n        \n        # VOT Files Section\n        lines.append(\"\\n\" + \"=\" * 40)\n        lines.append(\"VOT CATALOG FILES\")\n        lines.append(\"-\" * 40)\n        for file, info in integrity['vot_files'].items():\n            lines.append(f\"\\n{file}:\")\n            if info['status'] == 'valid':\n                lines.append(f\"  [OK] Status: VALID\")\n                lines.append(f\"  * Entries: {info['entries']:,}\")\n                lines.append(f\"  * Columns: {', '.join(info.get('columns', []))}\")\n            elif info['status'] == 'missing':\n                lines.append(f\"  [FAIL] Status: MISSING\")\n            else:\n                lines.append(f\"  [WARN] Status: CORRUPTED\")\n        \n        # Summary Section\n        lines.append(\"\\n\" + \"=\" * 40)\n        lines.append(\"SUMMARY\")\n        lines.append(\"-\" * 40)\n        lines.append(f\"Total PKL entries: {integrity['summary']['total_pkl_entries']:,}\")\n        lines.append(f\"Total VOT entries: {integrity['summary']['total_vot_entries']:,}\")\n        \n        if integrity['summary']['issues_found']:\n            lines.append(f\"\\n[WARN] Issues found ({len(integrity['summary']['issues_found'])}):\")\n            for issue in integrity['summary']['issues_found']:\n                lines.append(f\"  * {issue}\")\n        else:\n            lines.append(\"\\n[OK] All cache files are healthy\")\n        \n        lines.append(\"=\" * 70)\n        \n        return \"\\n\".join(lines)\n\n    def _create_simbad_instance(self):\n        \"\"\"Create and configure a SIMBAD instance.\"\"\"\n        custom_simbad = Simbad()\n        custom_simbad.reset_votable_fields()\n        custom_simbad.ROW_LIMIT = self.config.row_limit\n        custom_simbad.TIMEOUT = self.config.timeout\n        \n        # Add requested fields\n        for field in self.config.votable_fields:\n            try:\n                custom_simbad.add_votable_fields(field)\n            except Exception as e:\n                logger.warning(f\"Could not add field {field}: {e}\")\n        \n        return custom_simbad\n    \n    def _update_progress(self, current: int, total: int, message: str = \"\"):\n        \"\"\"Update progress through callback if available.\"\"\"\n        if self.progress_callback:\n            try:\n                self.progress_callback(current, total, message)\n            except Exception as e:\n                logger.error(f\"Progress callback error: {e}\")\n    \n    def _query_single_object(self, obj_name: str) -> Optional[Any]:\n        \"\"\"\n        Query a single object with retry logic.\n        \n        Returns:\n            Query result table or None if failed\n        \"\"\"\n        for attempt in range(self.config.max_retries):\n            try:\n                # Apply rate limiting\n                wait_time = self.rate_limiter.wait_if_needed()\n                \n                # Perform query\n                result = self.simbad.query_object(obj_name)\n                \n                if result is not None and len(result) > 0:\n                    self.stats.log_success()\n                    return result\n                else:\n                    # No results found (not an error, just no data)\n                    if attempt == self.config.max_retries - 1:\n                        self.stats.log_failure(obj_name, \"No data found\")\n                    return None\n                    \n            except Exception as e:\n                self.stats.log_retry()\n                \n                if attempt < self.config.max_retries - 1:\n                    # Exponential backoff for retries\n                    delay = self.config.retry_delay * (2 ** attempt)\n                    logger.warning(f\"Retry {attempt + 1} for {obj_name} after {delay:.1f}s: {e}\")\n                    time.sleep(delay)\n                else:\n                    # Final attempt failed\n                    self.stats.log_failure(obj_name, str(e))\n                    logger.error(f\"Failed to query {obj_name} after {self.config.max_retries} attempts: {e}\")\n                    \n                    if self.config.pause_on_error:\n                        input(f\"Error querying {obj_name}. Press Enter to continue...\")\n                    \n                    return None\n        \n        return None\n    \n    def calculate_optimal_batch_size(self, total_objects: int) -> int:\n        \"\"\"Calculate optimal batch size based on total workload.\"\"\"\n        if total_objects < 50:\n            return min(10, total_objects)\n        elif total_objects < 500:\n            return 25\n        elif total_objects < 1000:\n            return 50\n        elif total_objects < 5000:\n            return 100\n        else:\n            return min(200, self.config.batch_size)\n    \n    def query_objects(self, object_names: List[str], \n                      existing_properties: Optional[Dict] = None,\n                      properties_file: Optional[str] = None) -> Dict:\n        \"\"\"\n        Query multiple objects with batching and progress tracking.\n        \n        Args:\n            object_names: List of object names to query\n            existing_properties: Dictionary of already known properties\n            properties_file: Optional file to save progress\n            \n        Returns:\n            Dictionary of object properties\n        \"\"\"\n        if existing_properties is None:\n            existing_properties = {}\n        \n        # Filter out objects we already have\n        missing_ids = [name for name in object_names if name not in existing_properties]\n        \n        if not missing_ids:\n            logger.info(\"All objects already in cache\")\n            return existing_properties\n        \n        # Calculate batch size\n        batch_size = self.calculate_optimal_batch_size(len(missing_ids))\n        total_batches = (len(missing_ids) + batch_size - 1) // batch_size\n        \n        logger.info(f\"Querying {len(missing_ids)} objects in {total_batches} batches of {batch_size}\")\n        self._update_progress(0, len(missing_ids), f\"Starting SIMBAD queries...\")\n        \n        # Reset stats for this query session\n        self.stats = QueryStats()\n        \n        # Process in batches\n        for batch_num in range(total_batches):\n            batch_start = batch_num * batch_size\n            batch_end = min((batch_num + 1) * batch_size, len(missing_ids))\n            batch_ids = missing_ids[batch_start:batch_end]\n            \n            batch_message = f\"Batch {batch_num + 1}/{total_batches} ({batch_start + 1}-{batch_end})\"\n            logger.info(batch_message)\n            \n            # Process each object in the batch\n            for idx, obj_name in enumerate(batch_ids):\n                global_idx = batch_start + idx\n                \n                # Check for Messier objects (if messier_catalog module is available)\n                try:\n                    from messier_catalog import messier_catalog, star_cluster_catalog\n                    supplemental_data = {**messier_catalog, **star_cluster_catalog}\n                    \n                    if obj_name.startswith('M '):\n                        messier_id = f\"M{obj_name.split()[1]}\"\n                        if messier_id in supplemental_data:\n                            existing_properties[obj_name] = self._process_messier_object(\n                                messier_id, supplemental_data[messier_id]\n                            )\n                            self.stats.log_cached()\n                            continue\n                except ImportError:\n                    pass  # Messier catalog not available\n                \n                # Query SIMBAD\n                result = self._query_single_object(obj_name)\n                \n                if result is not None:\n                    existing_properties[obj_name] = self._process_simbad_result(result)\n                else:\n                    # Store empty entry for failed queries\n                    existing_properties[obj_name] = self._create_empty_entry(obj_name)\n                \n                # Update progress\n                self._update_progress(\n                    global_idx + 1, \n                    len(missing_ids),\n                    f\"{batch_message} - {obj_name}\"\n                )\n                \n                # Save progress periodically\n                if (global_idx + 1) % self.config.save_progress_interval == 0:\n                    if properties_file:\n                        self._save_properties(existing_properties, properties_file)\n                        if self.config.show_detailed_progress:\n                            logger.info(f\"Saved progress at {global_idx + 1} objects\")\n            \n            # Save after each batch\n            if properties_file:\n                self._save_properties(existing_properties, properties_file)\n                logger.info(f\"Batch {batch_num + 1} complete and saved\")\n        \n        # Final statistics\n        logger.info(self.stats.get_summary())\n        rate_stats = self.rate_limiter.get_stats()\n        logger.info(f\"Rate limiting: {rate_stats['actual_rate']:.2f} queries/s \"\n                   f\"(target: {rate_stats['target_rate']:.2f}/s)\")\n        \n        return existing_properties\n    \n    def _process_simbad_result(self, result_table) -> Dict:\n        \"\"\"Process SIMBAD query result into property dictionary.\"\"\"\n        props = {\n            'star_name': None,\n            'spectral_type': None,\n            'V_magnitude': None,\n            'B_magnitude': None,\n            'object_type': None,\n            'is_messier': False\n        }\n        \n        try:\n            # Extract main identifier\n            if 'MAIN_ID' in result_table.colnames:\n                star_name = result_table['MAIN_ID'][0]\n                props['star_name'] = star_name.decode('utf-8') if isinstance(star_name, bytes) else star_name\n            \n            # Extract spectral type\n            if 'SP_TYPE' in result_table.colnames:\n                sp_type = result_table['SP_TYPE'][0]\n                if sp_type:\n                    props['spectral_type'] = sp_type.decode('utf-8') if isinstance(sp_type, bytes) else sp_type\n            \n            # Extract magnitudes\n            if 'FLUX_V' in result_table.colnames:\n                props['V_magnitude'] = self._parse_magnitude(result_table['FLUX_V'][0])\n            \n            if 'FLUX_B' in result_table.colnames:\n                props['B_magnitude'] = self._parse_magnitude(result_table['FLUX_B'][0])\n            \n            # Extract object type\n            if 'OTYPE' in result_table.colnames:\n                otype = result_table['OTYPE'][0]\n                if otype:\n                    props['object_type'] = otype.decode('utf-8') if isinstance(otype, bytes) else otype\n        \n        except Exception as e:\n            logger.error(f\"Error processing SIMBAD result: {e}\")\n        \n        return props\n    \n    def _process_messier_object(self, messier_id: str, messier_data: Dict) -> Dict:\n        \"\"\"Process Messier object data.\"\"\"\n        return {\n            'star_name': messier_id,\n            'spectral_type': messier_data.get('spectral_type'),\n            'V_magnitude': messier_data.get('magnitude'),\n            'B_magnitude': None,\n            'object_type': messier_data.get('type'),\n            'distance_ly': messier_data.get('distance_ly'),\n            'notes': messier_data.get('notes', ''),\n            'is_messier': True\n        }\n    \n    def _create_empty_entry(self, obj_name: str) -> Dict:\n        \"\"\"Create empty property entry for failed queries.\"\"\"\n        return {\n            'star_name': obj_name,\n            'spectral_type': None,\n            'V_magnitude': None,\n            'B_magnitude': None,\n            'object_type': None,\n            'is_messier': False\n        }\n    \n    def _parse_magnitude(self, value) -> Optional[float]:\n        \"\"\"Parse magnitude value from various formats.\"\"\"\n        if value is None:\n            return None\n        if isinstance(value, (int, float)):\n            return float(value)\n        \n        value_str = str(value)\n        # Remove annotations like [~] or [some text]\n        cleaned = re.sub(r\"\\[.*?\\]\", \"\", value_str).strip()\n        \n        try:\n            return float(cleaned)\n        except ValueError:\n            return None\n    \n    def _save_properties(self, properties: Dict, filepath: str):\n        \"\"\"Save properties to file.\"\"\"\n        try:\n            # Convert to list format for compatibility\n            all_unique_ids = list(properties.keys())\n            property_lists = {\n                'unique_ids': all_unique_ids,\n                'star_names': [],\n                'spectral_types': [],\n                'V_magnitudes': [],\n                'B_magnitudes': [],\n                'object_types': [],\n                'is_messier': [],\n                'distance_ly': [],\n                'notes': []\n            }\n            \n            for uid in all_unique_ids:\n                props = properties[uid]\n                property_lists['star_names'].append(props.get('star_name'))\n                property_lists['spectral_types'].append(props.get('spectral_type'))\n                property_lists['V_magnitudes'].append(props.get('V_magnitude'))\n                property_lists['B_magnitudes'].append(props.get('B_magnitude'))\n                property_lists['object_types'].append(props.get('object_type'))\n                property_lists['is_messier'].append(props.get('is_messier', False))\n                property_lists['distance_ly'].append(props.get('distance_ly'))\n                property_lists['notes'].append(props.get('notes', ''))\n            \n            with open(filepath, 'wb') as f:\n                pickle.dump(property_lists, f)\n        \n        except Exception as e:\n            logger.error(f\"Error saving properties to {filepath}: {e}\")\n\n\n    def _extract_properties_from_result(self, result, star_id):\n        \"\"\"Extract properties from SIMBAD query result.\"\"\"\n        props = {'unique_id': star_id}\n        \n        # This is similar to your existing _process_simbad_result but returns different format\n        if 'MAIN_ID' in result.colnames:\n            star_name = result['MAIN_ID']\n            props['star_name'] = star_name.decode('utf-8') if isinstance(star_name, bytes) else str(star_name)\n        \n        if 'SP_TYPE' in result.colnames:\n            sp_type = result['SP_TYPE']\n            if sp_type:\n                props['spectral_type'] = sp_type.decode('utf-8') if isinstance(sp_type, bytes) else str(sp_type)\n        \n        if 'FLUX_V' in result.colnames:\n            props['V_magnitude'] = self._parse_magnitude(result['FLUX_V'])\n        \n        if 'FLUX_B' in result.colnames:\n            props['B_magnitude'] = self._parse_magnitude(result['FLUX_B'])\n        \n        if 'OTYPE' in result.colnames:\n            otype = result['OTYPE']\n            if otype:\n                props['object_type'] = otype.decode('utf-8') if isinstance(otype, bytes) else str(otype)\n        \n        return props\n\n    def load_existing_properties(self, filepath: str) -> Dict:\n        \"\"\"Load existing properties from pickle file.\"\"\"\n        if not os.path.exists(filepath):\n            return {}\n        \n        try:\n            with open(filepath, 'rb') as f:\n                data = pickle.load(f)\n            \n            # Handle both dict and list formats\n            if isinstance(data, dict) and 'unique_ids' in data:\n                # Convert list format to dict\n                properties = {}\n                unique_ids = data.get('unique_ids', [])\n                star_names = data.get('star_names', [])\n                spectral_types = data.get('spectral_types', [])\n                v_mags = data.get('V_magnitudes', [])\n                b_mags = data.get('B_magnitudes', [])\n                obj_types = data.get('object_types', [])\n                \n                for i, uid in enumerate(unique_ids):\n                    properties[uid] = {\n                        'star_name': star_names[i] if i < len(star_names) else None,\n                        'spectral_type': spectral_types[i] if i < len(spectral_types) else None,\n                        'V_magnitude': v_mags[i] if i < len(v_mags) else None,\n                        'B_magnitude': b_mags[i] if i < len(b_mags) else None,\n                        'object_type': obj_types[i] if i < len(obj_types) else None,\n                    }\n                return properties\n            elif isinstance(data, dict):\n                return data\n            else:\n                return {}\n        except Exception as e:\n            logger.error(f\"Error loading properties from {filepath}: {e}\")\n            return {}",
    "start_line": 173,
    "end_line": 1147,
    "has_docstring": true,
    "docstring": "Main class for managing SIMBAD queries with rate limiting and error handling.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class SimbadQueryManager",
    "component_id": "simbad_manager.SimbadQueryManager"
  },
  "simbad_manager.create_custom_simbad": {
    "id": "simbad_manager.create_custom_simbad",
    "name": "create_custom_simbad",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\simbad_manager.py",
    "relative_path": "simbad_manager.py",
    "depends_on": [
      "simbad_manager.SimbadConfig",
      "simbad_manager.SimbadQueryManager"
    ],
    "source_code": "def create_custom_simbad():\n    \"\"\"Compatibility function for existing code.\"\"\"\n    config = SimbadConfig()\n    manager = SimbadQueryManager(config)\n    return manager.simbad",
    "start_line": 1151,
    "end_line": 1155,
    "has_docstring": true,
    "docstring": "Compatibility function for existing code.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_custom_simbad",
    "component_id": "simbad_manager.create_custom_simbad"
  },
  "simbad_manager.query_simbad_for_star_properties": {
    "id": "simbad_manager.query_simbad_for_star_properties",
    "name": "query_simbad_for_star_properties",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\simbad_manager.py",
    "relative_path": "simbad_manager.py",
    "depends_on": [
      "simbad_manager.SimbadQueryManager"
    ],
    "source_code": "def query_simbad_for_star_properties(missing_ids, existing_properties, properties_file):\n    \"\"\"\n    Compatibility wrapper for existing code.\n    This maintains the same interface as the original function.\n    \"\"\"\n    # Load saved configuration if it exists\n    config = SimbadConfig.load_from_file()\n    \n    # Create manager\n    manager = SimbadQueryManager(config)\n    \n    # Query objects\n    updated_properties = manager.query_objects(\n        missing_ids,\n        existing_properties,\n        properties_file\n    )\n    \n    return updated_properties",
    "start_line": 1158,
    "end_line": 1176,
    "has_docstring": true,
    "docstring": "Compatibility wrapper for existing code.\nThis maintains the same interface as the original function.",
    "parameters": [
      "missing_ids",
      "existing_properties",
      "properties_file"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function query_simbad_for_star_properties",
    "component_id": "simbad_manager.query_simbad_for_star_properties"
  },
  "simbad_manager.quick_cache_check": {
    "id": "simbad_manager.quick_cache_check",
    "name": "quick_cache_check",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\simbad_manager.py",
    "relative_path": "simbad_manager.py",
    "depends_on": [
      "simbad_manager.SimbadConfig",
      "simbad_manager.SimbadQueryManager"
    ],
    "source_code": "def quick_cache_check():\n    \"\"\"Quick check of all cache files.\"\"\"\n    config = SimbadConfig()\n    manager = SimbadQueryManager(config)\n    print(manager.generate_cache_report())\n    return manager.verify_cache_integrity()",
    "start_line": 1181,
    "end_line": 1186,
    "has_docstring": true,
    "docstring": "Quick check of all cache files.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function quick_cache_check",
    "component_id": "simbad_manager.quick_cache_check"
  },
  "simbad_manager.rebuild_from_vot": {
    "id": "simbad_manager.rebuild_from_vot",
    "name": "rebuild_from_vot",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\simbad_manager.py",
    "relative_path": "simbad_manager.py",
    "depends_on": [
      "simbad_manager.SimbadConfig",
      "simbad_manager.SimbadQueryManager"
    ],
    "source_code": "def rebuild_from_vot(mode='distance', force=False):\n    \"\"\"\n    Rebuild PKL file from VOT caches.\n    \n    Args:\n        mode: 'distance' or 'magnitude'\n        force: Force rebuild even if PKL exists\n    \"\"\"\n    config = SimbadConfig()\n    manager = SimbadQueryManager(config)\n    \n    # Protect existing files first\n    manager.protect_all_caches()\n    \n    # Rebuild\n    result = manager.rebuild_pkl_from_vot_caches(mode=mode, force_rebuild=force)\n    \n    print(f\"Rebuilt {len(result)} star properties for {mode} mode\")\n    return result",
    "start_line": 1189,
    "end_line": 1207,
    "has_docstring": true,
    "docstring": "Rebuild PKL file from VOT caches.\n\nArgs:\n    mode: 'distance' or 'magnitude'\n    force: Force rebuild even if PKL exists",
    "parameters": [
      "mode",
      "force"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function rebuild_from_vot",
    "component_id": "simbad_manager.rebuild_from_vot"
  },
  "simbad_manager.protect_all_star_data": {
    "id": "simbad_manager.protect_all_star_data",
    "name": "protect_all_star_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\simbad_manager.py",
    "relative_path": "simbad_manager.py",
    "depends_on": [
      "simbad_manager.SimbadConfig",
      "simbad_manager.SimbadQueryManager"
    ],
    "source_code": "def protect_all_star_data():\n    \"\"\"Create protected backups of all star data files.\"\"\"\n    config = SimbadConfig()\n    manager = SimbadQueryManager(config)\n    \n    protected = manager.protect_all_caches()\n    print(f\"Protected {len(protected)} cache files\")\n    \n    # Also generate report\n    print(\"\\n\" + manager.generate_cache_report())\n    \n    return protected",
    "start_line": 1210,
    "end_line": 1221,
    "has_docstring": true,
    "docstring": "Create protected backups of all star data files.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function protect_all_star_data",
    "component_id": "simbad_manager.protect_all_star_data"
  },
  "social_media_export._parse_hover_html": {
    "id": "social_media_export._parse_hover_html",
    "name": "_parse_hover_html",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\social_media_export.py",
    "relative_path": "social_media_export.py",
    "depends_on": [],
    "source_code": "def _parse_hover_html(hover_html):\n    \"\"\"\n    Parse a Plotly hover HTML string into structured panel data.\n\n    The existing hover text follows this pattern:\n      <b>ObjectName</b><br>\n      optional RA/Dec line<br><br>\n      Distance from Center: 1.234 AU<br>\n      Velocity: 0.123 AU/day<br>\n      ...\n\n    Returns:\n        dict with keys: name, subtitle, body\n    \"\"\"\n    if not hover_html or not isinstance(hover_html, str):\n        return None\n\n    text = str(hover_html).strip()\n    if not text:\n        return None\n\n    # Extract the bold name: <b>Name</b>\n    name_match = re.match(r'<b>([^<]+)</b>', text)\n    if name_match:\n        name = name_match.group(1).strip()\n        # Everything after the name tag is potential body content\n        remainder = text[name_match.end():]\n    else:\n        # No bold tag - use first line as name\n        lines = text.split('<br>')\n        name = lines[0].strip()\n        remainder = '<br>'.join(lines[1:])\n\n    # Clean leading <br> tags from remainder\n    remainder = re.sub(r'^(\\s*<br>\\s*)+', '', remainder, flags=re.IGNORECASE)\n\n    # Try to extract a subtitle from RA/Dec line or first italic line\n    subtitle = ''\n    body = remainder\n\n    # Check for RA/Dec as subtitle (common pattern)\n    radec_match = re.match(r'\\s*(RA\\s*[^<]+Dec\\s*[^<]+?)(<br>|$)', remainder, re.IGNORECASE)\n    if radec_match:\n        subtitle = radec_match.group(1).strip()\n        body = remainder[radec_match.end():]\n    else:\n        # Check for italic subtitle: <i>text</i>\n        italic_match = re.match(r'\\s*<i>([^<]+)</i>', remainder)\n        if italic_match:\n            subtitle = italic_match.group(1).strip()\n            body = remainder[italic_match.end():]\n\n    # Clean leading <br> tags from body\n    body = re.sub(r'^(\\s*<br>\\s*)+', '', body, flags=re.IGNORECASE)\n\n    # Clean trailing <br> tags from body\n    body = re.sub(r'(\\s*<br>\\s*)+$', '', body, flags=re.IGNORECASE)\n\n    return {\n        'name': name,\n        'subtitle': subtitle,\n        'body': body\n    }",
    "start_line": 40,
    "end_line": 102,
    "has_docstring": true,
    "docstring": "Parse a Plotly hover HTML string into structured panel data.\n\nThe existing hover text follows this pattern:\n  <b>ObjectName</b><br>\n  optional RA/Dec line<br><br>\n  Distance from Center: 1.234 AU<br>\n  Velocity: 0.123 AU/day<br>\n  ...\n\nReturns:\n    dict with keys: name, subtitle, body",
    "parameters": [
      "hover_html"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _parse_hover_html",
    "component_id": "social_media_export._parse_hover_html"
  },
  "social_media_export._extract_trace_hover_data": {
    "id": "social_media_export._extract_trace_hover_data",
    "name": "_extract_trace_hover_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\social_media_export.py",
    "relative_path": "social_media_export.py",
    "depends_on": [
      "social_media_export._parse_hover_html"
    ],
    "source_code": "def _extract_trace_hover_data(trace):\n    \"\"\"\n    Extract hover content from a single Plotly trace.\n\n    Traces store hover content in the 'text' field as HTML strings.\n    Returns a list of JSON strings (one per point) for customdata,\n    plus a list of name-only strings for the simplified tooltip.\n\n    Returns:\n        tuple: (customdata_list, tooltip_text_list) or (None, None)\n            if trace has no hover content\n    \"\"\"\n    # Get the text field - could be a list or single value\n    text_data = None\n    if hasattr(trace, 'text'):\n        text_data = trace.text\n    elif isinstance(trace, dict):\n        text_data = trace.get('text')\n\n    if text_data is None:\n        return None, None\n\n    # Normalize to list\n    if isinstance(text_data, str):\n        text_list = [text_data]\n    elif isinstance(text_data, (list, tuple)):\n        text_list = list(text_data)\n    else:\n        return None, None\n\n    customdata_list = []\n    tooltip_list = []\n\n    for hover_html in text_list:\n        parsed = _parse_hover_html(hover_html)\n        if parsed:\n            customdata_list.append(json.dumps(parsed))\n            tooltip_list.append(parsed['name'])\n        else:\n            # Keep original text as fallback\n            customdata_list.append(json.dumps({\n                'name': str(hover_html)[:50],\n                'subtitle': '',\n                'body': str(hover_html)\n            }))\n            tooltip_list.append(str(hover_html)[:50])\n\n    return customdata_list, tooltip_list",
    "start_line": 105,
    "end_line": 152,
    "has_docstring": true,
    "docstring": "Extract hover content from a single Plotly trace.\n\nTraces store hover content in the 'text' field as HTML strings.\nReturns a list of JSON strings (one per point) for customdata,\nplus a list of name-only strings for the simplified tooltip.\n\nReturns:\n    tuple: (customdata_list, tooltip_text_list) or (None, None)\n        if trace has no hover content",
    "parameters": [
      "trace"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _extract_trace_hover_data",
    "component_id": "social_media_export._extract_trace_hover_data"
  },
  "social_media_export._prepare_social_figure": {
    "id": "social_media_export._prepare_social_figure",
    "name": "_prepare_social_figure",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\social_media_export.py",
    "relative_path": "social_media_export.py",
    "depends_on": [
      "social_media_export._parse_hover_html"
    ],
    "source_code": "def _prepare_social_figure(fig):\n    \"\"\"\n    Create a modified copy of the Plotly figure optimized for social media.\n\n    Modifications:\n      - Routes hover content to customdata (JSON for panel)\n      - Simplifies tooltip to name-only\n      - Strips annotations, non-animation updatemenus, legend\n      - Preserves animation play/pause buttons and date slider\n      - Removes axis labels, grid, background\n      - Increases marker size and orbit line width for visibility\n      - Sets marker opacity to 0.99 (Plotly hover detection bug workaround)\n      - Configures hoverlabel for minimal name-only tooltip\n\n    Returns:\n        dict: Modified figure as a dictionary (for JSON serialization)\n    \"\"\"\n    # Deep copy the figure data as dict\n    fig_dict = json.loads(fig.to_json())\n\n    # ---- Modify traces ----\n    for trace in fig_dict.get('data', []):\n\n        # Check if this trace has hover content to route\n        hoverinfo = trace.get('hoverinfo', '')\n        hovertemplate = trace.get('hovertemplate', '')\n\n        # Skip traces that explicitly skip hover\n        if hoverinfo == 'skip' or hoverinfo == 'none':\n            continue\n\n        # Get text content for hover-enabled traces\n        text_data = trace.get('text')\n        if text_data is not None:\n            # Normalize to list\n            if isinstance(text_data, str):\n                text_list = [text_data]\n            else:\n                text_list = list(text_data)\n\n            customdata_list = []\n            tooltip_list = []\n\n            for hover_html in text_list:\n                parsed = _parse_hover_html(hover_html)\n                if parsed:\n                    customdata_list.append(json.dumps(parsed))\n                    tooltip_list.append(parsed['name'])\n                else:\n                    fallback = str(hover_html)[:80] if hover_html else ''\n                    customdata_list.append(json.dumps({\n                        'name': fallback,\n                        'subtitle': '',\n                        'body': str(hover_html) if hover_html else ''\n                    }))\n                    tooltip_list.append(fallback)\n\n            # Route: customdata has full content for info panel click handler.\n            # Hover tooltip is disabled - the panel is the only display.\n            # text is cleared to prevent any fallback tooltip rendering.\n            trace['customdata'] = customdata_list\n            trace['text'] = ['' for _ in tooltip_list]\n            trace['hoverinfo'] = 'none'\n            trace['hovertemplate'] = None\n\n        # ---- Visual enhancements for small screens ----\n        marker = trace.get('marker', {})\n        if marker:\n            # Increase marker size\n            size = marker.get('size')\n            if isinstance(size, (int, float)):\n                marker['size'] = size + 4\n            elif isinstance(size, list):\n                marker['size'] = [s + 4 if isinstance(s, (int, float)) else s for s in size]\n\n            # Opacity 0.99 workaround for Plotly hover detection bug\n            marker['opacity'] = 0.99\n            trace['marker'] = marker\n\n        # Thicker orbit lines\n        line = trace.get('line', {})\n        if line and trace.get('mode', '') in ('lines', 'lines+markers'):\n            width = line.get('width', 2)\n            if isinstance(width, (int, float)):\n                line['width'] = max(width, 4)\n            trace['line'] = line\n\n    # ---- Modify layout ----\n    layout = fig_dict.get('layout', {})\n\n    # Strip legend\n    layout['showlegend'] = False\n\n    # Strip annotations (coordinate system box, etc.)\n    layout['annotations'] = []\n\n    # Filter updatemenus: KEEP animation controls (play/pause),\n    # STRIP UI chrome (hover toggle, camera buttons, URL buttons)\n    existing_menus = layout.get('updatemenus', [])\n    animation_menus = []\n    for menu in existing_menus:\n        buttons = menu.get('buttons', [])\n        # Animation menus have buttons with method='animate'\n        has_animate = any(\n            b.get('method') == 'animate' for b in buttons\n        )\n        if has_animate:\n            # Restyle for social view - white text on dark background\n            menu['font'] = {'color': '#f8fafc', 'size': 11}\n            menu['bgcolor'] = '#1e293b'\n            menu['bordercolor'] = '#334155'\n            # Position in top-left of the scene\n            menu['x'] = 0.02\n            menu['y'] = 0.98\n            menu['xanchor'] = 'left'\n            menu['yanchor'] = 'top'\n            # NOTE: redraw stays True so frames actually render.\n            # Camera preservation is handled via JavaScript in\n            # the HTML template (continuous layout.scene.camera sync).\n            animation_menus.append(menu)\n    layout['updatemenus'] = animation_menus\n\n    # Keep sliders for animations (date scrubber), strip otherwise\n    existing_sliders = layout.get('sliders', [])\n    if existing_sliders and animation_menus:\n        # Restyle sliders for social view\n        for slider in existing_sliders:\n            # Step label font: transparent + tiny so tick text is invisible,\n            # but labels must remain as real date strings because Plotly's\n            # currentvalue display reads them.\n            slider['font'] = {'color': 'rgba(0,0,0,0)', 'size': 1}\n            # Hide tick marks\n            slider['tickcolor'] = 'rgba(0,0,0,0)'\n            slider['ticklen'] = 0\n            slider['bordercolor'] = '#334155'\n            slider['borderwidth'] = 1\n            slider['activebgcolor'] = '#475569'\n            slider['bgcolor'] = '#1e293b'\n            # Ensure currentvalue (date display above slider) is visible\n            if 'currentvalue' not in slider:\n                slider['currentvalue'] = {}\n            slider['currentvalue']['visible'] = True\n            slider['currentvalue']['prefix'] = 'Date: '\n            slider['currentvalue']['font'] = {\n                'color': '#f8fafc', 'size': 12\n            }\n            slider['currentvalue']['xanchor'] = 'left'\n            # Keep step labels as real dates (required for currentvalue)\n            # They are hidden by the transparent font above.\n        layout['sliders'] = existing_sliders\n    else:\n        layout['sliders'] = []\n\n    # Minimal margins - add bottom space if animation slider present\n    has_slider = len(layout.get('sliders', [])) > 0\n    layout['margin'] = {'l': 0, 'r': 0, 't': 0, 'b': 40 if has_slider else 0}\n\n    # Dark background\n    layout['paper_bgcolor'] = '#000000'\n    layout['plot_bgcolor'] = '#000000'\n\n    # Configure hoverlabel for name-only tooltip (small, unobtrusive)\n    layout['hoverlabel'] = {\n        'bgcolor': '#0f172a',\n        'bordercolor': '#f8fafc',\n        'font': {\n            'family': 'Consolas, SF Mono, Fira Code, Courier New, monospace',\n            'size': 16,\n            'color': '#f8fafc'\n        },\n        'align': 'left'\n    }\n\n    # Clean up scene axes\n    scene = layout.get('scene', {})\n    for axis_key in ('xaxis', 'yaxis', 'zaxis'):\n        axis = scene.get(axis_key, {})\n        axis['showgrid'] = False\n        axis['zeroline'] = False\n        axis['showticklabels'] = False\n        axis['showspikes'] = False\n        axis['title'] = ''\n        axis['showbackground'] = False\n        axis['visible'] = False\n        scene[axis_key] = axis\n\n    scene['bgcolor'] = '#000000'\n    scene['domain'] = {'x': [0, 1], 'y': [0, 1]}  # Full width (orrery offsets for UI buttons)    \n    layout['scene'] = scene\n\n    fig_dict['layout'] = layout\n\n    # ---- Modify frame traces ----\n    # Animation frames carry their own trace data that REPLACES the base\n    # traces when a frame renders. Without this, the original hovertemplate\n    # and full text content come back on every frame advance.\n    for frame in fig_dict.get('frames', []):\n        for trace in frame.get('data', []):\n            text_data = trace.get('text')\n            if text_data is not None:\n                if isinstance(text_data, str):\n                    text_list = [text_data]\n                else:\n                    text_list = list(text_data)\n\n                customdata_list = []\n                tooltip_list = []\n                for hover_html in text_list:\n                    parsed = _parse_hover_html(hover_html)\n                    if parsed:\n                        customdata_list.append(json.dumps(parsed))\n                        tooltip_list.append(parsed['name'])\n                    else:\n                        fallback = str(hover_html)[:80] if hover_html else ''\n                        customdata_list.append(json.dumps({\n                            'name': fallback,\n                            'subtitle': '',\n                            'body': str(hover_html) if hover_html else ''\n                        }))\n                        tooltip_list.append(fallback)\n\n                trace['customdata'] = customdata_list\n                trace['text'] = ['' for _ in tooltip_list]\n                trace['hoverinfo'] = 'none'\n                trace['hovertemplate'] = None\n\n    return fig_dict",
    "start_line": 155,
    "end_line": 381,
    "has_docstring": true,
    "docstring": "Create a modified copy of the Plotly figure optimized for social media.\n\nModifications:\n  - Routes hover content to customdata (JSON for panel)\n  - Simplifies tooltip to name-only\n  - Strips annotations, non-animation updatemenus, legend\n  - Preserves animation play/pause buttons and date slider\n  - Removes axis labels, grid, background\n  - Increases marker size and orbit line width for visibility\n  - Sets marker opacity to 0.99 (Plotly hover detection bug workaround)\n  - Configures hoverlabel for minimal name-only tooltip\n\nReturns:\n    dict: Modified figure as a dictionary (for JSON serialization)",
    "parameters": [
      "fig"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _prepare_social_figure",
    "component_id": "social_media_export._prepare_social_figure"
  },
  "social_media_export._build_social_html": {
    "id": "social_media_export._build_social_html",
    "name": "_build_social_html",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\social_media_export.py",
    "relative_path": "social_media_export.py",
    "depends_on": [],
    "source_code": "def _build_social_html(fig_dict, plotly_js_src='cdn'):\n    \"\"\"\n    Build the complete HTML string for the social media view.\n\n    Parameters:\n        fig_dict: Modified Plotly figure as dictionary\n        plotly_js_src: 'cdn' for CDN link, 'offline' for embedded (larger file)\n\n    Returns:\n        str: Complete HTML document\n    \"\"\"\n    # Plotly.js source\n    if plotly_js_src == 'cdn':\n        plotly_script = '<script src=\"https://cdn.plot.ly/plotly-2.35.2.min.js\"></script>'\n    else:\n        # For offline, we'd need to embed - for now use CDN\n        plotly_script = '<script src=\"https://cdn.plot.ly/plotly-2.35.2.min.js\"></script>'\n\n    # Serialize figure data\n    fig_json = json.dumps(fig_dict, separators=(',', ':'))\n\n    # Extract data, layout, and frames separately\n    data_json = json.dumps(fig_dict.get('data', []), separators=(',', ':'))\n    layout_json = json.dumps(fig_dict.get('layout', {}), separators=(',', ':'))\n    frames_json = json.dumps(fig_dict.get('frames', []), separators=(',', ':'))\n\n    # Build the HTML template\n    # Using validated prototype design from prototyping session\n    html = f\"\"\"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<title>Paloma's Orrery - Social Media View</title>\n{plotly_script}\n<style>\n  /* ===== RESET & BASE ===== */\n  *, *::before, *::after {{ margin: 0; padding: 0; box-sizing: border-box; }}\n\n  html, body {{\n    width: 100vw;\n    height: 100vh;\n    overflow: hidden;\n    background: #000;\n    color: #f8fafc;\n    font-family: 'Consolas', 'SF Mono', 'Fira Code', 'Courier New', monospace;\n    -webkit-font-smoothing: antialiased;\n  }}\n\n  /* ===== LAYOUT: 60/40 split, locked to 9:16 portrait ===== */\n  .container {{\n    /* Lock to 9:16 aspect ratio: width = height * 9/16 */\n    height: 100vh;\n    width: min(100vw, calc(100vh * 9 / 16));\n    margin: 0 auto;\n    display: flex;\n    flex-direction: column;\n    background: #000;\n  }}\n\n  /* ===== 3D SCENE (top 60%) ===== */\n  .scene-area {{\n    flex: 6;\n    position: relative;\n    min-height: 0;\n  }}\n\n    #plotly-scene {{\n    width: 100%;\n    height: 100%;\n  }}\n\n  /* ===== DIVIDER ===== */\n  .divider {{\n    width: 100%;\n    height: 2px;\n    background: linear-gradient(90deg,\n      transparent 0%,\n      #334155 15%,\n      #64748b 50%,\n      #334155 85%,\n      transparent 100%\n    );\n    flex-shrink: 0;\n  }}\n\n  /* ===== INFO PANEL (bottom 40%) ===== */\n  .info-panel {{\n    flex: 4;\n    display: flex;\n    flex-direction: column;\n    padding: 28px 40px 20px 40px;\n    position: relative;\n    overflow: hidden;\n    min-height: 0;\n  }}\n\n  /* Header zone - object name */\n  .panel-header {{\n    flex-shrink: 0;\n    margin-bottom: 16px;\n    min-height: 60px;\n  }}\n\n  .object-name {{\n    font-size: clamp(28px, 4vw, 42px);\n    font-weight: 700;\n    color: #f8fafc;\n    letter-spacing: 1px;\n    line-height: 1.2;\n    transition: opacity 0.18s ease;\n  }}\n\n  .object-subtitle {{\n    font-size: clamp(16px, 2.2vw, 22px);\n    font-weight: 400;\n    color: #f8fafc;\n    margin-top: 4px;\n    font-style: italic;\n    line-height: 1.3;\n    transition: opacity 0.18s ease;\n  }}\n\n  /* Body zone - full content */\n  .panel-body {{\n    flex: 1;\n    overflow-y: auto;\n    overflow-x: hidden;\n    font-size: clamp(16px, 2.4vw, 24px);\n    line-height: 1.5;\n    color: #f8fafc;\n    padding-right: 8px;\n    transition: opacity 0.18s ease;\n\n    /* Scrollbar styling - subtle */\n    scrollbar-width: thin;\n    scrollbar-color: #334155 transparent;\n  }}\n\n  .panel-body::-webkit-scrollbar {{\n    width: 4px;\n  }}\n  .panel-body::-webkit-scrollbar-track {{\n    background: transparent;\n  }}\n  .panel-body::-webkit-scrollbar-thumb {{\n    background: #334155;\n    border-radius: 2px;\n  }}\n\n  /* Style HTML content in panel */\n  .panel-body b {{\n    color: #f8fafc;\n    font-weight: 600;\n  }}\n\n  .panel-body i {{\n    color: #cbd5e1;\n  }}\n\n  .panel-body br + br {{\n    display: block;\n    content: '';\n    margin-top: 8px;\n  }}\n\n  /* ===== BRANDING ===== */\n  .branding {{\n    position: absolute;\n    bottom: 16px;\n    right: 40px;\n    font-size: 16px;\n    color: #334155;\n    letter-spacing: 2px;\n    text-transform: uppercase;\n    font-weight: 600;\n  }}\n\n  /* ===== INITIAL STATE ===== */\n  .panel-empty-state {{\n    color: #475569;\n    font-size: clamp(16px, 2.2vw, 22px);\n    font-style: italic;\n    margin-top: 40px;\n    text-align: center;\n  }}\n\n  /* ===== FADE TRANSITION ===== */\n  .fading {{\n    opacity: 0.3;\n  }}\n\n  /* ===== HIDE PLOTLY CHROME ===== */\n  .modebar-container {{ display: none !important; }}\n\n</style>\n</head>\n<body>\n\n<div class=\"container\">\n  <!-- 3D Scene -->\n  <div class=\"scene-area\">\n    <div id=\"plotly-scene\"></div>\n  </div>\n\n  <!-- Divider -->\n  <div class=\"divider\"></div>\n\n  <!-- Info Panel -->\n  <div class=\"info-panel\">\n    <div class=\"panel-header\">\n      <div class=\"object-name\" id=\"obj-name\">Paloma's Orrery</div>\n      <div class=\"object-subtitle\" id=\"obj-subtitle\">Hover over an object to explore</div>\n    </div>\n    <div class=\"panel-body\" id=\"obj-body\">\n      <div class=\"panel-empty-state\">\n        Point at any planet, moon, or orbit to see its data here.\n      </div>\n    </div>\n    <div class=\"branding\">Paloma's Orrery</div>\n  </div>\n</div>\n\n<script>\n// ===== RENDER PLOTLY FIGURE =====\ndocument.addEventListener('DOMContentLoaded', function() {{\n\n  var data = {data_json};\n  var layout = {layout_json};\n  var frames = {frames_json};\n\n  var config = {{\n    displayModeBar: false,\n    scrollZoom: true,\n    responsive: true,\n    doubleClick: false\n  }};\n\n  // Force layout to fill the scene container\n  layout.autosize = true;\n\n  Plotly.newPlot('plotly-scene', data, layout, config).then(function() {{\n    // Add frames if animation\n    if (frames && frames.length > 0) {{\n      Plotly.addFrames('plotly-scene', frames);\n\n      // ===== CAMERA PRESERVATION FOR ANIMATIONS =====\n      // Plotly 3D redraw rebuilds WebGL from layout.scene.camera,\n      // resetting the user's view. We continuously track the camera\n      // and inject it back into the layout before each frame renders,\n      // then restore it after each redraw completes.\n      var plotDiv = document.getElementById('plotly-scene');\n      var lastCamera = null;\n\n      // Continuously track camera position (100ms poll)\n      setInterval(function() {{\n        try {{\n          var scene = plotDiv._fullLayout.scene._scene;\n          if (scene) {{\n            lastCamera = scene.getCamera();\n          }}\n        }} catch(e) {{}}\n      }}, 100);\n\n      // Before each frame renders, inject our camera into the layout\n      plotDiv.on('plotly_animatingframe', function(eventData) {{\n        if (lastCamera) {{\n          try {{\n            plotDiv._fullLayout.scene.camera = lastCamera;\n            plotDiv.layout.scene.camera = lastCamera;\n          }} catch(e) {{}}\n        }}\n      }});\n\n      // After each frame, restore camera if it got reset\n      plotDiv.on('plotly_afterplot', function() {{\n        if (lastCamera) {{\n          try {{\n            var scene = plotDiv._fullLayout.scene._scene;\n            if (scene) {{\n              scene.setCamera(lastCamera);\n            }}\n          }} catch(e) {{}}\n        }}\n      }});\n    }}\n    initEventListeners();\n  }});\n\n  // ===== RESIZE HANDLER =====\n  // Forces Plotly to recalculate WebGL hover coordinates after window resize.\n  // Critical for 9:16 where resize can break hover detection.\n  var resizeTimer = null;\n  window.addEventListener('resize', function() {{\n    if (resizeTimer) clearTimeout(resizeTimer);\n    resizeTimer = setTimeout(function() {{\n      var plotDiv = document.getElementById('plotly-scene');\n      Plotly.relayout(plotDiv, {{\n        'scene.camera': plotDiv._fullLayout.scene._scene.getCamera()\n      }});\n    }}, 250);\n  }});\n\n}});\n\n// ===== PANEL UPDATE LOGIC =====\nvar hoverTimer = null;\nvar currentObjectData = null;\nvar HOVER_DELAY = 800; // ms - throttle for smooth experience\n\nvar nameEl, subtitleEl, bodyEl;\n\nfunction initEventListeners() {{\n  nameEl = document.getElementById('obj-name');\n  subtitleEl = document.getElementById('obj-subtitle');\n  bodyEl = document.getElementById('obj-body');\n\n  var plotlyDiv = document.getElementById('plotly-scene');\n\n  // Hover: throttled panel update (primary in 16:9)\n  plotlyDiv.on('plotly_hover', function(data) {{\n    var point = data.points[0];\n    if (!point.customdata) return;\n\n    var objectData = point.customdata;\n\n    // Same object - don't restart timer\n    if (objectData === currentObjectData) return;\n\n    // Clear pending timer\n    if (hoverTimer) clearTimeout(hoverTimer);\n\n    // New timer\n    hoverTimer = setTimeout(function() {{\n      currentObjectData = objectData;\n      updatePanel(objectData);\n    }}, HOVER_DELAY);\n  }});\n\n  plotlyDiv.on('plotly_unhover', function() {{\n    if (hoverTimer) {{\n      clearTimeout(hoverTimer);\n      hoverTimer = null;\n    }}\n    // Panel stays showing last object (sticky)\n  }});\n\n  // Click: immediate panel update (backup, essential for 9:16\n  // where hover detection is unreliable after resize)\n  plotlyDiv.on('plotly_click', function(data) {{\n    var point = data.points[0];\n    if (!point.customdata) return;\n\n    // Clear any pending hover timer\n    if (hoverTimer) {{\n      clearTimeout(hoverTimer);\n      hoverTimer = null;\n    }}\n\n    var objectData = point.customdata;\n    currentObjectData = objectData;\n    updatePanel(objectData);\n  }});\n}}\n\nfunction updatePanel(data) {{\n  try {{\n    var parsed = (typeof data === 'string') ? JSON.parse(data) : data;\n\n    // Fade out\n    nameEl.classList.add('fading');\n    subtitleEl.classList.add('fading');\n    bodyEl.classList.add('fading');\n\n    setTimeout(function() {{\n      nameEl.textContent = parsed.name || '';\n      subtitleEl.textContent = parsed.subtitle || '';\n      bodyEl.innerHTML = parsed.body || '';\n\n      // Auto-size font for body\n      autoSizeFont();\n\n      // Fade in\n      nameEl.classList.remove('fading');\n      subtitleEl.classList.remove('fading');\n      bodyEl.classList.remove('fading');\n    }}, 180);\n\n  }} catch(e) {{\n    // Fallback: display raw content\n    bodyEl.innerHTML = String(data);\n  }}\n}}\n\nfunction autoSizeFont() {{\n  // Start at base size, shrink if content overflows\n  var baseFontSize = 24;\n  var minFontSize = 16;\n  var fontSize = baseFontSize;\n\n  bodyEl.style.fontSize = fontSize + 'px';\n\n  // Check overflow against available panel height\n  var panelEl = bodyEl.parentElement;\n  var headerEl = document.querySelector('.panel-header');\n  var maxHeight = panelEl.offsetHeight - headerEl.offsetHeight - 80;\n\n  while (bodyEl.scrollHeight > maxHeight && fontSize > minFontSize) {{\n    fontSize -= 1;\n    bodyEl.style.fontSize = fontSize + 'px';\n  }}\n}}\n</script>\n</body>\n</html>\n\"\"\"\n    return html",
    "start_line": 384,
    "end_line": 800,
    "has_docstring": true,
    "docstring": "Build the complete HTML string for the social media view.\n\nParameters:\n    fig_dict: Modified Plotly figure as dictionary\n    plotly_js_src: 'cdn' for CDN link, 'offline' for embedded (larger file)\n\nReturns:\n    str: Complete HTML document",
    "parameters": [
      "fig_dict",
      "plotly_js_src"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _build_social_html",
    "component_id": "social_media_export._build_social_html"
  },
  "social_media_export.get_trace_names": {
    "id": "social_media_export.get_trace_names",
    "name": "get_trace_names",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\social_media_export.py",
    "relative_path": "social_media_export.py",
    "depends_on": [],
    "source_code": "def get_trace_names(fig):\n    \"\"\"\n    Get a list of trace names from a Plotly figure.\n\n    Returns a list of (index, name) tuples for all traces.\n    Traces without a name get a generated label.\n\n    Parameters:\n        fig: Plotly figure object\n\n    Returns:\n        list of (int, str): (trace_index, trace_name) pairs\n    \"\"\"\n    names = []\n    for i, trace in enumerate(fig.data):\n        name = getattr(trace, 'name', None) or ''\n        if not name:\n            # Generate a label from trace type and index\n            trace_type = getattr(trace, 'type', 'trace')\n            name = f\"{trace_type} #{i}\"\n        names.append((i, name))\n    return names",
    "start_line": 803,
    "end_line": 824,
    "has_docstring": true,
    "docstring": "Get a list of trace names from a Plotly figure.\n\nReturns a list of (index, name) tuples for all traces.\nTraces without a name get a generated label.\n\nParameters:\n    fig: Plotly figure object\n\nReturns:\n    list of (int, str): (trace_index, trace_name) pairs",
    "parameters": [
      "fig"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_trace_names",
    "component_id": "social_media_export.get_trace_names"
  },
  "social_media_export.show_trace_selection_dialog": {
    "id": "social_media_export.show_trace_selection_dialog",
    "name": "show_trace_selection_dialog",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\social_media_export.py",
    "relative_path": "social_media_export.py",
    "depends_on": [
      "social_media_export.get_trace_names"
    ],
    "source_code": "def show_trace_selection_dialog(fig, parent=None):\n    \"\"\"\n    Show a dialog with checkboxes for each trace in the figure.\n\n    All traces are checked by default. The user unchecks traces\n    they want excluded from the social media export.\n\n    Parameters:\n        fig: Plotly figure object\n        parent: Parent Tk window (optional, for proper stacking)\n\n    Returns:\n        list of str: Names of selected traces, or None if cancelled.\n    \"\"\"\n    import tkinter as tk\n    import platform\n\n    trace_names = get_trace_names(fig)\n    if not trace_names:\n        return None\n\n    result = {'confirmed': False, 'selected': []}\n\n    # Create dialog window\n    if parent:\n        dialog = tk.Toplevel(parent)\n    else:\n        dialog = tk.Tk()\n\n    dialog.title(\"Social Media View - Select Traces\")\n    dialog.geometry(\"500x600\")\n    dialog.resizable(True, True)\n\n    # Try to keep on top\n    try:\n        dialog.attributes('-topmost', True)\n    except Exception:\n        pass\n\n    # Instructions\n    instructions = tk.Label(\n        dialog,\n        text=\"Select which traces to include in the social media view.\\n\"\n             \"Uncheck traces you want to hide.\",\n        justify='left',\n        wraplength=460,\n        pady=10,\n        padx=10\n    )\n    instructions.pack(fill='x')\n\n    # Scrollable frame for checkboxes\n    container = tk.Frame(dialog)\n    container.pack(fill='both', expand=True, padx=10)\n\n    canvas = tk.Canvas(container)\n    scrollbar = tk.Scrollbar(container, orient='vertical', command=canvas.yview)\n    scrollable_frame = tk.Frame(canvas)\n\n    scrollable_frame.bind(\n        '<Configure>',\n        lambda e: canvas.configure(scrollregion=canvas.bbox('all'))\n    )\n\n    canvas.create_window((0, 0), window=scrollable_frame, anchor='nw')\n    canvas.configure(yscrollcommand=scrollbar.set)\n\n    canvas.pack(side='left', fill='both', expand=True)\n    scrollbar.pack(side='right', fill='y')\n\n    # Mouse wheel scrolling\n    def on_mousewheel(event):\n        if platform.system() == 'Darwin':\n            canvas.yview_scroll(-1 * event.delta, 'units')\n        else:\n            canvas.yview_scroll(-1 * (event.delta // 120), 'units')\n\n    canvas.bind_all('<MouseWheel>', on_mousewheel)\n\n    # Create checkbox variables\n    check_vars = []\n    for idx, name in trace_names:\n        var = tk.IntVar(value=1)  # All checked by default\n        check_vars.append((idx, name, var))\n\n        cb = tk.Checkbutton(\n            scrollable_frame,\n            text=name,\n            variable=var,\n            anchor='w'\n        )\n        cb.pack(fill='x', padx=5, pady=1)\n\n    # Select All / Deselect All buttons\n    toggle_frame = tk.Frame(dialog)\n    toggle_frame.pack(fill='x', padx=10, pady=(5, 0))\n\n    def select_all():\n        for _, _, var in check_vars:\n            var.set(1)\n\n    def deselect_all():\n        for _, _, var in check_vars:\n            var.set(0)\n\n    tk.Button(toggle_frame, text=\"Select All\", command=select_all, width=12).pack(side='left', padx=5)\n    tk.Button(toggle_frame, text=\"Deselect All\", command=deselect_all, width=12).pack(side='left', padx=5)\n\n    # Count label\n    count_label = tk.Label(toggle_frame, text=f\"{len(trace_names)} traces\")\n    count_label.pack(side='right', padx=5)\n\n    # OK / Cancel buttons\n    button_frame = tk.Frame(dialog)\n    button_frame.pack(fill='x', padx=10, pady=10)\n\n    def on_ok():\n        result['confirmed'] = True\n        result['selected'] = [\n            name for _, name, var in check_vars if var.get() == 1\n        ]\n        dialog.destroy()\n\n    def on_cancel():\n        result['confirmed'] = False\n        dialog.destroy()\n\n    tk.Button(button_frame, text=\"Export\", command=on_ok, width=12,\n              bg='gray90', fg='blue').pack(side='left', padx=5)\n    tk.Button(button_frame, text=\"Cancel\", command=on_cancel, width=12).pack(side='left', padx=5)\n\n    # Handle window close\n    dialog.protocol('WM_DELETE_WINDOW', on_cancel)\n\n    # Unbind mousewheel on close to avoid errors\n    def cleanup():\n        try:\n            canvas.unbind_all('<MouseWheel>')\n        except Exception:\n            pass\n\n    dialog.bind('<Destroy>', lambda e: cleanup())\n\n    # Wait for dialog\n    dialog.wait_window()\n\n    if result['confirmed']:\n        return result['selected']\n    return None",
    "start_line": 827,
    "end_line": 975,
    "has_docstring": true,
    "docstring": "Show a dialog with checkboxes for each trace in the figure.\n\nAll traces are checked by default. The user unchecks traces\nthey want excluded from the social media export.\n\nParameters:\n    fig: Plotly figure object\n    parent: Parent Tk window (optional, for proper stacking)\n\nReturns:\n    list of str: Names of selected traces, or None if cancelled.",
    "parameters": [
      "fig",
      "parent"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function show_trace_selection_dialog",
    "component_id": "social_media_export.show_trace_selection_dialog"
  },
  "social_media_export.on_mousewheel": {
    "id": "social_media_export.on_mousewheel",
    "name": "on_mousewheel",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\social_media_export.py",
    "relative_path": "social_media_export.py",
    "depends_on": [],
    "source_code": "    def on_mousewheel(event):\n        if platform.system() == 'Darwin':\n            canvas.yview_scroll(-1 * event.delta, 'units')\n        else:\n            canvas.yview_scroll(-1 * (event.delta // 120), 'units')",
    "start_line": 898,
    "end_line": 902,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "event"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function on_mousewheel",
    "component_id": "social_media_export.on_mousewheel"
  },
  "social_media_export.select_all": {
    "id": "social_media_export.select_all",
    "name": "select_all",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\social_media_export.py",
    "relative_path": "social_media_export.py",
    "depends_on": [],
    "source_code": "    def select_all():\n        for _, _, var in check_vars:\n            var.set(1)",
    "start_line": 924,
    "end_line": 926,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function select_all",
    "component_id": "social_media_export.select_all"
  },
  "social_media_export.deselect_all": {
    "id": "social_media_export.deselect_all",
    "name": "deselect_all",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\social_media_export.py",
    "relative_path": "social_media_export.py",
    "depends_on": [],
    "source_code": "    def deselect_all():\n        for _, _, var in check_vars:\n            var.set(0)",
    "start_line": 928,
    "end_line": 930,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function deselect_all",
    "component_id": "social_media_export.deselect_all"
  },
  "social_media_export.on_ok": {
    "id": "social_media_export.on_ok",
    "name": "on_ok",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\social_media_export.py",
    "relative_path": "social_media_export.py",
    "depends_on": [],
    "source_code": "    def on_ok():\n        result['confirmed'] = True\n        result['selected'] = [\n            name for _, name, var in check_vars if var.get() == 1\n        ]\n        dialog.destroy()",
    "start_line": 943,
    "end_line": 948,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function on_ok",
    "component_id": "social_media_export.on_ok"
  },
  "social_media_export.on_cancel": {
    "id": "social_media_export.on_cancel",
    "name": "on_cancel",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\social_media_export.py",
    "relative_path": "social_media_export.py",
    "depends_on": [],
    "source_code": "    def on_cancel():\n        result['confirmed'] = False\n        dialog.destroy()",
    "start_line": 950,
    "end_line": 952,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function on_cancel",
    "component_id": "social_media_export.on_cancel"
  },
  "social_media_export.cleanup": {
    "id": "social_media_export.cleanup",
    "name": "cleanup",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\social_media_export.py",
    "relative_path": "social_media_export.py",
    "depends_on": [],
    "source_code": "    def cleanup():\n        try:\n            canvas.unbind_all('<MouseWheel>')\n        except Exception:\n            pass",
    "start_line": 962,
    "end_line": 966,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function cleanup",
    "component_id": "social_media_export.cleanup"
  },
  "social_media_export._show_social_save_dialog": {
    "id": "social_media_export._show_social_save_dialog",
    "name": "_show_social_save_dialog",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\social_media_export.py",
    "relative_path": "social_media_export.py",
    "depends_on": [
      "save_utils._get_initial_directory",
      "save_utils._update_last_directory"
    ],
    "source_code": "def _show_social_save_dialog():\n    \"\"\"\n    Show a save-as dialog for the social media HTML export.\n\n    Uses the same pattern as save_utils: remembers last directory,\n    defaults to Documents folder, provides a timestamped default name.\n\n    Returns:\n        str or None: Chosen file path, or None if cancelled.\n    \"\"\"\n    import threading as _threading\n\n    # macOS thread safety: skip dialog if not main thread\n    if platform.system() == 'Darwin' and _threading.current_thread() is not _threading.main_thread():\n        # Fall back to timestamped name in current directory\n        from datetime import datetime as _dt\n        ts = _dt.now().strftime('%Y%m%d_%H%M')\n        fallback = f\"social_view_{ts}.html\"\n        print(f\"[SOCIAL MEDIA] macOS thread safety: saving as {fallback}\")\n        return fallback\n\n    root = None\n    try:\n        from datetime import datetime as _dt\n        ts = _dt.now().strftime('%Y%m%d_%H%M')\n        default_name = f\"social_view_{ts}.html\"\n\n        # Try to use save_utils initial directory if available\n        try:\n            from save_utils import _get_initial_directory, _update_last_directory\n            initial_dir = _get_initial_directory()\n        except ImportError:\n            # Fallback: Documents folder\n            if platform.system() == 'Windows':\n                initial_dir = os.path.join(os.path.expanduser('~'), 'Documents')\n            else:\n                initial_dir = os.path.expanduser('~')\n            _update_last_directory = None\n\n        if not os.path.isdir(initial_dir):\n            initial_dir = os.getcwd()\n\n        root = tk.Tk()\n        root.withdraw()\n        root.attributes('-topmost', True)\n\n        file_path = filedialog.asksaveasfilename(\n            parent=root,\n            title=\"Save Social Media View\",\n            initialdir=initial_dir,\n            initialfile=default_name,\n            defaultextension=\".html\",\n            filetypes=[(\"HTML files\", \"*.html\"), (\"All files\", \"*.*\")]\n        )\n\n        if file_path:\n            # Update save_utils directory memory if available\n            if _update_last_directory is not None:\n                _update_last_directory(file_path)\n            return file_path\n\n        return None\n\n    except Exception as e:\n        print(f\"[SOCIAL MEDIA] Save dialog error: {e}\", flush=True)\n        # Fall back to timestamped name in current directory\n        from datetime import datetime as _dt\n        ts = _dt.now().strftime('%Y%m%d_%H%M')\n        return f\"social_view_{ts}.html\"\n\n    finally:\n        try:\n            if root:\n                root.destroy()\n        except Exception:\n            pass",
    "start_line": 978,
    "end_line": 1053,
    "has_docstring": true,
    "docstring": "Show a save-as dialog for the social media HTML export.\n\nUses the same pattern as save_utils: remembers last directory,\ndefaults to Documents folder, provides a timestamped default name.\n\nReturns:\n    str or None: Chosen file path, or None if cancelled.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function _show_social_save_dialog",
    "component_id": "social_media_export._show_social_save_dialog"
  },
  "social_media_export.export_social_html": {
    "id": "social_media_export.export_social_html",
    "name": "export_social_html",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\social_media_export.py",
    "relative_path": "social_media_export.py",
    "depends_on": [
      "social_media_export._prepare_social_figure",
      "social_media_export._build_social_html",
      "social_media_export._show_social_save_dialog"
    ],
    "source_code": "def export_social_html(fig, output_path=None, open_browser=True,\n                       plotly_js='cdn', trace_names=None):\n    \"\"\"\n    Export a Plotly figure as a social-media-optimized HTML file.\n\n    Creates a 9:16 portrait layout with:\n      - Top 60%: Interactive 3D scene (stripped of UI chrome)\n      - Bottom 40%: Persistent info panel (displays full hovertext)\n\n    The resulting HTML is designed for screen recording with Clipchamp\n    or similar tools, producing Instagram Reels or YouTube Shorts.\n\n    Save behavior:\n      - If output_path is provided: saves directly (no dialog)\n      - If output_path is None: shows save dialog via save_utils pattern\n\n    Parameters:\n        fig: Plotly figure object (from plot_objects() or animate_objects())\n        output_path: Output file path. If None, shows save dialog.\n        open_browser: If True, opens the file in the default browser.\n        plotly_js: 'cdn' for CDN-hosted Plotly.js (~10KB file),\n                   'offline' for embedded (~5MB file, works without internet)\n        trace_names: List of trace names to include. If None, all traces\n                     are included. Use show_trace_selection_dialog() to\n                     get this list from a GUI dialog.\n\n    Returns:\n        str: Path to the generated HTML file, or None on error/cancel.\n\n    Example:\n        from social_media_export import export_social_html\n\n        fig = plot_objects()  # existing Plotly figure\n        path = export_social_html(fig)\n        # Shows save dialog, then opens in browser\n\n        # Direct save (no dialog):\n        export_social_html(fig, output_path='my_social.html')\n\n        # With trace filtering:\n        selected = show_trace_selection_dialog(fig)\n        if selected is not None:\n            export_social_html(fig, trace_names=selected)\n    \"\"\"\n    try:\n        print(f\"[SOCIAL MEDIA] Preparing social media view...\", flush=True)\n\n        # Filter traces if trace_names provided\n        if trace_names is not None:\n            import plotly.graph_objects as go\n            filtered_data = [\n                t for t in fig.data\n                if (getattr(t, 'name', '') or '') in trace_names\n            ]\n            fig_filtered = go.Figure(data=filtered_data, layout=fig.layout)\n            # Preserve frames if animation\n            if hasattr(fig, 'frames') and fig.frames:\n                fig_filtered.frames = fig.frames\n            kept = len(filtered_data)\n            total = len(fig.data)\n            print(f\"[SOCIAL MEDIA] Trace filter: {kept}/{total} traces selected\", flush=True)\n        else:\n            fig_filtered = fig\n\n        # Prepare the modified figure\n        fig_dict = _prepare_social_figure(fig_filtered)\n\n        # Count traces with panel data\n        panel_traces = sum(\n            1 for t in fig_dict.get('data', [])\n            if t.get('customdata') and t.get('hoverinfo') != 'skip'\n        )\n        total_traces = len(fig_dict.get('data', []))\n        print(f\"[SOCIAL MEDIA] {panel_traces}/{total_traces} traces routed to info panel\", flush=True)\n\n        # Build HTML\n        html_content = _build_social_html(fig_dict, plotly_js_src=plotly_js)\n\n        # ---- Save: dialog or direct ----\n        if output_path is not None:\n            # Direct save (no dialog) - for programmatic use\n            if not output_path.endswith('.html'):\n                output_path += '.html'\n            save_path = output_path\n        else:\n            # Show save dialog - matches save_utils pattern\n            save_path = _show_social_save_dialog()\n            if save_path is None:\n                print(\"[SOCIAL MEDIA] Save cancelled by user.\", flush=True)\n                return None\n\n        # Write file\n        with open(save_path, 'w', encoding='utf-8', newline='\\n') as f:\n            f.write(html_content)\n\n        file_size_kb = os.path.getsize(save_path) / 1024\n        print(f\"[SOCIAL MEDIA] Saved: {save_path} ({file_size_kb:.0f} KB)\", flush=True)\n        print(f\"[SOCIAL MEDIA] Open in Chrome, resize to 9:16, screen record.\", flush=True)\n\n        # Open in browser\n        if open_browser:\n            webbrowser.open('file://' + os.path.abspath(save_path))\n\n        return save_path\n\n    except Exception as e:\n        print(f\"[SOCIAL MEDIA] Error: {e}\", flush=True)\n        import traceback\n        traceback.print_exc()\n        return None",
    "start_line": 1056,
    "end_line": 1165,
    "has_docstring": true,
    "docstring": "Export a Plotly figure as a social-media-optimized HTML file.\n\nCreates a 9:16 portrait layout with:\n  - Top 60%: Interactive 3D scene (stripped of UI chrome)\n  - Bottom 40%: Persistent info panel (displays full hovertext)\n\nThe resulting HTML is designed for screen recording with Clipchamp\nor similar tools, producing Instagram Reels or YouTube Shorts.\n\nSave behavior:\n  - If output_path is provided: saves directly (no dialog)\n  - If output_path is None: shows save dialog via save_utils pattern\n\nParameters:\n    fig: Plotly figure object (from plot_objects() or animate_objects())\n    output_path: Output file path. If None, shows save dialog.\n    open_browser: If True, opens the file in the default browser.\n    plotly_js: 'cdn' for CDN-hosted Plotly.js (~10KB file),\n               'offline' for embedded (~5MB file, works without internet)\n    trace_names: List of trace names to include. If None, all traces\n                 are included. Use show_trace_selection_dialog() to\n                 get this list from a GUI dialog.\n\nReturns:\n    str: Path to the generated HTML file, or None on error/cancel.\n\nExample:\n    from social_media_export import export_social_html\n\n    fig = plot_objects()  # existing Plotly figure\n    path = export_social_html(fig)\n    # Shows save dialog, then opens in browser\n\n    # Direct save (no dialog):\n    export_social_html(fig, output_path='my_social.html')\n\n    # With trace filtering:\n    selected = show_trace_selection_dialog(fig)\n    if selected is not None:\n        export_social_html(fig, trace_names=selected)",
    "parameters": [
      "fig",
      "output_path",
      "open_browser",
      "plotly_js",
      "trace_names"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function export_social_html",
    "component_id": "social_media_export.export_social_html"
  },
  "solar_visualization_shells.create_sun_hover_text": {
    "id": "solar_visualization_shells.create_sun_hover_text",
    "name": "create_sun_hover_text",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_sun_hover_text():\n    \"\"\"\n    Creates hover text for the Sun visualization with information about each layer.\n    Future expansion could include dynamic temperature and size data.\n    \n    Returns:\n        dict: Hover text for each layer of the Sun\n    \"\"\"\n    return {\n        'photosphere': (\n            'Solar Photosphere<br>'\n            'Temperature: ~6,000K<br>'\n            'Radius: 0.00465 AU'\n        ),\n        'inner_corona': (\n            'Inner Corona<br>'\n            'Temperature: >2,000,000K<br>'\n            'Extends to: 2-3 solar radii (~0.014 AU)'\n        ),\n        'outer_corona': (\n            'Outer Corona<br>'\n            'Temperature: ~1,000,000K<br>'\n            'Extends to: ~50 solar radii (~0.2 AU)'\n        )\n    }",
    "start_line": 713,
    "end_line": 737,
    "has_docstring": true,
    "docstring": "Creates hover text for the Sun visualization with information about each layer.\nFuture expansion could include dynamic temperature and size data.\n\nReturns:\n    dict: Hover text for each layer of the Sun",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_hover_text",
    "component_id": "solar_visualization_shells.create_sun_hover_text"
  },
  "solar_visualization_shells.create_corona_sphere": {
    "id": "solar_visualization_shells.create_corona_sphere",
    "name": "create_corona_sphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_corona_sphere(radius, n_points=100):  # Increased from 50 to 100 points\n    \"\"\"Create points for a sphere surface to represent corona layers.\"\"\"\n    phi = np.linspace(0, 2*np.pi, n_points)\n    theta = np.linspace(-np.pi/2, np.pi/2, n_points)\n    phi, theta = np.meshgrid(phi, theta)\n\n    x = radius * np.cos(theta) * np.cos(phi)\n    y = radius * np.cos(theta) * np.sin(phi)\n    z = radius * np.sin(theta)\n    \n    return x.flatten(), y.flatten(), z.flatten()",
    "start_line": 740,
    "end_line": 750,
    "has_docstring": true,
    "docstring": "Create points for a sphere surface to represent corona layers.",
    "parameters": [
      "radius",
      "n_points"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_corona_sphere",
    "component_id": "solar_visualization_shells.create_corona_sphere"
  },
  "solar_visualization_shells.create_sun_gravitational_shell": {
    "id": "solar_visualization_shells.create_sun_gravitational_shell",
    "name": "create_sun_gravitational_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_sun_gravitational_shell():\n    \"\"\"Creates the Sun's gravitational influence shell.\"\"\"\n    x, y, z = create_sphere_points(GRAVITATIONAL_INFLUENCE_AU, n_points=40)\n    \n    text_array = [gravitational_influence_info_hover for _ in range(len(x))]\n    customdata_array = [\"Sun's Gravitational Influence\" for _ in range(len(x))]\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=1.0,\n                color='rgb(102, 187, 106)', \n                opacity=0.3\n            ),\n            name='Sun\\'s Gravitational Influence',\n            text=text_array,             \n            customdata=customdata_array,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ),\n    ]\n    \n    \"\"\"\n    sun_traces = create_sun_direction_indicator(\n        center_position=(0, 0, 0), \n        shell_radius=GRAVITATIONAL_INFLUENCE_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace) \n    \"\"\"\n\n    return traces",
    "start_line": 754,
    "end_line": 787,
    "has_docstring": true,
    "docstring": "Creates the Sun's gravitational influence shell.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_gravitational_shell",
    "component_id": "solar_visualization_shells.create_sun_gravitational_shell"
  },
  "solar_visualization_shells.create_sun_outer_oort_shell": {
    "id": "solar_visualization_shells.create_sun_outer_oort_shell",
    "name": "create_sun_outer_oort_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_sun_outer_oort_shell():\n    \"\"\"Creates the Sun's outer Oort cloud shell.\"\"\"\n    x, y, z = create_sphere_points(OUTER_OORT_CLOUD_AU, n_points=40)\n    \n    text_array = [outer_oort_info_hover for _ in range(len(x))]\n    customdata_array = [\"Outer Oort Cloud\" for _ in range(len(x))]\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=1.0,\n                color='white',\n                opacity=0.2\n            ),\n            name='Outer Oort Cloud',\n            text=text_array,\n            customdata=customdata_array,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ),\n    ]\n    \n    \"\"\"\n    sun_traces = create_sun_direction_indicator(\n        center_position=(0, 0, 0), \n        shell_radius=OUTER_OORT_CLOUD_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace) \n    \"\"\"\n\n    return traces",
    "start_line": 789,
    "end_line": 822,
    "has_docstring": true,
    "docstring": "Creates the Sun's outer Oort cloud shell.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_outer_oort_shell",
    "component_id": "solar_visualization_shells.create_sun_outer_oort_shell"
  },
  "solar_visualization_shells.create_sun_inner_oort_shell": {
    "id": "solar_visualization_shells.create_sun_inner_oort_shell",
    "name": "create_sun_inner_oort_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_sun_inner_oort_shell():\n    \"\"\"Creates the Sun's inner Oort cloud shell.\"\"\"\n    x, y, z = create_sphere_points(INNER_OORT_CLOUD_AU, n_points=40)\n    \n    text_array = [inner_oort_info_hover for _ in range(len(x))]\n    customdata_array = [\"Inner Oort Cloud\" for _ in range(len(x))]\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=1.0,\n                color='white',\n                opacity=0.3\n            ),\n            name='Inner Oort Cloud',\n            text=text_array,\n            customdata=customdata_array,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ),\n    ]\n    \n    \"\"\"\n    sun_traces = create_sun_direction_indicator(\n        center_position=(0, 0, 0), \n        shell_radius=INNER_OORT_CLOUD_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n    \"\"\"\n    \n    return traces",
    "start_line": 824,
    "end_line": 857,
    "has_docstring": true,
    "docstring": "Creates the Sun's inner Oort cloud shell.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_inner_oort_shell",
    "component_id": "solar_visualization_shells.create_sun_inner_oort_shell"
  },
  "solar_visualization_shells.create_sun_inner_oort_limit_shell": {
    "id": "solar_visualization_shells.create_sun_inner_oort_limit_shell",
    "name": "create_sun_inner_oort_limit_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_sun_inner_oort_limit_shell():\n    \"\"\"Creates the inner limit of the Sun's Oort cloud shell.\"\"\"\n    x, y, z = create_sphere_points(INNER_LIMIT_OORT_CLOUD_AU, n_points=40)\n    \n    text_array = [inner_limit_oort_info_hover for _ in range(len(x))]\n    customdata_array = [\"Inner Limit of Oort Cloud\" for _ in range(len(x))]\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=1.0,\n                color='white',\n                opacity=0.3\n            ),\n            name='Inner Limit of Oort Cloud',\n            text=text_array,\n            customdata=customdata_array,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ),\n    ]\n    \n    \"\"\"\n    sun_traces = create_sun_direction_indicator(\n        center_position=(0, 0, 0), \n        shell_radius=INNER_LIMIT_OORT_CLOUD_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n    \"\"\"\n\n    return traces",
    "start_line": 859,
    "end_line": 892,
    "has_docstring": true,
    "docstring": "Creates the inner limit of the Sun's Oort cloud shell.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_inner_oort_limit_shell",
    "component_id": "solar_visualization_shells.create_sun_inner_oort_limit_shell"
  },
  "solar_visualization_shells.create_sun_heliopause_shell": {
    "id": "solar_visualization_shells.create_sun_heliopause_shell",
    "name": "create_sun_heliopause_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_sun_heliopause_shell():\n    \"\"\"Creates the Sun's heliopause shell.\"\"\"\n    x, y, z = create_sphere_points(HELIOPAUSE_RADII * SOLAR_RADIUS_AU, n_points=40)\n    \n    text_array = [solar_wind_info_hover for _ in range(len(x))]\n    customdata_array = [\"Solar Wind Heliopause\" for _ in range(len(x))]\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=0.5,\n                color='rgb(135, 206, 250)',\n                opacity=0.3\n            ),\n            name='Solar Wind Heliopause',\n            text=text_array,\n            customdata=customdata_array,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ),\n    ]\n    \n    \"\"\"\n    sun_traces = create_sun_direction_indicator(\n        center_position=(0, 0, 0), \n        shell_radius=HELIOPAUSE_RADII * SOLAR_RADIUS_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n    \"\"\"\n\n    return traces",
    "start_line": 894,
    "end_line": 927,
    "has_docstring": true,
    "docstring": "Creates the Sun's heliopause shell.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_heliopause_shell",
    "component_id": "solar_visualization_shells.create_sun_heliopause_shell"
  },
  "solar_visualization_shells.create_sun_termination_shock_shell": {
    "id": "solar_visualization_shells.create_sun_termination_shock_shell",
    "name": "create_sun_termination_shock_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_sun_termination_shock_shell():\n    \"\"\"Creates the Sun's termination shock shell.\"\"\"\n    x, y, z = create_sphere_points(TERMINATION_SHOCK_AU, n_points=40)\n    \n    text_array = [termination_shock_info_hover for _ in range(len(x))]\n    customdata_array = [\"Solar Wind Termination Shock\" for _ in range(len(x))]\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=0.5,\n                color='rgb(240, 244, 255)',\n                opacity=0.3\n            ),\n            name='Solar Wind Termination Shock',\n            text=text_array,\n            customdata=customdata_array,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ),\n    ]\n    \n    \"\"\"\n    sun_traces = create_sun_direction_indicator(\n        center_position=(0, 0, 0), \n        shell_radius=TERMINATION_SHOCK_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n    \"\"\"\n\n    return traces",
    "start_line": 929,
    "end_line": 962,
    "has_docstring": true,
    "docstring": "Creates the Sun's termination shock shell.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_termination_shock_shell",
    "component_id": "solar_visualization_shells.create_sun_termination_shock_shell"
  },
  "solar_visualization_shells.create_sun_outer_corona_shell": {
    "id": "solar_visualization_shells.create_sun_outer_corona_shell",
    "name": "create_sun_outer_corona_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_sun_outer_corona_shell():\n    \"\"\"Creates the Sun's outer corona shell.\"\"\"\n    x, y, z = create_sphere_points(OUTER_CORONA_RADII * SOLAR_RADIUS_AU, n_points=50)\n    \n    text_array = [outer_corona_info_hover for _ in range(len(x))]\n    customdata_array = [\"Sun: Outer Corona\" for _ in range(len(x))]\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=0.75,\n                color='rgb(25, 25, 112)',\n                opacity=0.8\n            ),\n            name='Sun: Outer Corona',\n            text=text_array,\n            customdata=customdata_array,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ),\n    ]\n    \n    return traces",
    "start_line": 964,
    "end_line": 988,
    "has_docstring": true,
    "docstring": "Creates the Sun's outer corona shell.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_outer_corona_shell",
    "component_id": "solar_visualization_shells.create_sun_outer_corona_shell"
  },
  "solar_visualization_shells.create_sun_inner_corona_shell": {
    "id": "solar_visualization_shells.create_sun_inner_corona_shell",
    "name": "create_sun_inner_corona_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_sun_inner_corona_shell():\n    \"\"\"Creates the Sun's inner corona shell.\"\"\"\n    x, y, z = create_sphere_points(INNER_CORONA_RADII * SOLAR_RADIUS_AU, n_points=60)\n    \n    text_array = [inner_corona_info_hover for _ in range(len(x))]\n    customdata_array = [\"Sun: Inner Corona\" for _ in range(len(x))]\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=1,\n                color='rgb(0, 0, 255)',\n                opacity=0.2\n            ),\n            name='Sun: Inner Corona',\n            text=text_array,\n            customdata=customdata_array,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ),\n    ]\n    \n    return traces",
    "start_line": 990,
    "end_line": 1014,
    "has_docstring": true,
    "docstring": "Creates the Sun's inner corona shell.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_inner_corona_shell",
    "component_id": "solar_visualization_shells.create_sun_inner_corona_shell"
  },
  "solar_visualization_shells.create_sun_chromosphere_shell": {
    "id": "solar_visualization_shells.create_sun_chromosphere_shell",
    "name": "create_sun_chromosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_sun_chromosphere_shell():\n    \"\"\"Creates the Sun's chromosphere shell.\"\"\"\n    x, y, z = create_sphere_points(CHROMOSPHERE_RADII * SOLAR_RADIUS_AU, n_points=60)\n    \n    text_array = [chromosphere_info_hover for _ in range(len(x))]\n    customdata_array = [\"Sun: Chromosphere\" for _ in range(len(x))]\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=1.25,\n                color='rgb(30, 144, 255)',\n                opacity=0.2\n            ),\n            name='Sun: Chromosphere',\n            text=text_array,\n            customdata=customdata_array,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ),\n    ]\n    \n    return traces",
    "start_line": 1016,
    "end_line": 1040,
    "has_docstring": true,
    "docstring": "Creates the Sun's chromosphere shell.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_chromosphere_shell",
    "component_id": "solar_visualization_shells.create_sun_chromosphere_shell"
  },
  "solar_visualization_shells.create_sun_photosphere_shell": {
    "id": "solar_visualization_shells.create_sun_photosphere_shell",
    "name": "create_sun_photosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_sun_photosphere_shell():\n    \"\"\"Creates the Sun's photosphere shell.\"\"\"\n    x, y, z = create_sphere_points(SOLAR_RADIUS_AU, n_points=60)\n    \n    text_array = [photosphere_info_hover for _ in range(len(x))]\n    customdata_array = [\"Sun: Photosphere\" for _ in range(len(x))]\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=7.0,\n                color='rgb(255, 244, 214)',\n                opacity=1.0\n            ),\n            name='Sun: Photosphere',\n            text=text_array,\n            customdata=customdata_array,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ),\n    ]\n    \n    return traces",
    "start_line": 1042,
    "end_line": 1066,
    "has_docstring": true,
    "docstring": "Creates the Sun's photosphere shell.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_photosphere_shell",
    "component_id": "solar_visualization_shells.create_sun_photosphere_shell"
  },
  "solar_visualization_shells.create_sun_radiative_shell": {
    "id": "solar_visualization_shells.create_sun_radiative_shell",
    "name": "create_sun_radiative_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_sun_radiative_shell():\n    \"\"\"Creates the Sun's radiative zone shell.\"\"\"\n    x, y, z = create_sphere_points(RADIATIVE_ZONE_AU, n_points=60)\n    \n    text_array = [radiative_zone_info_hover for _ in range(len(x))]\n    customdata_array = [\"Sun: Radiative Zone\" for _ in range(len(x))]\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=7,\n                color='rgb(30, 144, 255)',\n                opacity=1.0\n            ),\n            name='Sun: Radiative Zone',\n            text=text_array,\n            customdata=customdata_array,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ),\n    ]\n    \n    return traces",
    "start_line": 1068,
    "end_line": 1092,
    "has_docstring": true,
    "docstring": "Creates the Sun's radiative zone shell.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_radiative_shell",
    "component_id": "solar_visualization_shells.create_sun_radiative_shell"
  },
  "solar_visualization_shells.create_sun_core_shell": {
    "id": "solar_visualization_shells.create_sun_core_shell",
    "name": "create_sun_core_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_sun_core_shell():\n    \"\"\"Creates the Sun's core shell.\"\"\"\n    x, y, z = create_sphere_points(CORE_AU, n_points=60)\n    \n    text_array = [core_info_hover for _ in range(len(x))]\n    customdata_array = [\"Sun: Core\" for _ in range(len(x))]\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=10,\n                color='rgb(70, 130, 180)',\n                opacity=1.0\n            ),\n            name='Sun: Core',\n            text=text_array,\n            customdata=customdata_array,\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ),\n    ]\n    \n    return traces",
    "start_line": 1094,
    "end_line": 1118,
    "has_docstring": true,
    "docstring": "Creates the Sun's core shell.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_core_shell",
    "component_id": "solar_visualization_shells.create_sun_core_shell"
  },
  "solar_visualization_shells.create_sun_hills_cloud_torus": {
    "id": "solar_visualization_shells.create_sun_hills_cloud_torus",
    "name": "create_sun_hills_cloud_torus",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_sun_hills_cloud_torus(inner_radius=2000, outer_radius=20000, thickness_ratio=0.3):\n    \"\"\"\n    Create a toroidal (doughnut-shaped) Hills Cloud structure.\n    FIXED VERSION - Returns proper Plotly trace objects.\n    \n    Parameters:\n    - inner_radius: Inner boundary in AU (default: 2000)\n    - outer_radius: Outer boundary in AU (default: 20000)\n    - thickness_ratio: Ratio of torus thickness to major radius (default: 0.3)\n    \"\"\"\n    # Major radius (center to tube center)\n    major_radius = (inner_radius + outer_radius) / 2\n    # Minor radius (tube thickness)\n    minor_radius = (outer_radius - inner_radius) / 2 * thickness_ratio\n    \n    # Parametric equations for torus\n    n_points = 60\n    u = np.linspace(0, 2*np.pi, n_points)  # Around the tube\n    v = np.linspace(0, 2*np.pi, n_points)  # Around the major radius\n    \n    u, v = np.meshgrid(u, v)\n    \n    # Add some randomness to make it less perfect\n    noise_factor = 0.1\n    radius_variation = 1 + noise_factor * np.random.normal(0, 1, u.shape)\n    \n    x = (major_radius + minor_radius * np.cos(u)) * np.cos(v) * radius_variation\n    y = (major_radius + minor_radius * np.cos(u)) * np.sin(v) * radius_variation\n    z = minor_radius * np.sin(u) * radius_variation * 0.5  # Flatten slightly\n    \n    # Flatten the arrays to 1D\n    x_flat = x.flatten()\n    y_flat = y.flatten()\n    z_flat = z.flatten()\n    \n    # Create text and customdata arrays with same length as coordinates    \n    text_array = ['Hills Cloud (Inner Oort): Disk-like structure<br>' \n                  '2,000-20,000 AU<br>'\n                  'More tightly bound to Solar System<br>'\n                  'Source of Jupiter-family comets<br>'\n                  'Toroidal shape due to galactic tides'] * len(x_flat)\n    customdata_array = ['Hills Cloud Torus'] * len(x_flat)\n\n    # Create the Plotly trace object\n    trace = go.Scatter3d(\n        x=x_flat, \n        y=y_flat, \n        z=z_flat,\n        mode='markers',\n        marker=dict(\n            size=1.5,\n            color='rgb(173, 216, 230)',  # Light blue\n            opacity=0.4,\n            symbol='circle'\n        ),\n        name='Hills Cloud (Inner Oort - Toroidal)',\n        text=text_array,\n        customdata=customdata_array,\n        hovertemplate='%{text}<extra></extra>',\n        showlegend=True\n    )\n    \n    # Return a list containing the trace (consistent with other shell functions)\n    return [trace]",
    "start_line": 1124,
    "end_line": 1187,
    "has_docstring": true,
    "docstring": "Create a toroidal (doughnut-shaped) Hills Cloud structure.\nFIXED VERSION - Returns proper Plotly trace objects.\n\nParameters:\n- inner_radius: Inner boundary in AU (default: 2000)\n- outer_radius: Outer boundary in AU (default: 20000)\n- thickness_ratio: Ratio of torus thickness to major radius (default: 0.3)",
    "parameters": [
      "inner_radius",
      "outer_radius",
      "thickness_ratio"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_hills_cloud_torus",
    "component_id": "solar_visualization_shells.create_sun_hills_cloud_torus"
  },
  "solar_visualization_shells.create_sun_outer_oort_clumpy": {
    "id": "solar_visualization_shells.create_sun_outer_oort_clumpy",
    "name": "create_sun_outer_oort_clumpy",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_sun_outer_oort_clumpy(radius_min=20000, radius_max=100000, n_clumps=15):\n    \"\"\"\n    Create a clumpy, asymmetric outer Oort Cloud with density variations.\n    FIXED VERSION - Returns proper Plotly trace objects.\n    \"\"\"\n    points_x, points_y, points_z = [], [], []\n    \n    for i in range(n_clumps):\n        # Random clump center\n        clump_radius = np.random.uniform(radius_min, radius_max)\n        theta = np.random.uniform(0, 2*np.pi)\n        phi = np.random.uniform(-np.pi/2, np.pi/2)\n        \n        clump_center_x = clump_radius * np.cos(phi) * np.cos(theta)\n        clump_center_y = clump_radius * np.cos(phi) * np.sin(theta)\n        clump_center_z = clump_radius * np.sin(phi)\n        \n        # Generate points around clump center\n        n_points_in_clump = np.random.randint(50, 200)\n        clump_size = np.random.uniform(5000, 15000)  # AU\n        \n        for j in range(n_points_in_clump):\n            # Random point within clump\n            r = clump_size * np.random.beta(2, 5)  # Beta distribution for more realistic clustering\n            theta_local = np.random.uniform(0, 2*np.pi)\n            phi_local = np.random.uniform(-np.pi/2, np.pi/2)\n            \n            x = clump_center_x + r * np.cos(phi_local) * np.cos(theta_local)\n            y = clump_center_y + r * np.cos(phi_local) * np.sin(theta_local)\n            z = clump_center_z + r * np.sin(phi_local)\n            \n            # Ensure point is within Oort Cloud bounds\n            distance = np.sqrt(x**2 + y**2 + z**2)\n            if radius_min <= distance <= radius_max:\n                points_x.append(x)\n                points_y.append(y)\n                points_z.append(z)\n    \n    # Convert to numpy arrays\n    x = np.array(points_x)\n    y = np.array(points_y)\n    z = np.array(points_z)\n    \n    # Create text and customdata arrays\n    text_array = ['Outer Oort Cloud: Clumpy, asymmetric structure<br>' \n                  '20,000-100,000+ AU<br>' \n                  'Source of long-period comets<br>' \n                  'Influenced by galactic tides and stellar encounters'] * len(x)\n    customdata_array = ['Outer Oort Cloud'] * len(x)\n    \n    # Create the Plotly trace\n    trace = go.Scatter3d(\n        x=x, y=y, z=z,\n        mode='markers',\n        marker=dict(\n            size=1.0,\n            color='rgb(255, 255, 255)',  # White\n            opacity=0.3,\n            symbol='circle'\n        ),\n        name='Outer Oort Cloud (Clumpy)',\n        text=text_array,\n        customdata=customdata_array,\n        hovertemplate='%{text}<extra></extra>',\n        showlegend=True\n    )\n    \n    # Return a list containing the trace (consistent with other shell functions)\n    return [trace]",
    "start_line": 1189,
    "end_line": 1257,
    "has_docstring": true,
    "docstring": "Create a clumpy, asymmetric outer Oort Cloud with density variations.\nFIXED VERSION - Returns proper Plotly trace objects.",
    "parameters": [
      "radius_min",
      "radius_max",
      "n_clumps"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_outer_oort_clumpy",
    "component_id": "solar_visualization_shells.create_sun_outer_oort_clumpy"
  },
  "solar_visualization_shells.create_sun_galactic_tide": {
    "id": "solar_visualization_shells.create_sun_galactic_tide",
    "name": "create_sun_galactic_tide",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_sun_galactic_tide(radius=50000, n_points=2000):\n    \"\"\"\n    Create Oort Cloud structure influenced by galactic tidal forces.\n    The galactic plane creates asymmetry in the distribution.\n    FIXED VERSION - Returns proper Plotly trace objects.\n    \"\"\"\n    # Generate points in spherical coordinates\n    r = np.random.normal(radius, radius*0.3, n_points)\n    r = np.clip(r, radius*0.5, radius*1.5)  # Keep within reasonable bounds\n    \n    theta = np.random.uniform(0, 2*np.pi, n_points)\n    \n    # Galactic tide effect: fewer objects near galactic plane (z=0)\n    # Use a distribution that's depleted near z=0\n    phi_weights = np.linspace(-np.pi/2, np.pi/2, 100)\n    weights = 1 + 0.5 * np.abs(np.sin(phi_weights))  # More objects away from galactic plane\n    phi = np.random.choice(phi_weights, n_points, p=weights/weights.sum())\n    \n    x = r * np.cos(phi) * np.cos(theta)\n    y = r * np.cos(phi) * np.sin(theta)\n    z = r * np.sin(phi)\n    \n    # Create text and customdata arrays\n    text_array = ['Galactic Tide Influenced Objects<br>' \n                  'Asymmetric distribution due to Milky Way\\'s gravity<br>' \n                  'Objects avoid galactic plane<br>~50,000 AU typical distance'] * len(x)\n    customdata_array = ['Galactic Tide Region'] * len(x)\n    \n    # Create the Plotly trace\n    trace = go.Scatter3d(\n        x=x, y=y, z=z,\n        mode='markers',\n        marker=dict(\n            size=0.8,\n            color='rgb(255, 182, 193)',  # Light pink\n            opacity=0.2,\n            symbol='diamond'\n        ),\n        name='Galactic Tide Region',\n        text=text_array,\n        customdata=customdata_array,\n        hovertemplate='%{text}<extra></extra>',\n        showlegend=True\n    )\n    \n    # Return a list containing the trace (consistent with other shell functions)\n    return [trace]",
    "start_line": 1259,
    "end_line": 1305,
    "has_docstring": true,
    "docstring": "Create Oort Cloud structure influenced by galactic tidal forces.\nThe galactic plane creates asymmetry in the distribution.\nFIXED VERSION - Returns proper Plotly trace objects.",
    "parameters": [
      "radius",
      "n_points"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_sun_galactic_tide",
    "component_id": "solar_visualization_shells.create_sun_galactic_tide"
  },
  "solar_visualization_shells.create_enhanced_oort_cloud_visualization": {
    "id": "solar_visualization_shells.create_enhanced_oort_cloud_visualization",
    "name": "create_enhanced_oort_cloud_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [
      "solar_visualization_shells.create_sun_galactic_tide",
      "solar_visualization_shells.create_sun_hills_cloud_torus",
      "solar_visualization_shells.create_sun_outer_oort_clumpy"
    ],
    "source_code": "def create_enhanced_oort_cloud_visualization():\n    \"\"\"\n    Create a more scientifically accurate Oort Cloud visualization.\n    \"\"\"\n    traces = []\n    \n    # 1. Hills Cloud (Inner Oort) - Toroidal structure\n    if True:  # Replace with your checkbox logic\n        x_hills, y_hills, z_hills = create_sun_hills_cloud_torus()\n        \n        traces.append(go.Scatter3d(\n            x=x_hills, y=y_hills, z=z_hills,\n            mode='markers',\n            marker=dict(\n                size=1.5,\n                color='rgb(173, 216, 230)',  # Light blue\n                opacity=0.4,\n                symbol='circle'\n            ),\n            name='Hills Cloud (Inner Oort - Toroidal)',\n            text=['Hills Cloud: Disk-like structure, 2,000-20,000 AU<br>More tightly bound to Solar System<br>Source of Jupiter-family comets'] * len(x_hills),\n            customdata=['Hills Cloud'] * len(x_hills),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ))\n    \n    # 2. Outer Oort Cloud - Clumpy structure\n    if True:  # Replace with your checkbox logic\n        x_outer, y_outer, z_outer = create_sun_outer_oort_clumpy()\n        \n        traces.append(go.Scatter3d(\n            x=x_outer, y=y_outer, z=z_outer,\n            mode='markers',\n            marker=dict(\n                size=1.0,\n                color='rgb(255, 255, 255)',  # White\n                opacity=0.3,\n                symbol='circle'\n            ),\n            name='Outer Oort Cloud (Clumpy)',\n            text=['Outer Oort Cloud: Clumpy, asymmetric structure<br>20,000-100,000+ AU<br>Source of long-period comets<br>Influenced by galactic tides and stellar encounters'] * len(x_outer),\n            customdata=['Outer Oort Cloud'] * len(x_outer),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ))\n    \n    # 3. Galactic tide influenced region\n    if True:  # Replace with your checkbox logic\n        x_tide, y_tide, z_tide = create_sun_galactic_tide()\n        \n        traces.append(go.Scatter3d(\n            x=x_tide, y=y_tide, z=z_tide,\n            mode='markers',\n            marker=dict(\n                size=0.8,\n                color='rgb(255, 182, 193)',  # Light pink\n                opacity=0.2,\n                symbol='diamond'\n            ),\n            name='Galactic Tide Region',\n            text=['Galactic Tide Influenced Objects<br>Asymmetric distribution due to Milky Way\\'s gravity<br>Objects avoid galactic plane<br>~50,000 AU typical distance'] * len(x_tide),\n            customdata=['Galactic Tide Region'] * len(x_tide),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ))\n    \n    return traces",
    "start_line": 1307,
    "end_line": 1373,
    "has_docstring": true,
    "docstring": "Create a more scientifically accurate Oort Cloud visualization.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_enhanced_oort_cloud_visualization",
    "component_id": "solar_visualization_shells.create_enhanced_oort_cloud_visualization"
  },
  "solar_visualization_shells.create_oort_cloud_density_visualization": {
    "id": "solar_visualization_shells.create_oort_cloud_density_visualization",
    "name": "create_oort_cloud_density_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\solar_visualization_shells.py",
    "relative_path": "solar_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_oort_cloud_density_visualization():\n    \"\"\"\n    Alternative approach: Show Oort Cloud as density gradients rather than discrete shells.\n    \"\"\"\n    traces = []\n    \n    # Create multiple density layers\n    radii = [5000, 10000, 20000, 40000, 70000, 100000]\n    densities = [0.8, 0.6, 0.5, 0.3, 0.2, 0.1]  # Relative densities\n    \n    for i, (radius, density) in enumerate(zip(radii, densities)):\n        # Number of points proportional to density\n        n_points = int(500 * density)\n        \n        # Generate points with some randomness\n        theta = np.random.uniform(0, 2*np.pi, n_points)\n        phi = np.random.uniform(-np.pi/2, np.pi/2, n_points)\n        r = np.random.normal(radius, radius*0.1, n_points)\n        \n        x = r * np.cos(phi) * np.cos(theta)\n        y = r * np.cos(phi) * np.sin(theta)\n        z = r * np.sin(phi)\n        \n        traces.append(go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=max(0.5, 2.0 * density),\n                color=f'rgba(255, 255, 255, {density})',\n                opacity=density,\n            ),\n            name=f'Oort Density Layer {i+1}',\n            text=[f'Oort Cloud Density Layer<br>Distance: ~{radius:,} AU<br>Relative density: {density:.1f}'] * len(x),\n            customdata=[f'Density Layer {i+1}'] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        ))\n    \n    return traces",
    "start_line": 1375,
    "end_line": 1413,
    "has_docstring": true,
    "docstring": "Alternative approach: Show Oort Cloud as density gradients rather than discrete shells.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_oort_cloud_density_visualization",
    "component_id": "solar_visualization_shells.create_oort_cloud_density_visualization"
  },
  "star_properties.get_column_value_safe": {
    "id": "star_properties.get_column_value_safe",
    "name": "get_column_value_safe",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\star_properties.py",
    "relative_path": "star_properties.py",
    "depends_on": [],
    "source_code": "def get_column_value_safe(result_table, old_name, new_name):\n    \"\"\"\n    Get column value from either old (uppercase) or new (lowercase) format.\n    Handles both SIMBAD API versions for backward compatibility.\n    \"\"\"\n    # Try old format first (for consistency with existing code patterns)\n    if old_name in result_table.colnames:\n        value = result_table[old_name][0]\n    elif new_name in result_table.colnames:\n        value = result_table[new_name][0]\n    else:\n        return None\n    \n    # Decode bytes if necessary\n    if isinstance(value, bytes):\n        return value.decode('utf-8')\n    return value",
    "start_line": 10,
    "end_line": 26,
    "has_docstring": true,
    "docstring": "Get column value from either old (uppercase) or new (lowercase) format.\nHandles both SIMBAD API versions for backward compatibility.",
    "parameters": [
      "result_table",
      "old_name",
      "new_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function get_column_value_safe",
    "component_id": "star_properties.get_column_value_safe"
  },
  "star_properties.create_custom_simbad": {
    "id": "star_properties.create_custom_simbad",
    "name": "create_custom_simbad",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\star_properties.py",
    "relative_path": "star_properties.py",
    "depends_on": [],
    "source_code": "def create_custom_simbad():\n    custom_simbad = Simbad()\n    # Reset to the standard defaults, which typically include 'MAIN_ID'\n    custom_simbad.reset_votable_fields()\n    custom_simbad.ROW_LIMIT = 1\n    custom_simbad.TIMEOUT = 300\n    \n    # Add the extra fields you need for your script\n    custom_simbad.add_votable_fields('ids', 'sp', 'flux(V)', 'flux(B)', 'otype')\n    return custom_simbad",
    "start_line": 175,
    "end_line": 184,
    "has_docstring": false,
    "docstring": "",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_custom_simbad",
    "component_id": "star_properties.create_custom_simbad"
  },
  "star_properties.parse_magnitude": {
    "id": "star_properties.parse_magnitude",
    "name": "parse_magnitude",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\star_properties.py",
    "relative_path": "star_properties.py",
    "depends_on": [],
    "source_code": "def parse_magnitude(value):\n    if value is None:\n        return None\n    if isinstance(value, (int, float)):\n        return float(value)\n    value_str = str(value)\n    # remove anything like  [~] or [some text]\n    cleaned = re.sub(r\"\\[.*?\\]\", \"\", value_str).strip()\n    try:\n        return float(cleaned)\n    except ValueError:\n        return None",
    "start_line": 41,
    "end_line": 52,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parse_magnitude",
    "component_id": "star_properties.parse_magnitude"
  },
  "star_properties.load_existing_properties": {
    "id": "star_properties.load_existing_properties",
    "name": "load_existing_properties",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\star_properties.py",
    "relative_path": "star_properties.py",
    "depends_on": [],
    "source_code": "def load_existing_properties(properties_file):\n    \"\"\"Load existing star and Messier object properties from a file.\"\"\"\n    if os.path.exists(properties_file):\n        print(\"Loading properties from local file...\")\n        try:\n            with open(properties_file, 'rb') as f:\n                data = pickle.load(f)\n            \n            # Verify required keys are present\n            required_keys = {\n                'unique_ids', 'star_names', 'spectral_types', \n                'V_magnitudes', 'B_magnitudes', 'object_types'\n            }\n            \n            if not required_keys.issubset(data.keys()):\n                print(\"Error: Missing required keys in properties file.\")\n                return {}\n                \n            # Create dictionary of properties\n            existing_properties = {}\n            for i in range(len(data['unique_ids'])):\n                uid = data['unique_ids'][i]\n                \n                # Build properties dictionary with core fields\n                props = {\n                    'star_name': data['star_names'][i],\n                    'spectral_type': data['spectral_types'][i],\n                    'V_magnitude': data['V_magnitudes'][i],\n                    'B_magnitude': data['B_magnitudes'][i],\n                    'object_type': data['object_types'][i],\n                }\n                \n                # Add Messier-specific fields if present\n                if 'is_messier' in data:\n                    props['is_messier'] = data['is_messier'][i]\n                    if data['is_messier'][i]:\n                        props['distance_ly'] = data.get('distance_ly', [None] * len(data['unique_ids']))[i]\n                        props['notes'] = data.get('notes', [''] * len(data['unique_ids']))[i]\n                \n                existing_properties[uid] = props\n            \n            # Report statistics\n            messier_count = sum(1 for props in existing_properties.values() if props.get('is_messier', False))\n            print(f\"Loaded {len(existing_properties)} objects ({messier_count} Messier objects)\")\n            \n            return existing_properties\n            \n        except Exception as e:\n            print(f\"Error loading properties from file: {e}\")\n            return {}\n    else:\n        print(\"No existing properties file found. Starting fresh.\")\n        return {}",
    "start_line": 55,
    "end_line": 107,
    "has_docstring": true,
    "docstring": "Load existing star and Messier object properties from a file.",
    "parameters": [
      "properties_file"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function load_existing_properties",
    "component_id": "star_properties.load_existing_properties"
  },
  "star_properties.generate_unique_ids": {
    "id": "star_properties.generate_unique_ids",
    "name": "generate_unique_ids",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\star_properties.py",
    "relative_path": "star_properties.py",
    "depends_on": [],
    "source_code": "def generate_unique_ids(combined_data):\n    \"\"\"Generate unique identifiers for all stars consistently.\"\"\"\n    print(\"Generating unique identifiers...\")\n    unique_ids = []\n\n    for row in combined_data:\n        # First try HIP ID\n        uid = None\n        if 'HIP' in combined_data.colnames:\n            hip = row['HIP']\n            if not np.ma.is_masked(hip) and hip is not None:\n                try:\n                    uid = f\"HIP {int(hip)}\"\n                except (TypeError, ValueError):\n                    uid = None\n\n        # Then try Gaia Source ID\n        if uid is None and 'Source' in combined_data.colnames:\n            source = row['Source']\n            if not np.ma.is_masked(source) and source is not None:\n                try:\n                    uid = f\"Gaia DR3 {int(source)}\"\n                except (TypeError, ValueError):\n                    uid = None\n\n        # Finally use coordinates as fallback\n        if uid is None and 'RA_ICRS' in combined_data.colnames and 'DE_ICRS' in combined_data.colnames:\n            ra = row['RA_ICRS']\n            dec = row['DE_ICRS']\n            if not np.ma.is_masked(ra) and not np.ma.is_masked(dec):\n                uid = f\"J{ra:.6f}{dec:+.6f}\"\n\n        unique_ids.append(uid)\n\n    print(f\"Generated {len([uid for uid in unique_ids if uid is not None])} unique identifiers\")\n    return unique_ids",
    "start_line": 109,
    "end_line": 144,
    "has_docstring": true,
    "docstring": "Generate unique identifiers for all stars consistently.",
    "parameters": [
      "combined_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate_unique_ids",
    "component_id": "star_properties.generate_unique_ids"
  },
  "star_properties.save_properties_to_file": {
    "id": "star_properties.save_properties_to_file",
    "name": "save_properties_to_file",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\star_properties.py",
    "relative_path": "star_properties.py",
    "depends_on": [],
    "source_code": "def save_properties_to_file(properties, properties_file):\n    \"\"\"Save star properties to file with Messier object support.\"\"\"\n    all_unique_ids = list(properties.keys())\n    property_lists = {\n        'unique_ids': all_unique_ids,\n        'star_names': [],\n        'spectral_types': [],\n        'V_magnitudes': [],\n        'B_magnitudes': [],\n        'object_types': [],\n        'is_messier': [],\n        'distance_ly': [],\n        'notes': []\n    }\n    \n    for uid in all_unique_ids:\n        props = properties[uid]\n        property_lists['star_names'].append(props['star_name'])\n        property_lists['spectral_types'].append(props['spectral_type'])\n        property_lists['V_magnitudes'].append(props['V_magnitude'])\n        property_lists['B_magnitudes'].append(props['B_magnitude'])\n        property_lists['object_types'].append(props['object_type'])\n        property_lists['is_messier'].append(props.get('is_messier', False))\n        property_lists['distance_ly'].append(props.get('distance_ly', None))\n        property_lists['notes'].append(props.get('notes', ''))\n    \n    with open(properties_file, 'wb') as f:\n        pickle.dump(property_lists, f)",
    "start_line": 146,
    "end_line": 173,
    "has_docstring": true,
    "docstring": "Save star properties to file with Messier object support.",
    "parameters": [
      "properties",
      "properties_file"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function save_properties_to_file",
    "component_id": "star_properties.save_properties_to_file"
  },
  "star_properties.query_simbad_for_star_properties": {
    "id": "star_properties.query_simbad_for_star_properties",
    "name": "query_simbad_for_star_properties",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\star_properties.py",
    "relative_path": "star_properties.py",
    "depends_on": [
      "star_properties.save_properties_to_file",
      "star_properties.create_custom_simbad",
      "star_properties.get_column_value_safe"
    ],
    "source_code": "def query_simbad_for_star_properties(missing_ids, existing_properties, properties_file):\n    \"\"\"Query Simbad for missing star properties with backward compatibility.\"\"\"\n    print(f\"\\nQuerying Simbad for {len(missing_ids)} missing star properties...\")\n    try:\n        # Initialize supplemental data from Messier catalog\n        from messier_catalog import messier_catalog, star_cluster_catalog\n        supplemental_data = {**messier_catalog, **star_cluster_catalog}\n\n        custom_simbad = create_custom_simbad()\n\n        # Process in smaller batches to avoid timeouts\n        batch_size = 50\n        total_batches = (len(missing_ids) + batch_size - 1) // batch_size\n\n        for batch_num in range(total_batches):\n            start_idx = batch_num * batch_size\n            end_idx = min((batch_num + 1) * batch_size, len(missing_ids))\n            batch_ids = missing_ids[start_idx:end_idx]\n\n            print(f\"\\nProcessing batch {batch_num + 1}/{total_batches} ({start_idx + 1} to {end_idx})\")\n\n            for idx, obj_name in enumerate(batch_ids):\n                try:\n                    # Check if it's a Messier object\n                    messier_id = None\n                    if obj_name.startswith('M '):\n                        messier_id = f\"M{obj_name.split()[1]}\"\n                    \n                    # Query SIMBAD first\n                    result_table = custom_simbad.query_object(obj_name)\n                    \n                    if result_table is not None and len(result_table) > 0:\n                        # Extract properties with backward compatibility\n                        # These work with both old uppercase and new lowercase columns\n                        star_name = get_column_value_safe(result_table, 'MAIN_ID', 'main_id')\n                        sp_type = get_column_value_safe(result_table, 'SP_TYPE', 'sp_type')\n                        \n                        # Handle both old flux notation and new direct notation\n                        V_mag = get_column_value_safe(result_table, 'FLUX_V', 'V')\n                        B_mag = get_column_value_safe(result_table, 'FLUX_B', 'B')\n                        \n                        otype = get_column_value_safe(result_table, 'OTYPE', 'otype')\n                        \n                        # If star_name is still None, use the object name\n                        if star_name is None:\n                            star_name = obj_name\n                        \n                        # For Messier objects, supplement missing data from our catalog\n                        if messier_id and messier_id in supplemental_data:\n                            messier_data = supplemental_data[messier_id]\n                            print(f\"\\nSupplementing {messier_id} data from messier_catalog.py:\")\n                            \n                            # Track what data is being supplemented\n                            if V_mag is None and 'vmag' in messier_data:\n                                V_mag = messier_data['vmag']\n                                print(f\"  - Using catalog magnitude: {V_mag}\")\n                            \n                            if not otype and 'type' in messier_data:\n                                otype = messier_data['type']\n                                print(f\"  - Using catalog object type: {otype}\")\n                                \n                            star_name = f\"{messier_id}: {messier_data['name']}\"\n                            print(f\"  - Using catalog name: {star_name}\")\n                            \n                            if 'distance_ly' in messier_data:\n                                print(f\"  - Using catalog distance: {messier_data['distance_ly']} ly\")\n                                \n                            if 'notes' in messier_data:\n                                print(f\"  - Added catalog notes: {messier_data['notes'][:50]}...\")\n                            \n                            # Add Messier-specific properties\n                            existing_properties[obj_name] = {\n                                'star_name': star_name,\n                                'spectral_type': sp_type,\n                                'V_magnitude': V_mag,\n                                'B_magnitude': B_mag,\n                                'object_type': otype,\n                                'distance_ly': messier_data['distance_ly'],\n                                'notes': messier_data.get('notes', ''),\n                                'is_messier': True\n                            }\n                            print(f\"Added Messier object {star_name}\")\n                        else:\n                            # Standard star properties\n                            existing_properties[obj_name] = {\n                                'star_name': star_name,\n                                'spectral_type': sp_type,\n                                'V_magnitude': V_mag,\n                                'B_magnitude': B_mag,\n                                'object_type': otype,\n                                'is_messier': False\n                            }\n                    \n                    elif messier_id and messier_id in supplemental_data:\n                        # If SIMBAD query failed but we have Messier data\n                        messier_data = supplemental_data[messier_id]\n                        print(f\"\\nUsing only messier_catalog.py data for {messier_id} (SIMBAD query failed):\")\n                        print(f\"  - Using catalog magnitude: {messier_data['vmag']}\")\n                        print(f\"  - Using catalog object type: {messier_data['type']}\")\n                        print(f\"  - Using catalog name: {messier_data['name']}\")\n                        print(f\"  - Using catalog distance: {messier_data['distance_ly']} ly\")\n                        if 'notes' in messier_data:\n                            print(f\"  - Added catalog notes: {messier_data['notes'][:50]}...\")\n                            \n                        existing_properties[obj_name] = {\n                            'star_name': f\"{messier_id}: {messier_data['name']}\",\n                            'spectral_type': None,\n                            'V_magnitude': messier_data['vmag'],\n                            'B_magnitude': None,\n                            'object_type': messier_data['type'],\n                            'distance_ly': messier_data['distance_ly'],\n                            'notes': messier_data.get('notes', ''),\n                            'is_messier': True\n                        }\n                        print(f\"Added Messier object {messier_id} from catalog\")\n                    \n                    else:\n                        # No data found in either source\n                        existing_properties[obj_name] = {\n                            'star_name': obj_name,\n                            'spectral_type': None,\n                            'V_magnitude': None,\n                            'B_magnitude': None,\n                            'object_type': None,\n                            'is_messier': False\n                        }\n\n                except Exception as e:\n                    print(f\"Error querying {obj_name}: {e}\")\n                    existing_properties[obj_name] = {\n                        'star_name': obj_name,\n                        'spectral_type': None,\n                        'V_magnitude': None,\n                        'B_magnitude': None,\n                        'object_type': None,\n                        'is_messier': False\n                    }\n\n                if (idx + 1) % 10 == 0:\n                    print(f\"Processed {idx + 1}/{len(batch_ids)} objects in current batch\")\n\n                time.sleep(0.1)  # Rate limiting\n\n            # Save progress after each batch\n            try:\n                save_properties_to_file(existing_properties, properties_file)\n                print(f\"Saved progress after batch {batch_num + 1}\")\n            except Exception as e:\n                print(f\"Error saving batch progress: {e}\")\n\n        return existing_properties\n\n    except Exception as e:\n        print(f\"Error in Simbad query setup: {e}\")\n        return existing_properties",
    "start_line": 187,
    "end_line": 341,
    "has_docstring": true,
    "docstring": "Query Simbad for missing star properties with backward compatibility.",
    "parameters": [
      "missing_ids",
      "existing_properties",
      "properties_file"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function query_simbad_for_star_properties",
    "component_id": "star_properties.query_simbad_for_star_properties"
  },
  "star_properties.assign_properties_to_data": {
    "id": "star_properties.assign_properties_to_data",
    "name": "assign_properties_to_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\star_properties.py",
    "relative_path": "star_properties.py",
    "depends_on": [],
    "source_code": "def assign_properties_to_data(combined_data, existing_properties, unique_ids):\n    \"\"\"Assign retrieved properties to the combined data with Messier object support.\"\"\"\n    print(\"\\nAssigning properties to combined data...\")\n    \n    # Initialize property lists\n    props_to_assign = {\n        'Star_Name': [],\n        'Spectral_Type': [],\n        'V_mag': [],\n        'B_mag': [],\n        'Object_Type': [],\n        'Is_Messier': [],\n        'Distance_ly': [],\n        'Notes': []\n    }\n\n    # Collect properties for each object\n    for uid in unique_ids:\n        if uid is not None and uid in existing_properties:\n            props = existing_properties[uid]\n            props_to_assign['Star_Name'].append(props['star_name'] if props['star_name'] else \"Unknown\")\n            props_to_assign['Spectral_Type'].append(props['spectral_type'])\n            props_to_assign['V_mag'].append(float(props['V_magnitude']) if props['V_magnitude'] is not None else np.nan)\n            props_to_assign['B_mag'].append(float(props['B_magnitude']) if props['B_magnitude'] is not None else np.nan)\n            props_to_assign['Object_Type'].append(props['object_type'])\n            props_to_assign['Is_Messier'].append(props.get('is_messier', False))\n            props_to_assign['Distance_ly'].append(props.get('distance_ly', None))\n            props_to_assign['Notes'].append(props.get('notes', ''))\n        else:\n            # Default values for missing properties\n            props_to_assign['Star_Name'].append(\"Unknown\")\n            props_to_assign['Spectral_Type'].append(None)\n            props_to_assign['V_mag'].append(np.nan)\n            props_to_assign['B_mag'].append(np.nan)\n            props_to_assign['Object_Type'].append(None)\n            props_to_assign['Is_Messier'].append(False)\n            props_to_assign['Distance_ly'].append(None)\n            props_to_assign['Notes'].append('')\n\n    # Assign properties to combined_data\n    for col_name, values in props_to_assign.items():\n        combined_data[col_name] = values\n\n    # Report statistics\n    messier_count = sum(props_to_assign['Is_Messier'])\n    total_objects = len(unique_ids)\n    print(f\"Assigned properties to {total_objects} objects ({messier_count} Messier objects)\")\n\n    return combined_data",
    "start_line": 344,
    "end_line": 392,
    "has_docstring": true,
    "docstring": "Assign retrieved properties to the combined data with Messier object support.",
    "parameters": [
      "combined_data",
      "existing_properties",
      "unique_ids"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function assign_properties_to_data",
    "component_id": "star_properties.assign_properties_to_data"
  },
  "star_visualization_gui.is_frozen": {
    "id": "star_visualization_gui.is_frozen",
    "name": "is_frozen",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\star_visualization_gui.py",
    "relative_path": "star_visualization_gui.py",
    "depends_on": [],
    "source_code": "def is_frozen():\n    \"\"\"Check if running as a PyInstaller frozen executable.\"\"\"\n    return getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS')",
    "start_line": 35,
    "end_line": 37,
    "has_docstring": true,
    "docstring": "Check if running as a PyInstaller frozen executable.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function is_frozen",
    "component_id": "star_visualization_gui.is_frozen"
  },
  "star_visualization_gui.ScrollableFrame": {
    "id": "star_visualization_gui.ScrollableFrame",
    "name": "ScrollableFrame",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\star_visualization_gui.py",
    "relative_path": "star_visualization_gui.py",
    "depends_on": [],
    "source_code": "class ScrollableFrame(ttk.Frame):\n    \"\"\"A scrollable frame widget.\"\"\"\n    def __init__(self, parent, **kw):\n        super().__init__(parent, **kw)\n        canvas = tk.Canvas(self, highlightthickness=0)\n        vbar = ttk.Scrollbar(self, orient=\"vertical\", command=canvas.yview)\n        self.container = ttk.Frame(canvas)\n        self.container.bind(\n            \"<Configure>\",\n            lambda e: canvas.configure(scrollregion=canvas.bbox(\"all\"))\n        )\n        canvas.create_window((0, 0), window=self.container, anchor=\"nw\")\n        canvas.configure(yscrollcommand=vbar.set)\n        canvas.pack(side=\"left\", fill=\"both\", expand=True)\n        vbar.pack(side=\"right\", fill=\"y\")\n        \n        # Optional: mousewheel support\n        def _on_mousewheel(event):\n            canvas.yview_scroll(int(-1*(event.delta/120)), \"units\")\n        canvas.bind_all(\"<MouseWheel>\", _on_mousewheel)",
    "start_line": 61,
    "end_line": 80,
    "has_docstring": true,
    "docstring": "A scrollable frame widget.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "ttk.Frame"
    ],
    "class_name": null,
    "display_name": "class ScrollableFrame",
    "component_id": "star_visualization_gui.ScrollableFrame"
  },
  "star_visualization_gui.LazyStarPropertiesLoader": {
    "id": "star_visualization_gui.LazyStarPropertiesLoader",
    "name": "LazyStarPropertiesLoader",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\star_visualization_gui.py",
    "relative_path": "star_visualization_gui.py",
    "depends_on": [],
    "source_code": "class LazyStarPropertiesLoader:\n    \"\"\"Loads star properties on-demand rather than all at startup.\"\"\"\n    \n    def __init__(self):\n        self.loaded_properties = {}\n        self.property_files = {\n            'distance': 'star_data/star_properties_distance.pkl',\n            'magnitude': 'star_data/star_properties_magnitude.pkl',\n            'notable': 'star_data/star_properties.pkl'\n        }\n        self.file_stats = {}\n        self._scan_files()\n    \n    def _scan_files(self):\n        \"\"\"Quick scan to get file stats without loading data.\"\"\"\n        for key, filename in self.property_files.items():\n            if os.path.exists(filename):\n                size_mb = os.path.getsize(filename) / (1024 * 1024)\n                self.file_stats[key] = {\n                    'exists': True,\n                    'size_mb': size_mb,\n                    'filename': filename\n                }\n            else:\n                self.file_stats[key] = {\n                    'exists': False,\n                    'size_mb': 0,\n                    'filename': filename\n                }\n    \n    def get_properties(self, property_type='distance'):\n        \"\"\"Load properties on-demand with caching.\"\"\"\n        if property_type in self.loaded_properties:\n            return self.loaded_properties[property_type]\n        \n        if property_type not in self.property_files:\n            print(f\"Unknown property type: {property_type}\")\n            return {}\n        \n        filename = self.property_files[property_type]\n        if not os.path.exists(filename):\n            print(f\"File not found: {filename}\")\n            return {}\n        \n        print(f\"Loading {property_type} properties (first access)...\")\n        try:\n            with open(filename, 'rb') as f:\n                data = pickle.load(f)\n            \n            # Convert to consistent format\n            if isinstance(data, list):\n                properties = {}\n                for item in data:\n                    if isinstance(item, dict) and 'unique_id' in item:\n                        properties[item['unique_id']] = item\n            elif isinstance(data, dict):\n                properties = data\n            else:\n                properties = {}\n            \n            # Cache for future use\n            self.loaded_properties[property_type] = properties\n            print(f\"  Loaded {len(properties)} stars from {filename}\")\n            return properties\n            \n        except Exception as e:\n            print(f\"Error loading {filename}: {e}\")\n            return {}\n    \n    def get_star_count(self, property_type='distance'):\n        \"\"\"Get count without loading data.\"\"\"\n        if property_type in self.loaded_properties:\n            return len(self.loaded_properties[property_type])\n        \n        # For quick GUI display, return estimate based on file size\n        if property_type in self.file_stats and self.file_stats[property_type]['exists']:\n            # Rough estimate: ~100 bytes per star\n            size_bytes = self.file_stats[property_type]['size_mb'] * 1024 * 1024\n            return int(size_bytes / 100)\n        return 0\n    \n    def clear_cache(self, property_type=None):\n        \"\"\"Clear cached data to free memory.\"\"\"\n        if property_type:\n            if property_type in self.loaded_properties:\n                del self.loaded_properties[property_type]\n                print(f\"Cleared cache for {property_type}\")\n        else:\n            self.loaded_properties.clear()\n            print(\"Cleared all cached star properties\")\n    \n    def get_status_summary(self):\n        \"\"\"Get quick summary for GUI display.\"\"\"\n        summary = []\n        for key, stats in self.file_stats.items():\n            if stats['exists']:\n                count = self.get_star_count(key)\n                loaded = key in self.loaded_properties\n                status = \"loaded\" if loaded else \"available\"\n                summary.append(f\"{key.capitalize()}: ~{count} stars ({stats['size_mb']:.1f} MB) - {status}\")\n            else:\n                summary.append(f\"{key.capitalize()}: Not available\")\n        return \"\\n\".join(summary)",
    "start_line": 82,
    "end_line": 184,
    "has_docstring": true,
    "docstring": "Loads star properties on-demand rather than all at startup.",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class LazyStarPropertiesLoader",
    "component_id": "star_visualization_gui.LazyStarPropertiesLoader"
  },
  "star_visualization_gui.StarVisualizationSearchWidget": {
    "id": "star_visualization_gui.StarVisualizationSearchWidget",
    "name": "StarVisualizationSearchWidget",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\star_visualization_gui.py",
    "relative_path": "star_visualization_gui.py",
    "depends_on": [
      "orrery_integration.update"
    ],
    "source_code": "class StarVisualizationSearchWidget(ttk.Frame):\n    \"\"\"Search widget with unified display for all star information.\"\"\"\n    \n    def __init__(self, parent):\n        super().__init__(parent)\n        \n        self.star_data = {}  # Just the names for search\n        self.star_full_data = {}  # Complete properties\n        \n        self.last_selected_star = None\n        self.last_selected_category = None\n        \n        # Load all data\n        self.load_star_data()\n        \n        # Set up the UI\n        self.setup_ui()\n\n\n    def load_star_data(self):\n        \"\"\"Load only star NAMES for search lists, not full data.\"\"\"\n        # Initialize dictionaries\n        self.star_data = {}\n        self.star_full_data = {}  # Initialize empty - will load on demand\n        \n        # Notable stars - just names\n        self.star_data[\"Notable Stars\"] = sorted(unique_notes.keys())\n        \n        # For distance/magnitude - only get names, not full data\n        for data_type, category in [('distance', 'Stars by Distance'), \n                                    ('magnitude', 'Stars by Magnitude')]:\n            filename = f'star_data/star_properties_{data_type}.pkl'\n            if os.path.exists(filename):\n                try:\n                    with open(filename, 'rb') as f:\n                        data = pickle.load(f)\n                    if 'star_names' in data:\n                        self.star_data[category] = sorted(data['star_names'])\n                    else:\n                        self.star_data[category] = []\n                except:\n                    self.star_data[category] = []\n            else:\n                self.star_data[category] = []\n        \n        # Print summary - FIXED INDENTATION\n        print(\"\\n\" + \"=\"*60)\n        print(\"STAR DATA LOADING SUMMARY\")\n        print(\"=\"*60)\n        print(f\"Notable Stars: {len(self.star_data.get('Notable Stars', []))} stars\")\n        print(f\"Stars by Distance: {len(self.star_data.get('Stars by Distance', []))} stars\")  \n        print(f\"Stars by Magnitude: {len(self.star_data.get('Stars by Magnitude', []))} stars\")\n        print(\"=\"*60 + \"\\n\")        \n            \n\n    def load_enhanced_pickle(self, filename: str) -> Dict:\n        \"\"\"Load pickle file - handles both old and enhanced formats.\"\"\"\n        if not os.path.exists(filename):\n            print(f\"[FAIL] {filename} not found\")\n            return {}\n        \n        try:\n            with open(filename, 'rb') as f:\n                data = pickle.load(f)\n            \n            # Convert list format to dictionary keyed by star name\n            star_dict = {}\n            \n            if 'star_names' in data:\n                num_stars = len(data['star_names'])\n                \n                # Check if this is enhanced data\n                has_calculated = 'Temperature' in data\n                \n                if has_calculated:\n                    print(f\"[OK] Loaded {filename}: {num_stars} stars WITH calculated properties\")\n                else:\n                    print(f\"[WARN] Loaded {filename}: {num_stars} stars (basic properties only)\")\n                \n                for i in range(num_stars):\n                    star_name = data['star_names'][i]\n                    \n                    # Build star properties dictionary\n                    star_dict[star_name] = {\n                        'Star_Name': star_name,\n                        'unique_id': data.get('unique_ids', [None]*num_stars)[i],\n                        'spectral_type': data.get('spectral_types', [None]*num_stars)[i],\n                        'V_magnitude': data.get('V_magnitudes', [None]*num_stars)[i],\n                        'B_magnitude': data.get('B_magnitudes', [None]*num_stars)[i],\n                        'object_type': data.get('object_types', [None]*num_stars)[i],\n                        'distance_ly': data.get('distance_ly', [None]*num_stars)[i],\n                        'distance_pc': data.get('distance_pc', [None]*num_stars)[i],\n                    }\n                    \n                    # Add calculated properties if they exist\n                    if has_calculated:\n                        star_dict[star_name].update({\n                            'Temperature': data.get('Temperature', [None]*num_stars)[i],\n                            'Luminosity': data.get('Luminosity', [None]*num_stars)[i],\n                            'Abs_Mag': data.get('Abs_Mag', [None]*num_stars)[i],\n                            'RA_ICRS': data.get('RA_ICRS', [None]*num_stars)[i],\n                            'DE_ICRS': data.get('DE_ICRS', [None]*num_stars)[i],\n                            'ra_str': data.get('ra_str', [None]*num_stars)[i],\n                            'dec_str': data.get('dec_str', [None]*num_stars)[i],\n                            'Stellar_Class': data.get('Stellar_Class', [None]*num_stars)[i],\n                            'Object_Type_Desc': data.get('Object_Type_Desc', [None]*num_stars)[i],\n                            'Source_Catalog': data.get('Source_Catalog', [None]*num_stars)[i],\n                        })\n            \n            return star_dict\n            \n        except Exception as e:\n            print(f\"Error loading {filename}: {e}\")\n            return {}\n\n    def setup_ui(self):\n        \"\"\"Set up the UI with single column layout.\"\"\"\n        main_frame = ttk.Frame(self)\n        main_frame.pack(fill='both', expand=True, padx=5, pady=5)\n        \n        self.search_vars = {}\n        self.result_listboxes = {}\n        self.search_entries = {}\n        \n        categories = [\"Notable Stars\", \"Stars by Distance\", \"Stars by Magnitude\"]\n        \n        for category in categories:\n            # Create labeled frame for each category\n            category_frame = ttk.LabelFrame(main_frame, text=category, padding=5)\n            category_frame.pack(fill='x', padx=5, pady=5)\n            \n            # Search entry\n            search_frame = ttk.Frame(category_frame)\n            search_frame.pack(fill='x')\n            \n            ttk.Label(search_frame, text=\"Search:\").pack(side='left')\n            search_var = tk.StringVar()\n            search_entry = ttk.Entry(search_frame, textvariable=search_var, width=30)\n            search_entry.pack(side='left', fill='x', expand=True, padx=(5, 0))\n            \n            self.search_vars[category] = search_var\n            self.search_entries[category] = search_entry\n            search_var.trace('w', lambda *args, cat=category: self.on_search_change(cat))\n            \n            # Results listbox (collapsible)\n            list_frame = ttk.Frame(category_frame)\n            list_frame.pack(fill='x', pady=(5, 0))\n            \n            scrollbar = ttk.Scrollbar(list_frame)\n            scrollbar.pack(side='right', fill='y')\n            \n            listbox = tk.Listbox(list_frame, yscrollcommand=scrollbar.set, height=4)\n            listbox.pack(side='left', fill='both', expand=True)\n            scrollbar.config(command=listbox.yview)\n            \n            self.result_listboxes[category] = listbox\n            listbox.bind('<<ListboxSelect>>', lambda e, cat=category: self.on_select(cat))\n            \n            # Initially hide listbox\n            list_frame.pack_forget()\n            \n            # Show/hide listbox when typing\n            def toggle_listbox(cat, frame):\n                def handler(*args):\n                    if self.search_vars[cat].get():\n                        frame.pack(fill='x', pady=(5, 0))\n                    else:\n                        frame.pack_forget()\n                return handler\n            \n            search_var.trace('w', toggle_listbox(category, list_frame))\n        \n        # Separator\n        ttk.Separator(main_frame, orient='horizontal').pack(fill='x', pady=10)\n        \n        # Combined information display\n        info_frame = ttk.LabelFrame(main_frame, text=\"Star Information\", padding=5)\n        info_frame.pack(fill='both', expand=True, padx=5, pady=5)\n        \n        text_frame = ttk.Frame(info_frame)\n        text_frame.pack(fill='both', expand=True)\n        \n        v_scroll = ttk.Scrollbar(text_frame, orient='vertical')\n        v_scroll.pack(side='right', fill='y')\n        \n        h_scroll = ttk.Scrollbar(text_frame, orient='horizontal')\n        h_scroll.pack(side='bottom', fill='x')\n        \n        self.info_display = tk.Text(\n            text_frame,\n            height=27,\n            wrap='word',\n            yscrollcommand=v_scroll.set,\n            xscrollcommand=h_scroll.set,\n            font=('Consolas', 10)\n        )\n        self.info_display.pack(fill='both', expand=True)\n        v_scroll.config(command=self.info_display.yview)\n        h_scroll.config(command=self.info_display.xview)\n        \n        self.add_clipboard_support(self.info_display)\n        \n        # Initial message\n        self.info_display.insert('1.0', \n            \"Search for a star using any of the search fields above.\\n\\n\"\n            \"* Notable Stars: Stars with descriptions and notes\\n\"\n            \"* Stars by Distance: Stars within specified distance range\\n\"\n            \"* Stars by Magnitude: Stars brighter than specified magnitude\\n\\n\"\n            \"Start typing to see matching stars...\")\n\n        self.after(1000, lambda: print(f\"Info display actual height: {self.info_display.winfo_height()} pixels\"))\n        self.after(1000, lambda: print(f\"Info frame height: {info_frame.winfo_height()} pixels\"))\n        self.after(1000, lambda: print(f\"Window height: {self.winfo_height()} pixels\"))\n\n    def on_search_change(self, category: str):\n        \"\"\"Handle search input.\"\"\"\n        search_term = self.search_vars[category].get().lower()\n        listbox = self.result_listboxes[category]\n        \n        listbox.delete(0, tk.END)\n        \n        if not search_term:\n            return\n        \n        matches = [\n            star for star in self.star_data.get(category, [])\n            if search_term in star.lower()\n        ]\n        \n        for star in matches[:50]:\n            listbox.insert(tk.END, star)\n        \n        if len(matches) == 1:\n            listbox.selection_set(0)\n\n    def on_select(self, category: str):\n        \"\"\"Handle star selection.\"\"\"\n        listbox = self.result_listboxes[category]\n        try:\n            selection = listbox.get(listbox.curselection())\n            \n            if selection:\n                self.search_vars[category].set(selection)\n                \n                for other_cat in self.search_vars:\n                    if other_cat != category:\n                        self.search_vars[other_cat].set(\"\")\n                \n                self.last_selected_star = selection\n                self.last_selected_category = category\n                \n                for lb in self.result_listboxes.values():\n                    lb.delete(0, tk.END)\n                    lb.master.pack_forget()\n                \n                info_text = self.format_complete_star_info(selection, category)\n                self.info_display.delete('1.0', tk.END)\n                self.info_display.insert('1.0', info_text)\n                \n                self.highlight_urls(self.info_display)\n                \n        except:\n            pass\n\n\n    def format_complete_star_info(self, star_name: str, category: str) -> str:\n        \"\"\"Format all available star information.\"\"\"\n        output = []\n        output.append(f\"{'='*60}\")\n        output.append(f\"{star_name}\")\n        output.append(f\"{'='*60}\\n\")\n        \n        # CHANGE: Always load on-demand, don't check self.star_full_data\n        star_props = self.load_single_star_properties(star_name, category)\n        \n        # If not found or incomplete, check other catalogs\n        if not star_props or len(star_props) < 5:\n            for other_category in [\"Stars by Distance\", \"Stars by Magnitude\"]:\n                if other_category != category:\n                    other_props = self.load_single_star_properties(star_name, other_category)\n                    if other_props and len(other_props) > len(star_props):\n                        star_props = other_props\n                        break\n        \n        # 1. RA/Dec Coordinates\n        ra_dec = self.format_ra_dec(star_props)\n        if ra_dec:\n            output.append(\"COORDINATES:\")\n            output.append(\"-\" * 40)\n            output.append(ra_dec)\n            output.append(\"\")\n        \n        # 2. Core Properties\n        props_text = self.format_core_properties(star_props)\n        if props_text:\n            output.append(\"STAR PROPERTIES:\")\n            output.append(\"-\" * 40)\n            output.append(props_text)\n            output.append(\"\")\n        \n        # 3. Description from unique_notes\n        note = unique_notes.get(star_name, \"\")\n        if note and note != \"None.\":\n            output.append(\"DESCRIPTION:\")\n            output.append(\"-\" * 40)\n            clean_note = self.clean_html_note(note)\n            output.append(clean_note)\n            output.append(\"\")\n            \n            # 4. URL if present\n            url = self.extract_url(note)\n            if url:\n                output.append(\"REFERENCE URL:\")\n                output.append(\"-\" * 40)\n                output.append(url)\n                output.append(\"\")\n        \n        # 5. Source information\n        output.append(\"-\" * 60)\n        output.append(f\"Search Category: {category}\")\n        \n        # CHANGE 3: Update the availability check to not rely on pre-loaded data\n        available_in = []\n        if star_name in unique_notes:\n            available_in.append(\"Notable Stars\")\n\n        # Check if star exists in distance catalog\n        if self.check_star_exists(star_name, \"Stars by Distance\"):\n            available_in.append(\"Distance Catalog\")\n\n        # Check if star exists in magnitude catalog  \n        if self.check_star_exists(star_name, \"Stars by Magnitude\"):\n            available_in.append(\"Magnitude Catalog\")            \n        \n        if available_in:\n            output.append(f\"Available in: {', '.join(available_in)}\")\n        \n        return '\\n'.join(output)\n\n    def check_star_exists(self, star_name: str, category: str) -> bool:\n        \"\"\"Check if a star exists in a category without loading full data.\"\"\"\n        return star_name in self.star_data.get(category, [])\n\n    def load_single_star_properties(self, star_name: str, category: str) -> dict:\n        \"\"\"Load properties for a single star on-demand.\"\"\"\n        \n        # Map category to file\n        file_map = {\n            \"Stars by Distance\": \"star_data/star_properties_distance.pkl\",\n            \"Stars by Magnitude\": \"star_data/star_properties_magnitude.pkl\",\n            \"Notable Stars\": \"star_data/star_properties_distance.pkl\"  # Try distance file for notable stars\n        }\n        \n        filename = file_map.get(category)\n        if not filename or not os.path.exists(filename):\n            return {}\n        \n        try:\n            with open(filename, 'rb') as f:\n                data = pickle.load(f)\n            \n            # Handle dictionary format (new enhanced format)\n            if isinstance(data, dict) and star_name in data:\n                return data[star_name]\n            \n            # Handle list format (old format)\n            if isinstance(data, dict) and 'star_names' in data:\n                try:\n                    idx = data['star_names'].index(star_name)\n                    props = {'Star_Name': star_name}\n                    \n                    # In load_single_star_properties(), fix the field mapping:\n                    for field in ['unique_ids', 'spectral_types', 'V_magnitudes', 'B_magnitudes',\n                                'object_types', 'distance_ly', 'distance_pc', 'Temperature',\n                                'Luminosity', 'Abs_Mag', 'RA_ICRS', 'DE_ICRS', 'ra_str',\n                                'dec_str', 'Stellar_Class', 'Object_Type_Desc', 'Source_Catalog']:\n                        if field in data and idx < len(data[field]):\n                            value = data[field][idx]\n                            # Better field mapping\n                            if field == 'unique_ids':\n                                key = 'unique_id'\n                            elif field == 'spectral_types':\n                                key = 'spectral_type'\n                            elif field == 'V_magnitudes':\n                                key = 'V_magnitude'\n                            elif field == 'B_magnitudes':\n                                key = 'B_magnitude'\n                            elif field == 'object_types':\n                                key = 'object_type'\n                            else:\n                                key = field  # Use as-is for other fields\n                            props[key] = value\n\n                    return props\n                except (ValueError, IndexError):\n                    pass\n        \n        except Exception as e:\n            print(f\"Error loading {star_name} from {filename}: {e}\")\n        \n        return {}\n\n    def format_ra_dec(self, star_props: Dict) -> Optional[str]:\n        \"\"\"Format RA/Dec coordinates.\"\"\"\n        # Try pre-formatted strings first (from enhanced data)\n        ra_str = star_props.get('ra_str')\n        dec_str = star_props.get('dec_str')\n        \n        if ra_str and dec_str and str(ra_str).lower() not in ['nan', 'none', '']:\n            return f\"RA:  {ra_str}\\nDec: {dec_str}\\n{ra_str} {dec_str}\\n(J2000 epoch)\"\n        \n        # Try ICRS coordinates in degrees\n        ra_deg = star_props.get('RA_ICRS')\n        dec_deg = star_props.get('DE_ICRS')\n        \n        if ra_deg is not None and dec_deg is not None:\n            try:\n                ra_deg = float(ra_deg)\n                dec_deg = float(dec_deg)\n                \n                if not np.isnan(ra_deg) and not np.isnan(dec_deg):\n                    # Convert to sexagesimal\n                    ra_hours = ra_deg / 15.0\n                    ra_h = int(ra_hours)\n                    ra_m = int((ra_hours - ra_h) * 60)\n                    ra_s = ((ra_hours - ra_h) * 60 - ra_m) * 60\n                    \n                    dec_sign = '+' if dec_deg >= 0 else '-'\n                    dec_abs = abs(dec_deg)\n                    dec_d = int(dec_abs)\n                    dec_m = int((dec_abs - dec_d) * 60)\n                    dec_s = ((dec_abs - dec_d) * 60 - dec_m) * 60\n                    \n                    ra_formatted = f\"{ra_h:02d}h {ra_m:02d}m {ra_s:05.2f}s\"\n                    dec_formatted = f\"{dec_sign}{dec_d:02d} deg {dec_m:02d}' {dec_s:04.1f}\\\"\"\n                    \n                    return f\"RA:  {ra_formatted}\\nDec: {dec_formatted}\\n(J2000 epoch)\"\n            except:\n                pass\n        \n        return None\n\n    def format_core_properties(self, star_props: Dict) -> str:\n        \"\"\"Format star properties - reads from enhanced pickle data.\"\"\"\n        lines = []\n        \n        # Distance\n        distance_ly = star_props.get('distance_ly')\n        distance_pc = star_props.get('distance_pc')\n        \n        if distance_ly is not None and not pd.isna(distance_ly):\n            if distance_pc is None or pd.isna(distance_pc):\n                distance_pc = distance_ly / 3.26156\n            lines.append(f\"Distance: {distance_pc:.2f} pc ({distance_ly:.2f} ly)\")\n        elif distance_pc is not None and not pd.isna(distance_pc):\n            distance_ly = distance_pc * 3.26156\n            lines.append(f\"Distance: {distance_pc:.2f} pc ({distance_ly:.2f} ly)\")\n        \n        # Temperature (from enhanced data or basic)\n        temp = star_props.get('Temperature')\n        if temp is not None and not pd.isna(temp):\n            lines.append(f\"Temperature: {temp:.0f} K\")\n        \n        # Luminosity (from enhanced data)\n        lum = star_props.get('Luminosity')\n        if lum is not None and not pd.isna(lum):\n            lines.append(f\"Luminosity: {lum:.6f} L[SUN]\")\n        \n        # Absolute Magnitude (from enhanced data)\n        abs_mag = star_props.get('Abs_Mag')\n        if abs_mag is not None and not pd.isna(abs_mag):\n            lines.append(f\"Absolute Magnitude: {abs_mag:.2f}\")\n        \n        # Apparent Magnitude\n        app_mag = star_props.get('V_magnitude')\n        if app_mag is not None and not pd.isna(app_mag):\n            lines.append(f\"Apparent Magnitude: {app_mag:.2f}\")\n        \n        # Spectral Type\n        spec_type = star_props.get('spectral_type')\n        if spec_type and str(spec_type) not in ['Unknown', 'nan', 'None']:\n            lines.append(f\"Spectral Type: {spec_type}\")\n        \n        # Stellar Class (from enhanced data or parse from spectral type)\n        stellar_class = star_props.get('Stellar_Class')\n        if stellar_class and str(stellar_class) not in ['Unknown', 'nan', 'None']:\n            # Get full description if available\n            if stellar_class in stellar_class_labels:\n                lines.append(f\"Stellar Class: {stellar_class_labels[stellar_class]}\")\n            else:\n                lines.append(f\"Stellar Class: {stellar_class}\")\n        \n        # Object Type (expanded from enhanced data or basic code)\n        obj_type = star_props.get('Object_Type_Desc')  # Try enhanced first\n        if not obj_type or pd.isna(obj_type):\n            obj_type_code = star_props.get('object_type')  # Fall back to code\n            if obj_type_code and str(obj_type_code) not in ['Unknown', 'nan', 'None']:\n                # Expand using mapping\n                codes = re.split(r'[;, ]+', str(obj_type_code))\n                descriptions = []\n                for code in codes:\n                    code = code.strip()\n                    descriptions.append(object_type_mapping.get(code, code))\n                obj_type = ', '.join(descriptions)\n        \n        if obj_type and str(obj_type) not in ['Unknown', 'nan', 'None']:\n            lines.append(f\"Object Type: {obj_type}\")\n        \n        # Source Catalog (from enhanced data or infer from unique_id)\n        source = star_props.get('Source_Catalog')\n        if source:\n            lines.append(f\"Source Catalog: {source}\")\n        else:\n            uid = star_props.get('unique_id')\n            if uid:\n                if uid.startswith('HIP'):\n                    lines.append(\"Source Catalog: Hipparcos\")\n                elif uid.startswith('Gaia'):\n                    lines.append(\"Source Catalog: Gaia\")\n        \n        return '\\n'.join(lines)\n\n    def clean_html_note(self, note: str) -> str:\n        \"\"\"Remove HTML tags from note content.\"\"\"\n        clean = re.sub(r'<br\\s*/?>', '\\n', note)\n        clean = re.sub(r'<a\\s+href=\"[^\"]*\"[^>]*>([^<]*)</a>', r'\\1', clean)\n        clean = re.sub(r'<[^>]+>', '', clean)\n        clean = re.sub(r'\\n\\s*\\n', '\\n\\n', clean)\n        return clean.strip()\n\n    def extract_url(self, note: str) -> Optional[str]:\n        \"\"\"Extract URL from HTML anchor tags.\"\"\"\n        url_match = re.search(r'<a href=\"([^\"]+)\">', note)\n        if url_match:\n            return url_match.group(1)\n        return None\n\n    def highlight_urls(self, text_widget):\n        \"\"\"Make URLs clickable.\"\"\"\n        content = text_widget.get('1.0', tk.END)\n        text_widget.tag_remove(\"url\", \"1.0\", tk.END)\n        \n        url_pattern = r'https?://[^\\s]+'\n        for match in re.finditer(url_pattern, content):\n            start_idx = f\"1.0 + {match.start()} chars\"\n            end_idx = f\"1.0 + {match.end()} chars\"\n            text_widget.tag_add(\"url\", start_idx, end_idx)\n        \n        text_widget.tag_config(\"url\", foreground=\"blue\", underline=True)\n        \n        def open_url(event):\n            index = text_widget.index(f\"@{event.x},{event.y}\")\n            if \"url\" in text_widget.tag_names(index):\n                ranges = text_widget.tag_ranges(\"url\")\n                for i in range(0, len(ranges), 2):\n                    if text_widget.compare(index, \">=\", ranges[i]) and \\\n                       text_widget.compare(index, \"<=\", ranges[i+1]):\n                        url = text_widget.get(ranges[i], ranges[i+1])\n                        webbrowser.open(url)\n                        break\n        \n        text_widget.tag_bind(\"url\", \"<Button-1>\", open_url)\n        text_widget.tag_bind(\"url\", \"<Enter>\", lambda e: text_widget.config(cursor=\"hand2\"))\n        text_widget.tag_bind(\"url\", \"<Leave>\", lambda e: text_widget.config(cursor=\"\"))\n\n    def add_clipboard_support(self, widget):\n        \"\"\"Add copy/paste support.\"\"\"\n        def copy(event=None):\n            try:\n                selection = widget.get(tk.SEL_FIRST, tk.SEL_LAST)\n                widget.clipboard_clear()\n                widget.clipboard_append(selection)\n            except:\n                pass\n            return \"break\"\n        \n        def select_all(event=None):\n            widget.tag_add(tk.SEL, \"1.0\", tk.END)\n            widget.mark_set(tk.INSERT, \"1.0\")\n            widget.see(tk.INSERT)\n            return \"break\"\n        \n        widget.bind(\"<Control-c>\", copy)\n        widget.bind(\"<Control-a>\", select_all)\n        \n        menu = tk.Menu(widget, tearoff=0)\n        menu.add_command(label=\"Copy\", command=copy)\n        menu.add_command(label=\"Select All\", command=select_all)\n        \n        def show_menu(event):\n            menu.post(event.x_root, event.y_root)\n        \n        widget.bind(\"<Button-3>\", show_menu)\n\n    def get_selected_stars(self) -> Dict[str, Optional[str]]:\n        \"\"\"Get currently selected stars.\"\"\"\n        return {\n            category: self.search_vars[category].get()\n            for category in self.search_vars\n        }",
    "start_line": 187,
    "end_line": 786,
    "has_docstring": true,
    "docstring": "Search widget with unified display for all star information.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "ttk.Frame"
    ],
    "class_name": null,
    "display_name": "class StarVisualizationSearchWidget",
    "component_id": "star_visualization_gui.StarVisualizationSearchWidget"
  },
  "star_visualization_gui.StarVisualizationGUI": {
    "id": "star_visualization_gui.StarVisualizationGUI",
    "name": "StarVisualizationGUI",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\star_visualization_gui.py",
    "relative_path": "star_visualization_gui.py",
    "depends_on": [
      "save_utils._get_initial_directory",
      "planetarium_apparent_magnitude.main",
      "hr_diagram_apparent_magnitude.main",
      "plot_data_report_widget.PlotDataReportWidget",
      "star_visualization_gui.is_frozen",
      "palomas_orrery.save_window_config",
      "palomas_orrery.load_window_config",
      "hr_diagram_distance.main",
      "star_visualization_gui.StarVisualizationSearchWidget",
      "report_manager.ReportManager",
      "orrery_integration.update",
      "planetarium_distance.main",
      "social_media_export.export_social_html",
      "star_visualization_gui.ScrollableFrame"
    ],
    "source_code": "class StarVisualizationGUI(tk.Tk):\n    \"\"\"Main GUI window with search and visualization controls.\"\"\"\n    \n    def __init__(self):\n        super().__init__()\n        self.title(\"Star Visualization Control Panel -- Updated: January 10, 2026\")\n        \n        # ====================================================================\n        # WINDOW GEOMETRY AND CONFIG MANAGEMENT\n        # ====================================================================\n        \n        # Config file in application directory\n        self.CONFIG_FILE = os.path.join(os.getcwd(), 'star_viz_config.json')\n        print(f\"Window config file: {self.CONFIG_FILE}\", flush=True)\n        \n        # Platform-aware defaults\n        if platform.system() == 'Linux':\n            DEFAULT_GEOMETRY = \"1200x850\"\n            MIN_WIDTH, MIN_HEIGHT = 1050, 700\n            self.DEFAULT_SASH = [380, 780]\n        elif platform.system() == 'Darwin':\n            DEFAULT_GEOMETRY = \"1150x830\"\n            MIN_WIDTH, MIN_HEIGHT = 1000, 680\n            self.DEFAULT_SASH = [360, 750]\n        else:  # Windows\n            DEFAULT_GEOMETRY = \"1100x800\"\n            MIN_WIDTH, MIN_HEIGHT = 980, 650\n            self.DEFAULT_SASH = [340, 720]\n        \n        # Load saved config\n        self.saved_config = self.load_window_config()\n        if self.saved_config and self.saved_config.get('platform') == platform.system():\n            try:\n                self.geometry(self.saved_config['geometry'])\n                print(f\"Restored window geometry: {self.saved_config['geometry']}\", flush=True)\n                # Restore maximized state if it was saved\n                if self.saved_config.get('state') == 'zoomed':\n                    self.after(100, lambda: self.state('zoomed'))\n                    print(\"Window will be maximized\", flush=True)\n            except:\n                self.geometry(DEFAULT_GEOMETRY)\n        else:\n            self.geometry(DEFAULT_GEOMETRY)\n            print(f\"Using default geometry: {DEFAULT_GEOMETRY}\", flush=True)\n        \n        self.minsize(MIN_WIDTH, MIN_HEIGHT)\n        self.resizable(True, True)\n        self.protocol(\"WM_DELETE_WINDOW\", self.on_closing)\n        \n        # ====================================================================\n        \n        self.BUTTON_WIDTH = 35\n        self.BUTTON_FONT = (\"Arial\", 10, \"normal\")\n        \n        self.setup_ui()\n        \n        # Restore sash positions after UI is built\n        self.after(100, self.restore_sash_positions)\n        \n        # Check for and load last plot data after UI is ready\n        self.after(200, self.check_and_load_last_plot)\n    \n    def load_window_config(self):\n        \"\"\"Load saved window geometry and sash positions.\"\"\"\n        try:\n            if os.path.exists(self.CONFIG_FILE):\n                with open(self.CONFIG_FILE, 'r') as f:\n                    return json.load(f)\n        except Exception as e:\n            print(f\"Note: Could not load window config: {e}\", flush=True)\n        return None\n    \n    def save_window_config(self):\n        \"\"\"Save window geometry and sash positions.\"\"\"\n        try:\n            sash_positions = []\n            try:\n                for i in range(2):\n                    sash_positions.append(self.main_paned.sash_coord(i)[0])\n            except:\n                pass\n            config = {\n                'geometry': self.geometry(),\n                'state': self.state(),\n                'platform': platform.system(),\n                'sash_positions': sash_positions\n            }\n            with open(self.CONFIG_FILE, 'w') as f:\n                json.dump(config, f, indent=2)\n            print(f\"Window config saved to {self.CONFIG_FILE}\", flush=True)\n        except Exception as e:\n            print(f\"Note: Could not save window config: {e}\", flush=True)\n    \n    def restore_sash_positions(self):\n        \"\"\"Restore saved sash positions.\"\"\"\n        try:\n            positions = None\n            if self.saved_config and self.saved_config.get('platform') == platform.system():\n                positions = self.saved_config.get('sash_positions')\n            if positions and len(positions) >= 2:\n                self.main_paned.sash_place(0, positions[0], 0)\n                self.main_paned.sash_place(1, positions[1], 0)\n                print(f\"Restored sash positions: {positions}\", flush=True)\n            else:\n                self.main_paned.sash_place(0, self.DEFAULT_SASH[0], 0)\n                self.main_paned.sash_place(1, self.DEFAULT_SASH[1], 0)\n                print(f\"Using default sash positions: {self.DEFAULT_SASH}\", flush=True)\n        except Exception as e:\n            print(f\"Note: Could not restore sash positions: {e}\", flush=True)\n    \n    def on_closing(self):\n        \"\"\"Save config and close.\"\"\"\n        self.save_window_config()\n        self.destroy()\n\n\n    def run_visualization_with_console_output(self, script_path, args):\n        \"\"\"Run visualization and print output to console.\"\"\"\n        import subprocess\n        import sys\n        \n        result = subprocess.run(\n            [sys.executable, script_path] + args,\n            capture_output=True,\n            text=True\n        )\n        \n        print(\"\\n\" + \"=\"*60)\n        print(f\"Output from {script_path}:\")\n        print(\"=\"*60)\n        if result.stdout:\n            print(result.stdout)\n        if result.stderr:\n            print(\"ERRORS:\", result.stderr)\n        print(\"=\"*60 + \"\\n\")\n        \n        return result.returncode == 0\n\n    def check_and_load_last_plot(self):\n        \"\"\"Check for and load the last plot data on startup.\"\"\"\n        try:\n\n            # Try to load the scientific report first\n            report_mgr = ReportManager()\n            report_data = report_mgr.load_last_report()\n            \n            if report_data:\n                print(\"Found existing scientific report, loading...\")\n                self.plot_report.display_report(report_data)\n                return\n\n            # Try to load the last plot data\n            plot_data = PlotDataExchange.load_plot_data()\n            \n            if plot_data:\n                print(\"Found existing plot data, loading report...\")\n                \n                # Create minimal DataFrame for report\n                import pandas as pd\n                \n                # Get data from the saved plot\n                temp_valid = plot_data.get('temp_valid', 0)\n                temp_missing = plot_data.get('temp_missing', 0)\n                lum_valid = plot_data.get('lum_valid', 0)\n                lum_missing = plot_data.get('lum_missing', 0)\n                total_stars = plot_data.get('total_stars', 0)\n                \n                # Create arrays for Temperature and Luminosity\n                temp_array = [1] * temp_valid + [0] * temp_missing\n                lum_array = [1] * lum_valid + [0] * lum_missing\n                \n                # Make sure arrays are the same length (use total_stars as reference)\n                if len(temp_array) < total_stars:\n                    temp_array.extend([0] * (total_stars - len(temp_array)))\n                if len(lum_array) < total_stars:\n                    lum_array.extend([0] * (total_stars - len(lum_array)))\n                    \n                # Trim if too long\n                temp_array = temp_array[:total_stars]\n                lum_array = lum_array[:total_stars]\n                \n                # Create DataFrame\n                pseudo_df = pd.DataFrame({\n                    'Temperature': temp_array,\n                    'Luminosity': lum_array\n                })\n                \n                # Add catalog information if available\n                if plot_data.get('catalog_counts'):\n                    catalogs = []\n                    for catalog, count in plot_data['catalog_counts'].items():\n                        catalogs.extend([catalog] * count)\n                    if catalogs:\n                        # Make sure catalog list matches DataFrame length\n                        if len(catalogs) > len(pseudo_df):\n                            catalogs = catalogs[:len(pseudo_df)]\n                        elif len(catalogs) < len(pseudo_df):\n                            # Pad with 'Unknown' if needed\n                            catalogs.extend(['Unknown'] * (len(pseudo_df) - len(catalogs)))\n                        pseudo_df['Source_Catalog'] = catalogs\n                \n                # Add magnitude stats if available\n                if plot_data.get('magnitude_stats'):\n                    mag_stats = plot_data['magnitude_stats']\n                    # Use mean if available, otherwise use a default\n                    mag_value = mag_stats.get('mean', 0) if mag_stats else 0\n                    pseudo_df['Apparent_Magnitude'] = [mag_value] * len(pseudo_df)\n                \n                # Update the report widget\n                self.plot_report.update_report(\n                    combined_df=pseudo_df,\n                    counts_dict=plot_data.get('counts_dict', {}),\n                    processing_times=plot_data.get('processing_times', {}),\n                    mode=plot_data.get('mode', 'unknown'),\n                    limit_value=plot_data.get('limit_value')\n                )\n                \n        except Exception as e:\n            print(f\"Error loading last plot data: {e}\")\n            import traceback\n            traceback.print_exc()\n            self.status_label.config(\n                text=\"Ready\",\n                foreground=\"green\"\n            )\n\n    def setup_ui(self):\n        \"\"\"Build the complete user interface.\"\"\"\n        # Create PanedWindow for resizable columns\n        self.main_paned = tk.PanedWindow(self, orient=tk.HORIZONTAL, sashwidth=8,\n                                         sashrelief=tk.RAISED, bg='gray70')\n        self.main_paned.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n        # LEFT COLUMN - Star Search\n        left_frame = ttk.Frame(self.main_paned)\n        \n        search_label = ttk.Label(left_frame, text=\"Star Search\", font=(\"Arial\", 12, \"bold\"))\n        search_label.pack(pady=(0, 10))\n        \n        self.search_widget = StarVisualizationSearchWidget(left_frame)\n        self.search_widget.pack(fill='both', expand=True)\n        \n        # MIDDLE COLUMN - Visualization Controls\n        middle_scroll = ScrollableFrame(self.main_paned)\n        middle_frame = middle_scroll.container\n        \n        controls_label = ttk.Label(middle_frame, text=\"Visualization Controls\", font=(\"Arial\", 12, \"bold\"))\n        controls_label.pack(pady=(0, 10))\n        \n        # Distance controls\n        distance_frame = ttk.LabelFrame(middle_frame, text=\"Distance-based Visualization (4.25 through 100 light-years)\", padding=10)\n        distance_frame.pack(fill='x', pady=(0, 10))\n        \n        ttk.Label(distance_frame, text=\"Distance (light-years):\").pack(anchor='w')\n        self.ly_entry = ttk.Entry(distance_frame, width=20)\n        self.ly_entry.pack(fill='x', pady=(5, 10))\n        self.ly_entry.insert(0, \"20\")\n        \n        self.plot_3d_button = tk.Button(\n            distance_frame,\n            text=\"3D Stellar Neighborhood\",\n            command=self.plot_3d_distance,\n            bg='gray90',\n            fg='blue',\n            width=self.BUTTON_WIDTH,\n            font=self.BUTTON_FONT\n        )\n        self.plot_3d_button.pack(pady=(0, 5))\n        \n        self.plot_2d_button = tk.Button(\n            distance_frame,\n            text=\"2D HR Diagram\",\n            command=self.plot_2d_distance,\n            bg='gray90',\n            fg='blue',\n            width=self.BUTTON_WIDTH,\n            font=self.BUTTON_FONT\n        )\n        self.plot_2d_button.pack()\n        \n        # Magnitude controls\n        magnitude_frame = ttk.LabelFrame(middle_frame, text=\"Apparent Magnitude-based Visualization (-1.44 through 9)\", padding=10)\n        magnitude_frame.pack(fill='x', pady=(0, 10))\n\n        # ADD: Scale options for magnitude visualization\n        scale_frame = ttk.LabelFrame(magnitude_frame, text=\"Scale Options\", padding=5)\n        scale_frame.pack(fill='x', pady=(10, 0))\n\n        self.scale_var = tk.StringVar(value='Auto')\n        self.auto_scale_radio = ttk.Radiobutton(\n            scale_frame, \n            text=\"Automatic Scaling\",\n            variable=self.scale_var, \n            value='Auto'\n        )\n        self.auto_scale_radio.pack(anchor='w')\n\n        self.manual_scale_radio = ttk.Radiobutton(\n            scale_frame,\n            text=\"Manual Scale (Light-Years):\",\n            variable=self.scale_var,\n            value='Manual'\n        )\n        self.manual_scale_radio.pack(anchor='w')\n\n        self.scale_entry = ttk.Entry(scale_frame, width=20)\n        self.scale_entry.pack(fill='x', pady=(5, 0))\n        self.scale_entry.insert(0, '1400')\n\n        # Enable/disable scale entry based on selection\n        def on_scale_change(*args):\n            self.scale_entry.config(\n                state='normal' if self.scale_var.get() == 'Manual' else 'disabled'\n            )\n\n        self.scale_var.trace('w', on_scale_change)\n        on_scale_change()  # Set initial state\n        \n        ttk.Label(magnitude_frame, text=\"Limiting Magnitude:\").pack(anchor='w')\n        self.mag_entry = ttk.Entry(magnitude_frame, width=20)\n        self.mag_entry.pack(fill='x', pady=(5, 10))\n        self.mag_entry.insert(0, \"4\")\n        \n        self.plot_3d_mag_button = tk.Button(\n            magnitude_frame,\n            text=\"3D Visible Stars\",\n            command=self.plot_3d_magnitude,\n            bg='gray90',\n            fg='blue',\n            width=self.BUTTON_WIDTH,\n            font=self.BUTTON_FONT\n        )\n        self.plot_3d_mag_button.pack(pady=(0, 5))\n        \n        self.plot_2d_mag_button = tk.Button(\n            magnitude_frame,\n            text=\"2D HR Diagram (Visible)\",\n            command=self.plot_2d_magnitude,\n            bg='gray90',\n            fg='blue',\n            width=self.BUTTON_WIDTH,\n            font=self.BUTTON_FONT\n        )\n        self.plot_2d_mag_button.pack()\n        \n        # Status display\n        status_frame = ttk.LabelFrame(middle_frame, text=\"Status\", padding=10)\n        status_frame.pack(fill='x', pady=(10, 0))\n        \n        self.status_label = ttk.Label(status_frame, text=\"Ready\", foreground=\"green\")\n        self.status_label.pack()\n                \n        # Social Media Export\n        social_frame = ttk.LabelFrame(middle_frame, text=\"Social Media Export\", padding=10)\n        social_frame.pack(fill='x', pady=(10, 0))\n\n        ttk.Label(\n            social_frame,\n            text=\"Convert a saved 3D HTML to portrait social view\",\n            foreground=\"gray\"\n        ).pack(anchor='w')\n\n        self.social_view_button = tk.Button(\n            social_frame,\n            text=\"Social View from Saved HTML...\",\n            command=self.export_social_view,\n            bg='gray90',\n            fg='purple',\n            width=self.BUTTON_WIDTH,\n            font=self.BUTTON_FONT\n        )\n        self.social_view_button.pack(pady=(5, 0))\n\n        # ADD THIS NEW SECTION - Plot Data Report Widget\n        self.plot_report = PlotDataReportWidget(middle_frame)\n        self.plot_report.pack(fill='both', expand=True, pady=(10, 0))\n\n        # RIGHT COLUMN - Notes\n        right_frame = ttk.Frame(self.main_paned)\n        \n        notes_label = ttk.Label(right_frame, text=\"Notes\", font=(\"Arial\", 12, \"bold\"))\n        notes_label.pack(pady=(0, 10))\n        \n        notes_text = scrolledtext.ScrolledText(right_frame, wrap='word', width=30, height=45)\n        notes_text.pack(fill='both', expand=True)\n        notes_text.insert('1.0', \n            \"Star Visualization Guide\\n\"\n            \"========================\\n\\n\"\n            \"Distance Visualization:\\n\"\n            \"- Enter distance in light-years\\n\"\n            \"- Maximum: 100 light-years\\n\"\n            \"- Shows: ~9,750 stars at max\\n\\n\"\n            \"Magnitude Visualization:\\n\"\n            \"- Enter limiting magnitude (Vmag)\\n\"\n            \"- Range: -1.44 to 9.0\\n\"\n            \"- Shows: ~124,000 stars at Vmag 9\\n\\n\"\n            \"Description\t           Vmag\\n\"\n            \"--------------------   ---------\\n\"\n            \"Earth orbit            8.0 - 9.0\\n\"\n            \"Excellent dark sky\t    7.6 - 8.0\\n\"\n            \"Typical dark sky\t      7.1 - 7.5\\n\"\n            \"Rural sky\t             6.6 - 7.0\\n\"\n            \"Rural/suburban sky     6.1 - 6.5\\n\"\n            \"Suburban sky\t          5.6 - 6.0\\n\"\n            \"Bright suburban sky\t   5.1 - 5.5\\n\"\n            \"Suburban/urban sky\t    4.6 - 5.0\\n\"\n            \"City sky\t              4.1 - 4.5\\n\"\n            \"Inner-city sky\t        < 4.0\\n\"\n            \"Brightest star, Sirius -1.44\\n\\n\"\n            \"Cache Management:\\n\"\n            \"- Protected VOT/PKL files\\n\"\n            \"- Automatic backups created\\n\"\n            \"- Safe incremental updates\\n\"\n            \"- No data loss on errors\\n\\n\"\n            \"Search Features:\\n\"\n            \"- Search any star by name\\n\"\n            \"- View properties and notes\\n\"\n            \"- Click URLs to open in browser\\n\"\n            \"- Coordinates in J2000 epoch\\n\\n\"\n            \"Data Quality:\\n\"\n            \"- 77-99% stars have temperatures\\n\"\n            \"- All stars have luminosity\\n\"\n            \"- Enhanced stellar parameters\\n\"\n            \"- Hipparcos + Gaia catalogs\\n\\n\"\n            \"Tips:\\n\"\n            \"- Reducing limits uses cache only\\n\"\n            \"- Progress saves automatically\\n\"\n            \"- Safe to interrupt with Ctrl+C\\n\"\n        )\n        notes_text.config(state='disabled')\n        \n        # Add frames to PanedWindow\n        self.main_paned.add(left_frame, minsize=250, sticky='nsew')\n        self.main_paned.add(middle_scroll, minsize=300, sticky='nsew')\n        self.main_paned.add(right_frame, minsize=200, sticky='nsew')\n\n    # ============================================================\n    # PLOTTING METHODS - Updated for PyInstaller support\n    # ============================================================\n\n    def plot_3d_distance(self):\n        \"\"\"Launch 3D distance visualization.\"\"\"\n        try:\n            ly_value = float(self.ly_entry.get())\n            if ly_value <= 0 or ly_value > 100.1:\n                self.status_label.config(text=\"Enter 4.25 - 100 light-years\", foreground=\"red\")\n                return\n            \n            self.status_label.config(\n                text=f\"Generating 3D visualization for distance <= {ly_value} (~10-15 seconds)\",\n                foreground=\"blue\"\n            )\n            self.update()\n\n            if is_frozen() and PLOTTING_MODULES_AVAILABLE:\n                # Running as exe - call function directly\n                print(f\"Running planetarium_distance.main() directly (frozen exe)\")\n                old_argv = sys.argv\n                sys.argv = ['planetarium_distance.py', str(ly_value)]\n                try:\n                    planetarium_distance.main()\n                    self.status_label.config(text=f\"Launched 3D plot ({ly_value} ly)\", foreground=\"green\")\n                except Exception as e:\n                    print(f\"Error in planetarium_distance: {e}\")\n                    import traceback\n                    traceback.print_exc()\n                    self.status_label.config(text=\"Error generating 3D plot\", foreground=\"red\")\n                finally:\n                    sys.argv = old_argv\n            else:\n                # Running as Python script - use subprocess\n                script_path = os.path.join(os.path.dirname(__file__), 'planetarium_distance.py')\n                result = subprocess.run([sys.executable, script_path, str(ly_value)],\n                                    capture_output=True, text=True)\n                \n                print(\"\\n\" + \"=\"*60)\n                print(f\"Output from planetarium_distance.py ({ly_value} ly):\")\n                print(\"=\"*60)\n                if result.stdout:\n                    print(result.stdout)\n                if result.stderr:\n                    print(\"STDERR:\")\n                    print(result.stderr)\n                print(\"=\"*60 + \"\\n\")\n                \n                if result.returncode == 0:\n                    self.status_label.config(text=f\"Launched 3D plot ({ly_value} ly)\", foreground=\"green\")\n                else:\n                    self.status_label.config(text=\"Error generating 3D plot\", foreground=\"red\")\n                    \n        except ValueError:\n            self.status_label.config(text=\"Invalid distance value\", foreground=\"red\")\n        except Exception as e:\n            self.status_label.config(text=f\"Error: {e}\", foreground=\"red\")\n\n\n    def plot_2d_distance(self):\n        \"\"\"Launch 2D HR diagram for distance and update report.\"\"\"\n        try:\n            ly_value = float(self.ly_entry.get())\n            if ly_value <= 0 or ly_value > 100.1:\n                self.status_label.config(text=\"Enter 4.25 - 100 light-years\", foreground=\"red\")\n                return\n            \n            self.status_label.config(\n                text=f\"Generating 2D visualization for distance <= {ly_value} (~5-10 seconds)\",\n                foreground=\"blue\"\n            )\n            self.update()\n\n            if is_frozen() and PLOTTING_MODULES_AVAILABLE:\n                # Running as exe - call function directly\n                print(f\"Running hr_diagram_distance.main() directly (frozen exe)\")\n                old_argv = sys.argv\n                sys.argv = ['hr_diagram_distance.py', str(ly_value)]\n                try:\n                    hr_diagram_distance.main()\n                    self.status_label.config(text=f\"HR diagram completed ({ly_value} ly)\", foreground=\"green\")\n                    self.after(500, self.load_and_display_plot_report)\n                except Exception as e:\n                    print(f\"Error in hr_diagram_distance: {e}\")\n                    import traceback\n                    traceback.print_exc()\n                    self.status_label.config(text=\"Error generating plot\", foreground=\"red\")\n                finally:\n                    sys.argv = old_argv\n            else:\n                # Running as Python script - use subprocess\n                script_path = os.path.join(os.path.dirname(__file__), 'hr_diagram_distance.py')\n                result = subprocess.run([sys.executable, script_path, str(ly_value)], \n                                    capture_output=True, text=True)\n                \n                print(\"\\n\" + \"=\"*60)\n                print(f\"Output from hr_diagram_distance.py ({ly_value} ly):\")\n                print(\"=\"*60)\n                if result.stdout:\n                    print(result.stdout)\n                if result.stderr:\n                    print(\"STDERR:\")\n                    print(result.stderr)\n                print(\"=\"*60 + \"\\n\")\n                \n                if result.returncode == 0:\n                    self.status_label.config(text=f\"HR diagram completed ({ly_value} ly)\", foreground=\"green\")\n                    self.after(500, self.load_and_display_plot_report)\n                else:\n                    self.status_label.config(text=\"Error generating plot\", foreground=\"red\")\n                    \n        except ValueError:\n            self.status_label.config(text=\"Invalid distance value\", foreground=\"red\")\n        except Exception as e:\n            self.status_label.config(text=f\"Error: {e}\", foreground=\"red\")\n            \n\n    def plot_3d_magnitude(self):\n        \"\"\"Launch 3D magnitude visualization with scale options.\"\"\"\n        try:\n            mag_value = float(self.mag_entry.get())\n            if mag_value < -1.44 or mag_value > 9:\n                self.status_label.config(text=\"Enter magnitude -1.44 to 9\", foreground=\"red\")\n                return\n            \n            self.status_label.config(\n                text=f\"Generating 3D visualization for magnitude <= {mag_value} (~30-75 seconds)\",\n                foreground=\"blue\"\n            )\n            self.update()\n\n            # Get scale value if manual mode\n            scale_value = None\n            if hasattr(self, 'scale_var') and self.scale_var.get() == 'Manual':\n                try:\n                    scale_value = float(self.scale_entry.get())\n                    if scale_value <= 0:\n                        self.status_label.config(text=\"Scale must be positive\", foreground=\"red\")\n                        return\n                except ValueError:\n                    self.status_label.config(text=\"Invalid scale value\", foreground=\"red\")\n                    return\n\n            if is_frozen() and PLOTTING_MODULES_AVAILABLE:\n                # Running as exe - call function directly\n                print(f\"Running planetarium_apparent_magnitude.main() directly (frozen exe)\")\n                old_argv = sys.argv\n                if scale_value:\n                    sys.argv = ['planetarium_apparent_magnitude.py', str(mag_value), str(scale_value)]\n                else:\n                    sys.argv = ['planetarium_apparent_magnitude.py', str(mag_value)]\n                try:\n                    planetarium_apparent_magnitude.main()\n                    if scale_value:\n                        self.status_label.config(text=f\"Launched 3D plot (mag {mag_value}, scale {scale_value} ly)\", foreground=\"green\")\n                    else:\n                        self.status_label.config(text=f\"Launched 3D plot (mag {mag_value}, auto scale)\", foreground=\"green\")\n                except Exception as e:\n                    print(f\"Error in planetarium_apparent_magnitude: {e}\")\n                    import traceback\n                    traceback.print_exc()\n                    self.status_label.config(text=\"Error generating 3D plot\", foreground=\"red\")\n                finally:\n                    sys.argv = old_argv\n            else:\n                # Running as Python script - use subprocess\n                script_path = os.path.join(os.path.dirname(__file__), 'planetarium_apparent_magnitude.py')\n                cmd = [sys.executable, script_path, str(mag_value)]\n                \n                if scale_value:\n                    cmd.append(str(scale_value))\n                \n                result = subprocess.run(cmd, capture_output=True, text=True)\n                \n                print(\"\\n\" + \"=\"*60)\n                print(f\"Output from planetarium_apparent_magnitude.py (mag {mag_value}):\")\n                print(\"=\"*60)\n                if result.stdout:\n                    print(result.stdout)\n                if result.stderr:\n                    print(\"STDERR:\")\n                    print(result.stderr)\n                print(\"=\"*60 + \"\\n\")\n                \n                if result.returncode == 0:\n                    if scale_value:\n                        self.status_label.config(text=f\"Launched 3D plot (mag {mag_value}, scale {scale_value} ly)\", foreground=\"green\")\n                    else:\n                        self.status_label.config(text=f\"Launched 3D plot (mag {mag_value}, auto scale)\", foreground=\"green\")\n                else:\n                    self.status_label.config(text=\"Error generating 3D plot\", foreground=\"red\")\n                \n        except ValueError:\n            self.status_label.config(text=\"Invalid magnitude value\", foreground=\"red\")\n        except Exception as e:\n            self.status_label.config(text=f\"Error: {e}\", foreground=\"red\")\n\n\n    def plot_2d_magnitude(self):\n        \"\"\"Launch 2D HR diagram for magnitude and update report.\"\"\"\n        try:\n            mag_value = float(self.mag_entry.get())\n            if mag_value < -1.44 or mag_value > 9:\n                self.status_label.config(text=\"Enter magnitude -1.44 to 9\", foreground=\"red\")\n                return\n            \n            self.status_label.config(\n                text=f\"Generating 2D visualization for magnitude <= {mag_value} (~30-60 seconds)\",\n                foreground=\"blue\"\n            )\n            self.update()\n\n            if is_frozen() and PLOTTING_MODULES_AVAILABLE:\n                # Running as exe - call function directly\n                print(f\"Running hr_diagram_apparent_magnitude.main() directly (frozen exe)\")\n                old_argv = sys.argv\n                sys.argv = ['hr_diagram_apparent_magnitude.py', str(mag_value)]\n                try:\n                    hr_diagram_apparent_magnitude.main()\n                    self.status_label.config(text=f\"HR diagram completed (mag {mag_value})\", foreground=\"green\")\n                    self.after(500, self.load_and_display_plot_report)\n                except Exception as e:\n                    print(f\"Error in hr_diagram_apparent_magnitude: {e}\")\n                    import traceback\n                    traceback.print_exc()\n                    self.status_label.config(text=\"Error generating plot\", foreground=\"red\")\n                finally:\n                    sys.argv = old_argv\n            else:\n                # Running as Python script - use subprocess\n                script_path = os.path.join(os.path.dirname(__file__), 'hr_diagram_apparent_magnitude.py')\n                result = subprocess.run([sys.executable, script_path, str(mag_value)],\n                                    capture_output=True, text=True)\n                \n                print(\"\\n\" + \"=\"*60)\n                print(f\"Output from hr_diagram_apparent_magnitude.py (mag {mag_value}):\")\n                print(\"=\"*60)\n                if result.stdout:\n                    print(result.stdout)\n                if result.stderr:\n                    print(\"STDERR:\")\n                    print(result.stderr)\n                print(\"=\"*60 + \"\\n\")\n                \n                if result.returncode == 0:\n                    self.status_label.config(text=f\"HR diagram completed (mag {mag_value})\", foreground=\"green\")\n                    self.after(500, self.load_and_display_plot_report)\n                else:\n                    self.status_label.config(text=\"Error generating plot\", foreground=\"red\")\n                    \n        except ValueError:\n            self.status_label.config(text=\"Invalid magnitude value\", foreground=\"red\")\n        except Exception as e:\n            self.status_label.config(text=f\"Error: {e}\", foreground=\"red\")\n\n\n    def export_social_view(self):\n        \"\"\"Convert a saved 3D HTML file to a social media portrait view.\n\n        Opens a file picker for the user to select an HTML file previously\n        saved from any 3D stellar visualization. Extracts the Plotly figure\n        data using json_converter's bracket-matching extraction, rebuilds\n        a Plotly figure object, then passes it through social_media_export\n        to produce a 9:16 portrait HTML optimized for Instagram/YouTube.\n        \"\"\"\n        try:\n            from tkinter import filedialog as fd\n\n            # Pre-seed to last save directory if available\n            try:\n                from save_utils import _get_initial_directory\n                initial_dir = _get_initial_directory()\n            except ImportError:\n                initial_dir = os.path.expanduser('~')\n\n            if not os.path.isdir(initial_dir):\n                initial_dir = os.getcwd()\n\n            html_path = fd.askopenfilename(\n                parent=self,\n                title=\"Select 3D Visualization HTML\",\n                initialdir=initial_dir,\n                filetypes=[(\"HTML files\", \"*.html\"), (\"All files\", \"*.*\")]\n            )\n\n            if not html_path:\n                return  # User cancelled\n\n            self.status_label.config(\n                text=\"Extracting figure from HTML...\",\n                foreground=\"blue\"\n            )\n            self.update()\n\n            # Extract figure data from the HTML file\n            from json_converter import extract_plotly_json_from_html\n            fig_dict = extract_plotly_json_from_html(html_path)\n\n            if fig_dict is None:\n                self.status_label.config(\n                    text=\"Could not extract figure data from HTML\",\n                    foreground=\"red\"\n                )\n                messagebox.showerror(\n                    \"Extraction Failed\",\n                    \"Could not find Plotly figure data in the selected file.\\n\\n\"\n                    \"Make sure you selected an HTML file saved from a 3D \"\n                    \"stellar visualization.\",\n                    parent=self\n                )\n                return\n\n            # Rebuild as a Plotly figure object\n            import plotly.graph_objects as go\n            fig = go.Figure(fig_dict)\n\n            print(f\"[SOCIAL VIEW] Extracted figure with \"\n                  f\"{len(fig.data)} traces from {os.path.basename(html_path)}\")\n\n            # Generate output path next to the source file\n            base_name = os.path.splitext(os.path.basename(html_path))[0]\n            output_path = os.path.join(\n                os.path.dirname(html_path),\n                f\"{base_name}_social.html\"\n            )\n\n            self.status_label.config(\n                text=\"Generating social media view...\",\n                foreground=\"blue\"\n            )\n            self.update()\n\n            # Run the social media export\n            from social_media_export import export_social_html\n            export_social_html(\n                fig,\n                output_path=output_path,\n                open_browser=True,\n                plotly_js='cdn'\n            )\n\n            self.status_label.config(\n                text=f\"Social view saved: {os.path.basename(output_path)}\",\n                foreground=\"green\"\n            )\n            print(f\"[SOCIAL VIEW] Exported to {output_path}\")\n\n        except Exception as e:\n            self.status_label.config(\n                text=f\"Social view error: {e}\",\n                foreground=\"red\"\n            )\n            print(f\"[SOCIAL VIEW] Error: {e}\")\n            import traceback\n            traceback.print_exc()\n\n\n    def load_and_display_plot_report(self):\n        \"\"\"Load the plot data from the exchange file and update the report.\"\"\"\n        try:\n\n            # Try to load the scientific report first\n            report_mgr = ReportManager()\n            report_data = report_mgr.load_last_report()\n            \n            if report_data:\n                print(\"Loading scientific report with object type analysis...\")\n                self.plot_report.display_report(report_data)\n                return\n\n            plot_data = PlotDataExchange.load_plot_data()\n            \n            if plot_data:\n                # Convert the loaded data to format expected by the report widget\n                import pandas as pd\n                \n                # Get data values with defaults\n                temp_valid = plot_data.get('temp_valid', 0)\n                temp_missing = plot_data.get('temp_missing', 0)\n                lum_valid = plot_data.get('lum_valid', 0)\n                lum_missing = plot_data.get('lum_missing', 0)\n                total_stars = plot_data.get('total_stars', 0)\n                \n                # Create pseudo DataFrame ensuring consistent length\n                if total_stars > 0:\n                    # Create arrays\n                    temp_array = [1] * temp_valid + [0] * temp_missing\n                    lum_array = [1] * lum_valid + [0] * lum_missing\n                    \n                    # Ensure arrays match total_stars length\n                    temp_array = (temp_array + [0] * total_stars)[:total_stars]\n                    lum_array = (lum_array + [0] * total_stars)[:total_stars]\n                    \n                    pseudo_df = pd.DataFrame({\n                        'Temperature': temp_array,\n                        'Luminosity': lum_array\n                    })\n                else:\n                    # Empty DataFrame if no stars\n                    pseudo_df = pd.DataFrame({\n                        'Temperature': [],\n                        'Luminosity': []\n                    })\n                \n                # Add catalog information if available\n                if plot_data.get('catalog_counts') and len(pseudo_df) > 0:\n                    catalogs = []\n                    for catalog, count in plot_data['catalog_counts'].items():\n                        catalogs.extend([catalog] * min(count, total_stars - len(catalogs)))\n                        if len(catalogs) >= total_stars:\n                            break\n                            \n                    # Pad or trim catalog list\n                    if len(catalogs) < len(pseudo_df):\n                        catalogs.extend(['Unknown'] * (len(pseudo_df) - len(catalogs)))\n                    elif len(catalogs) > len(pseudo_df):\n                        catalogs = catalogs[:len(pseudo_df)]\n                        \n                    pseudo_df['Source_Catalog'] = catalogs\n                \n                # Add magnitude stats if available\n                if plot_data.get('magnitude_stats') and len(pseudo_df) > 0:\n                    mag_stats = plot_data['magnitude_stats']\n                    mag_mean = mag_stats.get('mean', 0) if mag_stats else 0\n                    pseudo_df['Apparent_Magnitude'] = [mag_mean] * len(pseudo_df)\n                \n                # Update the report widget\n                self.plot_report.update_report(\n                    combined_df=pseudo_df,\n                    counts_dict=plot_data.get('counts_dict', {}),\n                    processing_times=plot_data.get('processing_times', {}),\n                    mode=plot_data.get('mode', 'unknown'),\n                    limit_value=plot_data.get('limit_value')\n                )\n                \n                print(\"Plot report updated successfully\")\n                \n            else:\n                self.status_label.config(text=\"Could not load plot data\", foreground=\"orange\")\n                print(\"No plot data to load\")\n                \n        except Exception as e:\n            print(f\"Error in load_and_display_plot_report: {e}\")\n            import traceback\n            traceback.print_exc()\n            self.status_label.config(text=\"Error loading plot data\", foreground=\"red\")",
    "start_line": 789,
    "end_line": 1671,
    "has_docstring": true,
    "docstring": "Main GUI window with search and visualization controls.",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "tk.Tk"
    ],
    "class_name": null,
    "display_name": "class StarVisualizationGUI",
    "component_id": "star_visualization_gui.StarVisualizationGUI"
  },
  "stellar_data_patches.apply_temperature_patches": {
    "id": "stellar_data_patches.apply_temperature_patches",
    "name": "apply_temperature_patches",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\stellar_data_patches.py",
    "relative_path": "stellar_data_patches.py",
    "depends_on": [],
    "source_code": "def apply_temperature_patches(data):\n    \"\"\"Apply known fixes for stars with missing or incorrect data.\"\"\"\n    patch_count = 0\n    \n    for hip_id, (temp, lum, spec_type, notes) in STELLAR_PATCHES.items():\n        # Find stars with this HIP ID\n        mask = (data['HIP'] == hip_id)\n        \n        if mask.any():\n            # Check what needs patching\n            needs_temp = pd.isna(data.loc[mask, 'Temperature'].iloc[0]) or data.loc[mask, 'Temperature'].iloc[0] <= 0\n            needs_lum = pd.isna(data.loc[mask, 'Luminosity'].iloc[0]) or data.loc[mask, 'Luminosity'].iloc[0] <= 0\n            \n            if needs_temp:\n                data.loc[mask, 'Temperature'] = temp\n                data.loc[mask, 'Temperature_Method'] = 'patched'\n                print(f\"  Patched temperature for HIP {hip_id}: {temp}K\")\n            \n            if needs_lum:\n                data.loc[mask, 'Luminosity'] = lum\n                print(f\"  Patched luminosity for HIP {hip_id}: {lum} L[SUN]\")\n            \n            # Also patch spectral type if missing\n            if 'Spectral_Type' in data.columns and pd.isna(data.loc[mask, 'Spectral_Type'].iloc[0]):\n                data.loc[mask, 'Spectral_Type'] = spec_type\n            \n            if needs_temp or needs_lum:\n                patch_count += 1\n                print(f\"  Patched HIP {hip_id} ({notes})\")\n    \n    if patch_count > 0:\n        print(f\"Applied patches to {patch_count} stars\")\n    \n    return data",
    "start_line": 11,
    "end_line": 44,
    "has_docstring": true,
    "docstring": "Apply known fixes for stars with missing or incorrect data.",
    "parameters": [
      "data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function apply_temperature_patches",
    "component_id": "stellar_data_patches.apply_temperature_patches"
  },
  "stellar_parameters.estimate_temperature_from_spectral_type": {
    "id": "stellar_parameters.estimate_temperature_from_spectral_type",
    "name": "estimate_temperature_from_spectral_type",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\stellar_parameters.py",
    "relative_path": "stellar_parameters.py",
    "depends_on": [],
    "source_code": "def estimate_temperature_from_spectral_type(sp_type):\n    \"\"\"\n    Estimate effective temperature from spectral type.\n\n    Parameters:\n        sp_type (str): Spectral type string.\n\n    Returns:\n        float: Estimated effective temperature in Kelvin, or np.nan if unavailable.\n    \"\"\"\n    if sp_type is None or not isinstance(sp_type, str):\n        return np.nan\n        \n    sp_type = sp_type.strip().upper()\n    \n    # Extract spectral class and subclass\n    match = re.match(r'^([OBAFGKMLT])(?:\\s*)(\\d+(\\.\\d+)?|[A-Za-z\\-]+)?', sp_type)\n    if match:\n        spectral_class = match.group(1)\n        subclass_str = match.group(2)\n        \n        temps = spectral_subclass_temps.get(spectral_class)\n        if temps:\n            temp_start = temps.get(0)\n            temp_end = temps.get(9)\n            \n            if temp_start is None or temp_end is None:\n                return np.nan\n                \n            if subclass_str:\n                try:\n                    subclass = float(subclass_str)\n                    # Linear interpolation\n                    T_eff = temp_start - (temp_start - temp_end) * (subclass / 9.0)\n                    return T_eff\n                except ValueError:\n                    # For non-numeric subclasses, use weighted average favoring the cooler temperature\n                    return (temp_start + 2 * temp_end) / 3\n            else:\n                # No subclass, use weighted average\n                return (temp_start + 2 * temp_end) / 3\n    return np.nan",
    "start_line": 7,
    "end_line": 48,
    "has_docstring": true,
    "docstring": "Estimate effective temperature from spectral type.\n\nParameters:\n    sp_type (str): Spectral type string.\n\nReturns:\n    float: Estimated effective temperature in Kelvin, or np.nan if unavailable.",
    "parameters": [
      "sp_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function estimate_temperature_from_spectral_type",
    "component_id": "stellar_parameters.estimate_temperature_from_spectral_type"
  },
  "stellar_parameters.calculate_bv_temperature": {
    "id": "stellar_parameters.calculate_bv_temperature",
    "name": "calculate_bv_temperature",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\stellar_parameters.py",
    "relative_path": "stellar_parameters.py",
    "depends_on": [],
    "source_code": "def calculate_bv_temperature(B_V):\n    \"\"\"\n    Calculate temperature from B-V color index using Ballesteros' formula.\n\n    Parameters:\n        B_V (float): B-V color index.\n\n    Returns:\n        float: Estimated effective temperature in Kelvin, or np.nan if unavailable.\n    \"\"\"\n    if np.isnan(B_V):\n        return np.nan\n        \n    try:\n        T_eff = 4600 * ((1 / (0.92 * B_V + 1.7)) + (1 / (0.92 * B_V + 0.62)))\n        \n        # Validity range for B-V method\n        if T_eff < 1300 or T_eff > 50000:\n            return np.nan\n            \n        return T_eff\n    except:\n        return np.nan",
    "start_line": 50,
    "end_line": 72,
    "has_docstring": true,
    "docstring": "Calculate temperature from B-V color index using Ballesteros' formula.\n\nParameters:\n    B_V (float): B-V color index.\n\nReturns:\n    float: Estimated effective temperature in Kelvin, or np.nan if unavailable.",
    "parameters": [
      "B_V"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_bv_temperature",
    "component_id": "stellar_parameters.calculate_bv_temperature"
  },
  "stellar_parameters.select_best_temperature": {
    "id": "stellar_parameters.select_best_temperature",
    "name": "select_best_temperature",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\stellar_parameters.py",
    "relative_path": "stellar_parameters.py",
    "depends_on": [],
    "source_code": "def select_best_temperature(T_eff_BV, T_eff_sptype):\n    \"\"\"\n    Select the best temperature estimate based on various criteria.\n\n    Parameters:\n        T_eff_BV (float): Temperature estimated from B-V color index.\n        T_eff_sptype (float): Temperature estimated from spectral type.\n\n    Returns:\n        tuple: (Selected temperature, source of temperature)\n            - float: Selected temperature in Kelvin.\n            - str: Source of temperature ('bv_matched', 'bv_only', 'spectral_type_only', etc.)\n    \"\"\"\n    if np.isnan(T_eff_BV) and np.isnan(T_eff_sptype):\n        return np.nan, 'none'\n        \n    # For very hot stars (O and early B types), prefer spectral type\n    if not np.isnan(T_eff_sptype) and T_eff_sptype > 25000:\n        return T_eff_sptype, 'spectral_type_hot'\n        \n    # For very cool stars (late M and L types), prefer spectral type\n    if not np.isnan(T_eff_sptype) and T_eff_sptype < 2400:\n        return T_eff_sptype, 'spectral_type_cool'\n        \n    # If we only have one method, use it\n    if np.isnan(T_eff_BV):\n        return T_eff_sptype, 'spectral_type_only'\n    if np.isnan(T_eff_sptype):\n        return T_eff_BV, 'bv_only'\n        \n    # For intermediate temperatures, compare both methods\n    temp_diff_pct = abs(T_eff_BV - T_eff_sptype) / T_eff_sptype\n    if temp_diff_pct <= 0.2:  # Within 20%\n        return T_eff_BV, 'bv_matched'  # Prefer B-V when methods agree\n    else:\n        # When methods disagree significantly, prefer spectral type\n        return T_eff_sptype, 'spectral_type_disagreement'",
    "start_line": 74,
    "end_line": 110,
    "has_docstring": true,
    "docstring": "Select the best temperature estimate based on various criteria.\n\nParameters:\n    T_eff_BV (float): Temperature estimated from B-V color index.\n    T_eff_sptype (float): Temperature estimated from spectral type.\n\nReturns:\n    tuple: (Selected temperature, source of temperature)\n        - float: Selected temperature in Kelvin.\n        - str: Source of temperature ('bv_matched', 'bv_only', 'spectral_type_only', etc.)",
    "parameters": [
      "T_eff_BV",
      "T_eff_sptype"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function select_best_temperature",
    "component_id": "stellar_parameters.select_best_temperature"
  },
  "stellar_parameters.debug_orionis_stars": {
    "id": "stellar_parameters.debug_orionis_stars",
    "name": "debug_orionis_stars",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\stellar_parameters.py",
    "relative_path": "stellar_parameters.py",
    "depends_on": [
      "stellar_parameters.estimate_temperature_from_spectral_type",
      "stellar_parameters.calculate_bv_temperature",
      "stellar_parameters.select_best_temperature"
    ],
    "source_code": "def debug_orionis_stars(data, stage=\"\"):\n    \"\"\"Debug function to compare Epsilon and Zeta Orionis data through processing stages.\"\"\"\n    # Import the calculation functions at the start\n    from stellar_parameters import calculate_bv_temperature, estimate_temperature_from_spectral_type, select_best_temperature\n    import re\n\n    # HIP IDs: Epsilon = 26311, Zeta = 26727\n    eps_ori = data[data['HIP'] == 26311]\n    zet_ori = data[data['HIP'] == 26727]\n    \n    print(f\"\\nOrionis stars comparison at {stage}:\")\n    print(\"=\" * 50)\n    \n    columns = ['HIP', 'Vmag', 'B_mag', 'V_mag', 'Spectral_Type', 'B_V']\n    \n    print(f\"{'Parameter':<15} {'Epsilon Ori':<20} {'Zeta Ori':<20}\")\n    print(\"-\" * 55)\n    \n    for col in columns:\n        eps_val = eps_ori[col][0] if len(eps_ori) > 0 and col in eps_ori.colnames else \"Not in dataset\"\n        zet_val = zet_ori[col][0] if len(zet_ori) > 0 and col in zet_ori.colnames else \"Not in dataset\"\n        print(f\"{col:<15} {str(eps_val):<20} {str(zet_val):<20}\")\n    \n    if len(eps_ori) > 0 and len(zet_ori) > 0:\n        print(\"\\nDetailed temperature selection process:\")\n        for star_data, name in [(eps_ori, \"Epsilon Ori\"), (zet_ori, \"Zeta Ori\")]:\n            print(f\"\\n{name}:\")\n            sp_type = star_data['Spectral_Type'][0]\n            \n            # Try B-V temperature first\n            if 'B_V' in star_data.colnames:\n                bv = star_data['B_V'][0]\n            else:\n                # Calculate B-V from magnitudes\n                b_mag = star_data['B_mag'][0]\n                v_mag = star_data['V_mag'][0]\n                bv = b_mag - v_mag\n            print(f\"Calculated B-V: {bv}\")\n            try:\n                T_eff_BV = calculate_bv_temperature(bv)\n                print(f\"B-V temperature result: {T_eff_BV}\")\n            except Exception as e:\n                print(f\"B-V temperature calculation error: {str(e)}\")\n                T_eff_BV = np.nan\n            \n            # Try spectral type temperature\n            try:\n                T_eff_sptype = estimate_temperature_from_spectral_type(sp_type)\n                print(f\"Spectral type: {sp_type}\")\n                print(f\"Spectral type temperature result: {T_eff_sptype}\")\n            except Exception as e:\n                print(f\"Spectral type calculation error: {str(e)}\")\n                T_eff_sptype = np.nan\n            \n            # Show final selection\n            try:\n                T_eff, source = select_best_temperature(T_eff_BV, T_eff_sptype)\n                print(f\"Final selected temperature: {T_eff} (source: {source})\")\n            except Exception as e:\n                print(f\"Temperature selection error: {str(e)}\")\n\n    # Show final temperature and luminosity if present\n    if 'Temperature' in data.colnames or 'Luminosity' in data.colnames:\n        print(\"\\nFinal calculated values:\")\n        for param in ['Temperature', 'Luminosity']:\n            if param in data.colnames:\n                eps_val = eps_ori[param][0] if len(eps_ori) > 0 else \"Not calculated\"\n                zet_val = zet_ori[param][0] if len(zet_ori) > 0 else \"Not calculated\"\n                print(f\"{param:<15} {str(eps_val):<20} {str(zet_val):<20}\")\n    \n    # Additional parameters if present\n    for param in ['Temperature', 'Luminosity']:\n        if param in data.colnames:\n            eps_val = eps_ori[param][0] if len(eps_ori) > 0 else \"Not calculated\"\n            zet_val = zet_ori[param][0] if len(zet_ori) > 0 else \"Not calculated\"\n            print(f\"{param:<15} {str(eps_val):<20} {str(zet_val):<20}\")\n    \n    # Check specific conditions for temperature calculation\n    if 'B_V' in data.colnames and 'Spectral_Type' in data.colnames:\n        print(\"\\nTemperature calculation parameters:\")\n        for star_data, name in [(eps_ori, \"Epsilon Ori\"), (zet_ori, \"Zeta Ori\")]:\n            if len(star_data) > 0:\n                bv = star_data['B_V'][0]\n                sp_type = star_data['Spectral_Type'][0]\n                print(f\"\\n{name}:\")\n                print(f\"B-V value: {bv} ({'Valid' if not np.isnan(bv) else 'Invalid'})\")\n                print(f\"Spectral Type: {sp_type} ({'Valid' if sp_type else 'Invalid'})\")\n                \n                # Test temperature estimation methods\n                if not np.isnan(bv):\n                    from stellar_parameters import calculate_bv_temperature\n                    print(f\"B-V temperature: {calculate_bv_temperature(bv)}\")\n                if sp_type:\n                    from stellar_parameters import estimate_temperature_from_spectral_type\n                    print(f\"Spectral type temperature: {estimate_temperature_from_spectral_type(sp_type)}\")",
    "start_line": 112,
    "end_line": 206,
    "has_docstring": true,
    "docstring": "Debug function to compare Epsilon and Zeta Orionis data through processing stages.",
    "parameters": [
      "data",
      "stage"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function debug_orionis_stars",
    "component_id": "stellar_parameters.debug_orionis_stars"
  },
  "stellar_parameters.calculate_stellar_parameters": {
    "id": "stellar_parameters.calculate_stellar_parameters",
    "name": "calculate_stellar_parameters",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\stellar_parameters.py",
    "relative_path": "stellar_parameters.py",
    "depends_on": [
      "stellar_parameters.debug_orionis_stars",
      "stellar_parameters.estimate_temperature_from_spectral_type",
      "stellar_parameters.calculate_bv_temperature",
      "stellar_parameters.select_best_temperature"
    ],
    "source_code": "def calculate_stellar_parameters(combined_data):\n    \"\"\"Calculate stellar parameters with parallel debugging of both Orionis stars.\n     Includes special handling for bright stars with missing luminosity.\n    \n    Parameters:\n        combined_data (astropy Table): Table containing combined star data.\n\n    Returns:\n        combined_data (astropy Table): Updated table with new parameters added.\n        source_counts (dict): Counts of temperature determination sources.\n        estimation_results (dict): Counts of missing and estimated parameters.\n        \"\"\"\n    \n    print(\"\\nStarting stellar parameter calculations...\")\n    debug_orionis_stars(combined_data, \"start of parameter calculation\")\n    \n    # After calculating B-V\n    debug_orionis_stars(combined_data, \"after B-V calculation\")\n    \n    # After temperature calculation\n    debug_orionis_stars(combined_data, \"after temperature calculation\")\n    \n    # After luminosity calculation\n    debug_orionis_stars(combined_data, \"after luminosity calculation\")\n\n    M_sun = 4.83  # Absolute magnitude of the Sun\n\n    # Absolute magnitude estimates by spectral type and luminosity class\n    abs_mag_estimates = {\n        'I': {  # Supergiants\n            'O': -6.4, 'B': -6.0, 'A': -5.8,\n            'F': -5.6, 'G': -5.1, 'K': -4.6, 'M': -4.1\n        },\n        'II': {  # Bright Giants\n            'O': -5.5, 'B': -4.8, 'A': -4.3,\n            'F': -3.9, 'G': -3.5, 'K': -3.1, 'M': -2.6\n        },\n        'III': {  # Giants\n            'O': -4.5, 'B': -3.5, 'A': -2.8,\n            'F': -2.4, 'G': -2.1, 'K': -1.6, 'M': -1.2\n        }\n    }\n\n    distance_pc = combined_data['Distance_pc']\n    V_mag = combined_data['Apparent_Magnitude']\n    B_mag = combined_data['B_mag']\n    spectral_types = combined_data['Spectral_Type']\n\n    # Initialize arrays for calculated values\n    M_V_list = []\n    luminosity_list = []\n    B_V_list = []\n    temperature_list = []\n    temperature_sources = []\n    luminosity_estimated = []  # Track which luminosities are estimated\n\n    # Initialize counts for estimation results\n    initial_missing_temp = 0\n    recovered_temp = 0\n    final_missing_temp = 0\n    initial_missing_lum = 0\n    recovered_lum = 0\n    final_missing_lum = 0\n    bright_star_estimates = 0\n\n    print(\"Processing stellar parameters for each star...\")\n\n    for i in range(len(combined_data)):\n        # Initialize values\n        M_V = np.nan\n        L_Lsun = np.nan\n        B_V = np.nan\n        is_estimated = False\n\n        dist_pc = distance_pc[i]\n        Vmag = V_mag[i]\n        Bmag = B_mag[i]\n        sp_type = spectral_types[i]\n\n        # Calculate Absolute Magnitude and Luminosity\n        if not np.isnan(Vmag) and dist_pc > 0:\n            M_V = Vmag - 5 * (np.log10(dist_pc) - 1)\n            if not np.isnan(M_V):\n                L_Lsun = 10 ** ((M_sun - M_V) / 2.5)\n        else:\n            initial_missing_lum += 1\n\n        # If luminosity is missing and star is bright (Vmag <= 2.5), attempt estimation\n        if np.isnan(L_Lsun) and Vmag is not None and Vmag <= 2.5 and sp_type is not None:\n            try:\n                sp_type = str(sp_type).strip().upper()\n                spectral_class = sp_type[0] if sp_type[0] in 'OBAFGKM' else None\n                \n                # Extract luminosity class\n                lum_class = None\n                for cls in ['I', 'II', 'III']:\n                    if cls in sp_type:\n                        lum_class = cls\n                        break\n\n                if spectral_class and lum_class and lum_class in abs_mag_estimates:\n                    estimated_M_V = abs_mag_estimates[lum_class][spectral_class]\n                    L_Lsun = 10 ** ((M_sun - estimated_M_V) / 2.5)\n                    is_estimated = True\n                    bright_star_estimates += 1\n\n                    if is_estimated:\n                        print(f\"\\nLuminosity estimated for star:\")\n                        print(f\"  Name: {combined_data['Star_Name'][i]}\")\n                        print(f\"  Source Catalog: {combined_data['Source_Catalog'][i]}\")\n                        print(f\"  Vmag: {Vmag:.3f}\")\n                        print(f\"  Spectral Type: {sp_type}\")\n                        print(f\"  Estimated Luminosity: {L_Lsun:.2f} Lsun\")\n                        print(f\"  Temperature: {T_eff:.0f} K\")\n                        print(f\"  Distance: {combined_data['Distance_pc'][i]:.1f} pc ({combined_data['Distance_ly'][i]:.1f} ly)\")\n                        if 'P' in str(sp_type).upper() or 'VAR' in str(sp_type).upper():\n                            print(\"  Note: Star is peculiar/variable\")\n\n                    # Special handling for peculiar stars\n                    if 'P' in sp_type.upper() or 'VAR' in sp_type.upper():\n                        combined_data.meta['peculiar_star_note'] = combined_data.meta.get('peculiar_star_note', '') + \\\n                            f\"\\nNote: {combined_data['Star_Name'][i]} has peculiar or variable characteristics; \" \\\n                            f\"luminosity estimate may have higher uncertainty.\"\n            except Exception as e:\n                print(f\"Error estimating luminosity for bright star {combined_data['Star_Name'][i]}: {e}\")\n\n        # Calculate B-V Color Index\n        if not np.isnan(Vmag) and not np.isnan(Bmag):\n            B_V = Bmag - Vmag\n\n        # Store B-V for temperature calculation\n        B_V_list.append(B_V)\n\n        # Calculate temperatures using both methods\n        T_eff_BV = calculate_bv_temperature(B_V)\n        T_eff_sptype = estimate_temperature_from_spectral_type(sp_type)\n\n        # Check if initial temperatures are missing\n        if np.isnan(T_eff_BV) and np.isnan(T_eff_sptype):\n            initial_missing_temp += 1\n\n        # Select best temperature\n        T_eff, temp_source = select_best_temperature(T_eff_BV, T_eff_sptype)\n\n        # Check if temperature was recovered\n        if not np.isnan(T_eff):\n            recovered_temp += 1\n        else:\n            final_missing_temp += 1\n\n        # Append calculated values\n        M_V_list.append(M_V)\n        luminosity_list.append(L_Lsun)\n        temperature_list.append(T_eff)\n        temperature_sources.append(temp_source)\n        luminosity_estimated.append(is_estimated)\n\n    # Assign calculated values to combined_data\n    combined_data['Abs_Mag'] = M_V_list\n    combined_data['Luminosity'] = luminosity_list\n    combined_data['B_V'] = B_V_list\n    combined_data['Temperature'] = temperature_list\n    combined_data['Luminosity_Estimated'] = luminosity_estimated\n\n    # Convert Temperature column to float\n    combined_data['Temperature'] = combined_data['Temperature'].astype(float)\n\n    # Calculate detailed statistics\n    source_counts = {\n        'bv_matched': temperature_sources.count('bv_matched'),\n        'bv_only': temperature_sources.count('bv_only'),\n        'spectral_type_hot': temperature_sources.count('spectral_type_hot'),\n        'spectral_type_cool': temperature_sources.count('spectral_type_cool'),\n        'spectral_type_only': temperature_sources.count('spectral_type_only'),\n        'spectral_type_disagreement': temperature_sources.count('spectral_type_disagreement'),\n        'none': temperature_sources.count('none')\n    }\n\n    # Calculate recovered and final missing luminosities\n    recovered_lum = len(combined_data) - initial_missing_lum + bright_star_estimates\n    final_missing_lum = np.sum(np.isnan(luminosity_list))\n\n    # Print temperature determination statistics\n    print(\"\\nTemperature Determination Statistics:\")\n    for source, count in source_counts.items():\n        print(f\"{source.replace('_', ' ').title()}: {count}\")\n\n    print(f\"\\nParameter calculation summary:\")\n    print(f\"Total stars processed: {len(combined_data)}\")\n    print(f\"Stars with valid temperatures: {recovered_temp}\")\n    print(f\"Stars with valid luminosities: {len(combined_data) - final_missing_lum}\")\n    print(f\"Stars with estimated luminosities: {bright_star_estimates}\")\n    print(f\"Stars with valid B-V colors: {np.sum(~np.isnan(combined_data['B_V']))}\")\n\n    estimation_results = {\n        'initial_missing_temp': initial_missing_temp,\n        'recovered_temp': recovered_temp,\n        'final_missing_temp': final_missing_temp,\n        'initial_missing_lum': initial_missing_lum,\n        'recovered_lum': recovered_lum,\n        'final_missing_lum': final_missing_lum,\n        'bright_star_estimates': bright_star_estimates\n    }\n\n    return combined_data, source_counts, estimation_results",
    "start_line": 208,
    "end_line": 412,
    "has_docstring": true,
    "docstring": "Calculate stellar parameters with parallel debugging of both Orionis stars.\n Includes special handling for bright stars with missing luminosity.\n\nParameters:\n    combined_data (astropy Table): Table containing combined star data.\n\nReturns:\n    combined_data (astropy Table): Updated table with new parameters added.\n    source_counts (dict): Counts of temperature determination sources.\n    estimation_results (dict): Counts of missing and estimated parameters.\n    ",
    "parameters": [
      "combined_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_stellar_parameters",
    "component_id": "stellar_parameters.calculate_stellar_parameters"
  },
  "test_orbit_cache.TestOrbitCache": {
    "id": "test_orbit_cache.TestOrbitCache",
    "name": "TestOrbitCache",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\test_orbit_cache.py",
    "relative_path": "test_orbit_cache.py",
    "depends_on": [
      "orbit_data_manager.load_orbit_paths",
      "orbit_data_manager.save_orbit_paths"
    ],
    "source_code": "class TestOrbitCache(unittest.TestCase):\n    \"\"\"Test suite for orbit data caching functionality\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test environment before each test\"\"\"\n        # Create a test directory in the current project directory\n        self.test_dir = os.path.join(os.path.dirname(__file__), \"test_output\")\n        \n        # Create the directory if it doesn't exist\n        if not os.path.exists(self.test_dir):\n            os.makedirs(self.test_dir)\n            \n        # Clear any existing test files\n        for file in os.listdir(self.test_dir):\n            file_path = os.path.join(self.test_dir, file)\n            if os.path.isfile(file_path):\n                os.unlink(file_path)\n                \n        self.test_cache_file = os.path.join(self.test_dir, \"test_orbit_paths.json\")\n        \n        # Create sample data for testing\n        self.sample_new_format = {\n            \"Mars_Sun\": {\n                \"data_points\": {\n                    \"2025-01-01\": {\"x\": 1.5, \"y\": 0.2, \"z\": 0.1},\n                    \"2025-01-02\": {\"x\": 1.51, \"y\": 0.21, \"z\": 0.11},\n                    \"2025-01-03\": {\"x\": 1.52, \"y\": 0.22, \"z\": 0.12}\n                },\n                \"metadata\": {\n                    \"start_date\": \"2025-01-01\",\n                    \"end_date\": \"2025-01-03\",\n                    \"center_body\": \"Sun\",\n                    \"last_updated\": \"2025-01-01\"\n                }\n            },\n            \"Jupiter_Sun\": {\n                \"data_points\": {\n                    \"2025-01-01\": {\"x\": 5.2, \"y\": 0.3, \"z\": 0.15},\n                    \"2025-01-02\": {\"x\": 5.21, \"y\": 0.31, \"z\": 0.16}\n                },\n                \"metadata\": {\n                    \"start_date\": \"2025-01-01\",\n                    \"end_date\": \"2025-01-02\",\n                    \"center_body\": \"Sun\",\n                    \"last_updated\": \"2025-01-01\"\n                }\n            }\n        }\n        \n        self.sample_old_format = {\n            \"Venus_Sun\": {\n                \"x\": [0.72, 0.73, 0.74],\n                \"y\": [0.1, 0.11, 0.12],\n                \"z\": [0.05, 0.051, 0.052]\n            },\n            \"Earth_Sun\": {\n                \"x\": [1.0, 1.01, 1.02],\n                \"y\": [0.0, 0.01, 0.02],\n                \"z\": [0.0, 0.001, 0.002]\n            }\n        }\n        \n    def tearDown(self):\n        \"\"\"Clean up test environment after each test\"\"\"\n        # Don't remove the test directory - keep it for inspection\n        # Just clean up the module\n        if 'orbit_data_manager' in sys.modules:\n            del sys.modules['orbit_data_manager']\n            \n        print(f\"\\nTest files saved in: {self.test_dir}\")\n            \n    def test_save_and_load_valid_cache(self):\n        \"\"\"Test saving and loading valid cache data\"\"\"\n        # Patch BEFORE importing\n        with patch.dict('os.environ', {'ORBIT_PATHS_FILE': self.test_cache_file}):\n            # Now import with the patch active\n            import orbit_data_manager\n            \n            # Override the constant\n            orbit_data_manager.ORBIT_PATHS_FILE = self.test_cache_file\n            \n            # Save data\n            orbit_data_manager.save_orbit_paths(self.sample_new_format, self.test_cache_file)\n            \n            # Verify file exists in test directory\n            self.assertTrue(os.path.exists(self.test_cache_file))\n            \n            # Load the data\n            loaded_data = orbit_data_manager.load_orbit_paths(self.test_cache_file)\n            \n            # Verify data matches\n            self.assertEqual(loaded_data, self.sample_new_format)\n            \n    def test_load_nonexistent_file(self):\n        \"\"\"Test loading when cache file doesn't exist\"\"\"\n        with patch.dict('os.environ', {'ORBIT_PATHS_FILE': self.test_cache_file}):\n            import orbit_data_manager\n            orbit_data_manager.ORBIT_PATHS_FILE = self.test_cache_file\n            \n            # Ensure file doesn't exist\n            self.assertFalse(os.path.exists(self.test_cache_file))\n            \n            # Mock the status_display to avoid issues\n            orbit_data_manager.status_display = None\n            \n            # Load should return empty dict\n            loaded_data = orbit_data_manager.load_orbit_paths(self.test_cache_file)\n            self.assertEqual(loaded_data, {})\n            \n    def test_old_format_conversion(self):\n        \"\"\"Test automatic conversion from old to new format\"\"\"\n        with patch.dict('os.environ', {'ORBIT_PATHS_FILE': self.test_cache_file}):\n            import orbit_data_manager\n            orbit_data_manager.ORBIT_PATHS_FILE = self.test_cache_file\n            orbit_data_manager.status_display = None\n            \n            # Save old format data\n            with open(self.test_cache_file, 'w') as f:\n                json.dump(self.sample_old_format, f)\n                \n            # Load data (should trigger conversion)\n            loaded_data = orbit_data_manager.load_orbit_paths(self.test_cache_file)\n            \n            # Verify conversion happened\n            for key in self.sample_old_format:\n                self.assertIn(key, loaded_data)\n                self.assertIn(\"data_points\", loaded_data[key])\n                self.assertIn(\"metadata\", loaded_data[key])\n                \n    def test_corrupted_json_file(self):\n        \"\"\"Test handling of corrupted JSON file\"\"\"\n        with patch.dict('os.environ', {'ORBIT_PATHS_FILE': self.test_cache_file}):\n            import orbit_data_manager\n            orbit_data_manager.ORBIT_PATHS_FILE = self.test_cache_file\n            orbit_data_manager.status_display = None\n            \n            # Write invalid JSON\n            with open(self.test_cache_file, 'w') as f:\n                f.write(\"{invalid json content}\")\n                \n            # Load should handle gracefully\n            loaded_data = orbit_data_manager.load_orbit_paths(self.test_cache_file)\n            self.assertEqual(loaded_data, {})\n            \n            # Check that backup was created\n            backup_files = [f for f in os.listdir(self.test_dir) if '.corrupted' in f]\n            self.assertTrue(len(backup_files) > 0, \n                           f\"No backup files found. Files in {self.test_dir}: {os.listdir(self.test_dir)}\")\n                           \n    def test_status_display_updates(self):\n        \"\"\"Test that status display is updated during operations\"\"\"\n        with patch.dict('os.environ', {'ORBIT_PATHS_FILE': self.test_cache_file}):\n            import orbit_data_manager\n            orbit_data_manager.ORBIT_PATHS_FILE = self.test_cache_file\n            \n            # Track all print statements as a proxy for status updates\n            print_messages = []\n            \n            # Mock the print function to capture messages\n            with patch('builtins.print') as mock_print:\n                mock_print.side_effect = lambda *args, **kwargs: print_messages.append(' '.join(str(arg) for arg in args))\n                \n                # Create corrupted cache\n                corrupted_data = {\n                    \"Valid_Sun\": self.sample_new_format[\"Mars_Sun\"],\n                    \"Invalid_Sun\": \"corrupted\"\n                }\n                \n                with open(self.test_cache_file, 'w') as f:\n                    json.dump(corrupted_data, f)\n                    \n                # Load with repair - this should trigger status updates\n                orbit_data_manager.load_orbit_paths(self.test_cache_file)\n                \n                # Verify that status messages were printed\n                # We should see messages about cache repair\n                status_messages = [msg for msg in print_messages if 'CACHE REPAIR' in msg or 'Cache repaired' in msg]\n                self.assertTrue(len(status_messages) > 0, \n                              f\"No status messages found. All messages: {print_messages}\")\n            \n    def test_partially_corrupted_entries(self):\n        \"\"\"Test detection and removal of corrupted entries\"\"\"\n        with patch.dict('os.environ', {'ORBIT_PATHS_FILE': self.test_cache_file}):\n            import orbit_data_manager\n            orbit_data_manager.ORBIT_PATHS_FILE = self.test_cache_file\n            orbit_data_manager.status_display = None\n            \n            # Create mixed valid/invalid data\n            corrupted_data = {\n                \"Mars_Sun\": self.sample_new_format[\"Mars_Sun\"],  # Valid\n                \"Venus_Sun\": None,  # Invalid\n                \"Earth_Sun\": \"invalid string\",  # Invalid\n                \"Neptune_Sun\": {  # Valid old format\n                    \"x\": [30.0, 30.1],\n                    \"y\": [0.1, 0.11],\n                    \"z\": [0.01, 0.011]\n                }\n            }\n            \n            with open(self.test_cache_file, 'w') as f:\n                json.dump(corrupted_data, f)\n                \n            # Load with repair\n            loaded_data = orbit_data_manager.load_orbit_paths(self.test_cache_file)\n            \n            # Verify only valid entries remain\n            self.assertIn(\"Mars_Sun\", loaded_data)\n            self.assertIn(\"Neptune_Sun\", loaded_data)\n            self.assertNotIn(\"Venus_Sun\", loaded_data)\n            self.assertNotIn(\"Earth_Sun\", loaded_data)",
    "start_line": 28,
    "end_line": 237,
    "has_docstring": true,
    "docstring": "Test suite for orbit data caching functionality",
    "parameters": null,
    "node_type": "class",
    "base_classes": [
      "unittest.TestCase"
    ],
    "class_name": null,
    "display_name": "class TestOrbitCache",
    "component_id": "test_orbit_cache.TestOrbitCache"
  },
  "uranus_visualization_shells.create_uranus_core_shell": {
    "id": "uranus_visualization_shells.create_uranus_core_shell",
    "name": "create_uranus_core_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\uranus_visualization_shells.py",
    "relative_path": "uranus_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_uranus_core_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Uranus's core shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.2,  # Approximately 20% of Uranus's radius\n        'color': 'rgb(255, 215, 0)',  # estimated black body color at about 4982 degC (5255 K)\n        'opacity': 1.0,\n        'name': 'Core',\n        'description': (\n            \"Uranus core: Scientists believe Uranus has a relatively small, rocky core. This core is likely composed of silicate and <br>\" \n            \"metallic iron-nickel. It's estimated to have a mass roughly equivalent to that of Earth. Temperatures near the core can <br>\" \n            \"reach incredibly high values, around 4982 degC (5255 K) degrees Celsius.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * URANUS_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=4.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Uranus: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Uranus: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 18,
    "end_line": 62,
    "has_docstring": true,
    "docstring": "Creates Uranus's core shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_uranus_core_shell",
    "component_id": "uranus_visualization_shells.create_uranus_core_shell"
  },
  "uranus_visualization_shells.create_uranus_mantle_shell": {
    "id": "uranus_visualization_shells.create_uranus_mantle_shell",
    "name": "create_uranus_mantle_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\uranus_visualization_shells.py",
    "relative_path": "uranus_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_uranus_mantle_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Uranus's matel shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.7,  # Up to about 70% of Uranus's radius\n        'color': 'rgb(255, 138, 18)',  # estimated black body color at about 2,000 K\n        'opacity': 0.9,\n        'name': 'mantle',\n        'description': (\n            \"mantle: Surrounding the rocky core is a dense fluid layer often referred to as an \\\"icy mantle.\\\" This layer makes up the <br>\" \n            \"majority (80% or more) of the planet's mass. It's not ice in the traditional sense but rather a hot, dense fluid <br>\" \n            \"containing water, ammonia, and methane under immense pressure. These are sometimes referred to as \\\"ices\\\" by planetary <br>\" \n            \"scientists. This mantle is electrically conductive and is thought to be the region where Uranus' unusual magnetic field <br>\" \n            \"is generated.<br>\" \n            \"* It's estimated to extend out to roughly 60-70% of Uranus' total radius.<br>\" \n            \"* The temperature of Uranus' mantle is thought to range from around 2,000 K at its outer edge to about 5,000 K near <br>\" \n            \"the core.<br>\" \n            \"* The theoretical black body color of Uranus' mantle would transition from a deep orange-red in the outer regions to <br>\" \n            \"a pale yellow-white in the deeper regions near the core, if we could somehow observe its thermal radiation directly.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * URANUS_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.5,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Uranus: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Uranus: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 73,
    "end_line": 124,
    "has_docstring": true,
    "docstring": "Creates Uranus's matel shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_uranus_mantle_shell",
    "component_id": "uranus_visualization_shells.create_uranus_mantle_shell"
  },
  "uranus_visualization_shells.create_uranus_cloud_layer_shell": {
    "id": "uranus_visualization_shells.create_uranus_cloud_layer_shell",
    "name": "create_uranus_cloud_layer_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\uranus_visualization_shells.py",
    "relative_path": "uranus_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_uranus_cloud_layer_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Uranus's cloud layer shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.0,  # the top of the troposphere is actually 1.002\n        'color': 'rgb(173, 216, 230)',  # optical\n        'opacity': 1.0,\n        'name': 'Cloud Layer',\n        'description': (\n            \"Uranus Cloud Layer<br>\" \n            \"(Note: toggle off the cloud layer in the legend to better see the interior structure.)<br><br>\"\n            \"Troposphere: This is the lowest and densest part of the atmosphere, extending from where the pressure is about 100 bar <br>\" \n            \"(deep inside) up to an altitude of roughly 50 kilometers, where the pressure is around 0.1 bar. In the troposphere, the <br>\" \n            \"temperature generally decreases with altitude, ranging from around 320 K at the base to a frigid 53 K at the top. This <br>\" \n            \"region is where most of Uranus' cloud activity occurs. There are several cloud layers within the troposphere, thought to <br>\" \n            \"be composed of water ice (deepest), ammonium hydrosulfide, ammonia and hydrogen sulfide, and finally methane ice at the <br>\" \n            \"highest levels.<br>\" \n            \"* Radius Definition: The top of the troposphere, or the cloud layer, is not equivalent to the radius of Uranus. The radius of Uranus is <br>\" \n            \"  defined at a specific pressure level in its atmosphere. The quoted radius of Uranus (around 25,559 km at the equator) <br>\" \n            \"  is typically given at the 1 bar pressure level. This is an arbitrary but standard reference point in the atmosphere of <br>\" \n            \"  gas giants, roughly equivalent to Earth's sea-level atmospheric pressure. Since Uranus doesn't have a solid surface, this <br>\" \n            \"  pressure level serves as a convenient marker for the planet's \\\"size.\\\"<br>\"\n            \"* Troposphere and Cloud Layer Altitude: The troposphere of Uranus extends from deep within the atmosphere (pressures <br>\" \n            \"  around 100 bar) up to an altitude of about 50 km above the 1 bar level, where the pressure is around 0.1 bar. The <br>\" \n            \"  cloud layers exist within this troposphere. The uppermost cloud layer, composed of methane ice, is found at a pressure <br>\" \n            \"  level of about 1.2 bar. The visible cloud layer and the top of the troposphere are located within Uranus' atmosphere, <br>\" \n            \"  at altitudes significantly lower than the radius defined at the 1 bar pressure level. The radius encompasses all these <br>\" \n            \"  atmospheric layers down to that defined pressure. The radius of Uranus is like saying the \\\"surface\\\" is at a certain <br>\" \n            \"  depth in the atmosphere. The clouds are features that exist above that deeper level.<br>\" \n            \"* The top of Uranus' troposphere is defined by the tropopause, which is the temperature minimum in the atmosphere, <br>\" \n            \"  separating the troposphere from the stratosphere. This occurs at an altitude of approximately 50 kilometers above the <br>\" \n            \"  1 bar pressure level. At this altitude, the pressure is around 0.1 bar. Since the radius of Uranus is conventionally <br>\" \n            \"  defined at the 1 bar pressure level as approximately 25,559 kilometers, the equivalent radius at the top of the <br>\" \n            \"  troposphere (or cloud layer, which is within the upper troposphere) would be approximately 25,559 km + 50 km = 25,609 <br>\" \n            \"  kilometers. Therefore, the radius at the top of the troposphere is about 25,609 kilometers. To express this as a <br>\" \n            \"  fraction of Uranus' radius at the 1 bar level: Fraction = 25,609 km / 25,559 km ~ 1.002.\"\n            )\n    }\n    \n    # Calculate radius in AU\n    radius = layer_info['radius_fraction'] * URANUS_RADIUS_AU\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Create mesh with reasonable resolution for performance\n    resolution = 24  # Reduced from typical 50 for markers\n    \n    # Create a UV sphere\n    phi = np.linspace(0, 2*np.pi, resolution)\n    theta = np.linspace(-np.pi/2, np.pi/2, resolution)\n    phi, theta = np.meshgrid(phi, theta)\n    \n    x = radius * np.cos(theta) * np.cos(phi)\n    y = radius * np.cos(theta) * np.sin(phi)\n    z = radius * np.sin(theta)\n    \n    # Apply center position offset\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    # Create triangulation\n    indices = []\n    for i in range(resolution-1):\n        for j in range(resolution-1):\n            p1 = i * resolution + j\n            p2 = i * resolution + (j + 1)\n            p3 = (i + 1) * resolution + j\n            p4 = (i + 1) * resolution + (j + 1)\n            \n            indices.append([p1, p2, p4])\n            indices.append([p1, p4, p3])\n    \n    # Create main surface\n    surface_trace = go.Mesh3d(\n        x=x.flatten(), \n        y=y.flatten(), \n        z=z.flatten(),\n        i=[idx[0] for idx in indices],\n        j=[idx[1] for idx in indices],\n        k=[idx[2] for idx in indices],\n        color=layer_info['color'],\n        opacity=layer_info['opacity'],\n        name=f\"Uranus: {layer_info['name']}\",\n        showlegend=True,\n        hoverinfo='none',  # Disable hover on mesh surface\n        # Add these new parameters to make hover text invisible\n        hovertemplate=' ',  # Empty template instead of None\n        hoverlabel=dict(\n    #        bgcolor='rgba(0,0,0,0)',  # Transparent background\n            font=dict(\n                color='rgba(0,0,0,0)',  # Transparent text\n    #            size=0                  # Zero font size\n            ),\n            bordercolor='rgba(0,0,0,0)'  # Transparent border\n        ), \n        # Add these new parameters to eliminate shading\n        flatshading=True,  # Use flat shading instead of smooth\n        lighting=dict(\n            ambient=1.0,     # Set to maximum (1.0)\n            diffuse=0.0,     # Turn off diffuse lighting\n            specular=0.0,    # Turn off specular highlights\n            roughness=1.0,   # Maximum roughness\n            fresnel=0.0      # Turn off fresnel effect\n        ),\n        lightposition=dict(\n            x=0,  # Centered light\n            y=0,  # Centered light\n            z=10000  # Light from very far above to minimize shadows\n        )       \n    )\n        \n    # Use the Fibonacci sphere algorithm for more even point distribution\n    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points\n    \n    # Generate fibonacci sphere points\n    fib_points = fibonacci_sphere(samples=50)  # Originally, 50 hover points evenly distributed\n    \n    # Scale and offset the points\n    x_hover = [p[0] * radius + center_x for p in fib_points]\n    y_hover = [p[1] * radius + center_y for p in fib_points]\n    z_hover = [p[2] * radius + center_z for p in fib_points]\n        \n    # Create a list of repeated descriptions for each point\n    # This is crucial - we need exactly one text entry per point\n    hover_texts = [layer_info['description']] * len(x_hover)\n\n    # Just the name for \"Object Names Only\" mode\n    layer_name = f\"Uranus: {layer_info['name']}\"\n    minimal_hover_texts = [layer_name] * len(x_hover)\n\n    # Create hover trace with direct text assignment\n    hover_trace = go.Scatter3d(\n        x=x_hover, \n        y=y_hover, \n        z=z_hover,\n        mode='markers',\n        marker=dict(\n            size=2,  # originally 5\n            color='rgb(173, 216, 230)',  # Layer color, originally 'white'\n            opacity=1.0,  # originally 0.8\n            line=dict(  # Add a contrasting outline\n                width=1,\n                color='black'\n            )\n        ),\n        name=f\"Uranus: {layer_info['name']} (Info)\",\n        text=hover_texts,  # IMPORTANT: Matching length with coordinate arrays\n        customdata=minimal_hover_texts,  # For \"Object Names Only\" mode\n        hovertemplate='%{text}<extra></extra>',  # Use the standard hover template\n        showlegend=False  # Don't show in legend since it's just for hover\n    )\n\n    return [surface_trace, hover_trace]",
    "start_line": 137,
    "end_line": 306,
    "has_docstring": true,
    "docstring": "Creates Uranus's cloud layer shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_uranus_cloud_layer_shell",
    "component_id": "uranus_visualization_shells.create_uranus_cloud_layer_shell"
  },
  "uranus_visualization_shells.fibonacci_sphere": {
    "id": "uranus_visualization_shells.fibonacci_sphere",
    "name": "fibonacci_sphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\uranus_visualization_shells.py",
    "relative_path": "uranus_visualization_shells.py",
    "depends_on": [],
    "source_code": "    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points",
    "start_line": 251,
    "end_line": 266,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "samples"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fibonacci_sphere",
    "component_id": "uranus_visualization_shells.fibonacci_sphere"
  },
  "uranus_visualization_shells.create_uranus_upper_atmosphere_shell": {
    "id": "uranus_visualization_shells.create_uranus_upper_atmosphere_shell",
    "name": "create_uranus_upper_atmosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\uranus_visualization_shells.py",
    "relative_path": "uranus_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_uranus_upper_atmosphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Uranus's upper atmosphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.16,  \n        'color': 'rgb(240, 245, 250)',  # optical pale blue\n        'opacity': 0.5,\n        'name': 'Upper Atmosphere',\n        'description': (\n            \"Atmosphere: Uranus has a thick atmosphere primarily composed of Hydrogen (H2): Making up about 83% of the atmosphere; <br>\" \n            \"Helium (He): Constituting around 15%; Methane (CH4): Present in smaller amounts, around 2.3%. This methane absorbs red <br>\" \n            \"light, giving Uranus its characteristic blue-green hue. Trace amounts: Water (H2O) and ammonia (NH3) are also present <br>\" \n            \"in small quantities. Other hydrocarbons like ethane, acetylene, and methyl acetylene exist in trace amounts, formed by <br>\" \n            \"the breakdown of methane by sunlight. The atmosphere lacks the prominent banding seen on Jupiter and Saturn but does <br>\" \n            \"experience extremely cold temperatures, reaching as low as 49 Kelvin (-224  degC), making it the coldest planetary <br>\" \n            \"atmosphere in our solar system. The atmosphere is layered into a troposphere, stratosphere, and thermosphere.<br>\" \n            \"* The altitude of the top of Uranus' thermosphere is not as sharply defined as the tropopause. The thermosphere <br>\" \n            \"  gradually transitions into the exosphere. The stratosphere extends up to about 4,000 kilometers above the 1 bar <br>\" \n            \"  level. The thermosphere and exosphere then extend from this altitude outwards. Some sources suggest the thermosphere <br>\" \n            \"  can reach as high as two Uranus radii from the planet's center.<br>\" \n            \"* Top of Stratosphere (approximate lower bound of Thermosphere): Radius at 1 bar level: ~ 25,559 km; Altitude of <br>\" \n            \"  stratopause: ~ 4,000 km; Equivalent radius: 25,559 km + 4,000 km = 29,559 kilometers; Fraction of Uranus' radius <br>\" \n            \"  (at 1 bar): 29,559 km / 25,559 km ~ 1.157.<br>\" \n            \"* Outer Extent of Thermosphere/Exosphere (approximate upper bound): Radius at 1 bar level: ~ 25,559 km; Two Uranus radii <br>\" \n            \"  from the center: 2 * 25,559 km = 51,118 kilometers. Therefore, the equivalent radius at the top of the thermosphere <br>\" \n            \"  (or more accurately, the extended thermosphere/exosphere region) is estimated to range from approximately 1.16 to 2.0 <br>\" \n            \"  times the radius of Uranus as defined at the 1 bar pressure level. This indicates that the thermosphere of Uranus is a <br>\" \n            \"  very extended and diffuse region of its upper atmosphere.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * URANUS_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Uranus: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Uranus: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=layer_radius\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 319,
    "end_line": 386,
    "has_docstring": true,
    "docstring": "Creates Uranus's upper atmosphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_uranus_upper_atmosphere_shell",
    "component_id": "uranus_visualization_shells.create_uranus_upper_atmosphere_shell"
  },
  "uranus_visualization_shells.create_uranus_magnetosphere": {
    "id": "uranus_visualization_shells.create_uranus_magnetosphere",
    "name": "create_uranus_magnetosphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\uranus_visualization_shells.py",
    "relative_path": "uranus_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_magnetosphere_shape",
      "shared_utilities.create_sun_direction_indicator"
    ],
    "source_code": "def create_uranus_magnetosphere(center_position=(0, 0, 0)):\n    \"\"\"Creates Uranus's main magnetosphere structure.\"\"\"\n    # Parameters for magnetosphere components (in Uranus radii)\n    params = {\n        # Compressed sunward side\n        'sunward_distance': 21,  # Compressed toward the sun, ranges from 18-24 Ru\n        \n        # Equatorial extension (wider than polar)\n        'equatorial_radius': 27.5,   # ranges from 25-30 Ru\n        'polar_radius': 17.5,         # ranges from 15-20 Rs\n        \n        # Magnetotail parameters\n        'tail_length': 300,  # Length of visible magnetotail, ranges from 200-500 Ru\n        'tail_base_radius': 15,  # Radius at the base of the tail, ranges from 10-20 Ru\n        'tail_end_radius': 75,  # Radius at the end of the tail, ranges from 50-100 Ru\n    }\n    \n    # Scale everything by Uranus's radius in AU\n    for key in params:\n        params[key] *= URANUS_RADIUS_AU\n    \n    # Create magnetosphere main shape\n    x, y, z = create_magnetosphere_shape(params)\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Apply center position offset\n    x = np.array(x) + center_x\n    y = np.array(y) + center_y\n    z = np.array(z) + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.0,\n                color='rgb(200, 200, 255)', # Light blue for magnetic field\n                opacity=0.3\n            ),\n            name='Uranus: Magnetosphere',\n            text=[\"Magnetic Field (Magnetosphere): Uranus possesses a unique and peculiar magnetic field. Unlike most planets, its <br>\" \n            \"magnetic axis is tilted at a dramatic angle of nearly 60 degrees relative to its rotational axis. Furthermore, the <br>\" \n            \"magnetic field is offset from the planet's center by about one-third of Uranus' radius. This unusual orientation <br>\" \n            \"leads to a magnetosphere that is highly distorted and asymmetric. The magnetic field is generated by the convective <br>\" \n            \"motions of electrically conductive materials (likely the icy mantle) within the planet. The strength of Uranus' <br>\" \n            \"dipole magnetic field is significant, about 50 times that of Earth's, although smaller than Jupiter's. The <br>\" \n            \"magnetosphere deflects the solar wind, creating a complex boundary called the magnetopause, which extends a <br>\" \n            \"considerable distance from the planet.<br>\" \n            \"The Bow Shock points towards the Sun along the X-axis. The XY plane is the ecliptic.<br>\" \n            \"* The distance to Uranus' magnetopause (the boundary where the planet's magnetic field meets the solar wind) on the <BR>\" \n            \"  sunward side is estimated to be around 18-24 Ru.<br>\" \n            \"* The equatorial radius of Uranus' magnetosphere varies depending on solar wind conditions, but a typical estimate is <br>\" \n            \"  around 25-30 Ru.<br>\" \n            \"* The polar radius of Uranus' magnetosphere, measured from the center of the planet to the magnetopause along the <br>\" \n            \"  magnetic poles, is typically smaller than the equatorial radius due to the interaction with the solar wind and the <br>\" \n            \"  shape of the magnetic field. Estimates range, but it's likely in the order of 15-20 Ru.<br>\" \n            \"* The magnetotail is the region of the magnetosphere that extends away from the Sun, stretched by the solar wind. The <br>\" \n            \"  length of Uranus' magnetotail is highly variable and depends on the conditions of the solar wind. However, Voyager 2 <br>\" \n            \"  observations provided some insights. Estimates for the length of Uranus' magnetotail range significantly, but it's <br>\" \n            \"  often cited to extend hundreds of Uranus radii downwind. A reasonable estimate based on observations would be in the <br>\" \n            \"  order of several hundred Ru, perhaps around 200-500 Ru or even more under certain solar wind conditions.<br>\" \n            \"* The \\\"base\\\" of the magnetotail is the region connected to the planet's nightside magnetosphere. Its radius is <br>\" \n            \"  related to the size of the obstacle the planet presents to the solar wind. A typical estimate for the radius of the <br>\" \n            \"  magnetotail near the planet (the base) is on the order of the planet's radius. So, the tail base radius is estimated <br>\" \n            \"  to be around 10-20 Ru.<br>\" \n            \"* The magnetotail flares out as it extends away from the planet. The radius at the \\\"end\\\" (where it becomes less <br>\" \n            \"  well-defined and merges with the interplanetary medium) would be larger than at the base. This is even more variable <br>\" \n            \"  and less well-defined than the tail length. It could be several tens of Uranus radii. So, a rough estimate for the <br>\" \n            \"  tail end radius is ~50-100 Ru.\"] * len(x),\n            customdata=['Magnetosphere'] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=300 * URANUS_RADIUS_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 402,
    "end_line": 486,
    "has_docstring": true,
    "docstring": "Creates Uranus's main magnetosphere structure.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_uranus_magnetosphere",
    "component_id": "uranus_visualization_shells.create_uranus_magnetosphere"
  },
  "uranus_visualization_shells.create_uranus_radiation_belts": {
    "id": "uranus_visualization_shells.create_uranus_radiation_belts",
    "name": "create_uranus_radiation_belts",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\uranus_visualization_shells.py",
    "relative_path": "uranus_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.rotate_points"
    ],
    "source_code": "def create_uranus_radiation_belts(center_position=(0, 0, 0)):\n    \"\"\"Creates Uranus's radiation belts.\"\"\"\n    belt_colors = ['rgb(255, 255, 100)', 'rgb(100, 255, 150)']\n    belt_names = ['Inner Radiation Belt', 'Outer Radiation Belt']\n    belt_texts = [\n        \"Radiation Belts: Regions in its magnetosphere where charged particles (mainly electrons and protons) are trapped and <br>\" \n        \"accelerated by the magnetic field. Voyager 2 data revealed that Uranus' electron radiation belts are surprisingly intense, <br>\" \n        \"comparable to Earth's and much stronger than Saturn's. The source of these energetic particles is primarily the planet's <br>\" \n        \"upper atmosphere.<br>\" \n        \"* Voyager 2 was the first and so far only spacecraft to directly observe them during its flyby in 1986.<br>\" \n        \"* Composition: The primary charged particles in Uranus' radiation belts are electrons and protons. There is also a minor <br>\" \n        \"  component of molecular hydrogen ions.<br>\" \n        \"* Intensity: The intensity of Uranus' electron radiation belts was surprisingly found to be similar to those of Earth and <br>\" \n        \"  significantly more intense than those of Saturn. However, the proton radiation belts were observed to be much weaker than <br>\" \n        \"  expected, about 100 times lower than predicted.<br>\" \n        \"* Effects: The intense radiation in the electron belts can cause rapid darkening (within about 100,000 years) of any methane <br>\" \n        \"  trapped in the icy surfaces of Uranus' inner moons and ring particles. This is a likely contributor to the uniformly dark <br>\" \n        \"  and gray appearance of these objects. Uranus' moons can also create gaps in the radiation belts by sweeping up charged <br>\" \n        \"  particles as they orbit the planet.<br>\" \n        \"* Distances from Uranus' Center: The precise boundaries of Uranus' radiation belts are not as sharply defined as Earth's <br>\" \n        \"  Van Allen belts, and their structure is influenced by Uranus' unusual, highly tilted, and offset magnetic field. However, <br>\" \n        \"  based on Voyager 2 data and subsequent modeling, we can provide approximate ranges:<br>\" \n        \"  * Inner Radiation Belt (primarily protons): This belt is thought to be relatively weak and located closer to the planet, <br>\" \n        \"    likely within a few Uranus radii. Estimates suggest it may extend from around 1 to 3 R. However, its intensity is much <br>\" \n        \"    lower than expected.<br>\" \n        \"  * Outer Radiation Belt (primarily electrons): This belt is surprisingly intense, comparable to Earth's and much stronger <br>\" \n        \"    than Saturn's. It is believed to extend further out, roughly from 3 to 10 R. Some models suggest it might even extend <br>\" \n        \"    beyond this range, but the most intense regions are within 10 R.<br>\" \n        \"  * Asymmetry: Due to the complex magnetic field, the radiation belts are likely asymmetric and their extent can vary with <br>\" \n        \"    latitude and longitude.<br>\" \n        \"  * Dynamic: The structure and intensity of the belts can be influenced by solar wind activity.<br>\" \n        \"  * Data Limitations: Our understanding is primarily based on a single flyby from Voyager 2. Future missions are needed for <br>\" \n        \"    a more comprehensive mapping of Uranus' radiation belts.<br>\",\n\n        \"Radiation Belts: Regions in its magnetosphere where charged particles (mainly electrons and protons) are trapped and <br>\" \n        \"accelerated by the magnetic field. Voyager 2 data revealed that Uranus' electron radiation belts are surprisingly intense, <br>\" \n        \"comparable to Earth's and much stronger than Saturn's. The source of these energetic particles is primarily the planet's <br>\" \n        \"upper atmosphere.<br>\" \n        \"* Voyager 2 was the first and so far only spacecraft to directly observe them during its flyby in 1986.<br>\" \n        \"* Composition: The primary charged particles in Uranus' radiation belts are electrons and protons. There is also a minor <br>\" \n        \"  component of molecular hydrogen ions.<br>\" \n        \"* Intensity: The intensity of Uranus' electron radiation belts was surprisingly found to be similar to those of Earth and <br>\" \n        \"  significantly more intense than those of Saturn. However, the proton radiation belts were observed to be much weaker than <br>\" \n        \"  expected, about 100 times lower than predicted.<br>\" \n        \"* Effects: The intense radiation in the electron belts can cause rapid darkening (within about 100,000 years) of any methane <br>\" \n        \"  trapped in the icy surfaces of Uranus' inner moons and ring particles. This is a likely contributor to the uniformly dark <br>\" \n        \"  and gray appearance of these objects. Uranus' moons can also create gaps in the radiation belts by sweeping up charged <br>\" \n        \"  particles as they orbit the planet.<br>\" \n        \"* Distances from Uranus' Center: The precise boundaries of Uranus' radiation belts are not as sharply defined as Earth's <br>\" \n        \"  Van Allen belts, and their structure is influenced by Uranus' unusual, highly tilted, and offset magnetic field. However, <br>\" \n        \"  based on Voyager 2 data and subsequent modeling, we can provide approximate ranges:<br>\" \n        \"  * Inner Radiation Belt (primarily protons): This belt is thought to be relatively weak and located closer to the planet, <br>\" \n        \"    likely within a few Uranus radii. Estimates suggest it may extend from around 1 to 3 R. However, its intensity is much <br>\" \n        \"    lower than expected.<br>\" \n        \"  * Outer Radiation Belt (primarily electrons): This belt is surprisingly intense, comparable to Earth's and much stronger <br>\" \n        \"    than Saturn's. It is believed to extend further out, roughly from 3 to 10 R. Some models suggest it might even extend <br>\" \n        \"    beyond this range, but the most intense regions are within 10 R.<br>\" \n        \"  * Asymmetry: Due to the complex magnetic field, the radiation belts are likely asymmetric and their extent can vary with <br>\" \n        \"    latitude and longitude.<br>\" \n        \"  * Dynamic: The structure and intensity of the belts can be influenced by solar wind activity.<br>\" \n        \"  * Data Limitations: Our understanding is primarily based on a single flyby from Voyager 2. Future missions are needed for <br>\" \n        \"    a more comprehensive mapping of Uranus' radiation belts.<br>\" \n    ]\n    \n    # Belt distances in Uranus radii from the planet's center\n    belt_distances = [2, 6]\n    belt_thickness = 0.5 * URANUS_RADIUS_AU\n    \n    # Scale distances by Uranus's radius in AU\n    belt_distances = [d * URANUS_RADIUS_AU for d in belt_distances]\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n\n    # uranus tilt is 97.77 degrees, 105 was arrived at by trial and error\n    uranus_tilt = np.radians(105)\n    \n    traces = []\n    \n    for i, belt_distance in enumerate(belt_distances):\n        belt_x = []\n        belt_y = []\n        belt_z = []\n        \n        n_points = 80\n        n_rings = 5\n        \n        for i_ring in range(n_rings):\n            # Vary the radius slightly to create thickness\n            radius_offset = (i_ring / (n_rings-1) - 0.5) * belt_thickness\n            belt_radius = belt_distance + radius_offset\n            \n            for j in range(n_points):\n                angle = (j / n_points) * 2 * np.pi\n                \n                # Create a belt around Saturn's rotational axis\n                x = belt_radius * np.cos(angle)\n                y = belt_radius * np.sin(angle)\n                \n                # Add some z variation based on angle to create the shape of a belt\n                # rather than a perfect torus (thinner near poles)\n                z_scale = 0.2 * belt_radius  # Controls how flat the belts are\n                z = z_scale * np.sin(2 * angle)\n                \n                belt_x.append(x)\n                belt_y.append(y)\n                belt_z.append(z)\n        \n        # Apply center position offset\n        belt_x = np.array(belt_x) + center_x\n        belt_y = np.array(belt_y) + center_y\n        belt_z = np.array(belt_z) + center_z\n        \n        # Create the radiation belt hover text and customdata arrays\n        belt_text = [belt_texts[i]] * len(belt_x)\n        belt_customdata = [belt_names[i]] * len(belt_x)\n\n        # Apply center position offset\n        belt_x = np.array(belt_x)\n        belt_y = np.array(belt_y)\n        belt_z = np.array(belt_z)\n        \n        # Apply Saturn's axial tilt (rotate around x-axis)\n        belt_x_tilted, belt_y_tilted, belt_z_tilted = rotate_points(belt_x, belt_y, belt_z, uranus_tilt, 'x')\n            \n            \n            # First apply rotation around x-axis\n    #    x_tilted, y_tilted, z_tilted = rotate_points(x, y, z, np.radians(uranus_tilt), 'x')\n            \n            # Then apply rotation around y-axis with the same angle\n        belt_x_final, belt_y_final, belt_z_final = rotate_points(belt_x_tilted, belt_y_tilted, belt_z_tilted, uranus_tilt, 'y')        \n\n        # Apply center position offset\n    #    x = np.array(x) + center_x\n    #    y = np.array(y) + center_y\n    #    z = np.array(z) + center_z\n\n        # Apply center position offset\n    #    x_final = np.array(x_tilted) + center_x\n    #    y_final = np.array(y_tilted) + center_y\n    #    z_final = np.array(z_tilted) + center_z\n        \n        # Apply center position offset\n        belt_x_final = belt_x_tilted + center_x\n        belt_y_final = belt_y_tilted + center_y\n        belt_z_final = belt_z_tilted + center_z\n\n        traces.append(\n            go.Scatter3d(\n                x=belt_x_final,\n                y=belt_y_final,\n                z=belt_z_final,\n                mode='markers',\n                marker=dict(\n                    size=1.5,\n                    color=belt_colors[i],\n                    opacity=0.3\n                ),\n                name=belt_names[i],\n                text=belt_text,\n                customdata=belt_customdata,\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            )\n        )\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius= 6.0 * URANUS_RADIUS_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 493,
    "end_line": 666,
    "has_docstring": true,
    "docstring": "Creates Uranus's radiation belts.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_uranus_radiation_belts",
    "component_id": "uranus_visualization_shells.create_uranus_radiation_belts"
  },
  "uranus_visualization_shells.create_uranus_ring_system": {
    "id": "uranus_visualization_shells.create_uranus_ring_system",
    "name": "create_uranus_ring_system",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\uranus_visualization_shells.py",
    "relative_path": "uranus_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "saturn_visualization_shells.create_ring_points_saturn",
      "planet_visualization_utilities.rotate_points"
    ],
    "source_code": "def create_uranus_ring_system(center_position=(0, 0, 0)):\n    \"\"\"\n    Creates a visualization of Saturn's ring system.\n    \n    Parameters:\n        center_position (tuple): (x, y, z) position of Saturn's center\n        \n    Returns:\n        list: A list of plotly traces representing the ring components\n\n    Uranus Ring System Transformation:\n\n    For proper alignment with satellite orbits, Uranus's ring system requires a specific \n    compound rotation approach due to the planet's extreme axial tilt (97.77 deg).\n\n    The transformation uses these key elements:\n    1. A 105 deg rotation around the X-axis followed by a 105 deg rotation around the Y-axis\n    (empirically determined to match satellite orbit alignment)\n    2. Converting point coordinates to NumPy arrays before rotation\n    3. Applying center position offset to the final coordinates after both rotations\n\n    This approach ensures that all components of the Uranian system (rings, satellites, \n    radiation belts) share the same reference frame, correctly representing the planet's\n    unique orientation in space.\n\n    NOTE: The 105 deg value, rather than the nominal 97.77 deg axial tilt, accounts for the \n    specific reference frame conversion between Uranus's equatorial plane and the\n    ecliptic coordinate system used for visualization.\n    \n    \"\"\"\n    traces = []\n    \n    # Define Saturn's ring parameters in kilometers from Saturn's center\n    # Then convert to Saturn radii, and finally to AU\n    ring_params = {\n\n        'ring_6': {\n            'inner_radius_km': 41800,  # Inner edge (in km from Uranus's center)\n            'outer_radius_km': 41802,  # Outer edge (in km from Uranus's center)\n            'thickness_km': 2,         # Approximate thickness\n            'color': 'rgb(60, 60, 60)',  \n            'opacity': 0.4,\n            'name': 'Ring 6',\n            'description': (\n                \"Ring 6: Very narrow. Dark gray. 2 km thick. Very narrow, faint.<br>\" \n                \"* Dark, likely icy particles darkened by radiation<br>\" \n                \"* Relatively high density for its width.<br>\" \n                \"* Possibly fragments from small, disrupted moons or impacts on existing moons.<br>\" \n                \"* Narrow, relatively uniform width.\"\n            )\n        },\n\n        'ring_5': {\n            'inner_radius_km': 42200,  # Inner edge (in km from Uranus's center)\n            'outer_radius_km': 42207,  # Outer edge (in km from Uranus's center)\n            'thickness_km': 7,         # Approximate thickness, 2 to 7 km\n            'color': 'rgb(65, 65, 65)',  \n            'opacity': 0.4,\n            'name': 'Ring 5',\n            'description': (\n                \"Ring 5: Narrow. Dark gray. 2 to 7 km thick.<br>\" \n                \"* Narrow, slightly wider than Ring 6.<br>\" \n                \"* Dark, likely icy particles darkened by radiation.<br>\" \n                \"* Relatively high density for its width.<br>\" \n                \"* Possibly fragments from small, disrupted moons or impacts on existing moons.<br>\" \n                \"* Narrow, relatively uniform width.\"\n            )\n        },\n\n        'ring_4': {\n            'inner_radius_km': 42600,  # Inner edge (in km from Uranus's center)\n            'outer_radius_km': 42603,  # Outer edge (in km from Uranus's center)\n            'thickness_km': 3,         # Approximate thickness \n            'color': 'rgb(60, 60, 60)',  \n            'opacity': 0.4,\n            'name': 'Ring 4',\n            'description': (\n                \"Ring 4: Narrow. Dark gray. 3 km thick.<br>\" \n                \"* Narrow, very faint.<br>\" \n                \"* Dark, likely icy particles darkened by radiation.<br>\" \n                \"* Relatively high density for its width.<br>\" \n                \"* Possibly fragments from small, disrupted moons or impacts on existing moons.<br>\" \n                \"* Narrow, relatively uniform width.\"\n            )\n        },\n\n        'alpha_ring': {\n            'inner_radius_km': 44700,  # Inner edge (in km from Uranus's center)\n            'outer_radius_km': 44710,  # Outer edge (in km from Uranus's center)\n            'thickness_km': 10,         # Approximate thickness, 4 to 10 km\n            'color': 'rgb(70, 70, 70)',  \n            'opacity': 0.3,\n            'name': 'Alpha Ring',\n            'description': (\n                \"Alpha Ring: Relatively narrow. Dark gray. 4 to 10 km thick.<br>\" \n                \"* Relatively narrow, but wider than 4, 5, 6.<br>\" \n                \"* Shows some brightness variations.<br>\" \n                \"* Dark, likely icy particles darkened by radiation.<br>\" \n                \"* Moderate to high density for its width.<br>\" \n                \"* Possibly fragments from small, disrupted moons or impacts on existing moons, perhaps confined by shepherd moons.<br>\" \n                \"* Narrow, slight variations in width.\"\n            )\n        },\n\n        'beta_ring': {\n            'inner_radius_km': 45700,  # Inner edge (in km from Uranus's center)\n            'outer_radius_km': 45711,  # Outer edge (in km from Uranus's center)\n            'thickness_km': 11,         # Approximate thickness, 5 to 11 km\n            'color': 'rgb(75, 75, 75)',  \n            'opacity': 0.4,\n            'name': 'Beta Ring',\n            'description': (\n                \"Beta Ring: Relatively narrow, but can be brighter than Alpha. Dark gray, sometimes appears slightly lighter. <br>\" \n                \"5 to 11 km thick.<br>\" \n                \"* Relatively narrow, can be brighter than Alpha.<br>\" \n                \"* Shows some structure.<br>\" \n                \"* Dark, likely icy particles darkened by radiation.<br>\" \n                \"* Moderate to high density for its width.<br>\" \n                \"* Possibly fragments from small, disrupted moons or impacts on existing moons, perhaps confined by shepherd moons.<br>\" \n                \"* Narrow, slight variations in width.\"\n            )\n        },        \n\n        'eta_ring': {\n            'inner_radius_km': 47200,  # Inner edge (in km from Uranus's center)\n            'outer_radius_km': 47202,  # Outer edge (in km from Uranus's center)\n            'thickness_km': 2,         \n            'color': 'rgb(80, 70, 70)',  \n            'opacity': 0.2,\n            'name': 'Eta Ring',\n            'description': (\n                \"Eta Ring: Narrow, has a dusty component. Dark gray with a possible faint reddish tint due to associated dust. 2 km thick.<br>\" \n                \"* Narrow, has a faint, dusty component extending inwards and outwards.<br>\" \n                \"* Associated with the moon Mab's orbit.<br>\" \n                \"* Dark, likely icy particles mixed with fine dust.<br>\" \n                \"* Low to moderate density.<br>\" \n                \"* Likely generated by micrometeoroid impacts on small inner moons, with dustier regions.<br>\" \n                \"* Narrow core with broader, diffuse edges.\"\n            )\n        }, \n\n        'gamma_ring': {\n            'inner_radius_km': 47600,  # Inner edge (in km from Uranus's center)\n            'outer_radius_km': 47604,  # Outer edge (in km from Uranus's center)\n            'thickness_km': 4,         # 1 to 4 km\n            'color': 'rgb(70, 75, 70)',  \n            'opacity': 0.4,\n            'name': 'Gamma Ring',\n            'description': (\n                \"Gamma Ring: Narrow, can appear brighter than Eta. Dark gray, sometimes appears slightly greenish in false-color <br>\" \n                \"images used to study composition. 1 to 4 km thick.<br>\" \n                \"* Narrow, can appear brighter than Eta.<br>\" \n                \"* Shows some evidence of structure.<br>\" \n                \"* Dark, likely icy particles darkened by radiation.<br>\" \n                \"* Relatively high density for its width.<br>\" \n                \"* Possibly fragments from small, disrupted moons or impacts on existing moons, perhaps confined by shepherd moons.<br>\" \n                \"* Narrow, relatively uniform width.\"\n            )\n        },\n\n         'delta_ring': {\n            'inner_radius_km': 48300,  # Inner edge (in km from Uranus's center)\n            'outer_radius_km': 48307,  # Outer edge (in km from Uranus's center)\n            'thickness_km': 7,         # 3 to 7 km\n            'color': 'rgb(70, 70, 75)',  \n            'opacity': 0.3,\n            'name': 'Delta Ring',\n            'description': (\n                \"Delta Ring: Narrow, shows some variations in width and brightness. Dark gray, may show a subtle bluish tint in some <br>\" \n                \"enhanced images, but overall very dark. 3 to 7 km thick.<br>\" \n                \"* Narrow, shows significant variations in width and brightness along its circumference.<br>\" \n                \"* Has a faint, inner dusty component.<br>\" \n                \"* Dark, likely icy particles darkened by radiation mixed with some dust.<br>\" \n                \"* Moderate density.<br>\" \n                \"* Possibly fragments from small, disrupted moons or impacts, with confinement and dust generation mechanisms.<br>\" \n                \"* Narrow, with localized wider and fainter regions.\"\n            )\n        },    \n\n         'epsilon_ring': {\n            'inner_radius_km': 51100,  # Inner edge (in km from Uranus's center)\n            'outer_radius_km': 51190,  # Outer edge (in km from Uranus's center)\n            'thickness_km': 60,         # 20-100 km\n            'color': 'rgb(70, 70, 70)',  \n            'opacity': 0.3,\n            'name': 'Epsilon Ring',\n            'description': (\n                \"Epsilon Ring: Widest and most substantial of the main rings, density variations along it. Neutral dark gray. While <br>\" \n                \"the outer dusty Mu ring is bluish, the main Epsilon ring itself is generally considered neutral in color. 20-100 km thick.<br>\" \n                \"* Widest and most substantial of the main rings.<br>\" \n                \"* Shows significant density variations and kinks.<br>\" \n                \"* Confined by shepherd moons Cordelia and Ophelia.<br>\" \n                \"* Dark, likely icy particles darkened by radiation.<br>\" \n                \"* Variable density, generally moderate.<br>\" \n                \"* Likely fragments from a disrupted moon, with its sharp edges maintained by shepherd moons.<br>\" \n                \"* Relatively wide, with varying width and density.\"\n            )\n        },           \n\n         'nu_gossamer_ring': {\n            'inner_radius_km': 62000,  # Inner edge (in km from Uranus's center)\n            'outer_radius_km': 97700,  # Outer edge (in km from Uranus's center)\n            'thickness_km': 9500,         # 7000 to 12000 km\n            'color': 'rgb(150, 100, 100)',  \n            'opacity': 0.1,\n            'name': 'Nu Gossamer Ring',\n            'description': (\n                \"Nu Gossamer Ring: Broad, faint, and dusty outer ring. It's associated with the moon Portia. Faint reddish/dusty. <br>\" \n                \"7,000 to 12,000 km thick. These rings are much fainter and more diffuse than the main rings, composed primarily of <br>\" \n                \"fine dust particles. Their thicknesses are much greater than the main rings due to their diffuse nature. <br>\" \n                \"* The Mu ring's inner boundary (~86,000 km) is well within the Nu ring's outer boundary (~97,700 km). There is a <br>\" \n                \"  region between approximately 86,000 km and 97,700 km from Uranus' center where material from both rings can be <br>\" \n                \"  found. However, it's important to remember that these are broad, dusty rings. The density of particles within <br>\" \n                \"  them is likely quite low, and the overlap doesn't necessarily mean a dense collision zone like you might imagine <br>\" \n                \"  with solid rings. Instead, it's a region where the diffuse dust distributions of both rings coexist.<br>\" \n                \"* Faint and Diffuse: The Mu and Nu rings are indeed very faint and were discovered much later than the main rings, <br>\" \n                \"  requiring sensitive instruments like the Hubble Space Telescope and Voyager 2. Their low brightness indicates a low <br>\" \n                \"  density of particles.<br>\" \n                \"* Dust-Dominated: Observations confirm that these outer rings are primarily composed of fine dust particles. This is <br>\" \n                \"  evidenced by their colors (bluish for Mu, reddish for Nu), which are likely due to the way these small particles <br>\" \n                \"  scatter sunlight.<br>\" \n                \"* Source Moons: Both rings are strongly associated with small inner moons. Mu ring is linked to the moon Mab, which <br>\" \n                \"  orbits within it and is believed to be the primary source of its dust through micrometeoroid impacts. Nu ring is <br>\" \n                \"  associated with the moon Portia, although the exact mechanism of its dust generation is still being studied.<br>\" \n                \"* Broad Radial Extent: As the radius information shows, both the Mu and Nu rings are significantly broader than the <br>\" \n                \"  narrow main rings of Uranus.<br>\"                \n                \"* Broad, faint, and dusty outer ring extending significantly outwards.<br>\" \n                \"* Fine dust.<br>\" \n                \"* Very low density.<br>\"  \n                \"* Broad, diffuse, torus-like.\"\n            )\n        },\n\n         'Mu__goassamer_ring': {\n            'inner_radius_km': 86000,  # Inner edge (in km from Uranus's center)\n            'outer_radius_km': 102000,  # Outer edge (in km from Uranus's center)\n            'thickness_km': 16000,         # 15000 to 17000 km\n            'color': 'rgb(100, 150, 200)',  \n            'opacity': 0.1,\n            'name': 'Mu Gossamer Ring',\n            'description': (\n                \"Mu Gossamer Ring: Very broad, faint, and dusty outermost ring. It has a distinct bluish color and is associated with <br>\" \n                \"the moon Mab. Muted blue. 15,000 to 17,000 km thick. These rings are much fainter and more diffuse than the main <br>\" \n                \"rings, composed primarily of fine dust particles.<br>\"\n                \"* The Mu ring's inner boundary (~86,000 km) is well within the Nu ring's outer boundary (~97,700 km). There is a <br>\" \n                \"  region between approximately 86,000 km and 97,700 km from Uranus' center where material from both rings can be <br>\" \n                \"  found. However, it's important to remember that these are broad, dusty rings. The density of particles within <br>\" \n                \"  them is likely quite low, and the overlap doesn't necessarily mean a dense collision zone like you might imagine <br>\" \n                \"  with solid rings. Instead, it's a region where the diffuse dust distributions of both rings coexist.<br>\" \n                \"* Faint and Diffuse: The Mu and Nu rings are indeed very faint and were discovered much later than the main rings, <br>\" \n                \"  requiring sensitive instruments like the Hubble Space Telescope and Voyager 2. Their low brightness indicates a low <br>\" \n                \"  density of particles.<br>\" \n                \"* Dust-Dominated: Observations confirm that these outer rings are primarily composed of fine dust particles. This is <br>\" \n                \"  evidenced by their colors (bluish for Mu, reddish for Nu), which are likely due to the way these small particles <br>\" \n                \"  scatter sunlight.<br>\" \n                \"* Source Moons: Both rings are strongly associated with small inner moons. Mu ring is linked to the moon Mab, which <br>\" \n                \"  orbits within it and is believed to be the primary source of its dust through micrometeoroid impacts. Nu ring is <br>\" \n                \"  associated with the moon Portia, although the exact mechanism of its dust generation is still being studied.<br>\" \n                \"* Broad Radial Extent: As the radius information shows, both the Mu and Nu rings are significantly broader than the <br>\" \n                \"  narrow main rings of Uranus.<br>\"                 \n                \"* Very broad, faint, and dusty outermost ring with a distinct bluish color.<br>\" \n                \"* Strongly associated with the moon Mab, which orbits within it.<br>\" \n                \"* Fine dust (icy?)<br>\" \n                \"* Very low density.<br>\" \n                \"* Primarily generated by micrometeoroid impacts ejecting material from the surface of the small moon Mab.<br>\" \n                \"* Very broad, diffuse, torus-like, somewhat clumpy.\"                \n            )\n        },\n\n    }\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    uranus_tilt = np.radians(105)  # Convert to radians here, once; actual tilt is 97.77 but using 105 that is best fit empirically\n\n    # Create traces for each ring\n    for ring_name, ring_info in ring_params.items():\n        # Convert km to AU\n        inner_radius_au = ring_info['inner_radius_km'] / KM_PER_AU\n        outer_radius_au = ring_info['outer_radius_km'] / KM_PER_AU\n        thickness_au = ring_info['thickness_km'] / KM_PER_AU\n        \n        # Reduce point count for very large rings to improve performance\n        n_points = 100\n        if 'gossamer' in ring_name:\n            n_points = 80  # Fewer points for larger gossamer rings\n        \n        # Create ring points\n        x, y, z = create_ring_points_saturn (inner_radius_au, outer_radius_au, n_points, thickness_au)\n        \n        # Convert to numpy arrays BEFORE applying rotations\n        x = np.array(x)\n        y = np.array(y)\n        z = np.array(z)           \n            \n            # Apply the SAME compound rotation as for satellites\n            # First apply rotation around x-axis\n        x_tilted, y_tilted, z_tilted = rotate_points(x, y, z, uranus_tilt, 'x')\n            \n            # Then apply rotation around y-axis with the same angle\n        x_final, y_final, z_final = rotate_points(x_tilted, y_tilted, z_tilted, uranus_tilt, 'y')        \n\n        # Apply center position offset to the FINAL coordinates\n        x_final = x_final + center_x  # Use x_final from Y rotation\n        y_final = y_final + center_y  # Use y_final from Y rotation\n        z_final = z_final + center_z  # Use z_final from Y rotation\n        \n        # Create a text list for hover information\n        text_array = [ring_info['description'] for _ in range(len(x))]\n        \n        # Add ring trace\n        traces.append(\n            go.Scatter3d(\n    #            x=x, y=y, z=z,\n                x=x_final,\n                y=y_final,\n                z=z_final,\n                mode='markers',\n                marker=dict(\n                    size=1.5,  # Small markers for rings\n                    color=ring_info['color'],\n                    opacity=ring_info['opacity']\n                ),\n                name=f\"Uranus: {ring_info['name']}\",\n                text=text_array,\n                customdata=[f\"Uranus: {ring_info['name']}\"] * len(x),\n                hovertemplate='%{text}<extra></extra>',\n                showlegend=True\n            )\n        )\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=102000 / KM_PER_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 699,
    "end_line": 1038,
    "has_docstring": true,
    "docstring": "Creates a visualization of Saturn's ring system.\n\nParameters:\n    center_position (tuple): (x, y, z) position of Saturn's center\n    \nReturns:\n    list: A list of plotly traces representing the ring components\n\nUranus Ring System Transformation:\n\nFor proper alignment with satellite orbits, Uranus's ring system requires a specific \ncompound rotation approach due to the planet's extreme axial tilt (97.77 deg).\n\nThe transformation uses these key elements:\n1. A 105 deg rotation around the X-axis followed by a 105 deg rotation around the Y-axis\n(empirically determined to match satellite orbit alignment)\n2. Converting point coordinates to NumPy arrays before rotation\n3. Applying center position offset to the final coordinates after both rotations\n\nThis approach ensures that all components of the Uranian system (rings, satellites, \nradiation belts) share the same reference frame, correctly representing the planet's\nunique orientation in space.\n\nNOTE: The 105 deg value, rather than the nominal 97.77 deg axial tilt, accounts for the \nspecific reference frame conversion between Uranus's equatorial plane and the\necliptic coordinate system used for visualization.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_uranus_ring_system",
    "component_id": "uranus_visualization_shells.create_uranus_ring_system"
  },
  "uranus_visualization_shells.create_uranus_hill_sphere_shell": {
    "id": "uranus_visualization_shells.create_uranus_hill_sphere_shell",
    "name": "create_uranus_hill_sphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\uranus_visualization_shells.py",
    "relative_path": "uranus_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_uranus_hill_sphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Uranus's Hill sphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 2770, \n        'color': 'rgb(0, 255, 0)',  # Green for Hill sphere\n        'opacity': 0.25,\n        'name': 'Hill Sphere',\n        'description': (\n            \"SET MANUAL SCALE OF AT LEAST 0.6 AU TO VISUALIZE.<br><br>\"\n    \"The Hill sphere (also known as the Roche sphere) represents the region around a celestial body where its own gravity <br>\" \n    \"is the dominant force attracting satellites. Uranus has a Hill radius around 7.02x10^7 km, which corresponds to about <br>\" \n    \"2 770 Uranus radii (mean radius ~25 360 km). This means that any moon or other object orbiting Uranus within this <br>\" \n    \"sphere is primarily gravitationally bound to the planet. The major moons and rings of Uranus lie well within its Hill Sphere<br><br>\" \n                \"The Hill sphere is the region around a where its own gravity is the dominant force in attracting satellites. For <br>\" \n                \"a planet orbiting a star, it's the region where the planet's gravity is stronger than the star's tidal forces.<br><br>\" \n                \"The Hill Sphere radius can be described in words as follows: it is equal to the planet's average distance from the <br>\" \n                \"Sun (its orbital semi-major axis) multiplied by the cube root of the ratio between the planet's mass and three times <br>\" \n                \"the Sun's mass. In other words, you take how far the planet orbits out from the Sun, then scale that distance by the <br>\" \n                \"cube root of (planet mass / [3 x solar mass]) to find the boundary within which the planet's gravity dominates over the Sun's.\"\n        )\n    }\n        \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * URANUS_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Uranus: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Uranus: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    # Add sun direction indicator scaled to this shell's radius\n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=layer_radius\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 1051,
    "end_line": 1111,
    "has_docstring": true,
    "docstring": "Creates Uranus's Hill sphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_uranus_hill_sphere_shell",
    "component_id": "uranus_visualization_shells.create_uranus_hill_sphere_shell"
  },
  "venus_visualization_shells.create_venus_core_shell": {
    "id": "venus_visualization_shells.create_venus_core_shell",
    "name": "create_venus_core_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\venus_visualization_shells.py",
    "relative_path": "venus_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_venus_core_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Venus's core shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.5,  # Inner core: 0-50% of Venus's radius\n        'color': 'rgb(255, 180, 140)',  # Orange-red for hot iron core\n        'opacity': 1.0,\n        'name': 'Core',\n        'description': (\n            \"Scientists infer that Venus has a central core, likely composed primarily of iron and nickel, similar to Earth's. <br>\" \n            \"Its radius is estimated to be around 3,000 km. Due to the lack of a strong magnetic field, it's speculated that Venus's <br>\" \n            \"core might be solid or only partially liquid, or that it lacks the internal convection that drives Earth's magnetic <br>\" \n            \"field. The exact state and dynamics of Venus's core remain a topic of ongoing research.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * VENUS_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=4.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Venus: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Venus: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 16,
    "end_line": 61,
    "has_docstring": true,
    "docstring": "Creates Venus's core shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_venus_core_shell",
    "component_id": "venus_visualization_shells.create_venus_core_shell"
  },
  "venus_visualization_shells.create_venus_mantle_shell": {
    "id": "venus_visualization_shells.create_venus_mantle_shell",
    "name": "create_venus_mantle_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\venus_visualization_shells.py",
    "relative_path": "venus_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_venus_mantle_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Venus's mantle shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 0.98,  # Lower mantle: 50-98% of Venus's radius; actually it is nearly 100%, but representing as 98%\n        'color': 'rgb(230, 100, 20)',  # Reddish-brown\n        'opacity': 0.7,\n        'name': 'Mantle',\n        'description': (\n            \"Surrounding the core is a mantle made of hot, dense silicate rock, much like Earth's mantle. It's believed that heat <br>\" \n            \"generated by radioactive decay within Venus drives slow convection currents in the mantle. These currents are thought <br>\" \n            \"to be responsible for the planet's volcanism and tectonic activity, albeit different from Earth's plate tectonics\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * VENUS_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=3.4,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Venus: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Venus: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 69,
    "end_line": 113,
    "has_docstring": true,
    "docstring": "Creates Venus's mantle shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_venus_mantle_shell",
    "component_id": "venus_visualization_shells.create_venus_mantle_shell"
  },
  "venus_visualization_shells.create_venus_crust_shell": {
    "id": "venus_visualization_shells.create_venus_crust_shell",
    "name": "create_venus_crust_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\venus_visualization_shells.py",
    "relative_path": "venus_visualization_shells.py",
    "depends_on": [],
    "source_code": "def create_venus_crust_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Venus's crust shell using Mesh3d for better performance with improved hover.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.0,  # Crust: 100% of Venus's radius\n        'color': 'rgb(255, 255, 224)',  \n        'opacity': 1.0,\n        'name': 'Crust',\n        'description': (\n            \"Venus Crust<br>\" \n            \"(Note: toggle off the crust layer in the legend to better see the interior structure.)<br><br>\"\n            \"Venus has a crust primarily made of basalt rock, with an estimated thickness ranging from about 10 to 30 kilometers, <br>\" \n            \"possibly thicker in the highland regions. Unlike Earth, Venus does not appear to have plate tectonics. Instead, its <br>\" \n            \"surface is mostly a single, continuous plate. The heat from the mantle escapes through volcanic activity, which is <br>\" \n            \"widespread across the planet, leading to periodic resurfacing events on a global scale.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    radius = layer_info['radius_fraction'] * VENUS_RADIUS_AU\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # Create mesh with reasonable resolution for performance\n    resolution = 24  # Reduced from typical 50 for markers\n    \n    # Create a UV sphere\n    phi = np.linspace(0, 2*np.pi, resolution)\n    theta = np.linspace(-np.pi/2, np.pi/2, resolution)\n    phi, theta = np.meshgrid(phi, theta)\n    \n    x = radius * np.cos(theta) * np.cos(phi)\n    y = radius * np.cos(theta) * np.sin(phi)\n    z = radius * np.sin(theta)\n    \n    # Apply center position offset\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    # Create triangulation\n    indices = []\n    for i in range(resolution-1):\n        for j in range(resolution-1):\n            p1 = i * resolution + j\n            p2 = i * resolution + (j + 1)\n            p3 = (i + 1) * resolution + j\n            p4 = (i + 1) * resolution + (j + 1)\n            \n            indices.append([p1, p2, p4])\n            indices.append([p1, p4, p3])\n    \n    # Create main surface\n    surface_trace = go.Mesh3d(\n        x=x.flatten(), \n        y=y.flatten(), \n        z=z.flatten(),\n        i=[idx[0] for idx in indices],\n        j=[idx[1] for idx in indices],\n        k=[idx[2] for idx in indices],\n        color=layer_info['color'],\n        opacity=layer_info['opacity'],\n        name=f\"Venus: {layer_info['name']}\",\n        showlegend=True,\n        hoverinfo='none',  # Disable hover on mesh surface\n        # Add these new parameters to make hover text invisible\n        hovertemplate=' ',  # Empty template instead of None\n        hoverlabel=dict(\n    #        bgcolor='rgba(0,0,0,0)',  # Transparent background\n            font=dict(\n                color='rgba(0,0,0,0)',  # Transparent text\n    #            size=0                  # Zero font size\n            ),\n            bordercolor='rgba(0,0,0,0)'  # Transparent border\n        ), \n        # Add these new parameters to eliminate shading\n        flatshading=True,  # Use flat shading instead of smooth\n        lighting=dict(\n            ambient=1.0,     # Set to maximum (1.0)\n            diffuse=0.0,     # Turn off diffuse lighting\n            specular=0.0,    # Turn off specular highlights\n            roughness=1.0,   # Maximum roughness\n            fresnel=0.0      # Turn off fresnel effect\n        ),\n        lightposition=dict(\n            x=0,  # Centered light\n            y=0,  # Centered light\n            z=10000  # Light from very far above to minimize shadows\n        )       \n    )\n        \n    # Use the Fibonacci sphere algorithm for more even point distribution\n    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points\n    \n    # Generate fibonacci sphere points\n    fib_points = fibonacci_sphere(samples=50)  # Originally, 50 hover points evenly distributed\n    \n    # Scale and offset the points\n    x_hover = [p[0] * radius + center_x for p in fib_points]\n    y_hover = [p[1] * radius + center_y for p in fib_points]\n    z_hover = [p[2] * radius + center_z for p in fib_points]\n        \n    # Create a list of repeated descriptions for each point\n    # This is crucial - we need exactly one text entry per point\n    hover_texts = [layer_info['description']] * len(x_hover)\n\n    # Just the name for \"Object Names Only\" mode\n    layer_name = f\"Venus: {layer_info['name']}\"\n    minimal_hover_texts = [layer_name] * len(x_hover)\n\n    # Create hover trace with direct text assignment\n    hover_trace = go.Scatter3d(\n        x=x_hover, \n        y=y_hover, \n        z=z_hover,\n        mode='markers',\n        marker=dict(\n            size=2,  # originally 5\n            color='rgb(255, 255, 224)',  # Layer color\n            opacity=1.0,  # originally 0.8\n            line=dict(  # Add a contrasting outline\n                width=1,\n                color='black'\n            )\n        ),\n        name=f\"Venus: {layer_info['name']} (Info)\",\n        text=hover_texts,  # IMPORTANT: Matching length with coordinate arrays\n        customdata=minimal_hover_texts,  # For \"Object Names Only\" mode\n        hovertemplate='%{text}<extra></extra>',  # Use the standard hover template\n        showlegend=False  # Don't show in legend since it's just for hover\n    )\n\n    return [surface_trace, hover_trace]",
    "start_line": 122,
    "end_line": 270,
    "has_docstring": true,
    "docstring": "Creates Venus's crust shell using Mesh3d for better performance with improved hover.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_venus_crust_shell",
    "component_id": "venus_visualization_shells.create_venus_crust_shell"
  },
  "venus_visualization_shells.fibonacci_sphere": {
    "id": "venus_visualization_shells.fibonacci_sphere",
    "name": "fibonacci_sphere",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\venus_visualization_shells.py",
    "relative_path": "venus_visualization_shells.py",
    "depends_on": [],
    "source_code": "    def fibonacci_sphere(samples=1000):\n        points = []\n        phi = math.pi * (3. - math.sqrt(5.))  # Golden angle in radians\n        \n        for i in range(samples):\n            y = 1 - (i / float(samples - 1)) * 2  # y goes from 1 to -1\n            radius_at_y = math.sqrt(1 - y * y)  # Radius at y\n            \n            theta = phi * i  # Golden angle increment\n            \n            x = math.cos(theta) * radius_at_y\n            z = math.sin(theta) * radius_at_y\n            \n            points.append((x, y, z))\n        \n        return points",
    "start_line": 215,
    "end_line": 230,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "samples"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function fibonacci_sphere",
    "component_id": "venus_visualization_shells.fibonacci_sphere"
  },
  "venus_visualization_shells.create_venus_atmosphere_shell": {
    "id": "venus_visualization_shells.create_venus_atmosphere_shell",
    "name": "create_venus_atmosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\venus_visualization_shells.py",
    "relative_path": "venus_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_venus_atmosphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Venus's lower atmosphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.01,  \n        'color': 'rgb(150, 200, 255)',  # Light blue for atmosphere\n        'opacity': 0.5,\n        'name': 'Lower Atmosphere',\n        'description': (\n            \"Venus boasts an extremely dense atmosphere, about 90 times the pressure of Earth's atmosphere at the surface. It is <br>\" \n            \"composed primarily of carbon dioxide (about 96.5%) and nitrogen (about 3.5%), with trace amounts of other gases, <br>\" \n            \"including sulfuric acid clouds that completely enshroud the planet. This thick, CO2-rich atmosphere creates a runaway <br>\" \n            \"greenhouse effect, making Venus the hottest planet in our solar system with surface temperatures around 464 degC. The <br>\" \n            \"upper atmosphere exhibits a phenomenon called \\\"super-rotation,\\\" where winds blow much faster than the planet's slow <br>\" \n            \"rotation.<br><br>\"\n            \"The \\\"lower atmosphere\\\" of Venus is generally considered to be the troposphere, which extends from the surface up to \\n\" \n            \"an altitude of approximately 60 kilometers. This region contains the dense, hot air and the main cloud layers.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * VENUS_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.5,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Venus: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Venus: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    return traces",
    "start_line": 281,
    "end_line": 330,
    "has_docstring": true,
    "docstring": "Creates Venus's lower atmosphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_venus_atmosphere_shell",
    "component_id": "venus_visualization_shells.create_venus_atmosphere_shell"
  },
  "venus_visualization_shells.create_venus_upper_atmosphere_shell": {
    "id": "venus_visualization_shells.create_venus_upper_atmosphere_shell",
    "name": "create_venus_upper_atmosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\venus_visualization_shells.py",
    "relative_path": "venus_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_venus_upper_atmosphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Venus's upper atmosphere shell.\"\"\"\n    # Define layer properties\n    layer_info = {\n        'radius_fraction': 1.08,  # Mesosphere, thermosphere, and exosphere\n        'color': 'rgb(100, 150, 255)',  # Lighter blue\n        'opacity': 0.3,\n        'name': 'Upper Atmosphere',\n        'description': (\n            \"The upper atmosphere of Venus is a complex and dynamic region extending far beyond the troposphere. It doesn't have the <br>\" \n            \"same distinct layers (stratosphere, mesosphere, thermosphere) as Earth's in the same way due to the very different thermal <br>\" \n            \"structure and composition. However, we can broadly consider the regions above the main cloud deck (around 70 km) as the <br>\" \n            \"upper atmosphere. Here's a look at some key parts of the upper atmosphere and their approximate extents:<br>\" \n            \"* Mesosphere (approximately 60 km to 90-100 km): Above the main cloud layers, the temperature starts to decrease with <br>\" \n            \"  altitude. This region is considered the mesosphere. It's a transition zone between the lower, rapidly rotating atmosphere <br>\" \n            \"  and the upper atmosphere where solar radiation plays a more dominant role. Extent in Venus radii: The top of this layer is <br>\" \n            \"  around 90-100 km. So, the mesosphere extends up to about 1.5-1.6% of Venus's radius.<br>\" \n            \"* Thermosphere (approximately 90-100 km to 200+ km): Above the mesosphere, the temperature increases significantly with <br>\" \n            \"  altitude due to the absorption of solar extreme ultraviolet (EUV) radiation. This is the thermosphere. Unlike Earth's <br>\" \n            \"  thermosphere, Venus's thermosphere is surprisingly cold, with average temperatures around 300 K (27 degC), and even colder on <br>\" \n            \"  the night side (the \\\"cryosphere\\\" around 90-120 km can reach extremely low temperatures). This is due to efficient <br>\" \n            \"  radiative cooling by carbon dioxide. The thermosphere is also where significant day-night differences in temperature and <br>\" \n            \"  density occur due to Venus's slow rotation. A global circulation pattern moves hot air from the dayside to the nightside <br>\" \n            \"  at high altitudes. Extent in Venus radii: The thermosphere extends to at least 200 km, and potentially much higher, gradually <br>\" \n            \"  thinning into the exosphere. So, the thermosphere extends to at least 3.3% of Venus's radius.<br>\" \n            \"* Ionosphere (approximately 120 km to several hundred km): Within the thermosphere and extending into the exosphere lies the <br>\" \n            \"  ionosphere, a region where solar radiation has ionized the atmospheric gases, creating a layer of charged particles (ions <br>\" \n            \"  and electrons). Venus has a substantial ionosphere, with peak electron densities occurring around 120-140 km altitude. The <br>\" \n            \"  ionosphere plays a crucial role in interacting with the solar wind, as Venus lacks a strong global magnetic field.<br>\" \n            \"  * The solar wind directly impacts the ionosphere, leading to the formation of an induced magnetosphere.<br>\" \n            \"  * The nightside ionosphere is more variable and less dense than the dayside ionosphere, but it can extend to very high <br>\" \n            \"    altitudes, even forming a long, comet-like tail under certain solar wind conditions.<br>\" \n            \"  Extent in Venus radii: The main part of the ionosphere extends from about 120 km to several hundred kilometers. If we <br>\" \n            \"  consider an upper limit of, say, 500 km for a significant ionospheric density: So, the ionosphere can extend up to about 8.3% <br>\" \n            \"  of Venus's radius. However, the outermost fringes can be even more extended.<br>\" \n            \"* Exosphere (extends from where the atmosphere is very thin outwards into space): The uppermost layer of Venus's atmosphere <br>\" \n            \"  is the exosphere, where the gas density is so low that atoms and molecules can escape into space. The boundary between the <br>\" \n            \"  thermosphere and exosphere (the exobase) is not sharply defined but is generally considered to be above where collisions <br>\" \n            \"  between particles become infrequent. This is likely several hundred kilometers above the surface. The exosphere gradually <br>\" \n            \"  fades into space and interacts directly with the solar wind. Extent in Venus radii: The exosphere has no well-defined upper <br>\" \n            \"  limit. It extends outwards until the planet's gravity is no longer the dominant force.<br>\" \n            \"In summary, the upper atmosphere of Venus is a significant region:<br>\" \n            \"* The mesosphere occupies roughly 1.5-1.6% of Venus's radius.<br>\" \n            \"* The thermosphere extends to at least 3.3% of Venus's radius.<br>\" \n            \"* The ionosphere spans a considerable range within the thermosphere and exosphere, potentially reaching about 8% or more of <br>\" \n            \"  Venus's radius for significant charged particle densities.<br>\" \n            \"* The exosphere gradually fades out into space. It's important to remember that these are approximate extents, and the <br>\" \n            \"  boundaries between these regions are not always sharp and can vary with solar activity and other factors. The upper <br>\" \n            \"  atmosphere of Venus is a subject of ongoing research, and future missions will undoubtedly refine our understanding of <br>\" \n            \"  its structure and dynamics.\"\n        )\n    }\n    \n    # Calculate radius in AU\n    layer_radius = layer_info['radius_fraction'] * VENUS_RADIUS_AU\n    \n    # Create sphere points\n    x, y, z = create_sphere_points(layer_radius, n_points=50)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    traces = [\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.0,\n                color=layer_info['color'],\n                opacity=layer_info['opacity']\n            ),\n            name=f\"Venus: {layer_info['name']}\",\n            text=[layer_info['description']] * len(x),\n            customdata=[f\"Venus: {layer_info['name']}\"] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=layer_radius\n    )\n    for trace in sun_traces:\n        traces.append(trace) \n\n    return traces",
    "start_line": 340,
    "end_line": 429,
    "has_docstring": true,
    "docstring": "Creates Venus's upper atmosphere shell.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_venus_upper_atmosphere_shell",
    "component_id": "venus_visualization_shells.create_venus_upper_atmosphere_shell"
  },
  "venus_visualization_shells.create_venus_magnetosphere_shell": {
    "id": "venus_visualization_shells.create_venus_magnetosphere_shell",
    "name": "create_venus_magnetosphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\venus_visualization_shells.py",
    "relative_path": "venus_visualization_shells.py",
    "depends_on": [
      "planet_visualization_utilities.create_magnetosphere_shape",
      "shared_utilities.create_sun_direction_indicator"
    ],
    "source_code": "def create_venus_magnetosphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Venus's magnetosphere.\"\"\"\n    traces = []\n    \n    # Parameters for magnetosphere components (in Venus radii)\n    params = {\n        # Compressed sunward side\n        'sunward_distance': 1.5,  # Compressed toward the sun\n        \n        # Equatorial extension (wider than polar)\n        'equatorial_radius': 1.0,\n        'polar_radius': 1.0,\n        \n        # Magnetotail parameters\n        'tail_length': 60,  # Length of visible magnetotail\n        'tail_base_radius': 1.5,  # Radius at the base of the tail\n        'tail_end_radius': 30,  # Radius at the end of the tail\n        \n        # Radiation belts\n    #    'inner_belt_distance': 1.5,  # Distance in Earth radii\n    #    'outer_belt_distance': 4.5,  # Distance in Earth radii\n    #    'belt_thickness': 0.5,\n    }\n    \n    # Scale everything by Venus's radius in AU\n    for key in params:\n        params[key] *= VENUS_RADIUS_AU\n    \n    # Create magnetosphere main shape\n    x, y, z = create_magnetosphere_shape(params)\n    \n    # Unpack center position\n    center_x, center_y, center_z = center_position\n    \n    # 1. Add the main magnetosphere structure\n    x = np.array(x) + center_x\n    y = np.array(y) + center_y\n    z = np.array(z) + center_z\n    \n    magnetosphere_text = [\"Venus has a very weak, induced magnetosphere. Unlike Earth's magnetic field, which is generated internally by its <br>\" \n            \"liquid iron core, Venus's weak magnetosphere is formed by the interaction of the solar wind with the planet's <br>\" \n            \"ionosphere (the upper layer of its atmosphere containing charged particles). This induced magnetosphere is not as <br>\" \n            \"effective at deflecting charged particles from the Sun as Earth's strong magnetic field.<br><br>\" \n            \"The solar wind's magnetic field drapes around Venus, creating a comet-shaped magnetosphere with a bow shock on the <br>\" \n            \"sunward side and a long magnetotail extending away from the Sun. The extent of Venus's induced magnetosphere is highly <br>\" \n            \"variable and depends on the strength and direction of the solar wind.<br>\" \n            \"* Bow Shock: The bow shock, which is the outermost boundary where the supersonic solar wind is slowed and deflected by <br>\" \n            \"  Venus, typically stands off a few thousand kilometers above the dayside surface. At the subsolar point (the point <br>\" \n            \"  directly facing the Sun), it's often located around about 1.3 to 1.7 radii from the planet's center. However, this <br>\" \n            \"  distance can vary significantly with solar wind conditions.<br>\"\n            \"  The Bow Shock points towards the Sun along the X-axis. The XY plane is the ecliptic.<br>\" \n            \"* Magnetopause: The magnetopause is the inner boundary of the magnetosphere, where the magnetic pressure of the induced <br>\" \n            \"  magnetosphere balances the pressure of the shocked solar wind. On the dayside, the magnetopause is typically found much <br>\" \n            \"  closer to the planet than the bow shock, often around 1.05 to 1.1 radii from the planet's center during solar minimum <br>\" \n            \"  conditions. It can be pushed closer to the planet during periods of high solar wind pressure.<br>\" \n            \"* Magnetotail: The magnetotail extends far downstream from Venus, in the anti-sunward direction. Its length is much more <br>\" \n            \"  variable and can stretch to many Venus radii. Some observations have suggested that the magnetotail can extend to at <br>\" \n            \"  least ~45 radii and possibly even further during active solar wind conditions.<br>\" \n            \"  * Estimating the precise base radius and end radius of Venus's induced magnetotail is challenging due to its dynamic <br>\" \n            \"    nature and dependence on the ever-changing solar wind conditions. Unlike Earth's magnetotail, which is anchored by <br>\" \n            \"    a strong internal magnetic field, Venus's magnetotail is constantly being shaped and influenced by the solar wind <br>\" \n            \"    flow and the interplanetary magnetic field (IMF).<br>\" \n            \"    * Base Radius: The \\\"base\\\" of the magnetotail can be considered the region just behind Venus where the induced <br>\" \n            \"      magnetosphere forms a tail-like structure. This transition region is not a sharp boundary but rather a gradual <br>\" \n            \"      change in plasma and magnetic field characteristics. Near Venus, the magnetotail has a somewhat cylindrical or <br>\" \n            \"      lobed structure. Studies using Venus Express data have estimated the typical radius of the near-Venus magnetotail <br>\" \n            \"      to be around 1 to 1.5 Venus radii.<br>\" \n            \"    * End Radius (Length): The length of Venus's magnetotail is highly variable and can extend to significant distances <br>\" \n            \"      downstream. Recent flybys by spacecraft like Solar Orbiter have provided new insights into the far reaches of the <br>\" \n            \"      tail. Observations have detected the presence of the magnetotail and its boundaries (bow shock and induced <br>\" \n            \"      magnetospheric boundary) extending to at least 60 Venus radii (~363,120 km) downstream. There is even some evidence <br>\" \n            \"      suggesting that under certain solar wind conditions, the tail might extend even further, possibly up to or beyond 100 <br>\" \n            \"      Venus radii. One study of Mariner 10 data suggested possible detection of the tail as far as ~100 radii downstream. <br>\" \n            \"      * Dynamic Nature: The solar wind's pressure, speed, and the orientation of the IMF constantly buffet Venus's induced <br>\" \n            \"        magnetosphere, causing significant variations in its size and shape.<br>\" \n            \"      * Boundary Identification: Defining the exact outer boundary of the magnetotail can be challenging as the plasma <br>\" \n            \"        environment gradually transitions back to the solar wind.<br>\" \n            \"      * Limited Far-Tail Observations: While recent missions have provided valuable data, the far magnetotail of Venus has <br>\" \n            \"        not been as extensively sampled as Earth's.<br>\" \n            \"    * Estimating the width of Venus's magnetotail at distances of 45 to 60 Venus radii is challenging due to the <br>\" \n            \"      limited number of direct observations so far out in the tail. Most detailed studies have focused on the near-<br>\" \n            \"      Venus magnetotail (within ~10 to 12 radii). However, recent flybys, particularly by Solar Orbiter, are providing <br>\" \n            \"      new insights.<br>\" \n            \"      * Overall Expansion: The induced magnetotail of Venus is known to flare or expand as it extends downstream from <br>\" \n            \"        the planet. This is a common feature of magnetotails formed by the interaction of the solar wind with a planetary <br>\" \n            \"        obstacle.<br>\" \n            \"      * Solar Orbiter Observations: A recent study based on Solar Orbiter flybys, which reached as far as 60 radii downstream, <br>\" \n            \"        suggests that the bow shock (the outer boundary) at this distance is about 15-20 radii in the lateral direction <br>\" \n            \"        (which would give a total width of roughly 30-40 radii if we assume some symmetry around the tail axis). The induced <br>\" \n            \"        magnetospheric boundary (IMB), which is inside the bow shock, was still detected at 20 radii downstream in this study, <br>\" \n            \"        but its width at larger distances was not specifically quantified.<br>\" \n            \"      * Earlier Estimates: Older studies based on Pioneer Venus Orbiter data, which primarily sampled the tail up to ~12 radii, <br>\" \n            \"        found the tail to be about 4 radii wide and 3.2 radii high at that distance. Extrapolating this far out is difficult <br>\" \n            \"        due to the flaring. Therefore, a reasonable estimate for the width of Venus's magnetotail at 45 to 60 Venus radii <br>\" \n            \"        would likely be on the order of tens of Venus radii, possibly in the range of 20 to 40 radii or even wider, based on <br>\" \n            \"        the observed bow shock dimensions at that distance. The actual width can vary significantly depending on the solar <br>\" \n            \"        wind conditions (pressure, speed, IMF orientation). The shape of the tail might not be perfectly circular at these <br>\" \n            \"        large distances.<br>\"\n            \"In summary, the extent of Venus's induced magnetosphere in terms of Venus radii is:<br>\" \n            \"* Dayside (from the center): Extends to roughly 1.3 - 1.7 radii at the bow shock and about 1.05 - 1.1 radii at the <br>\" \n            \"  magnetopause.<br>\"\n            \"  The Bow Shock points towards the Sun along the X-axis. The XY plane is the ecliptic.<br>\" \n            \"* Nightside (magnetotail): Can extend to at least tens of Venus radii, with estimates reaching up to ~45 radii or <br>\" \n            \"  more under certain solar wind conditions.<br>\" \n            \"The size and shape of Venus's induced magnetosphere are highly dynamic, constantly being shaped by the ever-changing <br>\" \n            \"solar wind.\"]\n    \n    magnetosphere_customdata = ['Venus: Magnetosphere']\n\n    traces.append(\n        go.Scatter3d(\n            x=x, y=y, z=z,\n            mode='markers',\n            marker=dict(\n                size=2.0,\n                color='rgb(180, 180, 255)', # Light blue for magnetic field\n                opacity=0.2\n            ),\n            name='Venus: Magnetosphere',\n            text=magnetosphere_text * len(x),\n            customdata=magnetosphere_customdata * len(x),      \n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    )\n    \n    # 2. Create and add bow shock\n    bow_shock_x = []\n    bow_shock_y = []\n    bow_shock_z = []\n    \n    n_phi = 30\n    n_theta = 30\n    bow_shock_standoff = 15 * VENUS_RADIUS_AU\n    bow_shock_width = 25 * VENUS_RADIUS_AU\n    \n    # Create a paraboloid for the bow shock\n    for i_phi in range(n_phi):\n        phi = (i_phi / (n_phi-1)) * np.pi  # Only the front half\n        \n        for i_theta in range(n_theta):\n            theta = (i_theta / (n_theta-1)) * 2 * np.pi\n            \n            # Paraboloid shape, flattened in x-direction for bow shock\n            x = -bow_shock_standoff * np.cos(phi)  # Negative for sunward direction\n            rho = bow_shock_width * (1 + np.sin(phi)) / 2  # Wider for larger phi (away from sun)\n            y = rho * np.cos(theta)\n            z = rho * np.sin(theta)\n            \n            bow_shock_x.append(x)\n            bow_shock_y.append(y)\n            bow_shock_z.append(z)\n    \n    # Apply center position offset\n    bow_shock_x = np.array(bow_shock_x) + center_x\n    bow_shock_y = np.array(bow_shock_y) + center_y\n    bow_shock_z = np.array(bow_shock_z) + center_z\n    \n    bow_shock_text = [\"Bow Shock: The bow shock, which is the outermost boundary where the supersonic solar wind is slowed and <br>\" \n                      \"deflected by Venus, typically stands off a few thousand kilometers above the dayside surface. At the subsolar <br>\" \n                      \"point (the point directly facing the Sun), it's often located around ~0.3 to 0.7 radii above the surface, or <br>\" \n                      \"about 1.3 to 1.7 radii from the planet's center. However, this distance can vary significantly with solar wind <br>\" \n                      \"conditions.<br>\"\n                      \"The Bow Shock points towards the Sun along the X-axis. The XY plane is the ecliptic.\"]\n    \n    bow_shock_customdata = ['Venus: Bow Shock']\n\n    traces.append(\n        go.Scatter3d(\n            x=bow_shock_x,\n            y=bow_shock_y,\n            z=bow_shock_z,\n            mode='markers',\n            marker=dict(\n                size=1.5,\n                color='rgb(255, 200, 150)',  # Orange-ish color for bow shock\n                opacity=0.2\n            ),\n            name='Venus: Bow Shock',\n            text=bow_shock_text * len(bow_shock_x),\n            customdata=bow_shock_customdata * len(bow_shock_x),  # This was the line causing the error\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    )\n        \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=60 * VENUS_RADIUS_AU\n    )\n    for trace in sun_traces:\n        traces.append(trace)\n\n    return traces",
    "start_line": 440,
    "end_line": 633,
    "has_docstring": true,
    "docstring": "Creates Venus's magnetosphere.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_venus_magnetosphere_shell",
    "component_id": "venus_visualization_shells.create_venus_magnetosphere_shell"
  },
  "venus_visualization_shells.create_venus_hill_sphere_shell": {
    "id": "venus_visualization_shells.create_venus_hill_sphere_shell",
    "name": "create_venus_hill_sphere_shell",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\venus_visualization_shells.py",
    "relative_path": "venus_visualization_shells.py",
    "depends_on": [
      "shared_utilities.create_sun_direction_indicator",
      "planet_visualization_utilities.create_sphere_points"
    ],
    "source_code": "def create_venus_hill_sphere_shell(center_position=(0, 0, 0)):\n    \"\"\"Creates Venus's Hill sphere.\"\"\"\n    # Hill sphere radius in Venus radii\n    radius_fraction = 166  # Venus's Hill sphere is about 1 million km or 166 Venus radii\n    \n    # Calculate radius in AU\n    radius_au = radius_fraction * VENUS_RADIUS_AU\n    \n    # Create sphere points with fewer points for memory efficiency\n    n_points = 30  # Reduced for large spheres\n    x, y, z = create_sphere_points(radius_au, n_points=n_points)\n    \n    # Apply center position offset\n    center_x, center_y, center_z = center_position\n    x = x + center_x\n    y = y + center_y\n    z = z + center_z\n    \n    # Create hover text\n    hover_text = (\"Venus's Hill Sphere (extends to ~166 Venus radii or about 1 million km)<br><br>\" \n                \"The Hill sphere is the region around a where its own gravity is the dominant force in attracting satellites. For <br>\" \n                \"a planet orbiting a star, it's the region where the planet's gravity is stronger than the star's tidal forces.<br><br>\" \n                \"The Hill Sphere radius can be described in words as follows: it is equal to the planet's average distance from the <br>\" \n                \"Sun (its orbital semi-major axis) multiplied by the cube root of the ratio between the planet's mass and three times <br>\" \n                \"the Sun's mass. In other words, you take how far the planet orbits out from the Sun, then scale that distance by the <br>\" \n                \"cube root of (planet mass / [3 x solar mass]) to find the boundary within which the planet's gravity dominates over the Sun's.\"\n                )\n    \n    # Create the trace\n    traces = [\n        go.Scatter3d(\n            x=x,\n            y=y,\n            z=z,\n            mode='markers',\n            marker=dict(\n                size=1.0,\n                color='rgb(0, 255, 0)',  # Green for Hill sphere\n                opacity=0.25\n            ),\n            name='Venus: Hill Sphere',\n            text=[hover_text] * len(x),\n            customdata=['Venus: Hill Sphere'] * len(x),\n            hovertemplate='%{text}<extra></extra>',\n            showlegend=True\n        )\n    ]\n    \n    sun_traces = create_sun_direction_indicator(\n        center_position=center_position, \n        shell_radius=radius_au\n    )\n    for trace in sun_traces:\n        traces.append(trace) \n\n    return traces",
    "start_line": 643,
    "end_line": 698,
    "has_docstring": true,
    "docstring": "Creates Venus's Hill sphere.",
    "parameters": [
      "center_position"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_venus_hill_sphere_shell",
    "component_id": "venus_visualization_shells.create_venus_hill_sphere_shell"
  },
  "verify_orbit_cache.create_backup": {
    "id": "verify_orbit_cache.create_backup",
    "name": "create_backup",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\verify_orbit_cache.py",
    "relative_path": "verify_orbit_cache.py",
    "depends_on": [],
    "source_code": "def create_backup(file_path):\n    \"\"\"Create a timestamped backup of the orbit cache file.\"\"\"\n    if not os.path.exists(file_path):\n        print(f\"No file to backup at {file_path}\")\n        return None\n        \n    backup_name = f\"{file_path}.verify_backup.{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n    try:\n        shutil.copy2(file_path, backup_name)\n        size_mb = os.path.getsize(file_path) / (1024 * 1024)\n        print(f\"[OK] Created backup: {backup_name} ({size_mb:.1f} MB)\")\n        return backup_name\n    except Exception as e:\n        print(f\"[FAIL] Failed to create backup: {e}\")\n        return None",
    "start_line": 19,
    "end_line": 33,
    "has_docstring": true,
    "docstring": "Create a timestamped backup of the orbit cache file.",
    "parameters": [
      "file_path"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_backup",
    "component_id": "verify_orbit_cache.create_backup"
  },
  "verify_orbit_cache.verify_orbit_cache": {
    "id": "verify_orbit_cache.verify_orbit_cache",
    "name": "verify_orbit_cache",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\verify_orbit_cache.py",
    "relative_path": "verify_orbit_cache.py",
    "depends_on": [
      "verify_orbit_cache.create_backup"
    ],
    "source_code": "def verify_orbit_cache(file_path='orbit_paths.json', repair=False):\n    \"\"\"Verify the orbit cache file and optionally repair it.\"\"\"\n    \n    print(f\"\\n{'='*60}\")\n    print(f\"Orbit Cache Verification Tool\")\n    print(f\"{'='*60}\\n\")\n    \n    # Step 1: Create backup\n    print(\"Step 1: Creating backup...\")\n    backup_file = create_backup(file_path)\n    if not backup_file and os.path.exists(file_path):\n        response = input(\"Failed to create backup. Continue anyway? (y/n): \")\n        if response.lower() != 'y':\n            return\n    \n    # Step 2: Check file exists and size\n    print(\"\\nStep 2: Checking file...\")\n    if not os.path.exists(file_path):\n        print(f\"[FAIL] File not found: {file_path}\")\n        return\n        \n    file_size = os.path.getsize(file_path)\n    file_size_mb = file_size / (1024 * 1024)\n    print(f\"[OK] File exists: {file_size:,} bytes ({file_size_mb:.1f} MB)\")\n    \n    # Step 3: Load and parse JSON\n    print(\"\\nStep 3: Loading JSON...\")\n    try:\n        with open(file_path, 'r') as f:\n            data = json.load(f)\n        print(f\"[OK] JSON is valid\")\n    except json.JSONDecodeError as e:\n        print(f\"[FAIL] JSON is corrupted: {e}\")\n        print(f\"\\nFile appears to be corrupted beyond simple repair.\")\n        print(f\"You should restore from backup: {backup_file}\")\n        return\n    except Exception as e:\n        print(f\"[FAIL] Error reading file: {e}\")\n        return\n    \n    # Step 4: Validate structure\n    print(\"\\nStep 4: Validating orbit data structure...\")\n    if not isinstance(data, dict):\n        print(f\"[FAIL] Root structure is not a dictionary\")\n        return\n        \n    total_entries = len(data)\n    valid_entries = 0\n    corrupted_entries = []\n    old_format_entries = []\n    \n    for orbit_key, orbit_data in data.items():\n        try:\n            # Check basic structure\n            if not isinstance(orbit_data, dict):\n                corrupted_entries.append((orbit_key, \"Not a dictionary\"))\n                continue\n            \n            # Check for new format\n            if \"data_points\" in orbit_data and \"metadata\" in orbit_data:\n                # Validate new format\n                if not isinstance(orbit_data[\"data_points\"], dict):\n                    corrupted_entries.append((orbit_key, \"Invalid data_points\"))\n                    continue\n                if not isinstance(orbit_data[\"metadata\"], dict):\n                    corrupted_entries.append((orbit_key, \"Invalid metadata\"))\n                    continue\n                valid_entries += 1\n                \n            # Check for old format\n            elif all(k in orbit_data for k in ['x', 'y', 'z']):\n                # Validate old format\n                if not all(isinstance(orbit_data[k], list) for k in ['x', 'y', 'z']):\n                    corrupted_entries.append((orbit_key, \"Invalid coordinate arrays\"))\n                    continue\n                    \n                lens = [len(orbit_data[k]) for k in ['x', 'y', 'z']]\n                if len(set(lens)) != 1:\n                    corrupted_entries.append((orbit_key, f\"Mismatched array lengths: {lens}\"))\n                    continue\n                    \n                old_format_entries.append(orbit_key)\n                valid_entries += 1\n            else:\n                corrupted_entries.append((orbit_key, \"Unknown format\"))\n                \n        except Exception as e:\n            corrupted_entries.append((orbit_key, f\"Validation error: {str(e)}\"))\n    \n    # Step 5: Report findings\n    print(f\"\\n{'='*60}\")\n    print(f\"VALIDATION RESULTS\")\n    print(f\"{'='*60}\")\n    print(f\"Total entries: {total_entries}\")\n    print(f\"Valid entries: {valid_entries}\")\n    print(f\"Old format entries: {len(old_format_entries)}\")\n    print(f\"Corrupted entries: {len(corrupted_entries)}\")\n    \n    if old_format_entries:\n        print(f\"\\nOld format entries (will be auto-converted on next load):\")\n        for entry in old_format_entries[:5]:\n            print(f\"  - {entry}\")\n        if len(old_format_entries) > 5:\n            print(f\"  ... and {len(old_format_entries) - 5} more\")\n    \n    if corrupted_entries:\n        print(f\"\\nCorrupted entries found:\")\n        for entry, reason in corrupted_entries[:10]:\n            print(f\"  - {entry}: {reason}\")\n        if len(corrupted_entries) > 10:\n            print(f\"  ... and {len(corrupted_entries) - 10} more\")\n    \n    # Step 6: Repair if requested\n    if corrupted_entries and repair:\n        print(f\"\\n{'='*60}\")\n        print(f\"REPAIR MODE\")\n        print(f\"{'='*60}\")\n        \n        response = input(f\"Remove {len(corrupted_entries)} corrupted entries? (y/n): \")\n        if response.lower() == 'y':\n            # Remove corrupted entries\n            for entry, _ in corrupted_entries:\n                del data[entry]\n            \n            # Save repaired data\n            repair_file = file_path + '.repaired'\n            with open(repair_file, 'w') as f:\n                json.dump(data, f)\n            \n            print(f\"[OK] Repaired data saved to: {repair_file}\")\n            print(f\"  Remaining entries: {len(data)}\")\n            print(f\"\\nTo use the repaired file:\")\n            print(f\"  1. Verify the repaired file looks correct\")\n            print(f\"  2. mv {repair_file} {file_path}\")\n    \n    elif corrupted_entries:\n        print(f\"\\nTo repair, run: python {__file__} --repair\")\n    \n    # Step 7: Show sample data\n    if valid_entries > 0:\n        print(f\"\\n{'='*60}\")\n        print(f\"SAMPLE DATA\")\n        print(f\"{'='*60}\")\n        \n        sample_key = list(data.keys())[0]\n        sample_data = data[sample_key]\n        \n        print(f\"\\nExample entry: {sample_key}\")\n        if \"data_points\" in sample_data:\n            num_points = len(sample_data[\"data_points\"])\n            print(f\"  Format: New (time-indexed)\")\n            print(f\"  Data points: {num_points}\")\n            if sample_data.get(\"metadata\"):\n                print(f\"  Start date: {sample_data['metadata'].get('start_date', 'Unknown')}\")\n                print(f\"  End date: {sample_data['metadata'].get('end_date', 'Unknown')}\")\n                print(f\"  Center body: {sample_data['metadata'].get('center_body', 'Unknown')}\")\n        else:\n            print(f\"  Format: Old (array-based)\")\n            print(f\"  Data points: {len(sample_data.get('x', []))}\")\n    \n    print(f\"\\n{'='*60}\")\n    print(f\"Verification complete!\")\n    print(f\"{'='*60}\")",
    "start_line": 35,
    "end_line": 197,
    "has_docstring": true,
    "docstring": "Verify the orbit cache file and optionally repair it.",
    "parameters": [
      "file_path",
      "repair"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function verify_orbit_cache",
    "component_id": "verify_orbit_cache.verify_orbit_cache"
  },
  "visualization_2d.format_value": {
    "id": "visualization_2d.format_value",
    "name": "format_value",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_2d.py",
    "relative_path": "visualization_2d.py",
    "depends_on": [],
    "source_code": "def format_value(value, format_spec, default=\"Unknown\"):\n    \"\"\"Format a value using Python's built-in format function.\"\"\"\n    if value is None or (isinstance(value, float) and np.isnan(value)):\n        return default\n    try:\n        return format(value, format_spec)  # Correct way!\n    except (ValueError, TypeError):\n        return default",
    "start_line": 20,
    "end_line": 27,
    "has_docstring": true,
    "docstring": "Format a value using Python's built-in format function.",
    "parameters": [
      "value",
      "format_spec",
      "default"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function format_value",
    "component_id": "visualization_2d.format_value"
  },
  "visualization_2d.create_hover_text": {
    "id": "visualization_2d.create_hover_text",
    "name": "create_hover_text",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_2d.py",
    "relative_path": "visualization_2d.py",
    "depends_on": [
      "visualization_2d.format_value"
    ],
    "source_code": "def create_hover_text(df, include_3d=False):\n    \"\"\"Create hover text with graceful handling of missing columns.\"\"\"\n    hover_text_list = []\n\n    for _, row in df.iterrows():\n        star_name = row[\"Star_Name\"]\n        note = unique_notes.get(star_name, \"None.\")\n\n        # Get distance values, defaulting to NaN\n        distance_pc = row.get('Distance_pc', np.nan)\n        distance_ly = row.get('Distance_ly', np.nan)\n\n        # Calculate ly if missing but we have pc\n        if pd.isna(distance_ly) and pd.notna(distance_pc):\n            distance_ly = distance_pc * 3.26156\n\n        # Format distance strings, handling NaN explicitly\n        pc_str = f\"{distance_pc:.2f}\" if pd.notna(distance_pc) else \"Unknown\"\n        ly_str = f\"{distance_ly:.2f}\" if pd.notna(distance_ly) else \"Unknown\"\n\n        # ========== BUILD HOVER TEXT WITH CLEANER LAYOUT ==========\n        \n        # 1. STAR NAME (no extra line break after)\n        hover_text = f'<b>{star_name}</b><br>'\n        \n        # 2. RA/DEC (right after name)\n        # Try pre-computed strings first\n        if 'ra_str' in row and row.get('ra_str'):\n            ra_str = str(row['ra_str']).strip()\n            dec_str = str(row['dec_str']).strip()\n            if ra_str and ra_str.lower() not in ['nan', 'none', '']:\n                hover_text += f\"RA: {ra_str}, Dec: {dec_str} (J2000)<br>\"\n        # Otherwise convert from ICRS coordinates\n        elif 'RA_ICRS' in row and pd.notna(row.get('RA_ICRS')):\n            ra_deg = float(row['RA_ICRS'])\n            dec_deg = float(row['DE_ICRS'])\n            \n            # Convert RA to hours:minutes:seconds\n            ra_hours = ra_deg / 15.0\n            ra_h = int(ra_hours)\n            ra_m = int((ra_hours - ra_h) * 60)\n            ra_s = ((ra_hours - ra_h) * 60 - ra_m) * 60\n            \n            # Convert Dec to degrees:arcminutes:arcseconds\n            dec_sign = '+' if dec_deg >= 0 else '-'\n            dec_abs = abs(dec_deg)\n            dec_d = int(dec_abs)\n            dec_m = int((dec_abs - dec_d) * 60)\n            dec_s = ((dec_abs - dec_d) * 60 - dec_m) * 60\n            \n            hover_text += f\"RA: {ra_h:02d}h {ra_m:02d}m {ra_s:05.2f}s, Dec: {dec_sign}{dec_d:02d} deg {dec_m:02d}' {dec_s:04.1f}\\\" (J2000)<br>\"\n        \n        # 3. MAIN PROPERTIES (in logical order)\n        hover_text += f'Distance: {pc_str} pc ({ly_str} ly)<br>'\n        \n        # Temperature\n        has_temp = row.get('Has_Temperature', True)\n        if has_temp:\n            hover_text += f'Temperature: {format_value(row.get(\"Temperature\"), \".0f\")} K<br>'\n        else:\n            hover_text += f'Temperature: Unknown (displayed in gray)<br>'\n        \n        # Luminosity\n        hover_text += f'Luminosity: {format_value(row.get(\"Luminosity\"), \".6f\")} Lsun<br>'\n        \n        # Magnitudes\n        hover_text += f'Absolute Magnitude: {format_value(row.get(\"Abs_Mag\"), \".2f\")}<br>'\n        hover_text += f'Apparent Magnitude: {format_value(row.get(\"Apparent_Magnitude\"), \".2f\")}<br>'\n        \n        # Classifications\n        hover_text += f'Spectral Type: {format_value(row.get(\"Spectral_Type\"), \"\")}<br>'\n        hover_text += f'Stellar Class: {format_value(row.get(\"Stellar_Class\"), \"\")}<br>'\n        hover_text += f'Object Type: {format_value(row.get(\"Object_Type_Desc\"), \"\")}<br>'\n        \n        # Source info\n        hover_text += f'Source Catalog: {format_value(row.get(\"Source_Catalog\"), \"\")}<br>'\n        \n        # Marker size (if present)\n        if 'Marker_Size' in row.index:\n            hover_text += f'Marker Size: {format_value(row[\"Marker_Size\"], \".2f\")} px<br>'\n        \n        # 4. NOTE AT THE END (only if it's not the default \"None.\")\n        if note != \"None.\":\n            hover_text += f'<br>Note: {note}'\n\n        hover_text_list.append(hover_text)\n\n    return hover_text_list",
    "start_line": 30,
    "end_line": 117,
    "has_docstring": true,
    "docstring": "Create hover text with graceful handling of missing columns.",
    "parameters": [
      "df",
      "include_3d"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_hover_text",
    "component_id": "visualization_2d.create_hover_text"
  },
  "visualization_2d.prepare_2d_data": {
    "id": "visualization_2d.prepare_2d_data",
    "name": "prepare_2d_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_2d.py",
    "relative_path": "visualization_2d.py",
    "depends_on": [],
    "source_code": "def prepare_2d_data(combined_data):\n#    \"\"\"Prepare data specifically for 2D HR diagram plotting.\"\"\"\n\n    \"\"\"Prepare data for plotting.\"\"\"\n    combined_df = combined_data  # Just assign it directly\n    print(\"\\nPreparing data for visualization...\")\n\n    # Filter out stars with non-positive temperatures\n    combined_df = combined_df[combined_df['Temperature'] > 0].copy()\n\n    print(\"Parsing stellar classes...\")\n    def parse_luminosity_class(spectral_type):\n        if spectral_type is None or pd.isna(spectral_type):\n            return \"Unknown\"\n        match = re.search(r'([IV]+)', str(spectral_type))\n        if match:\n            luminosity_class = match.group(1)\n            return class_mapping.get(luminosity_class, luminosity_class)\n        return \"Unknown\"\n    \n    combined_df['Stellar_Class'] = combined_df['Spectral_Type'].apply(parse_luminosity_class)\n\n    print(\"Expanding object type descriptions...\")\n    def expand_object_type(ot):\n        if ot is None:\n            return 'Unknown'\n        ot_codes = re.split(r'[;, ]+', str(ot))\n        descriptions = []\n        for code in ot_codes:\n            if code in object_type_mapping:\n                desc = object_type_mapping[code]\n            else:\n                matched = False\n                for key in object_type_mapping:\n                    if key in code:\n                        desc = object_type_mapping[key]\n                        matched = True\n                        break\n                if not matched:\n                    desc = code\n            descriptions.append(desc)\n        return ', '.join(descriptions)\n\n    combined_df['Object_Type_Desc'] = combined_df['Object_Type'].apply(expand_object_type)\n\n    # Temperature normalization\n    temp_min = 1300\n    temp_max = 50000\n    combined_df['Temperature_Clipped'] = combined_df['Temperature'].clip(lower=temp_min, upper=temp_max)\n    combined_df['Temperature_Normalized'] = (combined_df['Temperature_Clipped'] - temp_min) / (temp_max - temp_min)\n\n    print(\"Calculating marker sizes...\")\n    def apparent_magnitude_to_size(app_mag, mag_min=-1.5, mag_max=8.5, size_min=2, size_max=24):\n        if app_mag is None or np.isnan(app_mag):\n            return size_min\n        app_mag_clipped = np.clip(app_mag, mag_min, mag_max)\n        log_brightness = -0.4 * app_mag_clipped\n        log_brightness_min = -0.4 * mag_max\n        log_brightness_max = -0.4 * mag_min\n        normalized_brightness = (log_brightness - log_brightness_min) / (log_brightness_max - log_brightness_min)\n        size = size_min + (size_max - size_min) * normalized_brightness\n        return np.clip(size, size_min, size_max)\n\n    combined_df['Marker_Size'] = combined_df['Apparent_Magnitude'].apply(apparent_magnitude_to_size)\n\n    print(\"Creating hover texts...\")\n    combined_df['Hover_Text'] = create_hover_text(combined_df, include_3d=False)\n    minimal_hover_texts = [f'<b>{row[\"Star_Name\"]}</b>' for _, row in combined_df.iterrows()]\n    combined_df['Min_Hover_Text'] = minimal_hover_texts\n    print(\"Data preparation complete.\")\n    \n    return combined_df",
    "start_line": 120,
    "end_line": 191,
    "has_docstring": true,
    "docstring": "Prepare data for plotting.",
    "parameters": [
      "combined_data"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function prepare_2d_data",
    "component_id": "visualization_2d.prepare_2d_data"
  },
  "visualization_2d.parse_luminosity_class": {
    "id": "visualization_2d.parse_luminosity_class",
    "name": "parse_luminosity_class",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_2d.py",
    "relative_path": "visualization_2d.py",
    "depends_on": [],
    "source_code": "    def parse_luminosity_class(spectral_type):\n        if spectral_type is None or pd.isna(spectral_type):\n            return \"Unknown\"\n        match = re.search(r'([IV]+)', str(spectral_type))\n        if match:\n            luminosity_class = match.group(1)\n            return class_mapping.get(luminosity_class, luminosity_class)\n        return \"Unknown\"",
    "start_line": 131,
    "end_line": 138,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "spectral_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parse_luminosity_class",
    "component_id": "visualization_2d.parse_luminosity_class"
  },
  "visualization_2d.expand_object_type": {
    "id": "visualization_2d.expand_object_type",
    "name": "expand_object_type",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_2d.py",
    "relative_path": "visualization_2d.py",
    "depends_on": [],
    "source_code": "    def expand_object_type(ot):\n        if ot is None:\n            return 'Unknown'\n        ot_codes = re.split(r'[;, ]+', str(ot))\n        descriptions = []\n        for code in ot_codes:\n            if code in object_type_mapping:\n                desc = object_type_mapping[code]\n            else:\n                matched = False\n                for key in object_type_mapping:\n                    if key in code:\n                        desc = object_type_mapping[key]\n                        matched = True\n                        break\n                if not matched:\n                    desc = code\n            descriptions.append(desc)\n        return ', '.join(descriptions)",
    "start_line": 143,
    "end_line": 161,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "ot"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function expand_object_type",
    "component_id": "visualization_2d.expand_object_type"
  },
  "visualization_2d.apparent_magnitude_to_size": {
    "id": "visualization_2d.apparent_magnitude_to_size",
    "name": "apparent_magnitude_to_size",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_2d.py",
    "relative_path": "visualization_2d.py",
    "depends_on": [],
    "source_code": "    def apparent_magnitude_to_size(app_mag, mag_min=-1.5, mag_max=8.5, size_min=2, size_max=24):\n        if app_mag is None or np.isnan(app_mag):\n            return size_min\n        app_mag_clipped = np.clip(app_mag, mag_min, mag_max)\n        log_brightness = -0.4 * app_mag_clipped\n        log_brightness_min = -0.4 * mag_max\n        log_brightness_max = -0.4 * mag_min\n        normalized_brightness = (log_brightness - log_brightness_min) / (log_brightness_max - log_brightness_min)\n        size = size_min + (size_max - size_min) * normalized_brightness\n        return np.clip(size, size_min, size_max)",
    "start_line": 172,
    "end_line": 181,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "app_mag",
      "mag_min",
      "mag_max",
      "size_min",
      "size_max"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function apparent_magnitude_to_size",
    "component_id": "visualization_2d.apparent_magnitude_to_size"
  },
  "visualization_2d.generate_footer_text": {
    "id": "visualization_2d.generate_footer_text",
    "name": "generate_footer_text",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_2d.py",
    "relative_path": "visualization_2d.py",
    "depends_on": [],
    "source_code": "def generate_footer_text(counts_dict, estimation_results=None, mag_limit=None, max_light_years=None):\n    \"\"\"Generate updated footer text including estimation information.\"\"\"\n    # Extract counts\n    hip_bright_count = counts_dict.get('hip_bright_count', 0)\n    hip_mid_count = counts_dict.get('hip_mid_count', 0)\n    gaia_mid_count = counts_dict.get('gaia_mid_count', 0)\n    gaia_faint_count = counts_dict.get('gaia_faint_count', 0)\n    total_stars = counts_dict.get('total_stars', 0)\n\n    # Get estimation results\n    if estimation_results is None:\n        estimation_results = counts_dict.get('estimation_results', {})\n\n    recovered_lum = estimation_results.get('recovered_lum', 0)\n    recovered_temp = estimation_results.get('recovered_temp', 0)\n    initial_missing_lum = estimation_results.get('initial_missing_lum', 0)\n    initial_missing_temp = estimation_results.get('initial_missing_temp', 0)\n    final_missing_lum = estimation_results.get('final_missing_lum', 0)\n    final_missing_temp = estimation_results.get('final_missing_temp', 0)\n\n    if mag_limit is not None:\n        footer_text = (\n            \"     The Hertzsprung-Russell (H-R) diagram is a fundamental tool in astrophysics that graphically represents the \"\n            \"relationship between a star's surface temperature and its luminosity (intrinsic brightness). The H-R diagram illustrates the life \"\n            \"cycles of stars. As stars age, they move to different<br>regions on the diagram, providing insights into their evolutionary stages.<br>\"\n\n            f\"     We are plotting stars with apparent magnitude (Vmag) <= <span style='color:red;'>{mag_limit}</span>. \" \n   \n            \"* Star properties from <a href='https://simbad.u-strasbg.fr/simbad/'>Simbad</a>. \"\n            \"Temperature was estimated using B-V color index, spectral type, or <a href='https://www.cosmos.esa.int/gaia' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Gaia</a> BP-RP color. \"\n            \"Luminosity was estimated using apparent<br>magnitude, distance, and extinction correction. \"\n            \n            \"Marker size indicates apparent magnitude (except Sun), temperature (Kelvin) decreases right on x-axis, \"\n            \"and luminosity (Lsun) is on y-axis. \"\n            \"<a href='https://en.wikipedia.org/wiki/Stellar_classification'>Harvard classification</a> \"\n            \"spectral types shown in colored bands. \"\n            \n    #        \"<br>-- Python script by Tony Quintanilla, with assistance from ChatGPT and Claude, Updated November 2024.\"\n        )\n\n    elif max_light_years is not None:\n        footer_text = (\n\n            \"     The Hertzsprung-Russell (H-R) diagram is a fundamental tool in astrophysics that graphically represents the \"\n            \"relationship between a star's surface temperature and its luminosity (intrinsic brightness). The H-R diagram illustrates the life \"\n            \"cycles of stars. As stars age, they move to different<br>regions on the diagram, providing insights into their evolutionary stages.<br>\"\n\n            f\"     This H-R diagram shows {total_stars:,d} <a href='https://en.wikipedia.org/wiki/List_of_nearest_stars'>stars</a> within \"\n            f\"<span style='background-color: red; color: red'>{int(max_light_years)}</span> light-years of the Sun. \"\n            \"Temperature is plotted on the x-axis (decreasing to the right), \"\n            \"and Luminosity in solar units on the y-axis. \"\n            \"Temperatures are calculated using B-V color indices when available. \"\n            \"The B-V color index provides<br>a quantitative measure of a star's color, which is directly related to its surface temperature. \"\n            \"Otherwise temperature is estimated from spectral types. \"\n            \"Star properties retrieved from the <a href='https://simbad.u-strasbg.fr/simbad/'>Simbad</a> database. \"\n            \"<a href='https://en.wikipedia.org/wiki/Stellar_classification'>Harvard Stellar classification</a> by spectral \"\n            \"types L through B.\"\n    #        \"-- Python script by Tony Quintanilla, with assistance from ChatGPT and Claude, November 2024.\"\n        )\n\n    else:\n        footer_text = 'No additional information provided.'\n        \n    return footer_text",
    "start_line": 193,
    "end_line": 256,
    "has_docstring": true,
    "docstring": "Generate updated footer text including estimation information.",
    "parameters": [
      "counts_dict",
      "estimation_results",
      "mag_limit",
      "max_light_years"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate_footer_text",
    "component_id": "visualization_2d.generate_footer_text"
  },
  "visualization_2d.create_hr_diagram": {
    "id": "visualization_2d.create_hr_diagram",
    "name": "create_hr_diagram",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_2d.py",
    "relative_path": "visualization_2d.py",
    "depends_on": [
      "visualization_2d.generate_footer_text",
      "visualization_core.generate_star_count_text",
      "save_utils.save_plot",
      "visualization_utils.add_hover_toggle_buttons"
    ],
    "source_code": "def create_hr_diagram(combined_df, counts_dict, mag_limit=None, max_light_years=None):\n    \"\"\"Create HR diagram for either magnitude or distance-based data.\"\"\"\n\n    \"\"\"\n    Create and display the Hertzsprung-Russell (HR) diagram.\n\n    Parameters:\n        combined_df (pandas DataFrame): The data prepared for plotting.\n        hover_text_list (list): List of hover text strings for each star.\n        mag_limit (float): The upper limit of the apparent magnitude.\n        counts_dict (dict): Dictionary containing counts of stars in different categories.\n\n    Returns:\n        None\n    \"\"\"\n    # Define temperature-based colors\n    print(\"Defining color scales...\")\n\n    temperature_colors = {\n        1300: 'rgb(255, 0, 0)',        # Red for L\n        2400: 'rgb(255, 0, 0)',        # Red for M\n        3700: 'rgb(255, 165, 0)',      # Orange for K\n        5200: 'rgb(255, 255, 0)',      # Yellow for G\n        6000: 'rgb(255, 255, 255)',    # White for F\n        7500: 'rgb(173, 216, 230)',    # Light Blue for A\n        10000: 'rgb(0, 0, 255)',       # Blue for B\n        30000: 'rgb(0, 0, 139)',       # Dark Blue for O\n        50000: 'rgb(75, 0, 130)',      # Indigo for upper O limit\n    }\n\n    # Create colorscale\n    temp_min = 1300\n    temp_max = 50000\n    colorscale = [\n        [(temp - temp_min) / (temp_max - temp_min), color]\n        for temp, color in sorted(temperature_colors.items())\n    ]\n\n    # Define spectral ranges with temperature bounds and colors\n    spectral_ranges = [\n        {'type': 'O', 'temp_min': 30000, 'temp_max': 50000, 'color': 'rgba(75, 0, 130, 0.2)'},\n        {'type': 'B', 'temp_min': 10000, 'temp_max': 30000, 'color': 'rgba(0, 0, 255, 0.2)'},\n        {'type': 'A', 'temp_min': 7500,  'temp_max': 10000, 'color': 'rgba(173, 216, 230, 0.2)'},\n        {'type': 'F', 'temp_min': 6000,  'temp_max': 7500,  'color': 'rgba(255, 255, 255, 0.2)'},\n        {'type': 'G', 'temp_min': 5200,  'temp_max': 6000,  'color': 'rgba(255, 255, 0, 0.2)'},\n        {'type': 'K', 'temp_min': 3700,  'temp_max': 5200,  'color': 'rgba(255, 165, 0, 0.2)'},\n        {'type': 'M', 'temp_min': 2400,  'temp_max': 3700,  'color': 'rgba(255, 0, 0, 0.2)'},\n        {'type': 'L', 'temp_min': 1300,  'temp_max': 2400,  'color': 'rgba(255, 0, 0, 0.1)'}\n    ]\n\n    # Create plot\n    print(\"Creating HR diagram...\")\n\n    fig = go.Figure()\n\n    # Plot stars for each catalog separately\n    for catalog in ['Hipparcos', 'Gaia']:\n        catalog_data = combined_df[combined_df['Source_Catalog'] == catalog]\n        \n        # More comprehensive debug\n        print(f\"\\nProcessing {catalog}: {len(catalog_data)} stars\")\n        \n        if catalog == 'Hipparcos':\n            # Check if Mizar is in combined_df at all\n            mizar_in_combined = combined_df[combined_df['HIP'] == 65378]\n            print(f\"Mizar in combined_df: {len(mizar_in_combined)} entries\")\n            if len(mizar_in_combined) > 0:\n                print(f\"  Source_Catalog: {mizar_in_combined['Source_Catalog'].iloc[0]}\")\n            \n            # Check if Mizar is in the filtered catalog_data\n            mizar = catalog_data[catalog_data['HIP'] == 65378]\n            print(f\"Mizar in Hipparcos subset: {len(mizar)} entries\")\n            \n            if len(mizar) > 0:\n                print(f\"\\nMizar plotting properties:\")\n                print(f\"  Temperature: {mizar['Temperature'].iloc[0]}\")\n                print(f\"  Luminosity: {mizar['Luminosity'].iloc[0]}\")\n                print(f\"  Marker_Size: {mizar['Marker_Size'].iloc[0]}\")\n                print(f\"  Temperature_Normalized: {mizar['Temperature_Normalized'].iloc[0]}\")\n                print(f\"  Hover_Text exists: {pd.notna(mizar['Hover_Text'].iloc[0])}\")\n                print(f\"  Min_Hover_Text exists: {pd.notna(mizar['Min_Hover_Text'].iloc[0])}\")\n            else:\n                print(\"WARNING: Mizar NOT in Hipparcos trace!\")\n        \n        fig.add_trace(go.Scatter(\n            x=catalog_data['Temperature'],  # Remove log transform here\n            y=catalog_data['Luminosity'],\n            mode='markers',\n            marker=dict(\n                size=catalog_data['Marker_Size'],\n                color=catalog_data['Temperature_Normalized'],\n                colorscale=colorscale,\n                cmin=0,\n                cmax=1,\n\n        #        colorbar=dict(\n        #            title='Temperature (K)',\n        #            tickmode='array',\n        #            tickvals=[\n        #                (temp - temp_min) / (temp_max - temp_min)\n        #                for temp in sorted(temperature_colors.keys())\n        #            ],\n        #            ticktext=[f'{temp:,}' for temp in sorted(temperature_colors.keys())],\n        #            tickfont=dict(color='white'),\n        #            titlefont=dict(color='white')\n\n                colorbar=dict(\n                    title=dict(text='Temperature (K)', font=dict(color='white')),\n                    tickmode='array',\n                    tickvals=[\n                        (temp - temp_min) / (temp_max - temp_min)\n                        for temp in sorted(temperature_colors.keys())\n                    ],\n                    ticktext=[f'{temp:,}' for temp in sorted(temperature_colors.keys())],\n                    tickfont=dict(color='white')\n        #        )\n\n                ) if catalog == 'Hipparcos' else None,\n                showscale=(catalog == 'Hipparcos'),\n            ),\n            text=catalog_data['Hover_Text'],\n            customdata=catalog_data['Min_Hover_Text'], # Add this line\n            hovertemplate='%{text}<extra></extra>',\n            name=catalog,\n            showlegend=True\n        ))\n\n    # Add spectral type annotations\n    fig.add_annotation(\n        x=0.5,\n        y=1.10,\n        text='Spectral Type:',\n        showarrow=False,\n        xref='paper',\n        yref='paper',\n        xanchor='center',\n        yanchor='bottom',\n        font=dict(color='white', size=14)\n    )\n\n    # Define fixed ranges for axes\n    x_range = [np.log10(50000), np.log10(1300)]  # Temperature range\n    y_range = [-6, 7]  # Luminosity range from Lsun 0.000001 to 10,000,000\n\n    # Define explicit positions for spectral type labels\n    label_positions_paper = {\n        'O': 0.08,\n        'B': 0.30,\n        'A': 0.485,\n        'F': 0.555,\n        'G': 0.60,\n        'K': 0.67,\n        'M': 0.77,\n        'L': 0.92,\n    }\n\n    # Update the spectral type bands\n    for s_range in spectral_ranges:\n        fig.add_shape(\n            type=\"rect\",\n            xref='x',\n            yref='paper',\n            x0=s_range['temp_max'],  # Remove log transform\n            x1=s_range['temp_min'],  # Remove log transform\n            y0=0,\n            y1=1,\n            fillcolor=s_range['color'],\n            opacity=0.65,\n            line_width=0,\n            layer='below'\n        )\n\n        # Add label using paper coordinates\n        x_paper = label_positions_paper[s_range['type']]\n        fig.add_annotation(\n            x=x_paper,\n            y=1.02,\n            text=s_range['type'],\n            showarrow=False,\n            xref='paper',\n            yref='paper',\n            font=dict(color='white', size=12),\n            align='center',\n            yanchor='bottom',\n            xanchor='center',\n        )\n\n# Determine the title based on the provided parameters\n    if mag_limit is not None:\n        title_text = f'Hertzsprung-Russell Diagram of Unaided-Eye Visible Stars (Apparent Magnitude <= {mag_limit})'\n    elif max_light_years is not None:\n#        title_text = f'Hertzsprung-Russell Diagram of Stars within {int(max_light_years)} Light-Years'\n        title_text = f'Hertzsprung-Russell Diagram of Stars within {max_light_years:.1f} Light-Years'        \n    else:\n        title_text = 'Hertzsprung-Russell Diagram'\n\n    # Update the plot title\n    fig.update_layout(\n        title=dict(\n            text=title_text,\n            x=0.5,\n            y=0.95,\n            xanchor='center',\n            yanchor='top',\n            font=dict(color='white', size=20)\n        ),\n\n    # Restore the xaxis configuration\n    xaxis=dict(\n        title='Temperature (K)',\n#        autorange='reversed',  # This is key for proper temperature display\n        type='log',\n        color='white',\n#        range=x_range,\n        range=[np.log10(50000), np.log10(1300)],  # Explicitly set range\n        tickmode='array',\n        tickvals=[50000, 30000, 10000, 7500, 6000, 5200, 3700, 2400, 1300],\n        ticktext=['50,000', '30,000', '10,000', '7,500', '6,000', '5,200', '3,700', '2,400', '1,300'],\n    ),\n\n        yaxis=dict(\n            title='Luminosity (Lsun)',\n            type='log',\n            color='white',\n            range=y_range,\n        ),\n        paper_bgcolor='black',\n        plot_bgcolor='black',\n        font=dict(color='white'),\n        showlegend=True,\n        legend=dict(\n            orientation='h',\n            yanchor='bottom',\n            y=1.08,\n            xanchor='right',\n            x=1\n        ),\n        margin=dict(t=125, b=155),\n    )\n\n    # Add the labels (if stellar_class_labels is defined in constants_new)\n    for label in stellar_class_labels:\n        fig.add_annotation(\n            x=label['x'],\n            y=label['y'],\n            text=label['text'],\n            showarrow=False,\n            xref='paper',\n            yref='y',\n            font=label['font'],  # Use the font from the dictionary\n            textangle=label.get('rotation', 0),\n            align='left'\n        )\n\n    # Update Sun position\n    sun_minimal_hover_text = '<b>Sun</b>'  # Create minimal hover text for the Sun\n    fig.add_trace(go.Scatter(\n        x=[5778],  # Remove log transform\n        y=[1],\n        mode='markers',\n        marker=dict(\n            size=14,\n            symbol='circle',\n            color='rgb(102, 187, 106)',\n            line=dict(color='white', width=1),\n        ),\n        text=[hover_text_sun],\n        customdata=[sun_minimal_hover_text],  # Add customdata for the Sun\n        hovertemplate='%{text}<extra></extra>',\n        name='Sun',\n        showlegend=True,\n    ))\n\n    # Prepare footer text using counts_dict\n    print(\"Preparing footer text...\")\n\n    # Extract counts from counts_dict\n    hip_bright_count = counts_dict.get('hip_bright_count', 0)\n    hip_mid_count = counts_dict.get('hip_mid_count', 0)\n    gaia_mid_count = counts_dict.get('gaia_mid_count', 0)\n    gaia_faint_count = counts_dict.get('gaia_faint_count', 0)\n    total_stars = hip_bright_count + hip_mid_count + gaia_mid_count + gaia_faint_count\n\n    # Compute plottable and missing stars\n    plottable_mask = ~np.isnan(combined_df['Temperature']) & ~np.isnan(combined_df['Luminosity'])\n    plottable_count = plottable_mask.sum()\n    missing_stars = total_stars - plottable_count\n\n    # Additional counts from counts_dict\n    source_counts = counts_dict.get('source_counts', {\n        'bv_matched': 0,\n        'bv_only': 0,\n        'spectral_type_hot': 0,\n        'spectral_type_cool': 0,\n        'spectral_type_only': 0,\n        'spectral_type_disagreement': 0,\n        'none': 0\n    })\n\n    missing_temp_only = source_counts['none']\n    missing_lum_only = missing_stars - missing_temp_only  # Simplified for this context\n    missing_both = 0  # Adjust according to your data\n\n    # Generate the star count text\n    star_count_text = generate_star_count_text(counts_dict, combined_df)\n\n    footer_text = generate_footer_text(\n        counts_dict,\n        estimation_results=counts_dict.get('estimation_results'),\n        mag_limit=mag_limit,\n        max_light_years=max_light_years\n    )\n\n    # Combine both texts\n    full_footer_text = footer_text + star_count_text\n\n    # Add footer annotation\n    fig.add_annotation(\n        text=full_footer_text,\n        align='left',\n        showarrow=False,\n        xref='paper',\n        yref='paper',\n        x=-0.05,\n        y=-0.15,\n        xanchor='left',\n        yanchor='top',\n        font=dict(size=10, color='white')\n    )\n\n    # Instead of just showing the plot, offer save options\n    default_name = (\n        f\"hr_diagram_magnitude_{mag_limit}\" if mag_limit is not None\n        else f\"hr_diagram_distance_{max_light_years}ly\"\n    )\n\n# Add hover toggle buttons\n    fig = add_hover_toggle_buttons(fig)\n\n    # Save and offer save options\n    default_name = (\n        f\"hr_diagram_magnitude_{mag_limit}\" if mag_limit is not None\n        else f\"hr_diagram_distance_{max_light_years}ly\"\n    )\n    save_plot(fig, default_name)\n    \n    # Render the plot\n    print(\"Rendering plot...\")\n    fig.show()",
    "start_line": 258,
    "end_line": 606,
    "has_docstring": true,
    "docstring": "Create HR diagram for either magnitude or distance-based data.",
    "parameters": [
      "combined_df",
      "counts_dict",
      "mag_limit",
      "max_light_years"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_hr_diagram",
    "component_id": "visualization_2d.create_hr_diagram"
  },
  "visualization_3d.parse_stellar_classes": {
    "id": "visualization_3d.parse_stellar_classes",
    "name": "parse_stellar_classes",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_3d.py",
    "relative_path": "visualization_3d.py",
    "depends_on": [],
    "source_code": "def parse_stellar_classes(df):\n    \"\"\"Parse stellar classes from spectral types.\"\"\"\n    def parse_luminosity_class(spectral_type):\n        if spectral_type is None or pd.isna(spectral_type):\n            return \"Unknown\"\n        match = re.search(r'([IV]+)', str(spectral_type))\n        if match:\n            luminosity_class = match.group(1)\n            return class_mapping.get(luminosity_class, luminosity_class)\n        return \"Unknown\"\n    \n    df['Stellar_Class'] = df['Spectral_Type'].apply(parse_luminosity_class)\n    return df",
    "start_line": 24,
    "end_line": 36,
    "has_docstring": true,
    "docstring": "Parse stellar classes from spectral types.",
    "parameters": [
      "df"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parse_stellar_classes",
    "component_id": "visualization_3d.parse_stellar_classes"
  },
  "visualization_3d.parse_luminosity_class": {
    "id": "visualization_3d.parse_luminosity_class",
    "name": "parse_luminosity_class",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_3d.py",
    "relative_path": "visualization_3d.py",
    "depends_on": [],
    "source_code": "    def parse_luminosity_class(spectral_type):\n        if spectral_type is None or pd.isna(spectral_type):\n            return \"Unknown\"\n        match = re.search(r'([IV]+)', str(spectral_type))\n        if match:\n            luminosity_class = match.group(1)\n            return class_mapping.get(luminosity_class, luminosity_class)\n        return \"Unknown\"",
    "start_line": 26,
    "end_line": 33,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "spectral_type"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function parse_luminosity_class",
    "component_id": "visualization_3d.parse_luminosity_class"
  },
  "visualization_3d.expand_object_type": {
    "id": "visualization_3d.expand_object_type",
    "name": "expand_object_type",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_3d.py",
    "relative_path": "visualization_3d.py",
    "depends_on": [],
    "source_code": "def expand_object_type(ot):\n    \"\"\"Expand object type codes to full descriptions.\"\"\"\n    if ot is None or pd.isna(ot):\n        return 'Unknown'\n    ot_codes = re.split(r'[;, ]+', str(ot))\n    descriptions = []\n    for code in ot_codes:\n        code = code.strip()\n        if code in object_type_mapping:\n            desc = object_type_mapping[code]\n        else:\n            # Try partial matching\n            matched = False\n            for key in object_type_mapping:\n                if key in code:\n                    desc = object_type_mapping[key]\n                    matched = True\n                    break\n            if not matched:\n                desc = code\n        descriptions.append(desc)\n    return ', '.join(descriptions)",
    "start_line": 38,
    "end_line": 59,
    "has_docstring": true,
    "docstring": "Expand object type codes to full descriptions.",
    "parameters": [
      "ot"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function expand_object_type",
    "component_id": "visualization_3d.expand_object_type"
  },
  "visualization_3d.prepare_3d_data": {
    "id": "visualization_3d.prepare_3d_data",
    "name": "prepare_3d_data",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_3d.py",
    "relative_path": "visualization_3d.py",
    "depends_on": [
      "visualization_3d.parse_stellar_classes"
    ],
    "source_code": "def prepare_3d_data(combined_df, max_value, counts, mode=None):\n    \"\"\"Prepare data for 3D visualization with proper handling of Messier objects.\"\"\"\n    print(\"\\nPreparing data for 3D visualization...\")\n    \n    # Create mask for Messier objects based on Source_Catalog\n    messier_mask = combined_df['Source_Catalog'] == 'Messier'\n    \n    # Remove any duplicate Messier objects that might be in the stellar data\n    stellar_objects = combined_df[~messier_mask].copy()\n    stellar_objects = stellar_objects[\n        ~stellar_objects['Star_Name'].str.contains('M[0-9]+:', na=False)\n    ]    \n    # Print diagnostic information\n    print(f\"\\nData composition before separation:\")\n    print(f\"Total objects: {len(combined_df)}\")\n    print(f\"Messier objects: {messier_mask.sum()}\")\n    print(f\"Stellar objects: {(~messier_mask).sum()}\")\n    \n    # Separate Messier objects from stars\n    messier_objects = combined_df[messier_mask].copy() if messier_mask.any() else pd.DataFrame()\n    stellar_objects = combined_df[~messier_mask].copy()\n\n    # Parse stellar classes to get descriptions\n    stellar_objects = parse_stellar_classes(stellar_objects)\n    \n    # Expand object types to get descriptions  \n    stellar_objects['Object_Type_Desc'] = stellar_objects['Object_Type'].apply(expand_object_type)\n    \n    # Process stellar objects - include ALL stars for spatial completeness\n    plottable_stars = stellar_objects.copy()  # Use all stars\n\n    # Track which stars have temperature data\n    has_temp = ~pd.isna(plottable_stars['Temperature']) & (plottable_stars['Temperature'] > 0)\n\n    print(f\"\\nProcessing stellar objects:\")\n    print(f\"Total stars: {len(stellar_objects)}\")\n    print(f\"Stars with temperature: {has_temp.sum()}\")\n    print(f\"Stars without temperature: {(~has_temp).sum()}\")\n\n    # Temperature normalization ONLY for stars with temperature\n    temp_min = 1300\n    temp_max = 50000\n\n    # Create normalized temperature, keep NaN for missing values\n    plottable_stars['Temperature_Clipped'] = plottable_stars['Temperature'].clip(lower=temp_min, upper=temp_max)\n    plottable_stars['Temperature_Normalized'] = (plottable_stars['Temperature_Clipped'] - temp_min) / (temp_max - temp_min)\n\n    # Add flag for hover text and color assignment\n    plottable_stars['Has_Temperature'] = has_temp\n\n    # Calculate marker sizes based on apparent magnitude\n    def calculate_marker_size(app_mag, is_messier=False):\n        if is_messier:\n            return 20  # Fixed size for Messier objects\n        if pd.isna(app_mag):\n            return 2\n        mag_min, mag_max = -1.44, 9\n        size_min, size_max = 2, 24\n        app_mag_clipped = np.clip(app_mag, mag_min, mag_max)\n        log_brightness = -0.4 * app_mag_clipped\n        log_brightness_min = -0.4 * mag_max\n        log_brightness_max = -0.4 * mag_min\n        normalized_brightness = (log_brightness - log_brightness_min) / (log_brightness_max - log_brightness_min)\n        return np.clip(size_min + (size_max - size_min) * normalized_brightness, size_min, size_max)\n    \n    plottable_stars['Marker_Size'] = plottable_stars['Apparent_Magnitude'].apply(\n        lambda x: calculate_marker_size(x, False)\n    )\n    \n    # Create hover text for stars\n    plottable_stars['Hover_Text'] = create_hover_text(plottable_stars, include_3d=True)\n    plottable_stars['Min_Hover_Text'] = plottable_stars['Star_Name'].apply(\n        lambda name: f'<b>{name}</b>'\n    )\n    \n    # Process Messier objects if present\n    if not messier_objects.empty:\n        print(f\"\\nProcessing {len(messier_objects)} Messier objects\")\n        \n        # Set fixed properties for Messier objects\n        messier_objects['Temperature_Normalized'] = 0.07  # This is 7% in the color scale, about yellow or white\n        messier_objects['Marker_Size'] = 30  # Fixed size\n        messier_objects['Source_Catalog'] = 'Messier'  # Ensure this is set\n                \n        # Check for missing coordinates\n        missing_coords = messier_objects[pd.isna(messier_objects['x']) | \n                                       pd.isna(messier_objects['y']) | \n                                       pd.isna(messier_objects['z'])]\n        if not missing_coords.empty:\n            print(\"\\nWarning: Some Messier objects have missing coordinates:\")\n            for _, obj in missing_coords.iterrows():\n                print(f\"  {obj['Star_Name']}\")\n        else:\n            print(\"All Messier objects have valid coordinates\")\n        \n        # Combine plottable stars and Messier objects\n        plottable_df = pd.concat([plottable_stars, messier_objects], ignore_index=True)\n        print(f\"\\nFinal dataset:\")\n        print(f\"Stars: {len(plottable_stars)}\")\n        print(f\"Messier objects: {len(messier_objects)}\")\n        print(f\"Total: {len(plottable_df)}\")\n    else:\n        plottable_df = plottable_stars\n        print(\"\\nNo Messier objects to process\")\n    \n    # Add metadata\n    plottable_df.attrs['mode'] = mode\n    plottable_df.attrs['max_value'] = max_value\n    \n    return plottable_df",
    "start_line": 61,
    "end_line": 170,
    "has_docstring": true,
    "docstring": "Prepare data for 3D visualization with proper handling of Messier objects.",
    "parameters": [
      "combined_df",
      "max_value",
      "counts",
      "mode"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function prepare_3d_data",
    "component_id": "visualization_3d.prepare_3d_data"
  },
  "visualization_3d.calculate_marker_size": {
    "id": "visualization_3d.calculate_marker_size",
    "name": "calculate_marker_size",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_3d.py",
    "relative_path": "visualization_3d.py",
    "depends_on": [],
    "source_code": "    def calculate_marker_size(app_mag, is_messier=False):\n        if is_messier:\n            return 20  # Fixed size for Messier objects\n        if pd.isna(app_mag):\n            return 2\n        mag_min, mag_max = -1.44, 9\n        size_min, size_max = 2, 24\n        app_mag_clipped = np.clip(app_mag, mag_min, mag_max)\n        log_brightness = -0.4 * app_mag_clipped\n        log_brightness_min = -0.4 * mag_max\n        log_brightness_max = -0.4 * mag_min\n        normalized_brightness = (log_brightness - log_brightness_min) / (log_brightness_max - log_brightness_min)\n        return np.clip(size_min + (size_max - size_min) * normalized_brightness, size_min, size_max)",
    "start_line": 112,
    "end_line": 124,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "app_mag",
      "is_messier"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function calculate_marker_size",
    "component_id": "visualization_3d.calculate_marker_size"
  },
  "visualization_3d.format_value": {
    "id": "visualization_3d.format_value",
    "name": "format_value",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_3d.py",
    "relative_path": "visualization_3d.py",
    "depends_on": [],
    "source_code": "def format_value(value, format_spec, default=\"Unknown\"):\n    \"\"\"\n    Format a value using Python's built-in format function.\n    \n    Parameters:\n        value: The value to format\n        format_spec (str): Format specification (e.g., \".2f\", \".0f\", etc.)\n        default (str): Default value to return if formatting fails\n        \n    Returns:\n        str: The formatted value or default string if formatting fails\n    \"\"\"\n    if value is None or (isinstance(value, float) and np.isnan(value)):\n        return default\n    try:\n        # Use Python's built-in format function which correctly handles format specs\n        return format(value, format_spec)\n    except (ValueError, TypeError):\n        return default",
    "start_line": 172,
    "end_line": 190,
    "has_docstring": true,
    "docstring": "Format a value using Python's built-in format function.\n\nParameters:\n    value: The value to format\n    format_spec (str): Format specification (e.g., \".2f\", \".0f\", etc.)\n    default (str): Default value to return if formatting fails\n    \nReturns:\n    str: The formatted value or default string if formatting fails",
    "parameters": [
      "value",
      "format_spec",
      "default"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function format_value",
    "component_id": "visualization_3d.format_value"
  },
  "visualization_3d.create_hover_text": {
    "id": "visualization_3d.create_hover_text",
    "name": "create_hover_text",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_3d.py",
    "relative_path": "visualization_3d.py",
    "depends_on": [
      "visualization_3d.format_value"
    ],
    "source_code": "def create_hover_text(df, include_3d=False):\n    \"\"\"Create hover text with graceful handling of missing columns.\"\"\"\n    hover_text_list = []\n\n    for _, row in df.iterrows():\n        star_name = row[\"Star_Name\"]\n        note = unique_notes.get(star_name, \"None.\")\n\n        # Get distance values, defaulting to NaN\n        distance_pc = row.get('Distance_pc', np.nan)\n        distance_ly = row.get('Distance_ly', np.nan)\n\n        # Calculate ly if missing but we have pc\n        if pd.isna(distance_ly) and pd.notna(distance_pc):\n            distance_ly = distance_pc * 3.26156\n\n        # Format distance strings, handling NaN explicitly\n        pc_str = f\"{distance_pc:.2f}\" if pd.notna(distance_pc) else \"Unknown\"\n        ly_str = f\"{distance_ly:.2f}\" if pd.notna(distance_ly) else \"Unknown\"\n\n        # ========== BUILD HOVER TEXT WITH CLEANER LAYOUT ==========\n        \n        # 1. STAR NAME (no extra line break after)\n        hover_text = f'<b>{star_name}</b><br>'\n        \n        # 2. RA/DEC (right after name)\n        # Try pre-computed strings first\n        if 'ra_str' in row and row.get('ra_str'):\n            ra_str = str(row['ra_str']).strip()\n            dec_str = str(row['dec_str']).strip()\n            if ra_str and ra_str.lower() not in ['nan', 'none', '']:\n                hover_text += f\"RA: {ra_str}, Dec: {dec_str} (J2000)<br>\"\n        # Otherwise convert from ICRS coordinates\n        elif 'RA_ICRS' in row and pd.notna(row.get('RA_ICRS')):\n            ra_deg = float(row['RA_ICRS'])\n            dec_deg = float(row['DE_ICRS'])\n            \n            # Convert RA to hours:minutes:seconds\n            ra_hours = ra_deg / 15.0\n            ra_h = int(ra_hours)\n            ra_m = int((ra_hours - ra_h) * 60)\n            ra_s = ((ra_hours - ra_h) * 60 - ra_m) * 60\n            \n            # Convert Dec to degrees:arcminutes:arcseconds\n            dec_sign = '+' if dec_deg >= 0 else '-'\n            dec_abs = abs(dec_deg)\n            dec_d = int(dec_abs)\n            dec_m = int((dec_abs - dec_d) * 60)\n            dec_s = ((dec_abs - dec_d) * 60 - dec_m) * 60\n            \n            hover_text += f\"RA: {ra_h:02d}h {ra_m:02d}m {ra_s:05.2f}s, Dec: {dec_sign}{dec_d:02d} deg {dec_m:02d}' {dec_s:04.1f}\\\" (J2000)<br>\"\n        \n        # 3. MAIN PROPERTIES (in logical order)\n        hover_text += f'Distance: {pc_str} pc ({ly_str} ly)<br>'\n        \n        # Temperature\n        has_temp = row.get('Has_Temperature', True)\n        if has_temp:\n            hover_text += f'Temperature: {format_value(row.get(\"Temperature\"), \".0f\")} K<br>'\n        else:\n            hover_text += f'Temperature: Unknown (displayed in gray)<br>'\n        \n        # Luminosity\n        hover_text += f'Luminosity: {format_value(row.get(\"Luminosity\"), \".6f\")} Lsun<br>'\n        \n        # Magnitudes\n        hover_text += f'Absolute Magnitude: {format_value(row.get(\"Abs_Mag\"), \".2f\")}<br>'\n        hover_text += f'Apparent Magnitude: {format_value(row.get(\"Apparent_Magnitude\"), \".2f\")}<br>'\n        \n        # Classifications\n        hover_text += f'Spectral Type: {format_value(row.get(\"Spectral_Type\"), \"\")}<br>'\n        hover_text += f'Stellar Class: {format_value(row.get(\"Stellar_Class\"), \"\")}<br>'\n        hover_text += f'Object Type: {format_value(row.get(\"Object_Type_Desc\"), \"\")}<br>'\n        \n        # Source info\n        hover_text += f'Source Catalog: {format_value(row.get(\"Source_Catalog\"), \"\")}<br>'\n        \n        # Marker size (if present)\n        if 'Marker_Size' in row.index:\n            hover_text += f'Marker Size: {format_value(row[\"Marker_Size\"], \".2f\")} px<br>'\n        \n        # 4. NOTE AT THE END (only if it's not the default \"None.\")\n        if note != \"None.\":\n            hover_text += f'<br>Note: {note}'\n\n        hover_text_list.append(hover_text)\n\n    return hover_text_list",
    "start_line": 194,
    "end_line": 281,
    "has_docstring": true,
    "docstring": "Create hover text with graceful handling of missing columns.",
    "parameters": [
      "df",
      "include_3d"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_hover_text",
    "component_id": "visualization_3d.create_hover_text"
  },
  "visualization_3d.create_hover_text_old": {
    "id": "visualization_3d.create_hover_text_old",
    "name": "create_hover_text_old",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_3d.py",
    "relative_path": "visualization_3d.py",
    "depends_on": [
      "visualization_3d.format_value"
    ],
    "source_code": "def create_hover_text_old(df, include_3d=False):\n    \"\"\"Create hover text with graceful handling of missing columns.\"\"\"\n    hover_text_list = []\n\n    for _, row in df.iterrows():\n        star_name = row[\"Star_Name\"]\n        note = unique_notes.get(star_name, \"None.\")\n\n        # Get distance values, defaulting to NaN (ASSIGN THESE FIRST)\n        distance_pc = row.get('Distance_pc', np.nan)\n        distance_ly = row.get('Distance_ly', np.nan)\n\n        # Calculate ly if missing but we have pc\n        if pd.isna(distance_ly) and pd.notna(distance_pc):\n            distance_ly = distance_pc * 3.26156\n\n        # Format distance strings, handling NaN explicitly\n        pc_str = f\"{distance_pc:.2f}\" if pd.notna(distance_pc) else \"Unknown\"\n        ly_str = f\"{distance_ly:.2f}\" if pd.notna(distance_ly) else \"Unknown\"\n\n        # Build the hover_text string incrementally using concatenation\n        hover_text = f'<b>{star_name}</b><br><br>'\n        hover_text += f'{note}<br><br>'\n        hover_text += f'Distance: {pc_str} pc ({ly_str} ly)<br>'\n        hover_text += f'Object Type: {format_value(row.get(\"Object_Type_Desc\"), \"\")}<br>'\n        hover_text += f'Stellar Class: {format_value(row.get(\"Stellar_Class\"), \"\")}<br>'\n        \n        # Handle temperature with special message for stars without temperature data\n        has_temp = row.get('Has_Temperature', True)  # Default to True for backward compatibility\n        if has_temp:\n            hover_text += f'Temperature: {format_value(row.get(\"Temperature\"), \".0f\")} K<br>'\n        else:\n            hover_text += f'Temperature: Unknown (displayed in gray)<br>'\n        \n        hover_text += f'Luminosity: {format_value(row.get(\"Luminosity\"), \".6f\")} Lsun<br>'\n        hover_text += f'Absolute Magnitude: {format_value(row.get(\"Abs_Mag\"), \".2f\")}<br>'\n        hover_text += f'Apparent Magnitude: {format_value(row.get(\"Apparent_Magnitude\"), \".2f\")}<br>'\n        hover_text += f'Spectral Type: {format_value(row.get(\"Spectral_Type\"), \"\")}<br>'\n        hover_text += f'Source Catalog: {format_value(row.get(\"Source_Catalog\"), \"\")}<br>'\n\n        if 'Marker_Size' in row.index:\n            hover_text += f'<br>Marker Size: {format_value(row[\"Marker_Size\"], \".2f\")} px'\n\n        hover_text_list.append(hover_text)\n\n    return hover_text_list",
    "start_line": 283,
    "end_line": 328,
    "has_docstring": true,
    "docstring": "Create hover text with graceful handling of missing columns.",
    "parameters": [
      "df",
      "include_3d"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_hover_text_old",
    "component_id": "visualization_3d.create_hover_text_old"
  },
  "visualization_3d.create_notable_stars_list": {
    "id": "visualization_3d.create_notable_stars_list",
    "name": "create_notable_stars_list",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_3d.py",
    "relative_path": "visualization_3d.py",
    "depends_on": [],
    "source_code": "def create_notable_stars_list(combined_df, unique_notes, user_max_coord=None):\n    \"\"\"\n    Create list of notable stars, using vector distance for filtering.\n    \n    Parameters:\n        combined_df: DataFrame containing star data\n        unique_notes: Dictionary of notable star descriptions\n        user_max_coord: Optional maximum display boundary value\n    \"\"\"\n    notable_stars = []\n    mode = combined_df.attrs.get('mode', 'distance')\n    max_value = combined_df.attrs.get('max_value', 100.0)\n\n    print(f\"\\nCreating notable stars list:\")\n    print(f\"Mode: {mode}\")\n    print(f\"Max distance: {max_value} light-years\")\n    if user_max_coord is not None:\n        print(f\"Display boundaries: +/-{user_max_coord} light-years\")\n\n    for star_name in sorted(unique_notes.keys()):\n        # Check if it's a non-stellar object (Messier, NGC, or IC or special objects labeled X)\n    #    is_messier = star_name.startswith('M') or star_name.startswith('N') or star_name.startswith('I')\n        is_non_stellar = (\n            star_name.startswith('M') or \n            star_name.startswith('NGC') or \n            star_name.startswith('IC') or\n            star_name.startswith('X')\n        )\n\n        # Find the object in the combined_df\n        if is_non_stellar:\n            # Extract object number\n            if star_name.startswith('M'):\n                catalog_prefix = 'M'\n                obj_num = star_name.split()[1] if ' ' in star_name else star_name[1:]\n                search_pattern = f\"{catalog_prefix}{obj_num}\"\n            else:  # NGC or IC\n                search_pattern = star_name  # Use full name for NGC/IC objects\n            \n            star_data = combined_df[\n                combined_df['Star_Name'].str.contains(search_pattern, na=False)\n            ]\n        else:\n            star_data = combined_df[combined_df['Star_Name'] == star_name]\n\n        if not star_data.empty:\n            star_row = star_data.iloc[0]\n            \n            # Get coordinates\n            x = float(star_row['x'])\n            y = float(star_row['y'])\n            z = float(star_row['z'])\n            \n            # Calculate actual distance from Earth\n            distance = np.sqrt(x*x + y*y + z*z)\n\n            # Apply filtering based on mode\n            should_include = True\n            if mode == 'distance':\n                if distance > max_value:\n                    print(f\"Skipping {star_name} - beyond distance limit ({distance:.1f} > {max_value} ly)\")\n                    should_include = False\n            elif mode == 'magnitude':\n    #            if star_row['Apparent_Magnitude'] > max_value and not is_messier:\n                if not is_non_stellar and star_row['Apparent_Magnitude'] > max_value:\n                    print(f\"Skipping {star_name} - too faint (mag {star_row['Apparent_Magnitude']:.1f} > {max_value})\")\n                    should_include = False\n\n            # Apply display boundary filtering if specified\n            if should_include and user_max_coord is not None:\n                # Check if star falls outside the display boundaries\n                if (abs(x) > user_max_coord or \n                    abs(y) > user_max_coord or \n                    abs(z) > user_max_coord):\n                    print(f\"Skipping {star_name} - outside display boundaries (+/-{user_max_coord} ly)\")\n                    should_include = False\n\n            if should_include:\n                # Use same distance for camera positioning since already calculated\n                direction = {\n                    'x': x/distance,\n                    'y': y/distance,\n                    'z': z/distance\n                }\n                notable_stars.append({\n                    'label': star_name,\n                    'method': 'relayout',\n                    'args': [{\n                        'scene.camera': {\n                            'center': {'x': 0, 'y': 0, 'z': 0},\n                            'eye': {'x': -0.005 * direction['x'],\n                                  'y': -0.005 * direction['y'],\n                                  'z': -0.005 * direction['z']},\n                            'up': {'x': 0, 'y': 0, 'z': 1}\n                        }\n                    }]\n                })\n                print(f\"Added {star_name} to notable stars list (distance: {distance:.1f} ly)\")\n\n    print(f\"\\nTotal notable objects included: {len(notable_stars)}\")\n    return notable_stars",
    "start_line": 330,
    "end_line": 430,
    "has_docstring": true,
    "docstring": "Create list of notable stars, using vector distance for filtering.\n\nParameters:\n    combined_df: DataFrame containing star data\n    unique_notes: Dictionary of notable star descriptions\n    user_max_coord: Optional maximum display boundary value",
    "parameters": [
      "combined_df",
      "unique_notes",
      "user_max_coord"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_notable_stars_list",
    "component_id": "visualization_3d.create_notable_stars_list"
  },
  "visualization_3d.create_3d_visualization": {
    "id": "visualization_3d.create_3d_visualization",
    "name": "create_3d_visualization",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_3d.py",
    "relative_path": "visualization_3d.py",
    "depends_on": [
      "visualization_3d.create_notable_stars_list"
    ],
    "source_code": "def create_3d_visualization(combined_df, max_value, user_max_coord=None):\n    \"\"\"\n    Create 3D visualization of stellar neighborhood or magnitude-limited stars.\n    \n    Parameters:\n        combined_df (pd.DataFrame): Prepared star data from prepare_3d_data\n        max_value (float): Maximum distance or magnitude limit\n        user_max_coord (float, optional): User-defined maximum coordinate value for plot axes.\n    \"\"\"\n    print(\"Creating 3D visualization...\")\n\n    # Create minimal hover text version\n    combined_df['Min_Hover_Text'] = combined_df['Star_Name'].apply(\n        lambda name: f'<b>{name}</b>' if name else 'Unknown'\n    )\n    \n    # Calculate axis ranges and determine scale text\n    if user_max_coord is not None:\n        print(f\"Using user-defined scale: +/-{user_max_coord} light-years\")\n        axis_range = [-user_max_coord, user_max_coord]\n        scale_text = f\" (Scale: +/-{user_max_coord} light-years, manual)\"\n    else:\n        # Calculate automatically from data\n        max_coord = max(\n            abs(combined_df['x'].max()), abs(combined_df['x'].min()),\n            abs(combined_df['y'].max()), abs(combined_df['y'].min()),\n            abs(combined_df['z'].max()), abs(combined_df['z'].min())\n        )\n        # Add some padding for better visualization\n        max_coord = max_coord * 1.1\n        print(f\"Using automatic scale: +/-{max_coord:.2f} light-years\")\n        axis_range = [-max_coord, max_coord]\n        scale_text = f\" (Scale: +/-{max_coord:.1f} light-years, auto)\"\n    \n    # Set default analysis results if not present in DataFrame attributes\n    analysis = combined_df.attrs.get('analysis', {\n        'total_stars': len(combined_df),\n        'plottable_hip': len(combined_df[combined_df['Source_Catalog'] == 'Hipparcos']),\n        'plottable_gaia': len(combined_df[combined_df['Source_Catalog'] == 'Gaia']),\n        'missing_temp': len(combined_df[pd.isna(combined_df['Temperature'])]),\n        'missing_lum': len(combined_df[pd.isna(combined_df['Luminosity'])]),\n        'temp_le_zero': len(combined_df[\n            (~pd.isna(combined_df['Temperature'])) & \n            (combined_df['Temperature'] <= 0)\n        ])\n    })\n\n    # Set default visualization parameters if not present\n    vis_params = combined_df.attrs.get('visualization_params', {\n        'temp_min': 1300,\n        'temp_max': 50000,\n        'mag_min': -1.44,\n        'mag_max': 9.0\n    })\n\n    mode = combined_df.attrs.get('mode', 'magnitude')\n    \n    # Define temperature-based colors\n    temperature_colors = {\n        1300: 'rgb(255, 0, 0)',        # Red for L\n        2400: 'rgb(255, 0, 0)',        # Red for M\n        3700: 'rgb(255, 165, 0)',      # Orange for K\n        5200: 'rgb(255, 255, 0)',      # Yellow for G\n        6000: 'rgb(255, 255, 255)',    # White for F\n        7500: 'rgb(173, 216, 230)',    # Light Blue for A\n        10000: 'rgb(0, 0, 255)',       # Blue for B\n        30000: 'rgb(0, 0, 139)',       # Dark Blue for O\n        50000: 'rgb(75, 0, 130)',      # Indigo for upper O limit\n    }\n\n    # Create colorscale\n    temp_min = vis_params['temp_min']\n    temp_max = vis_params['temp_max']\n    colorscale = [\n        [(temp - temp_min) / (temp_max - temp_min), color]\n        for temp, color in sorted(temperature_colors.items())\n    ]\n    \n     # Create figure\n    fig = go.Figure()\n    \n# In visualization_3d.py and planetarium_apparent_magnitude.py\n# Modify the trace creation section to handle special objects first:\n\n    # Create masks for different object types\n#    messier_mask = combined_df['Source_Catalog'] == 'Messier'\n    special_mask = combined_df['Star_Name'].str.startswith('X ', na=False)\n    messier_mask = (combined_df['Source_Catalog'] == 'Messier') & ~special_mask\n    \n    # Create mask for regular stars (not Messier and not special)\n    regular_stars_mask = ~(messier_mask | special_mask)\n\n    # First add regular stars trace with \"gray stars\"\n    fig.add_trace(go.Scatter3d(\n        x=combined_df[regular_stars_mask]['x'],\n        y=combined_df[regular_stars_mask]['y'],\n        z=combined_df[regular_stars_mask]['z'],\n        mode='markers',\n        marker=dict(\n            size=combined_df[regular_stars_mask]['Marker_Size'],\n            # Use list comprehension directly\n            color=['gray' if not has_t else norm_t \n                for has_t, norm_t in zip(combined_df[regular_stars_mask]['Has_Temperature'],\n                                        combined_df[regular_stars_mask]['Temperature_Normalized'])],\n            colorscale=colorscale,\n            cmin=0,\n            cmax=1,\n\n    #        colorbar=dict(\n    #            title='K',\n    #            tickmode='array',\n    #            tickvals=[\n    #                (temp - temp_min) / (temp_max - temp_min)\n    #                for temp in sorted(temperature_colors.keys())\n    #            ],\n    #            ticktext=[f\"{temp:,}\" for temp in sorted(temperature_colors.keys())],\n    #            tickfont=dict(color='white'),\n    #            titlefont=dict(color='white')\n    #        ),\n\n            colorbar=dict(\n                title=dict(text='K', font=dict(color='white')),\n                tickmode='array',\n                tickvals=[\n                    (temp - temp_min) / (temp_max - temp_min)\n                    for temp in sorted(temperature_colors.keys())\n                ],\n                ticktext=[f\"{temp:,}\" for temp in sorted(temperature_colors.keys())],\n                tickfont=dict(color='white')\n            ),\n\n            showscale=True,\n        ),\n        text=combined_df[regular_stars_mask]['Hover_Text'].values,\n        customdata=combined_df[regular_stars_mask]['Min_Hover_Text'].values,\n        hovertemplate='%{text}<extra></extra>',\n        name='Stars',\n        showlegend=True\n    ))\n\n    # Calculate the count of stars without temperature\n    stars_without_temp_count = (~combined_df[regular_stars_mask]['Has_Temperature']).sum()\n\n    # Add legend entry for stars without temperature\n#    if stars_without_temp_count > 0:\n#        fig.add_trace(go.Scatter3d(\n#            x=[None],\n#            y=[None],\n#            z=[None],\n#            mode='markers',\n#            marker=dict(\n#                size=3,  # Small size to match typical faint stars\n#                color='gray',\n#            ),\n#            name=f'Stars without temperature ({stars_without_temp_count})',\n#            showlegend=True,\n#            hoverinfo='skip'\n#        ))\n\n    # Add Sun trace\n    fig.add_trace(go.Scatter3d(\n        x=[0], y=[0], z=[0],\n        mode='markers',\n        marker=dict(\n            size=14,\n            symbol='circle',\n            color='rgb(102, 187, 106)',     # chlorophyl green\n            line=dict(color='yellow', width=2),\n        ),\n        text=[hover_text_sun],\n        customdata=['<b>Sun</b>'],\n        hovertemplate='%{text}<extra></extra>',\n        name='Sun',\n        showlegend=True\n    ))\n\n    # Add special X objects before Messier objects\n    if special_mask.any():\n        special_df = combined_df[special_mask]\n        print(f\"\\nFound {len(special_df)} special X objects:\")\n        for _, obj in special_df.iterrows():\n            print(f\"  {obj['Star_Name']}: ({obj['x']:.1f}, {obj['y']:.1f}, {obj['z']:.1f}) ly\")\n\n        # Add legend entry\n        fig.add_trace(go.Scatter3d(\n            x=[None], y=[None], z=[None],\n            mode='markers',\n            marker=dict(\n                size=15,\n                symbol='circle-open',\n                color='blue',\n                opacity=1,\n                line=dict(color='white', width=2),\n            ),\n            name='Special Objects',\n            showlegend=True\n        ))\n\n        # Add actual special X objects\n        fig.add_trace(go.Scatter3d(\n            x=special_df['x'],\n            y=special_df['y'],\n            z=special_df['z'],\n            mode='markers',\n            marker=dict(\n    #            size=special_df['Marker_Size'],\n                size=15,  # Fixed size of 20 for special objects\n                symbol='circle-open',\n                color='blue',\n                line=dict(color='white', width=5),\n                opacity=1\n            ),\n            text=special_df['Hover_Text'],\n            customdata=special_df['Min_Hover_Text'],\n            hovertemplate='%{text}<extra></extra>',\n            name='Special Objects',\n            showlegend=False\n        ))\n\n    # Add Messier objects last\n    if messier_mask.any():\n        messier_df = combined_df[messier_mask]\n        print(f\"\\nFound {len(messier_df)} Messier objects:\")\n        for _, obj in messier_df.iterrows():\n            print(f\"  {obj['Star_Name']}: ({obj['x']:.1f}, {obj['y']:.1f}, {obj['z']:.1f}) ly\")\n\n        # Add legend entry for Messier objects\n        fig.add_trace(go.Scatter3d(\n            x=[None], y=[None], z=[None],\n            mode='markers',\n            marker=dict(\n                size=20,\n                symbol='circle-open',\n                color='red',\n                opacity=1,\n                line=dict(color='white', width=2),\n            ),\n            name='Non-stellar Objects',\n            showlegend=True\n        ))\n\n        # Add actual non-stellar objects\n        fig.add_trace(go.Scatter3d(\n            x=messier_df['x'],\n            y=messier_df['y'],\n            z=messier_df['z'],\n            mode='markers',\n            marker=dict(\n    #            size=messier_df['Marker_Size'],\n                size=20,  # Fixed size of 20 for non-stellar objects\n                symbol='circle-open',\n                color='red',\n                line=dict(color='white', width=5),\n                opacity=0.5\n            ),\n            text=messier_df['Hover_Text'],\n            customdata=messier_df['Min_Hover_Text'],\n            hovertemplate='%{text}<extra></extra>',\n            name='Non-stellar Objects',\n            showlegend=False\n        ))\n    \n    # Set title and footer text based on mode\n    if mode == 'distance':\n#        title_text = f'Interactive 3D Visualization of Stars within {int(max_value)} Light-Years{scale_text}'\n        title_text = f\"Interactive 3D Visualization of Stars within {max_value:.1f} Light-Years\"\n\n        footer_text = (\n            f\"This visualization shows <span style='color:red'>{len(combined_df):,d}</span> stars (of \"\n            f\"<span style='color:red'>{analysis['total_stars']:,d}</span> unique stars detected) within \"\n        #    f\"<span style='color:red'>{int(max_value)}</span> light-years from the Sun. \"\n            f\"<span style='color:red'>{max_value:.1f}</span> light-years from the Sun. \"\n\n            f\"Catalog breakdown of plotted stars: <span style='color:red'>{analysis['plottable_hip']:,d}</span> from \"\n            f\"<a href='https://www.cosmos.esa.int/web/hipparcos/catalogues' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Hipparcos</a> and \"\n            f\"<span style='color:red'>{analysis['plottable_gaia']:,d}</span> with temperature and \" \n            f\"<span style='color:red'>{analysis['missing_temp']:,d}</span> without temperature data<br>\" \n            f\"(plotted uniformly small and gray) \"\n            f\"from <a href='https://www.cosmos.esa.int/gaia' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Gaia</a>. \"\n        #    f\"<span style='color:red'>{analysis['missing_lum']:,d}</span> lack luminosity data, and \"\n        #    f\"<span style='color:red'>{analysis['temp_le_zero']:,d}</span> have invalid temperatures. \"\n            f\"Star properties from <a href='http://simbad.u-strasbg.fr/simbad/' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Simbad</a> database. \"\n            f\"Marker size indicates luminosity (1e-6 to 1e3 Lsun), \"\n            f\"color indicates temperature based on black-body radiation (1,300K to 50,000K).<br>\"\n            f\"The Sun is shown in chlorophyll green at the origin (0, 0, 0). \"\n            f\"Python script by Tony Quintanilla with assistance from Claude, ChatGPT, Gemini, and DeepSeek, September 2025.<br>\"\n            f\"Search: <a href='https://www.nasa.gov/' target='_blank' style='color:#1E90FF; text-decoration:underline;'>NASA</a>, \"            \n            f\"<a href='https://skyview.gsfc.nasa.gov/current/cgi/titlepage.pl' target='_blank' style='color:#1E90FF; text-decoration:underline;'>NASA Skyview</a>, \"\n            f\"and <a href='http://simbad.u-strasbg.fr/simbad/' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Simbad</a> \"\n            f\"with the star name, for example: \\\"* alf Aql\\\". \" \n            f\"<span style='color:red'>Paloma's Orrery project website:</span> <a href='https://sites.google.com/view/tony-quintanilla' target='_blank' style='color:#1E90FF; text-decoration:underline;'>here</a>. \"\n        )\n\n    else:  # magnitude mode\n            # Count Messier objects\n            messier_count = len(combined_df[combined_df['Source_Catalog'] == 'Messier'])\n            \n            title_text = f'Interactive 3D Visualization of Unaided-Eye Visible Stars<br>Apparent Magnitude <= {max_value}{scale_text}'\n\n            \"\"\"\n            footer_text = (    \n                f\"This visualization shows <span style='color:red'>{len(combined_df):,d}</span> objects visible to the naked eye \"\n                f\"(apparent magnitude <= <span style='color:red'>{max_value}</span>). \"\n                f\"Catalog breakdown of plotted stars: <span style='color:red'>{analysis['plottable_hip']:,d}</span> from \"\n                f\"<a href='https://www.cosmos.esa.int/web/hipparcos/catalogues' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Hipparcos</a> and \"\n                f\"<span style='color:red'>{analysis['plottable_gaia']:,d}</span> from \"\n                f\"<span style='color:red'>{analysis['missing_temp']:,d}</span> without temperature data<br>\" \n                f\"<a href='https://www.cosmos.esa.int/gaia' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Gaia</a>. \"\n                f\"<span style='color:red'>{messier_count}</span> Special and other non-stellar objects are also displayed. \"\n                f\"<a href='http://www.messier.seds.org/' target='_blank' style='color:#1E90FF; text-decoration:underline;'>SEDS Messier Catalog</a>.<br>\"\n            #    f\"Data quality: <span style='color:red'>{analysis['missing_temp']:,d}</span> stars lack temperature data, \"\n            #    f\"<span style='color:red'>{analysis['missing_lum']:,d}</span> lack luminosity data. \"\n                f\"Star properties from <a href='http://simbad.u-strasbg.fr/simbad/' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Simbad</a> database. \"\n                f\"Star marker size is inversely proportional to apparent magnitude, where lower apparent magnitudes are brighter. \"\n                f\"Star color indicates temperature based on black-body radiation (scale: 1,300K to 50,000K).<br>\"\n                f\"The Sun is shown in chlorophyll green (source of life's energy!) at the origin of the plot (0, 0, 0). \"\n                f\"The plot coordinates are standardized to the International Celestial Reference System, \"\n                f\"so the Milky Way is tilted approximately 63 deg with respect to the<br>celestial equator. \"\n                f\"Non-stellar object markers do not reflect object type, apparent magnitude or temperature, but are fixed. \" \n                f\"Python script by Tony Quintanilla with assistance from ChatGPT, Claude, Gemini AI, and DeepSeek February 2025.<br>\"\n                f\"Search: <a href='https://www.nasa.gov/' target='_blank' style='color:#1E90FF; text-decoration:underline;'>NASA</a>, \"\n                f\"<a href='http://simbad.u-strasbg.fr/simbad/' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Simbad</a>, \"\n                f\"<a href='https://www.wikisky.org/?locale=EN' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Sky-Map</a>. \"\n                f\"For Simbad use the star name from Star Information, for example: \\\"* alf Aql\\\", for Sky-Map use the name or RA and Dec.\"              \n            )\n            \"\"\"\n\n            footer_text = (    \n                f\"This visualization shows <span style='color:red'>{len(combined_df):,d}</span> objects visible to the naked eye \"\n                f\"(apparent magnitude <= <span style='color:red'>{max_value}</span>). \"\n                f\"Catalog breakdown: <span style='color:red'>{analysis['plottable_hip']:,d}</span> from \"\n                f\"<a href='https://www.cosmos.esa.int/web/hipparcos/catalogues' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Hipparcos</a>, \"\n                f\"<span style='color:red'>{analysis['plottable_gaia'] + analysis['missing_temp']:,d}</span> from \"\n                f\"<a href='https://www.cosmos.esa.int/gaia' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Gaia</a> \"\n                f\"(<span style='color:red'>{analysis['plottable_gaia']:,d}</span> with temperature, \"\n                f\"<span style='color:red'>{analysis['missing_temp']:,d}</span> without), and \"\n                f\"<span style='color:red'>{messier_count}</span> <a href='http://www.messier.seds.org/' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Messier and non-stellar</a> objects. \"\n                f\"Star properties from <a href='http://simbad.u-strasbg.fr/simbad/' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Simbad</a> database.<br>\"\n                f\"Star marker size is inversely proportional to apparent magnitude (brighter stars appear larger). \"\n                f\"Star color indicates temperature based on black-body radiation (1,300K to 50,000K). \"\n                f\"Stars without temperature data are displayed in gray.<br>\"\n                f\"The Sun is shown in chlorophyll green at the origin (0, 0, 0). \"\n                f\"Python script by Tony Quintanilla with assistance from Claude, ChatGPT, Gemini, and DeepSeek, September 2025.<br>\"\n                f\"Search: <a href='https://www.nasa.gov/' target='_blank' style='color:#1E90FF; text-decoration:underline;'>NASA</a>, \"\n                f\"<a href='http://simbad.u-strasbg.fr/simbad/' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Simbad</a>, \"\n                f\"<a href='https://www.wikisky.org/?locale=EN' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Sky-Map</a>. \"\n                f\"For Simbad use the star name from Star Information, for example: \\\"* alf Aql\\\", for Sky-Map use the name or RA and Dec.\"\n\n            )            \n\n    # Update layout with centered axes\n    fig.update_layout(\n        scene=dict(\n            xaxis=dict(title='X (light-years)', range=axis_range, backgroundcolor='black', gridcolor='gray', showbackground=True),\n            yaxis=dict(title='Y (light-years)', range=axis_range, backgroundcolor='black', gridcolor='gray', showbackground=True),\n            zaxis=dict(title='Z (light-years)', range=axis_range, backgroundcolor='black', gridcolor='gray', showbackground=True),\n            aspectmode='cube'\n        ),\n        paper_bgcolor='black',\n        plot_bgcolor='black',\n        title=dict(\n            text=title_text,\n            x=0.5,\n            y=0.93,\n            xanchor='center',\n            yanchor='top',\n            font=dict(color='white', size=20)\n        ),\n        showlegend=True,\n        legend=dict(\n            yanchor=\"top\",\n            y=1.1,\n            xanchor=\"left\",\n            x=1.06,\n            font=dict(color='white'),\n            bgcolor='rgba(0,0,0,0.5)'\n        ),\n        margin=dict(t=90, b=85),\n        annotations=[\n            dict(\n                text=\"Click on the legend items<br>to toggle them off or<br>back on:\",\n                xref=\"paper\",\n                yref=\"paper\",\n                x=0.9,\n                y=1.09,\n                showarrow=False,\n                font=dict(size=12, color='white'),\n                align='left',\n                xanchor='left',\n                yanchor='top'\n            ),\n\n            dict(       # target marker \n                x=0.500,\n                y=0.505,\n        #        text='<span style=\"vertical-align:1em;\">-></span>',\n                text='<span style=\"vertical-align:1em;\"><></span>',                \n                showarrow=False,\n                xref='paper',\n                yref='paper',\n                font=dict(size=60, color='rgba(0, 255, 255, 0.5)')  # Semi-transparent blue-green\n            ),\n\n        ]\n    )\n    \n    # Add footer annotation\n    fig.add_annotation(\n        text=footer_text,\n        align='left',\n        showarrow=False,\n        xref='paper',\n        yref='paper',\n        x=0.01,\n        y=-0.15,\n        font=dict(size=10, color='white')\n    )\n\n# In visualization_3d.py, replace the notable stars creation block with:\n\n    # Create notable stars list for dropdown menu\n    notable_stars = []\n    for star_name in sorted(unique_notes.keys()):  # Sort alphabetically\n        # Escape special regex characters in star name\n        safe_star_name = re.escape(star_name)\n        \n        # First check if it's a Messier object\n        star_data = combined_df[combined_df['Star_Name'].str.contains(safe_star_name, regex=True, na=False)]\n        if star_data.empty:\n            # Then check for exact matches\n            star_data = combined_df[combined_df['Star_Name'] == star_name]\n        \n        if not star_data.empty:\n            # Get the object's coordinates\n            x = float(star_data['x'].iloc[0])\n            y = float(star_data['y'].iloc[0])\n            z = float(star_data['z'].iloc[0])\n            \n            # Calculate the unit vector pointing to the object\n            distance = np.sqrt(x*x + y*y + z*z)\n            if distance > 0:  # Avoid division by zero\n                direction = {\n                    'x': x/distance,\n                    'y': y/distance,\n                    'z': z/distance\n                }\n                notable_stars.append({      # this moves the camera to point to the notable star\n                    'label': star_name,\n                    'method': 'relayout',\n                    'args': [{\n                        'scene.camera': {\n                            'center': {'x': 0, 'y': 0, 'z': 0},\n                            'eye': {'x': -0.005 * direction['x'], \n                                  'y': -0.005 * direction['y'], \n                                  'z': -0.005 * direction['z']},\n                            'up': {'x': 0, 'y': 0, 'z': 1}\n                        }\n                    }]\n                })\n\n    # Get the list of notable stars considering both magnitude and scale limits\n    notable_stars = create_notable_stars_list(combined_df, unique_notes, user_max_coord)\n\n    # Build updatemenus list conditionally (OUTSIDE of fig.update_layout)\n    updatemenus = [\n        # Center button (always present)\n        dict(\n            type=\"buttons\",\n            direction=\"left\",\n            x=0.05,\n            y=1.15,\n            buttons=[dict(\n                label=\"Move Camera to the Sun (Center)\",\n                method=\"relayout\",\n                args=[{\n                    \"scene.camera\": {\n                        \"eye\": {\"x\": 0.001, \"y\": 0.001, \"z\": 0.001},\n                        \"center\": {\"x\": 1, \"y\": 0, \"z\": 0},\n                        \"up\": {\"x\": 0, \"y\": 0, \"z\": 1}\n                    }\n                }]\n            )],\n            bgcolor='rgba(255,255,255,0.50)',\n            font=dict(color='blue'),\n            bordercolor='white',\n            borderwidth=1\n        ),\n        # Hover text controls (always present)\n        dict(\n            type=\"buttons\",\n            direction=\"right\",\n            x=0.2,\n            y=0.08,\n            buttons=[\n                dict(\n                    label=\"Full Star Info\",\n                    method=\"update\",\n                    args=[{\"hovertemplate\": '%{text}<extra></extra>'}]\n                ),\n                dict(\n                    label=\"Star Names Only\",\n                    method=\"update\",\n                    args=[{\"hovertemplate\": '%{customdata}<extra></extra>'}]\n                ),\n            ],\n            font=dict(color='blue'),\n            bgcolor='rgba(255,255,255,0.50)',\n            bordercolor='white',\n            borderwidth=1\n        )\n    ]\n\n    # Only add notable stars dropdown if there are notable stars\n    if notable_stars:\n        updatemenus.insert(1, dict(\n            name=\"notable_stars\",\n            type=\"dropdown\",\n            direction=\"down\",\n            x=0.01,\n            y=1.05,\n            buttons=notable_stars,\n            pad={\"r\": 10, \"t\": 10},\n            showactive=True,\n            bgcolor='rgba(255,255,255,0.50)',\n            font=dict(color='blue'),\n            bordercolor='white',\n            borderwidth=1\n        ))\n\n    # NOW update layout with the built list\n    fig.update_layout(updatemenus=updatemenus)\n    \n    # Print debug info about Messier objects\n    print(\"\\nChecking for Messier objects...\")\n    messier_mask = combined_df['Source_Catalog'] == 'Messier'\n    if messier_mask.any():\n        messier_data = combined_df[messier_mask]\n        print(f\"Found {len(messier_data)} Messier objects to plot:\")\n        for _, obj in messier_data.iterrows():\n            print(f\"  {obj['Star_Name']}: ({obj['x']:.1f}, {obj['y']:.1f}, {obj['z']:.1f}) ly\")\n\n    # Return the figure for any further processing\n    return fig",
    "start_line": 433,
    "end_line": 975,
    "has_docstring": true,
    "docstring": "Create 3D visualization of stellar neighborhood or magnitude-limited stars.\n\nParameters:\n    combined_df (pd.DataFrame): Prepared star data from prepare_3d_data\n    max_value (float): Maximum distance or magnitude limit\n    user_max_coord (float, optional): User-defined maximum coordinate value for plot axes.",
    "parameters": [
      "combined_df",
      "max_value",
      "user_max_coord"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_3d_visualization",
    "component_id": "visualization_3d.create_3d_visualization"
  },
  "visualization_core.format_value": {
    "id": "visualization_core.format_value",
    "name": "format_value",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_core.py",
    "relative_path": "visualization_core.py",
    "depends_on": [],
    "source_code": "def format_value(value, format_spec, default=\"Unknown\"):\n    \"\"\"Format values consistently across visualizations.\"\"\"\n    if value is None or (isinstance(value, float) and np.isnan(value)):\n        return default\n    try:\n    #    return format_spec.format(value)  # wrong\n        return format(value, format_spec)  # CORRECT\n    except (ValueError, TypeError):\n        return default",
    "start_line": 14,
    "end_line": 22,
    "has_docstring": true,
    "docstring": "Format values consistently across visualizations.",
    "parameters": [
      "value",
      "format_spec",
      "default"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function format_value",
    "component_id": "visualization_core.format_value"
  },
  "visualization_core.create_hover_text": {
    "id": "visualization_core.create_hover_text",
    "name": "create_hover_text",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_core.py",
    "relative_path": "visualization_core.py",
    "depends_on": [
      "visualization_core.format_value"
    ],
    "source_code": "def create_hover_text(df, include_3d=False):\n    \"\"\"\n    Create hover text for plots with identification of estimated values and special cases.\n    \n    Parameters:\n        df (pandas DataFrame): DataFrame containing star data\n        include_3d (bool): Whether to include 3D coordinate information\n        \n    Returns:\n        list: List of formatted hover texts for each star\n    \"\"\"\n    hover_text_list = []\n    \n    for _, row in df.iterrows():\n        hover_text = f'<b>{row[\"Star_Name\"]}</b><br>'\n        \n        # ========== ROBUST RA/DEC HANDLING - ALWAYS WORKS ==========\n        ra_str = None\n        dec_str = None\n        \n        # Method 1: Try to get pre-computed strings if they exist\n        if 'ra_str' in df.columns:\n            try:\n                ra_val = row.get('ra_str', '')\n                dec_val = row.get('dec_str', '')\n                # Check if they're valid (not empty, not 'nan', not None)\n                if ra_val and str(ra_val).strip() and str(ra_val).strip().lower() not in ['nan', 'none', '']:\n                    ra_str = str(ra_val).strip()\n                    dec_str = str(dec_val).strip() if dec_val else ''\n            except:\n                pass  # If any error, fall through to Method 2\n        \n        # Method 2: Convert from ICRS coordinates if no valid strings\n        if not ra_str and 'RA_ICRS' in df.columns:\n            try:\n                ra_deg = row.get('RA_ICRS')\n                dec_deg = row.get('DE_ICRS')\n                \n                if pd.notna(ra_deg) and pd.notna(dec_deg):\n                    # Convert to sexagesimal\n                    ra_hours = float(ra_deg) / 15.0\n                    ra_h = int(ra_hours)\n                    ra_m = int((ra_hours - ra_h) * 60)\n                    ra_s = ((ra_hours - ra_h) * 60 - ra_m) * 60\n                    \n                    dec_deg_float = float(dec_deg)\n                    dec_sign = '+' if dec_deg_float >= 0 else '-'\n                    dec_abs = abs(dec_deg_float)\n                    dec_d = int(dec_abs)\n                    dec_m = int((dec_abs - dec_d) * 60)\n                    dec_s = ((dec_abs - dec_d) * 60 - dec_m) * 60\n                    \n                    ra_str = f\"{ra_h:02d}h {ra_m:02d}m {ra_s:05.2f}s\"\n                    dec_str = f\"{dec_sign}{dec_d:02d} deg {dec_m:02d}' {dec_s:04.1f}\\\"\"\n            except Exception as e:\n                # If conversion fails, just skip RA/Dec\n                pass\n        \n        # Add to hover text if we got valid coordinates\n        if ra_str and dec_str:\n            hover_text += f\"RA: {ra_str}, Dec: {dec_str} (J2000)<br>\"\n        # ========== END ROBUST RA/DEC SECTION ==========\n        \n        # Add coordinates if 3D\n        if include_3d:\n            hover_text += (f'Distance: {format_value(row[\"Distance_pc\"], \".2f\")} pc '\n                         f'({format_value(row[\"Distance_ly\"], \".2f\")} ly)<br>')\n        \n        # Handle luminosity with estimation notes\n        lum_estimated = row.get('Luminosity_Estimated', False)\n        hover_text += f'Luminosity: {format_value(row[\"Luminosity\"], \".6f\")} Lsun'\n        if lum_estimated:\n            hover_text += ' (estimated from spectral type)'\n            # Add note about uncertainty for peculiar or variable stars\n            sp_type = str(row.get(\"Spectral_Type\", \"\")).upper()\n            if 'P' in sp_type or 'VAR' in sp_type:\n                hover_text += '<br>Luminosity note: Star is peculiar/variable; luminosity estimate may have higher uncertainty.'\n        hover_text += '<br>'\n        \n        # Temperature info with estimation note if applicable\n        temp_estimated = row.get('Temperature_Estimated', False)\n        hover_text += f'Temperature: {format_value(row[\"Temperature\"], \".0f\")} K'\n        if temp_estimated:\n            method = row.get('Temperature_Method', 'spectral type')\n            hover_text += f' (estimated from {method})'\n        hover_text += '<br>'\n        \n        # Add other stellar properties\n        hover_text += f'Absolute Magnitude: {format_value(row[\"Abs_Mag\"], \".2f\")}<br>'\n        hover_text += f'Apparent Magnitude: {format_value(row[\"V_mag\"], \".2f\")}<br>'\n        \n        # Add spectral and stellar class info\n        sp_type = row.get(\"Spectral_Type\", \"Unknown\")\n        hover_text += f'Spectral Type: {sp_type}'\n        if 'P' in str(sp_type).upper():\n            hover_text += ' (Peculiar)'\n        hover_text += '<br>'\n        \n        stellar_class = row.get(\"Stellar_Class\", \"Unknown\")\n        hover_text += f'Stellar Class: {stellar_class}'\n        if stellar_class in class_mapping:\n            hover_text += f' ({class_mapping[stellar_class]})'\n        hover_text += '<br>'\n        \n        # Object type with expanded description\n        obj_type = row.get(\"Object_Type_Desc\", \"Unknown\")\n        hover_text += f'Object Type: {obj_type}<br>'\n        \n        # Add parallax quality info if available\n        if 'e_Plx' in row and 'Plx' in row:\n            try:\n                rel_error = abs(row['e_Plx'] / row['Plx'])\n                if rel_error > 0.2:  # 20% error threshold\n                    hover_text += f'Warning: High parallax uncertainty ({rel_error:.1%})<br>'\n            except (TypeError, ZeroDivisionError):\n                pass\n        \n        # Add custom notes from unique_notes\n        note = unique_notes.get(row[\"Star_Name\"], \"None.\")\n        hover_text += f'Note: {note}'\n        \n        hover_text_list.append(hover_text)\n    \n    return hover_text_list",
    "start_line": 25,
    "end_line": 148,
    "has_docstring": true,
    "docstring": "Create hover text for plots with identification of estimated values and special cases.\n\nParameters:\n    df (pandas DataFrame): DataFrame containing star data\n    include_3d (bool): Whether to include 3D coordinate information\n    \nReturns:\n    list: List of formatted hover texts for each star",
    "parameters": [
      "df",
      "include_3d"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_hover_text",
    "component_id": "visualization_core.create_hover_text"
  },
  "visualization_core.prepare_temperature_colors": {
    "id": "visualization_core.prepare_temperature_colors",
    "name": "prepare_temperature_colors",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_core.py",
    "relative_path": "visualization_core.py",
    "depends_on": [],
    "source_code": "def prepare_temperature_colors():\n    \"\"\"Define consistent temperature color scales.\"\"\"\n    return {\n        1300: 'rgb(255, 0, 0)',        # Red for L\n        2400: 'rgb(255, 0, 0)',        # Red for M\n        3700: 'rgb(255, 165, 0)',      # Orange for K\n        5200: 'rgb(255, 255, 0)',      # Yellow for G\n        6000: 'rgb(255, 255, 255)',    # White for F\n        7500: 'rgb(173, 216, 230)',    # Light Blue for A\n        10000: 'rgb(0, 0, 255)',       # Blue for B\n        30000: 'rgb(0, 0, 139)',       # Dark Blue for O\n        50000: 'rgb(75, 0, 130)',      # Indigo for upper O limit\n    }",
    "start_line": 150,
    "end_line": 162,
    "has_docstring": true,
    "docstring": "Define consistent temperature color scales.",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function prepare_temperature_colors",
    "component_id": "visualization_core.prepare_temperature_colors"
  },
  "visualization_core.analyze_star_counts": {
    "id": "visualization_core.analyze_star_counts",
    "name": "analyze_star_counts",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_core.py",
    "relative_path": "visualization_core.py",
    "depends_on": [],
    "source_code": "def analyze_star_counts(combined_df):\n    \"\"\"Analyze star counts and exclusion reasons in detail.\"\"\"\n    print(\"\\nDetailed Star Count Analysis:\")\n    \n    # Initial catalog breakdown\n    hips_mask = combined_df['Source_Catalog'] == 'Hipparcos'\n    total_hip = np.sum(hips_mask)\n    total_gaia = len(combined_df) - total_hip\n    \n    print(f\"\\nInitial Counts by Catalog:\")\n    print(f\"Hipparcos stars: {total_hip}\")\n    print(f\"Gaia stars: {total_gaia}\")\n    print(f\"Total unique stars: {len(combined_df)}\")\n    \n    # Temperature analysis\n    has_temp = ~pd.isna(combined_df['Temperature'])\n    valid_temp = has_temp & (combined_df['Temperature'] > 0)\n    print(f\"\\nTemperature Analysis:\")\n    print(f\"Stars with temperature data: {np.sum(has_temp)}\")\n    print(f\"Stars with valid temperature > 0: {np.sum(valid_temp)}\")\n    print(f\"Stars with temperature <= 0: {np.sum(has_temp & ~valid_temp)}\")\n    \n    # Luminosity analysis\n    has_lum = ~pd.isna(combined_df['Luminosity'])\n    print(f\"\\nLuminosity Analysis:\")\n    print(f\"Stars with luminosity data: {np.sum(has_lum)}\")\n    \n    # Plottable analysis\n    plottable = valid_temp & has_lum\n    \n    print(f\"\\nPlottable Stars Analysis:\")\n    print(f\"Stars meeting all criteria: {np.sum(plottable)}\")\n    print(f\"Excluded due to missing/invalid temperature: {len(combined_df) - np.sum(valid_temp)}\")\n    print(f\"Excluded due to missing luminosity: {np.sum(~has_lum)}\")\n    \n    # Catalog breakdown of plottable stars\n    plottable_hip = np.sum(plottable & hips_mask)\n    plottable_gaia = np.sum(plottable & ~hips_mask)\n    \n    print(f\"\\nPlottable Stars by Catalog:\")\n    print(f\"Hipparcos: {plottable_hip}\")\n    print(f\"Gaia: {plottable_gaia}\")\n    \n    return {\n        'total_stars': len(combined_df),\n        'plottable_stars': np.sum(plottable),\n        'plottable_hip': plottable_hip,\n        'plottable_gaia': plottable_gaia,\n        'missing_temp': np.sum(combined_df['Temperature'].isna()),  # Just NaN values\n        'missing_lum': np.sum(combined_df['Luminosity'].isna()),    # Just NaN values\n        'temp_le_zero': np.sum(has_temp & ~valid_temp),\n        'missing_temp_only': len(combined_df[combined_df['Temperature'].isna() & ~combined_df['Luminosity'].isna()]),\n        'missing_lum_only': len(combined_df[~combined_df['Temperature'].isna() & combined_df['Luminosity'].isna()]),\n        'missing_both': len(combined_df[combined_df['Temperature'].isna() & combined_df['Luminosity'].isna()])\n    }",
    "start_line": 164,
    "end_line": 218,
    "has_docstring": true,
    "docstring": "Analyze star counts and exclusion reasons in detail.",
    "parameters": [
      "combined_df"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function analyze_star_counts",
    "component_id": "visualization_core.analyze_star_counts"
  },
  "visualization_core.analyze_magnitude_distribution": {
    "id": "visualization_core.analyze_magnitude_distribution",
    "name": "analyze_magnitude_distribution",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_core.py",
    "relative_path": "visualization_core.py",
    "depends_on": [],
    "source_code": "def analyze_magnitude_distribution(data, mag_limit=None):\n    \"\"\"Analyze and print the distribution of stars by magnitude ranges.\"\"\"\n    # [Existing analyze_magnitude_distribution code]\n# def analyze_magnitude_distribution(data, mag_limit=8.5): \n    \"\"\"\n    Analyze and print the distribution of stars by magnitude ranges.\n\n    Parameters:\n        data (astropy Table or pandas DataFrame): The data containing star information.\n        mag_limit (float): The upper limit of the apparent magnitude to consider.\n\n    Returns:\n        int: Total number of stars analyzed.\n    \"\"\"\n    # Convert data to pandas DataFrame if it's an astropy Table\n    if not isinstance(data, pd.DataFrame):\n        df = data.to_pandas()\n    else:\n        df = data\n\n    print(\"\\nSTAR MAGNITUDE DISTRIBUTION ANALYSIS\")\n    print(\"=\" * 50)\n\n    # Define magnitude ranges and descriptions\n    mag_ranges = [\n        (-2, -1, \"Very bright stars (mag -2 to -1)\"),\n        (-1, 0, \"Brightest stars (mag -1 to 0)\"),\n        (0, 1, \"1st magnitude stars (mag 0 to 1)\"),\n        (1, 1.73, \"Upper bright stars (mag 1 to 1.73)\"),\n        (1.74, 2, \"Lower bright stars (mag 1.74 to 2)\"),\n        (2, 3, \"3rd magnitude stars (mag 2 to 3)\"),\n        (3, 4, \"4th magnitude stars (mag 3 to 4)\"),\n        (4, 5, \"5th magnitude stars (mag 4 to 5)\"),\n        (5, 6, \"6th magnitude stars (mag 5 to 6)\"),\n        (6, mag_limit, f\"Faint stars (mag 6 to {mag_limit})\")\n    ]\n\n    print(f\"\\nDistribution by Apparent Magnitude and Source:\")\n    print(f\"{'Magnitude Range':<25} {'Total':>8} {'Hipparcos':>10} {'Gaia':>8} {'%':>7}\")\n    print(\"-\" * 60)\n\n    total_stars = 0\n    for mag_min, mag_max, desc in mag_ranges:\n        # Create mask for stars within the magnitude range\n        mask = df['Apparent_Magnitude'].between(mag_min, mag_max)\n        total = mask.sum()\n        # Masks for each source catalog\n        hip_mask = mask & (df['Source_Catalog'] == 'Hipparcos')\n        gaia_mask = mask & (df['Source_Catalog'] == 'Gaia')\n        hip_count = hip_mask.sum()\n        gaia_count = gaia_mask.sum()\n\n        if total > 0:\n            percent = (total / len(df)) * 100\n            print(f\"{desc:<25} {total:>8d} {hip_count:>10d} {gaia_count:>8d} {percent:>6.1f}%\")\n            total_stars += total\n\n    print(\"-\" * 60)\n    print(f\"Total stars: {total_stars:,d}\")\n\n    return total_stars",
    "start_line": 220,
    "end_line": 280,
    "has_docstring": true,
    "docstring": "Analyze and print the distribution of stars by magnitude ranges.",
    "parameters": [
      "data",
      "mag_limit"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function analyze_magnitude_distribution",
    "component_id": "visualization_core.analyze_magnitude_distribution"
  },
  "visualization_core.analyze_and_report_stars": {
    "id": "visualization_core.analyze_and_report_stars",
    "name": "analyze_and_report_stars",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_core.py",
    "relative_path": "visualization_core.py",
    "depends_on": [],
    "source_code": "def analyze_and_report_stars(combined_df, mode='distance', max_value=None):\n    \"\"\"\n    Analyze star data and report statistics for both distance and magnitude-limited samples.\n    \n    Parameters:\n        combined_df: pandas DataFrame containing the star data\n        mode: 'distance' or 'magnitude' to adjust reporting format\n        max_value: Maximum distance in light-years or magnitude limit\n        \n    Returns:\n        dict: Analysis results containing counts and statistics\n    \"\"\"\n    # Initialize analysis dictionary\n    analysis = {\n        'catalog_counts': {\n            'hipparcos': {\n                'bright': np.sum((combined_df['Source_Catalog'] == 'Hipparcos') & \n                               (combined_df['Apparent_Magnitude'] <= 1.73)),\n                'mid': np.sum((combined_df['Source_Catalog'] == 'Hipparcos') & \n                            (combined_df['Apparent_Magnitude'] > 1.73) & \n                            (combined_df['Apparent_Magnitude'] <= 4.0)),\n                'faint': np.sum((combined_df['Source_Catalog'] == 'Hipparcos') & \n                              (combined_df['Apparent_Magnitude'] > 4.0))\n            },\n            'gaia': {\n                'mid': np.sum((combined_df['Source_Catalog'] == 'Gaia') & \n                            (combined_df['Apparent_Magnitude'] > 1.73) & \n                            (combined_df['Apparent_Magnitude'] <= 4.0)),\n                'faint': np.sum((combined_df['Source_Catalog'] == 'Gaia') & \n                              (combined_df['Apparent_Magnitude'] > 4.0))\n            }\n        },\n        'data_quality': {\n            'total_stars': len(combined_df),\n            'valid_temp': np.sum(~pd.isna(combined_df['Temperature'])),\n            'valid_lum': np.sum(~pd.isna(combined_df['Luminosity'])),\n            'valid_bv': np.sum(~pd.isna(combined_df['B_V'])),\n            'temp_le_zero': np.sum((~pd.isna(combined_df['Temperature'])) & \n                                 (combined_df['Temperature'] <= 0))\n        }\n    }\n\n    # Calculate plottable stars\n    plottable = (\n        ~pd.isna(combined_df['Temperature']) & \n        ~pd.isna(combined_df['Luminosity']) & \n        (combined_df['Temperature'] > 0)\n    )\n    \n    analysis['plottable'] = {\n        'total': np.sum(plottable),\n        'hipparcos': np.sum(plottable & (combined_df['Source_Catalog'] == 'Hipparcos')),\n        'gaia': np.sum(plottable & (combined_df['Source_Catalog'] == 'Gaia'))\n    }\n\n    # Print analysis\n    print(\"\\nStar Count Analysis:\")\n    print(f\"Total stars analyzed: {analysis['data_quality']['total_stars']:,d}\")\n\n    # Print catalog breakdown\n    print(\"\\nCatalog Breakdown:\")\n    hip_bright = analysis['catalog_counts']['hipparcos']['bright']\n    hip_mid = analysis['catalog_counts']['hipparcos']['mid']\n    gaia_mid = analysis['catalog_counts']['gaia']['mid']\n    gaia_faint = analysis['catalog_counts']['gaia']['faint']\n\n    print(f\"Hipparcos bright (<= 1.73): {hip_bright:,d}\")\n    print(f\"Mid-range stars (1.73-4.0):\")\n    print(f\"  - From Hipparcos: {hip_mid:,d}\")\n    print(f\"  - From Gaia: {gaia_mid:,d}\")\n    print(f\"Gaia faint (>4.0): {gaia_faint:,d}\")\n\n    # Mode-specific reporting\n    if mode == 'distance':\n        print(f\"\\nDistance-based Analysis:\")\n        print(f\"Stars within {max_value} light-years: {analysis['data_quality']['total_stars']:,d}\")\n    else:  # magnitude mode\n        print(f\"\\nMagnitude-based Analysis:\")\n        print(f\"Stars brighter than magnitude {max_value}: {analysis['data_quality']['total_stars']:,d}\")\n\n    # Data quality report\n    print(\"\\nData Quality:\")\n    print(f\"Stars with valid temperature: {analysis['data_quality']['valid_temp']:,d}\")\n    print(f\"Stars with valid luminosity: {analysis['data_quality']['valid_lum']:,d}\")\n    print(f\"Stars with valid B-V color: {analysis['data_quality']['valid_bv']:,d}\")\n    \n    # Plottable stars report\n    print(\"\\nPlottable Stars:\")\n    print(f\"Total plottable: {analysis['plottable']['total']:,d}\")\n    print(f\"  - From Hipparcos: {analysis['plottable']['hipparcos']:,d}\")\n    print(f\"  - From Gaia: {analysis['plottable']['gaia']:,d}\")\n\n    return analysis",
    "start_line": 282,
    "end_line": 374,
    "has_docstring": true,
    "docstring": "Analyze star data and report statistics for both distance and magnitude-limited samples.\n\nParameters:\n    combined_df: pandas DataFrame containing the star data\n    mode: 'distance' or 'magnitude' to adjust reporting format\n    max_value: Maximum distance in light-years or magnitude limit\n    \nReturns:\n    dict: Analysis results containing counts and statistics",
    "parameters": [
      "combined_df",
      "mode",
      "max_value"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function analyze_and_report_stars",
    "component_id": "visualization_core.analyze_and_report_stars"
  },
  "visualization_core.generate_star_count_text": {
    "id": "visualization_core.generate_star_count_text",
    "name": "generate_star_count_text",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_core.py",
    "relative_path": "visualization_core.py",
    "depends_on": [],
    "source_code": "def generate_star_count_text(counts_dict, combined_df=None):\n    \"\"\"Generate detailed text about star counts from different catalogs.\"\"\"\n    # Get all counts\n    total_stars = counts_dict['total_stars']\n    plottable_count = counts_dict['plottable_count']\n    missing_temp = counts_dict['missing_temp_only']\n    missing_lum = counts_dict['missing_lum_only']\n    \n    # Catalog breakdowns\n    hip_bright = counts_dict.get('hip_bright_count', 0)\n    hip_mid = counts_dict.get('hip_mid_count', 0)\n    gaia_mid = counts_dict.get('gaia_mid_count', 0)\n    gaia_faint = counts_dict.get('gaia_faint_count', 0)\n    \n    # Get the bright star estimates from the estimation_results\n    estimation_results = counts_dict.get('estimation_results', {})\n    bright_star_estimates = estimation_results.get('bright_star_estimates', 0)\n    \n    return (\n        f\"<br>     Total stars plotted: <span style='background-color: red; color: red'>{total_stars:,d}</span>: \"\n        f\"<a href='https://www.cosmos.esa.int/web/hipparcos/catalogues' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Hipparcos</a> bright (Vmag <= 1.73): <span style='background-color: red; color: red'>{hip_bright}</span> stars. \"\n        f\"Hipparcos mid (1.73 < Vmag <= 4.0): <span style='background-color: red; color: red'>{hip_mid}</span> stars. \"\n    #    f\"<a href='https://vizier.cds.unistra.fr/viz-bin/VizieR-3'>Gaia</a> mid (1.73 < Vmag <= 4.0): <span style='background-color: red; color: red'>{gaia_mid}</span> stars. \"\n        f\"<a href='https://www.cosmos.esa.int/gaia' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Gaia</a> faint (Vmag > 4.0): <span style='background-color: red; color: red'>{gaia_faint}</span> stars.\"\n        f\"<br>     Search: <a href='https://www.nasa.gov/' target='_blank' style='color:#1E90FF; text-decoration:underline;'>NASA</a>, \"\n        f\"<a href='http://simbad.u-strasbg.fr/simbad/' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Simbad</a>, \"\n        f\"<a href='https://www.wikisky.org/?locale=EN' target='_blank' style='color:#1E90FF; text-decoration:underline;'>Sky-Map</a>. \"\n        f\"For Simbad use the star name from Star Information, for example: \\\"* alf Aql\\\", for Sky-Map use the name or RA and Dec.\" \n        f\"<br>     -- Python script by Tony Quintanilla, with assistance from Claude, ChatGPT, Gemini, and DeepSeek, September 2025.\"\n        \n    )",
    "start_line": 376,
    "end_line": 406,
    "has_docstring": true,
    "docstring": "Generate detailed text about star counts from different catalogs.",
    "parameters": [
      "counts_dict",
      "combined_df"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function generate_star_count_text",
    "component_id": "visualization_core.generate_star_count_text"
  },
  "visualization_utils.add_hover_toggle_buttons": {
    "id": "visualization_utils.add_hover_toggle_buttons",
    "name": "add_hover_toggle_buttons",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_utils.py",
    "relative_path": "visualization_utils.py",
    "depends_on": [],
    "source_code": "def add_hover_toggle_buttons(fig):     \n    \"\"\"\n    Add hover text toggle buttons to any Plotly figure.\n    \n    Parameters:\n        fig (plotly.graph_objects.Figure): The figure to add buttons to\n        \n    Returns:\n        plotly.graph_objects.Figure: The modified figure with hover toggle buttons\n        \n    Note:\n        Traces must include both 'text' (full hover info) and 'customdata' (minimal hover info)\n        properties for the toggle to work correctly.\n    \"\"\"\n    # Get existing updatemenus and convert to list\n    updatemenus = list(fig.layout.updatemenus) if hasattr(fig.layout, 'updatemenus') and fig.layout.updatemenus is not None else []\n    \n    # Create hover text toggle buttons\n    hover_buttons = dict(\n        type=\"buttons\",\n        direction=\"right\",\n        x=0.2,\n        y=0.2,\n        buttons=[\n            dict(\n                label=\"Full Object Info\",\n                method=\"update\",\n        #        args=[{\"hovertemplate\": None}]\n                args=[{\"hovertemplate\": \"%{text}<extra></extra>\"}]\n                # Enhanced hover template with semi-transparent background\n        #        args=[{\"hovertemplate\": \"<div style='background-color:rgba(0,0,0,0); color:white; padding:10px; border-radius:5px;'>%{text}</div><extra></extra>\"}]\n            ),\n            dict(\n                label=\"Object Names Only\",\n                method=\"update\",\n                args=[{\"hovertemplate\": '%{customdata}<extra></extra>'}]\n                # Enhanced hover template with semi-transparent background\n        #        args=[{\"hovertemplate\": \"<div style='background-color:rgba(0,0,0,0); color:white; padding:5px; border-radius:5px;'>%{text}</div><extra></extra>\"}]\n            ),\n        ],\n        font=dict(color='blue'),        # button parameters\n        bgcolor='rgba(255,255,255,0.70)',\n        bordercolor='white',\n        borderwidth=1,\n    )\n    \n    # Add hover buttons to updatemenus\n    updatemenus.append(hover_buttons)\n    \n    # Update figure layout\n    fig.update_layout(updatemenus=updatemenus)\n\n    # Update default hovertemplate for all traces that aren't orbits\n    for trace in fig.data:\n        if trace.hoverinfo != 'skip':  # Skip orbit traces\n            trace.hovertemplate = \"%{text}<extra></extra>\"  # Set default template\n    \n    return fig",
    "start_line": 9,
    "end_line": 66,
    "has_docstring": true,
    "docstring": "Add hover text toggle buttons to any Plotly figure.\n\nParameters:\n    fig (plotly.graph_objects.Figure): The figure to add buttons to\n    \nReturns:\n    plotly.graph_objects.Figure: The modified figure with hover toggle buttons\n    \nNote:\n    Traces must include both 'text' (full hover info) and 'customdata' (minimal hover info)\n    properties for the toggle to work correctly.",
    "parameters": [
      "fig"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_hover_toggle_buttons",
    "component_id": "visualization_utils.add_hover_toggle_buttons"
  },
  "visualization_utils.add_camera_center_button": {
    "id": "visualization_utils.add_camera_center_button",
    "name": "add_camera_center_button",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_utils.py",
    "relative_path": "visualization_utils.py",
    "depends_on": [],
    "source_code": "def add_camera_center_button(fig, center_object_name='Sun'):\n    \"\"\"\n    Add a button to move the camera to the center object.\n    \n    Places the camera AT the center object (like standing on it) looking outward,\n    rather than looking AT the center from outside.\n    \n    Parameters:\n        fig (plotly.graph_objects.Figure): The figure to add buttons to\n        center_object_name (str): Name of the center object (default: 'Sun')\n        \n    Returns:\n        plotly.graph_objects.Figure: The modified figure with camera center button\n    \"\"\"\n    # Get existing updatemenus and convert to list\n    existing_menus = list(fig.layout.updatemenus) if hasattr(fig.layout, 'updatemenus') and fig.layout.updatemenus is not None else []\n    \n    # Capture the CURRENT axis ranges from the figure to preserve them\n    try:\n        if hasattr(fig.layout, 'scene') and hasattr(fig.layout.scene, 'xaxis'):\n            x_range = list(fig.layout.scene.xaxis.range)\n            y_range = list(fig.layout.scene.yaxis.range)\n            z_range = list(fig.layout.scene.zaxis.range)\n            has_ranges = True\n            print(f\"[Camera Button] Preserving axis ranges: X={x_range}, Y={y_range}, Z={z_range}\")\n        else:\n            has_ranges = False\n            print(f\"[Camera Button] Warning: Could not read axis ranges\")\n    except:\n        has_ranges = False\n        print(f\"[Camera Button] Warning: Error reading axis ranges\")\n    \n    # Build button args with camera AT the center looking along +X axis\n    # Eye at origin (the center object), looking along +X axis\n    # This puts you \"at\" the center object looking outward\n    button_args = {\n        \"scene.camera\": {\n            \"eye\": {\"x\": 0.001, \"y\": 0, \"z\": 0},  # AT the center (tiny offset to avoid singularity)\n            \"center\": {\"x\": 1, \"y\": 0, \"z\": 0},   # Looking along +X axis (toward RA=0deg)\n            \"up\": {\"x\": 0, \"y\": 0, \"z\": 1}        # Z-axis is up\n        }\n    }\n    \n    # Add axis ranges if we successfully captured them\n    if has_ranges:\n        button_args[\"scene.xaxis.range\"] = x_range\n        button_args[\"scene.yaxis.range\"] = y_range\n        button_args[\"scene.zaxis.range\"] = z_range\n    \n    # Create camera center button\n    camera_button = dict(\n        type=\"buttons\",\n        direction=\"left\",\n        x=0.05,\n        y=1.0,\n        buttons=[dict(\n    #        label=f\"Move Camera to {center_object_name} (Center) along the +X axis (Aries)\",\n            label=f\"Center (Aries)\",\n            method=\"relayout\",\n            args=[button_args]\n        )],\n        bgcolor='rgba(255,255,255,0.50)',\n        font=dict(color='blue'),\n        bordercolor='white',\n        borderwidth=1\n    )\n    \n    # Add to existing menus\n    existing_menus.append(camera_button)\n    \n    # Update figure layout\n    fig.update_layout(updatemenus=existing_menus)\n    \n    return fig",
    "start_line": 68,
    "end_line": 141,
    "has_docstring": true,
    "docstring": "Add a button to move the camera to the center object.\n\nPlaces the camera AT the center object (like standing on it) looking outward,\nrather than looking AT the center from outside.\n\nParameters:\n    fig (plotly.graph_objects.Figure): The figure to add buttons to\n    center_object_name (str): Name of the center object (default: 'Sun')\n    \nReturns:\n    plotly.graph_objects.Figure: The modified figure with camera center button",
    "parameters": [
      "fig",
      "center_object_name"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_camera_center_button",
    "component_id": "visualization_utils.add_camera_center_button"
  },
  "visualization_utils.add_look_at_object_buttons": {
    "id": "visualization_utils.add_look_at_object_buttons",
    "name": "add_look_at_object_buttons",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_utils.py",
    "relative_path": "visualization_utils.py",
    "depends_on": [],
    "source_code": "def add_look_at_object_buttons(fig, positions, center_object_name='Sun', target_objects=None):\n    \"\"\"\n    Add buttons to point camera from center toward specific target objects.\n    \n    Parameters:\n        fig (plotly.graph_objects.Figure): The figure to add buttons to\n        positions (dict): Dictionary mapping object names to their position data\n                         Each position should have 'x', 'y', 'z' keys\n        center_object_name (str): Name of the center object (default: 'Sun')\n        target_objects (list): List of object names to create buttons for\n                              If None, creates buttons for all major planets\n        \n    Returns:\n        plotly.graph_objects.Figure: The modified figure with look-at buttons\n    \"\"\"\n    # Get existing updatemenus and convert to list\n    existing_menus = list(fig.layout.updatemenus) if hasattr(fig.layout, 'updatemenus') and fig.layout.updatemenus is not None else []\n    \n    # Capture the CURRENT axis ranges from the figure to preserve them\n    try:\n        if hasattr(fig.layout, 'scene') and hasattr(fig.layout.scene, 'xaxis'):\n            x_range = list(fig.layout.scene.xaxis.range)\n            y_range = list(fig.layout.scene.yaxis.range)\n            z_range = list(fig.layout.scene.zaxis.range)\n            has_ranges = True\n        else:\n            has_ranges = False\n    except:\n        has_ranges = False\n    \n    # Default target objects if none specified (major planets + some interesting objects)\n    if target_objects is None:\n#        target_objects = ['Mercury', 'Venus', 'Earth', 'Mars', 'Jupiter', \n#                         'Saturn', 'Uranus', 'Neptune', 'Pluto']\n    # AFTER (auto-detect all objects):\n        target_objects = [name for name in positions.keys() if name != center_object_name]\n        print(f\"[Camera Buttons] Auto-detected {len(target_objects)} target objects from positions\")        \n\n    \n    # Get center position (default to origin if not in positions)\n    center_pos = [0, 0, 0]\n    if center_object_name in positions and positions[center_object_name] is not None:\n        center_data = positions[center_object_name]\n        if isinstance(center_data, dict) and 'x' in center_data:\n            center_pos = [center_data['x'], center_data['y'], center_data['z']]\n    \n    # Create list of buttons\n    buttons = []\n    \n    # First button: Look along +X axis (original behavior)\n    button_args_x = {\n        \"scene.camera\": {\n            \"eye\": {\"x\": 0.001, \"y\": 0, \"z\": 0},\n            \"center\": {\"x\": 1, \"y\": 0, \"z\": 0},\n            \"up\": {\"x\": 0, \"y\": 0, \"z\": 1}\n        }\n    }\n    if has_ranges:\n        button_args_x[\"scene.xaxis.range\"] = x_range\n        button_args_x[\"scene.yaxis.range\"] = y_range\n        button_args_x[\"scene.zaxis.range\"] = z_range\n    \n    buttons.append(dict(\n        label=f\"View +X axis (Aries) from {center_object_name}\",\n        method=\"relayout\",\n        args=[button_args_x]\n    ))\n    \n    # Add buttons for each target object\n    for target_name in target_objects:\n        if target_name not in positions or positions[target_name] is None:\n            continue\n            \n        target_data = positions[target_name]\n        if not isinstance(target_data, dict) or 'x' not in target_data:\n            continue\n        \n        target_pos = [target_data['x'], target_data['y'], target_data['z']]\n        \n        # Calculate direction vector from center to target\n        direction = np.array(target_pos) - np.array(center_pos)\n        distance = np.linalg.norm(direction)\n        \n        if distance < 1e-10:  # Too close, skip\n            continue\n        \n        # Normalize the direction\n        direction_norm = direction / distance\n        \n        # Place camera at center, looking toward target\n        # Use a small offset to avoid singularity at origin\n        camera_offset = 0.001\n        \n        # Camera position\n        eye_pos = {\n            'x': center_pos[0] + direction_norm[0] * camera_offset,\n            'y': center_pos[1] + direction_norm[1] * camera_offset,\n            'z': center_pos[2] + direction_norm[2] * camera_offset\n        }\n        \n        # Look at the target position\n        center_look = {\n            'x': target_pos[0],\n            'y': target_pos[1],\n            'z': target_pos[2]\n        }\n        \n        button_args = {\n            \"scene.camera\": {\n                \"eye\": eye_pos,\n                \"center\": center_look,\n                \"up\": {\"x\": 0, \"y\": 0, \"z\": 1}\n            }\n        }\n        \n        if has_ranges:\n            button_args[\"scene.xaxis.range\"] = x_range\n            button_args[\"scene.yaxis.range\"] = y_range\n            button_args[\"scene.zaxis.range\"] = z_range\n        \n        buttons.append(dict(\n            label=f\"View {target_name} from {center_object_name}\",\n            method=\"relayout\",\n            args=[button_args]\n        ))\n    \n    # Create dropdown menu with all buttons\n    if buttons:\n        camera_dropdown = dict(\n            type=\"dropdown\",\n            direction=\"down\",\n            x=0.02,\n            y=1.0,\n            xanchor=\"left\",\n            yanchor=\"top\",\n            buttons=buttons,\n            bgcolor='rgba(255,255,255,0.70)',\n            font=dict(color='blue'),\n            bordercolor='white',\n            borderwidth=1,\n            pad=dict(t=0, b=0)\n        )\n        \n        # Add to existing menus\n        existing_menus.append(camera_dropdown)\n        \n        # Update figure layout\n        fig.update_layout(updatemenus=existing_menus)\n        \n        # Add target marker annotation at screen center\n        fig.add_annotation(\n            dict(       # target marker \n                x=0.6,\n                y=0.5085,\n                text='<span style=\"vertical-align:1em;\"><></span>',                \n                showarrow=False,\n                xref='paper',\n                yref='paper',\n                font=dict(size=60, color='rgba(0, 255, 255, 0.5)')  # Semi-transparent cyan\n            )\n        )\n\n        print(f\"[Camera Buttons] Added dropdown with {len(buttons)} view options\")\n    \n    return fig",
    "start_line": 143,
    "end_line": 307,
    "has_docstring": true,
    "docstring": "Add buttons to point camera from center toward specific target objects.\n\nParameters:\n    fig (plotly.graph_objects.Figure): The figure to add buttons to\n    positions (dict): Dictionary mapping object names to their position data\n                     Each position should have 'x', 'y', 'z' keys\n    center_object_name (str): Name of the center object (default: 'Sun')\n    target_objects (list): List of object names to create buttons for\n                          If None, creates buttons for all major planets\n    \nReturns:\n    plotly.graph_objects.Figure: The modified figure with look-at buttons",
    "parameters": [
      "fig",
      "positions",
      "center_object_name",
      "target_objects"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_look_at_object_buttons",
    "component_id": "visualization_utils.add_look_at_object_buttons"
  },
  "visualization_utils.add_fly_to_object_buttons": {
    "id": "visualization_utils.add_fly_to_object_buttons",
    "name": "add_fly_to_object_buttons",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_utils.py",
    "relative_path": "visualization_utils.py",
    "depends_on": [],
    "source_code": "def add_fly_to_object_buttons(fig, positions, center_object_name='Sun', target_objects=None, \n                               fly_distance=0.1, distance_scale_factor=0.05):\n    \"\"\"\n    Add buttons to fly the camera TO specific target objects, keeping focus on the object.\n    \n    Unlike add_look_at_object_buttons (which views FROM center TOWARD target),\n    this places the camera NEAR the target looking AT the target.\n    \n    Parameters:\n        fig (plotly.graph_objects.Figure): The figure to add buttons to\n        positions (dict): Dictionary mapping object names to their position data\n                         Each position should have 'x', 'y', 'z' keys\n        center_object_name (str): Name of the center object (default: 'Sun')\n        target_objects (list): List of object names to create buttons for\n                              If None, creates buttons for all objects in positions\n        fly_distance (float): Base distance from object for camera (AU), default 0.1\n        distance_scale_factor (float): Scale factor for distance-based offset, default 0.05\n                                       Camera distance = fly_distance + (object_distance * scale_factor)\n        \n    Returns:\n        plotly.graph_objects.Figure: The modified figure with fly-to buttons\n    \"\"\"\n    # Get existing updatemenus and convert to list\n    existing_menus = list(fig.layout.updatemenus) if hasattr(fig.layout, 'updatemenus') and fig.layout.updatemenus is not None else []\n    \n    # Default target objects if none specified\n    if target_objects is None:\n        target_objects = [name for name in positions.keys() if name != center_object_name]\n        print(f\"[Fly To Buttons] Auto-detected {len(target_objects)} target objects from positions\")\n    \n    # Get center position (default to origin if not in positions)\n    center_pos = np.array([0.0, 0.0, 0.0])\n    if center_object_name in positions and positions[center_object_name] is not None:\n        center_data = positions[center_object_name]\n        if isinstance(center_data, dict) and 'x' in center_data:\n            center_pos = np.array([center_data['x'], center_data['y'], center_data['z']])\n    \n    # Create list of buttons\n    buttons = []\n        \n    # Capture original axis ranges for \"Full View\" button\n    try:\n        orig_x_range = list(fig.layout.scene.xaxis.range) if fig.layout.scene.xaxis.range else None\n        orig_y_range = list(fig.layout.scene.yaxis.range) if fig.layout.scene.yaxis.range else None\n        orig_z_range = list(fig.layout.scene.zaxis.range) if fig.layout.scene.zaxis.range else None\n    except:\n        orig_x_range = orig_y_range = orig_z_range = None\n    \n    # Add \"Full View\" button first if we have original ranges\n    if orig_x_range and orig_y_range and orig_z_range:\n        buttons.append(dict(\n            label=\"Return to Full View\",\n            method=\"relayout\",\n            args=[{\n                \"scene.camera\": {\n                    \"eye\": {\"x\": 1.5, \"y\": 1.5, \"z\": 1.2},\n                    \"center\": {\"x\": 0, \"y\": 0, \"z\": 0},\n                    \"up\": {\"x\": 0, \"y\": 0, \"z\": 1}\n                },\n                \"scene.xaxis.range\": orig_x_range,\n                \"scene.yaxis.range\": orig_y_range,\n                \"scene.zaxis.range\": orig_z_range,\n                \"scene.aspectmode\": \"cube\",\n                \"scene.aspectratio\": {\"x\": 1, \"y\": 1, \"z\": 1}\n            }]\n        ))\n    \n    # Add buttons for each target object\n    for target_name in target_objects:\n        if target_name not in positions or positions[target_name] is None:\n            continue\n            \n        target_data = positions[target_name]\n        if not isinstance(target_data, dict) or 'x' not in target_data:\n            continue\n        \n        target_pos = np.array([target_data['x'], target_data['y'], target_data['z']])\n        \n        # Calculate direction vector from target to center (camera will be on this side)\n        direction_to_center = center_pos - target_pos\n        distance_from_center = np.linalg.norm(direction_to_center)\n        \n        if distance_from_center < 1e-10:  # Target is at center, skip\n            continue\n        \n        # Normalize the direction\n        direction_norm = direction_to_center / distance_from_center\n        \n        # Calculate camera offset distance (closer for nearby objects, slightly further for distant)\n        view_radius = fly_distance + (distance_from_center * distance_scale_factor)\n\n        # Zoom axis ranges to target area\n        new_x_range = [float(target_pos[0]) - view_radius, float(target_pos[0]) + view_radius]\n        new_y_range = [float(target_pos[1]) - view_radius, float(target_pos[1]) + view_radius]\n        new_z_range = [float(target_pos[2]) - view_radius, float(target_pos[2]) + view_radius]\n        \n        button_args = {\n            \"scene.camera\": {\n                \"eye\": {\"x\": 1.5, \"y\": 1.5, \"z\": 1.2},\n                \"center\": {\"x\": 0, \"y\": 0, \"z\": 0},\n                \"up\": {\"x\": 0, \"y\": 0, \"z\": 1}\n            },\n            \"scene.xaxis.range\": new_x_range,\n            \"scene.yaxis.range\": new_y_range,\n            \"scene.zaxis.range\": new_z_range,\n            \"scene.aspectmode\": \"cube\",\n            \"scene.aspectratio\": {\"x\": 1, \"y\": 1, \"z\": 1}            \n        }\n        \n        # Format distance for label\n        if distance_from_center < 0.01:\n            dist_str = f\"{distance_from_center*149597870.7:.0f} km\"  # Convert AU to km\n        elif distance_from_center < 1:\n            dist_str = f\"{distance_from_center:.3f} AU\"\n        else:\n            dist_str = f\"{distance_from_center:.2f} AU\"\n        \n        buttons.append(dict(\n            label=f\"Fly to {target_name} ({dist_str})\",\n            method=\"relayout\",\n            args=[button_args]\n        ))\n    \n    # Sort buttons by distance for easier navigation\n    def extract_distance(button):\n        label = button['label']\n        if \"Full View\" in label:\n            return -1  # Keep Full View first\n        try:\n            # Extract the part in parentheses\n            dist_part = label.split('(')[1].split(')')[0]\n            if 'km' in dist_part:\n                return float(dist_part.replace(' km', '').replace(',', '')) / 149597870.7\n            else:\n                return float(dist_part.replace(' AU', ''))\n        except:\n            return float('inf')\n    \n    buttons.sort(key=extract_distance)\n    \n    # Create dropdown menu with all buttons\n    if buttons:\n        fly_to_dropdown = dict(\n            type=\"dropdown\",\n            direction=\"down\",\n            x=0.02,\n            y=0.92,  # Position below the \"View from\" dropdown\n            xanchor=\"left\",\n            yanchor=\"top\",\n            buttons=buttons,\n            bgcolor='rgba(255,255,200,0.85)',  # Slightly yellow to distinguish from View dropdown\n            font=dict(color='darkgreen'),\n            bordercolor='green',\n            borderwidth=1,\n            pad=dict(t=0, b=0)\n        )\n        \n        # Add to existing menus\n        existing_menus.append(fly_to_dropdown)\n        \n        # Update figure layout\n        fig.update_layout(updatemenus=existing_menus)\n        \n        print(f\"[Fly To Buttons] Added dropdown with {len(buttons)} fly-to options\")\n    \n    return fig",
    "start_line": 310,
    "end_line": 475,
    "has_docstring": true,
    "docstring": "Add buttons to fly the camera TO specific target objects, keeping focus on the object.\n\nUnlike add_look_at_object_buttons (which views FROM center TOWARD target),\nthis places the camera NEAR the target looking AT the target.\n\nParameters:\n    fig (plotly.graph_objects.Figure): The figure to add buttons to\n    positions (dict): Dictionary mapping object names to their position data\n                     Each position should have 'x', 'y', 'z' keys\n    center_object_name (str): Name of the center object (default: 'Sun')\n    target_objects (list): List of object names to create buttons for\n                          If None, creates buttons for all objects in positions\n    fly_distance (float): Base distance from object for camera (AU), default 0.1\n    distance_scale_factor (float): Scale factor for distance-based offset, default 0.05\n                                   Camera distance = fly_distance + (object_distance * scale_factor)\n    \nReturns:\n    plotly.graph_objects.Figure: The modified figure with fly-to buttons",
    "parameters": [
      "fig",
      "positions",
      "center_object_name",
      "target_objects",
      "fly_distance",
      "distance_scale_factor"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function add_fly_to_object_buttons",
    "component_id": "visualization_utils.add_fly_to_object_buttons"
  },
  "visualization_utils.extract_distance": {
    "id": "visualization_utils.extract_distance",
    "name": "extract_distance",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_utils.py",
    "relative_path": "visualization_utils.py",
    "depends_on": [],
    "source_code": "    def extract_distance(button):\n        label = button['label']\n        if \"Full View\" in label:\n            return -1  # Keep Full View first\n        try:\n            # Extract the part in parentheses\n            dist_part = label.split('(')[1].split(')')[0]\n            if 'km' in dist_part:\n                return float(dist_part.replace(' km', '').replace(',', '')) / 149597870.7\n            else:\n                return float(dist_part.replace(' AU', ''))\n        except:\n            return float('inf')",
    "start_line": 434,
    "end_line": 446,
    "has_docstring": false,
    "docstring": "",
    "parameters": [
      "button"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function extract_distance",
    "component_id": "visualization_utils.extract_distance"
  },
  "visualization_utils.format_hover_text": {
    "id": "visualization_utils.format_hover_text",
    "name": "format_hover_text",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_utils.py",
    "relative_path": "visualization_utils.py",
    "depends_on": [],
    "source_code": "def format_hover_text(obj_data, name, is_solar_system=False):\n    \"\"\"\n    Format hover text consistently for different types of objects.\n    \n    Parameters:\n        obj_data (dict): Object data containing position and other properties\n        name (str): Name of the object\n        is_solar_system (bool): Whether this is a solar system object\n        \n    Returns:\n        tuple: (full_hover_text, minimal_hover_text)\n    \"\"\"\n    minimal_hover_text = f\"<b>{name}</b>\"\n    \n    if is_solar_system:\n        # Format values with proper handling of non-numeric values\n        range_str = f\"{obj_data.get('range', 'N/A'):.5f}\" if isinstance(obj_data.get('range'), (int, float)) else 'N/A'\n        dist_lm_str = f\"{obj_data.get('distance_lm', 'N/A'):.5f}\" if isinstance(obj_data.get('distance_lm'), (int, float)) else 'N/A'\n        dist_lh_str = f\"{obj_data.get('distance_lh', 'N/A'):.5f}\" if isinstance(obj_data.get('distance_lh'), (int, float)) else 'N/A'\n        vel_str = f\"{obj_data.get('velocity', 'N/A'):.5f}\" if isinstance(obj_data.get('velocity'), (int, float)) else 'N/A'\n        \n        # Build hover text\n        full_hover_text = (\n            f\"<b>{name}</b><br><br>\"\n            f\"Distance from Center: {range_str} AU<br>\"\n            f\"Distance: {dist_lm_str} light-minutes<br>\"\n            f\"Distance: {dist_lh_str} light-hours<br>\"\n            f\"Velocity: {vel_str} AU/day<br>\"\n            f\"Orbital Period: {obj_data.get('orbital_period', 'N/A')} Earth years\"\n        )\n        \n        if obj_data.get('mission_info'):\n            full_hover_text += f\"<br>{obj_data['mission_info']}\"\n    else:\n        # Format for stellar objects with proper handling of non-numeric values\n        dist_pc = obj_data.get('Distance_pc', 'N/A')\n        dist_ly = obj_data.get('Distance_ly', 'N/A')\n        temp = obj_data.get('Temperature', 'N/A')\n        lum = obj_data.get('Luminosity', 'N/A')\n        app_mag = obj_data.get('Apparent_Magnitude', 'N/A')\n        \n        dist_pc_str = f\"{dist_pc:.2f}\" if isinstance(dist_pc, (int, float)) else 'N/A'\n        dist_ly_str = f\"{dist_ly:.2f}\" if isinstance(dist_ly, (int, float)) else 'N/A'\n        temp_str = f\"{temp:.0f}\" if isinstance(temp, (int, float)) else 'N/A'\n        lum_str = f\"{lum:.6f}\" if isinstance(lum, (int, float)) else 'N/A'\n        app_mag_str = f\"{app_mag:.2f}\" if isinstance(app_mag, (int, float)) else 'N/A'\n        \n        full_hover_text = (\n            f\"<b>{name}</b><br><br>\"\n            f\"Distance: {dist_pc_str} pc ({dist_ly_str} ly)<br>\"\n            f\"Temperature: {temp_str} K<br>\"\n            f\"Luminosity: {lum_str} Lsun<br>\"\n            f\"Apparent Magnitude: {app_mag_str}<br>\"\n            f\"Spectral Type: {obj_data.get('Spectral_Type', 'Unknown')}<br>\"\n            f\"Source Catalog: {obj_data.get('Source_Catalog', 'Unknown')}\"\n        )\n    \n    return full_hover_text, minimal_hover_text",
    "start_line": 478,
    "end_line": 535,
    "has_docstring": true,
    "docstring": "Format hover text consistently for different types of objects.\n\nParameters:\n    obj_data (dict): Object data containing position and other properties\n    name (str): Name of the object\n    is_solar_system (bool): Whether this is a solar system object\n    \nReturns:\n    tuple: (full_hover_text, minimal_hover_text)",
    "parameters": [
      "obj_data",
      "name",
      "is_solar_system"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function format_hover_text",
    "component_id": "visualization_utils.format_hover_text"
  },
  "visualization_utils.format_detailed_hover_text": {
    "id": "visualization_utils.format_detailed_hover_text",
    "name": "format_detailed_hover_text",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_utils.py",
    "relative_path": "visualization_utils.py",
    "depends_on": [
      "formatting_utils.format_maybe_float",
      "celestial_coordinates.format_radec_hover_component",
      "formatting_utils.format_km_float"
    ],
    "source_code": "def format_detailed_hover_text(obj_data, obj_name, center_object_name, objects, planetary_params, parent_planets, CENTER_BODY_RADII, \n                               KM_PER_AU, LIGHT_MINUTES_PER_AU, KNOWN_ORBITAL_PERIODS):\n    \"\"\"\n    Generate detailed hover text for celestial objects with comprehensive information.\n    \n    Parameters:\n        obj_data (dict): Object position data\n        obj_name (str): Name of the celestial object\n        center_object_name (str): Name of the center body\n        objects (list): List of all celestial objects\n        planetary_params (dict): Dictionary of planetary parameters\n        parent_planets (dict): Dictionary mapping planets to their satellites\n        CENTER_BODY_RADII (dict): Dictionary of body radii in km\n        KM_PER_AU (float): Conversion factor from AU to km\n        LIGHT_MINUTES_PER_AU (float): Conversion factor from AU to light-minutes\n        KNOWN_ORBITAL_PERIODS (dict): Dictionary of known orbital periods\n        \n    Returns:\n        tuple: (full_hover_text, minimal_hover_text, satellite_note)\n    \"\"\"\n    # Calculate distance from center\n    distance_from_origin = np.sqrt(obj_data['x']**2 + obj_data['y']**2 + obj_data['z']**2)\n    \n    # Format values with proper formatting functions\n    distance_au = format_maybe_float(distance_from_origin)\n    distance_km = format_km_float(distance_from_origin * KM_PER_AU)\n    distance_lm = format_maybe_float(distance_from_origin * LIGHT_MINUTES_PER_AU)\n    distance_lh = format_maybe_float(distance_from_origin * LIGHT_MINUTES_PER_AU / 60)\n    velocity_au = format_maybe_float(obj_data.get('velocity', 'N/A'))\n    \n    # Calculate velocity in km/hr and km/sec\n    velocity_km_hr = \"N/A\"\n    velocity_km_sec = \"N/A\"\n    if isinstance(obj_data.get('velocity'), (int, float)):\n        vel_km_hr_val = obj_data.get('velocity') * KM_PER_AU / 24\n        vel_km_sec_val = vel_km_hr_val / 3600\n        velocity_km_hr = f\"{vel_km_hr_val:,.2f}\"\n        velocity_km_sec = f\"{vel_km_sec_val:.3f}\"\n    \n    # Calculate surface distance if we have valid distance data\n    center_radius_km = CENTER_BODY_RADII.get(center_object_name, 0)  # Default to 0 if center body not found\n    surface_distance_str = \"N/A\"\n    \n#    if isinstance(distance_from_origin * KM_PER_AU, (int, float)) and (distance_from_origin * KM_PER_AU) > center_radius_km:\n    if isinstance(distance_from_origin * KM_PER_AU, (int, float)):\n        surface_distance_km = (distance_from_origin * KM_PER_AU) - center_radius_km\n        surface_distance_str = format_km_float(surface_distance_km)\n\n    # Add an explanatory note for negative values\n    if surface_distance_km < 0:\n        surface_distance_str += \" (below mean datum)\"       # This applies to the Mars Rover that is sitting below the datum.\n    \n    # Check if this is a planetary satellite\n    is_satellite = False\n    planet = None\n    for p, satellites in parent_planets.items():\n        if obj_name in satellites:\n            is_satellite = True\n            planet = p\n            break\n    \n    # Get orbital period information\n#    calculated_period = \"N/A\"\n    known_period = \"N/A\"\n    \n    # Calculate orbital period for non-satellites\n#    if not is_satellite and obj_name in planetary_params:\n#        a = planetary_params[obj_name]['a']  # Semi-major axis in AU\n            \n#       if a > 0:\n#            orbital_period_years = np.sqrt(a ** 3)\n#            calculated_period = {\n#                'years': orbital_period_years,\n#                'days': orbital_period_years * 365.25\n#            }  # OK: Correct indentation - closes the dict properly\n\n    \n    # Format calculated period\n#    if isinstance(calculated_period, dict):\n#        calc_years = calculated_period.get('years')\n#        calc_days = calculated_period.get('days')\n#        calculated_period_str = f\"{calc_years:.4f} Earth years ({calc_days:.2f} days)\"\n#    else:\n#        calculated_period_str = str(calculated_period)\n    \n    # Get known orbital period if available\n#    if obj_name in KNOWN_ORBITAL_PERIODS:\n#        known_value = KNOWN_ORBITAL_PERIODS[obj_name]\n        \n#        if known_value is None:\n            # Handle hyperbolic/parabolic objects\n#            known_period = \"N/A (hyperbolic/parabolic orbit)\"\n#        else:\n#            known_period = {\n#                'days': known_value,\n#                'years': known_value / 365.25\n#            }\n    \n    # Get known orbital period if available\n    # Context-aware: Pluto uses barycentric period (6.387 days) when centered on Pluto-Charon Barycenter\n    if obj_name == 'Pluto' and center_object_name == 'Pluto-Charon Barycenter':\n        # Pluto orbits the barycenter with the same period as Charon (6.387 days)\n        known_value = 6.387  # Binary orbital period, same as Charon\n        known_period = {\n            'days': known_value,\n            'years': known_value / 365.25\n        }\n    elif obj_name in KNOWN_ORBITAL_PERIODS:\n        known_value = KNOWN_ORBITAL_PERIODS[obj_name]\n        \n        if known_value is None:\n            # Handle hyperbolic/parabolic objects\n            known_period = \"N/A (hyperbolic/parabolic orbit)\"\n        else:\n            known_period = {\n                'days': known_value,\n                'years': known_value / 365.25\n            }\n\n    # Format known period\n    if isinstance(known_period, dict):\n        known_years = known_period.get('years')\n        known_days = known_period.get('days')\n        known_period_str = f\"{known_years:.4f} Earth years ({known_days:.2f} days)\"\n    else:\n        known_period_str = str(known_period)\n    \n    # Find the object's info in the objects list\n    obj_info = next((o for o in objects if o['name'] == obj_name), None)\n    mission_info = obj_info.get('mission_info', '') if obj_info else ''\n    \n    # ===== NEW: Calculate RA/Dec for full hover text =====\n    radec_component = format_radec_hover_component(obj_data, obj_name, compact=False)    \n        \n    # Now build the hover text\n    if radec_component:\n            # If we have RA/Dec, include it\n        full_hover_text = (\n            f\"<b>{obj_name}</b><br>\"  # <- Note: Changed from \"<br><br>\" to \"<br>\"\n            f\"{radec_component}<br><br>\"  # <- NEW LINE: RA/Dec info\n            f\"Distance from Center: {distance_au} AU<br>\"\n            f\"Distance: {distance_km} kilometers<br>\"\n            f\"Distance: {distance_lm} light-minutes<br>\"\n            f\"Distance: {distance_lh} light-hours<br>\"\n            f\"Distance to Center Surface: {surface_distance_str} kilometers<br>\"\n            f\"Velocity: {velocity_au} AU/day<br>\"\n            f\"Velocity: {velocity_km_hr} km/hr ({velocity_km_sec} km/sec)<br>\"\n        )\n    \n    else:\n        # If no RA/Dec available, keep original format\n        full_hover_text = (\n            f\"<b>{obj_name}</b><br><br>\"\n            f\"Distance from Center: {distance_au} AU<br>\"\n            f\"Distance: {distance_km} kilometers<br>\"\n            f\"Distance: {distance_lm} light-minutes<br>\"\n            f\"Distance to Center Surface: {surface_distance_str} kilometers<br>\"\n            f\"Velocity: {velocity_au} AU/day<br>\"\n            f\"Velocity: {velocity_km_hr} km/hr ({velocity_km_sec} km/sec)<br>\"\n        )\n    \n    # Add orbital period information (known period only)\n    full_hover_text += f\"Known Orbital Period: {known_period_str}\"\n    \n    # Add derivation note for Orcus when derived from Vanth\n    if obj_data.get('derived_from_vanth'):\n        full_hover_text += (\n            f\"<br><br><b>Position: Derived from Vanth</b><br>\"\n            f\"JPL cannot query Orcus (920090482) at barycenter.<br>\"\n            f\"Derived: Orcus pos = -Vanth pos x 0.16 (mass ratio)<br>\"\n            f\"Data: JPL Horizons ID 120090482\"\n        )\n\n    # Add mission_info if it exists\n    if mission_info:\n        full_hover_text += f\"<br>{mission_info}\"\n    \n    # Determine if this is a satellite of the center object specifically\n    satellite_note = \"\"\n    if is_satellite and planet == center_object_name:\n        satellite_note = f\"<br>Moon of {center_object_name}\"\n    \n\n    # ===== NEW: Calculate RA/Dec for minimal hover text =====\n    radec_compact = format_radec_hover_component(obj_data, obj_name, compact=True)\n\n    minimal_hover_text = f\"<b>{obj_name}</b>\"\n    if radec_compact:\n        minimal_hover_text += f\"<br>{radec_compact}\"  # <- NEW LINE   \n    \n    return full_hover_text, minimal_hover_text, satellite_note",
    "start_line": 537,
    "end_line": 727,
    "has_docstring": true,
    "docstring": "Generate detailed hover text for celestial objects with comprehensive information.\n\nParameters:\n    obj_data (dict): Object position data\n    obj_name (str): Name of the celestial object\n    center_object_name (str): Name of the center body\n    objects (list): List of all celestial objects\n    planetary_params (dict): Dictionary of planetary parameters\n    parent_planets (dict): Dictionary mapping planets to their satellites\n    CENTER_BODY_RADII (dict): Dictionary of body radii in km\n    KM_PER_AU (float): Conversion factor from AU to km\n    LIGHT_MINUTES_PER_AU (float): Conversion factor from AU to light-minutes\n    KNOWN_ORBITAL_PERIODS (dict): Dictionary of known orbital periods\n    \nReturns:\n    tuple: (full_hover_text, minimal_hover_text, satellite_note)",
    "parameters": [
      "obj_data",
      "obj_name",
      "center_object_name",
      "objects",
      "planetary_params",
      "parent_planets",
      "CENTER_BODY_RADII",
      "KM_PER_AU",
      "LIGHT_MINUTES_PER_AU",
      "KNOWN_ORBITAL_PERIODS"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function format_detailed_hover_text",
    "component_id": "visualization_utils.format_detailed_hover_text"
  },
  "visualization_utils.update_figure_frames": {
    "id": "visualization_utils.update_figure_frames",
    "name": "update_figure_frames",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\visualization_utils.py",
    "relative_path": "visualization_utils.py",
    "depends_on": [
      "visualization_utils.add_hover_toggle_buttons"
    ],
    "source_code": "def update_figure_frames(fig, include_hover_toggle=True):\n    \"\"\"\n    Update figure frames to maintain hover text toggle functionality in animations.\n    \n    Parameters:\n        fig (plotly.graph_objects.Figure): The figure containing frames\n        include_hover_toggle (bool): Whether to include hover toggle buttons\n    \n    Returns:\n        plotly.graph_objects.Figure: The updated figure\n    \"\"\"\n    if not hasattr(fig, 'frames') or not fig.frames:\n        return fig\n        \n    # Add hover toggle buttons if requested\n    if include_hover_toggle:\n        fig = add_hover_toggle_buttons(fig)\n    \n    # Ensure frames maintain hover text format\n    for frame in fig.frames:\n        for trace in frame.data:\n            if hasattr(trace, 'hovertemplate'):\n                trace.hovertemplate = '%{text}<extra></extra>'\n    \n    return fig",
    "start_line": 729,
    "end_line": 753,
    "has_docstring": true,
    "docstring": "Update figure frames to maintain hover text toggle functionality in animations.\n\nParameters:\n    fig (plotly.graph_objects.Figure): The figure containing frames\n    include_hover_toggle (bool): Whether to include hover toggle buttons\n\nReturns:\n    plotly.graph_objects.Figure: The updated figure",
    "parameters": [
      "fig",
      "include_hover_toggle"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function update_figure_frames",
    "component_id": "visualization_utils.update_figure_frames"
  },
  "vot_cache_manager.VOTCacheMetadata": {
    "id": "vot_cache_manager.VOTCacheMetadata",
    "name": "VOTCacheMetadata",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\vot_cache_manager.py",
    "relative_path": "vot_cache_manager.py",
    "depends_on": [],
    "source_code": "class VOTCacheMetadata:\n    \"\"\"Metadata for VOT cache files\"\"\"\n    filename: str\n    query_type: str  # 'distance' or 'magnitude'\n    limit_value: float\n    entry_count: int\n    creation_date: str\n    last_modified: str\n    catalog: str  # 'hipparcos' or 'gaia'\n    min_parallax: Optional[float] = None  # For distance queries\n    checksum: Optional[str] = None\n    \n    def to_dict(self):\n        return asdict(self)\n    \n    @classmethod\n    def from_dict(cls, data: Dict):\n        return cls(**data)",
    "start_line": 24,
    "end_line": 41,
    "has_docstring": true,
    "docstring": "Metadata for VOT cache files",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class VOTCacheMetadata",
    "component_id": "vot_cache_manager.VOTCacheMetadata"
  },
  "vot_cache_manager.VOTCacheManager": {
    "id": "vot_cache_manager.VOTCacheManager",
    "name": "VOTCacheManager",
    "component_type": "class",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\vot_cache_manager.py",
    "relative_path": "vot_cache_manager.py",
    "depends_on": [
      "vot_cache_manager.VOTCacheMetadata",
      "star_properties.query_simbad_for_star_properties"
    ],
    "source_code": "class VOTCacheManager:\n    \"\"\"Manager for safe VOT cache file operations\"\"\"\n    \n#    def __init__(self, cache_dir: str = '.'):\n    def __init__(self, cache_dir: str = 'star_data'):\n        self.cache_dir = cache_dir\n        self.metadata_suffix = '_metadata.json'\n        self.backup_suffix = '.backup'\n        self.temp_suffix = '.tmp'\n        \n        # Protected base VOT files (recovered archives)\n        self.protected_files = {\n            'hipparcos_data_distance.vot': {\n                'type': 'distance',\n                'limit': 100.1,  # 100.1 light-years\n                'catalog': 'hipparcos'\n            },\n            'hipparcos_data_magnitude.vot': {\n                'type': 'magnitude', \n                'limit': 9.0,  # V magnitude 9\n                'catalog': 'hipparcos'\n            },\n            'gaia_data_distance.vot': {\n                'type': 'distance',\n                'limit': 100.1,\n                'catalog': 'gaia'\n            },\n            'gaia_data_magnitude.vot': {\n                'type': 'magnitude',\n                'limit': 9.0,\n                'catalog': 'gaia'\n            }\n        }\n    \n    def protect_base_file(self, filepath: str) -> bool:\n        \"\"\"\n        Create protected backup of base VOT file.\n        Similar to PKL protection in simbad_manager.\n        \"\"\"\n        if not os.path.exists(filepath):\n            logger.warning(f\"Base file {filepath} does not exist\")\n            return False\n        \n        # Create protected backup with timestamp\n        protected_backup = filepath + '.protected_' + time.strftime('%Y%m%d_%H%M%S')\n        \n        try:\n            shutil.copy2(filepath, protected_backup)\n            logger.info(f\"Created protected backup: {protected_backup}\")\n            \n            # Also create metadata for the protected file\n            self._create_metadata_for_vot(filepath, protected_backup)\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to protect base file {filepath}: {e}\")\n            return False\n    \n    def _create_metadata_for_vot(self, original_path: str, backup_path: str = None):\n        \"\"\"Create metadata file for VOT cache\"\"\"\n        target_path = backup_path if backup_path else original_path\n        \n        try:\n            # Load VOT to get entry count\n            table = Table.read(target_path, format='votable')\n            entry_count = len(table)\n            \n            # Get file info from protected_files or infer\n            basename = os.path.basename(original_path)\n            file_info = self.protected_files.get(basename, {})\n            \n            metadata = VOTCacheMetadata(\n                filename=basename,\n                query_type=file_info.get('type', 'unknown'),\n                limit_value=file_info.get('limit', 0.0),\n                entry_count=entry_count,\n                creation_date=datetime.now().isoformat(),\n                last_modified=datetime.now().isoformat(),\n                catalog=file_info.get('catalog', 'unknown')\n            )\n            \n            # Save metadata\n            metadata_file = target_path + self.metadata_suffix\n            with open(metadata_file, 'w') as f:\n                json.dump(metadata.to_dict(), f, indent=2)\n            \n            logger.info(f\"Created metadata for {target_path}: {entry_count} entries\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to create metadata for {target_path}: {e}\")\n    \n    def safe_load_vot(self, filepath: str) -> Optional[Table]:\n        \"\"\"\n        Safely load VOT file with validation.\n        Returns None if file is corrupted or missing.\n        \"\"\"\n        if not os.path.exists(filepath):\n            logger.warning(f\"VOT file not found: {filepath}\")\n            return None\n        \n        try:\n            table = Table.read(filepath, format='votable')\n            \n            # Basic validation\n            if len(table) == 0:\n                logger.warning(f\"VOT file {filepath} is empty\")\n                return None\n            \n            # Check for required columns based on catalog type\n            basename = os.path.basename(filepath)\n            if 'hipparcos' in basename.lower():\n                required_cols = ['HIP', 'Plx', 'Vmag']\n            elif 'gaia' in basename.lower():\n                required_cols = ['Source', 'Plx', 'Gmag']\n            else:\n                required_cols = []\n            \n            missing_cols = [col for col in required_cols if col not in table.colnames]\n            if missing_cols:\n                logger.warning(f\"VOT file {filepath} missing columns: {missing_cols}\")\n            \n            return table\n            \n        except Exception as e:\n            logger.error(f\"Failed to load VOT file {filepath}: {e}\")\n            \n            # Try to restore from backup\n            backup_file = filepath + self.backup_suffix\n            if os.path.exists(backup_file):\n                logger.info(f\"Attempting to restore from backup: {backup_file}\")\n                try:\n                    table = Table.read(backup_file, format='votable')\n                    # Restore the main file\n                    shutil.copy2(backup_file, filepath)\n                    logger.info(f\"Successfully restored {filepath} from backup\")\n                    return table\n                except Exception as e2:\n                    logger.error(f\"Failed to restore from backup: {e2}\")\n            \n            return None\n    \n    def safe_save_vot(self, table: Table, filepath: str, metadata: Optional[VOTCacheMetadata] = None):\n        \"\"\"\n        Safely save VOT file with atomic operation and backup.\n        Similar to safe_save_properties in simbad_manager.\n        \"\"\"\n        if table is None or len(table) == 0:\n            logger.error(\"Refusing to save empty table\")\n            raise ValueError(\"Cannot save empty VOT table\")\n        \n        # Safety check: prevent data loss\n        if os.path.exists(filepath):\n            existing_table = self.safe_load_vot(filepath)\n            if existing_table is not None:\n                original_count = len(existing_table)\n                new_count = len(table)\n                \n                # Don't allow massive data loss\n                if original_count > 100 and new_count < original_count * 0.1:\n                    emergency_backup = filepath + '.emergency_' + time.strftime('%Y%m%d_%H%M%S')\n                    shutil.copy2(filepath, emergency_backup)\n                    logger.error(f\"SAFETY: Blocked save that would reduce {original_count} to {new_count} entries\")\n                    logger.info(f\"Emergency backup created: {emergency_backup}\")\n                    raise ValueError(f\"Refusing to save: would lose {original_count - new_count} entries\")\n        \n        # Atomic save operation\n        temp_file = filepath + self.temp_suffix\n        backup_file = filepath + self.backup_suffix\n        \n        try:\n            # Write to temp file\n            votable.writeto(votable.from_table(table), temp_file)\n            \n            # Verify temp file\n            verify_table = Table.read(temp_file, format='votable')\n            if len(verify_table) != len(table):\n                raise ValueError(\"Verification failed: row count mismatch\")\n            \n            # Backup original if it exists\n            if os.path.exists(filepath):\n                if os.path.exists(backup_file):\n                    os.remove(backup_file)\n                shutil.move(filepath, backup_file)\n            \n            # Move temp to final\n            shutil.move(temp_file, filepath)\n            \n            # Save metadata if provided\n            if metadata:\n                metadata.last_modified = datetime.now().isoformat()\n                metadata.entry_count = len(table)\n                metadata_file = filepath + self.metadata_suffix\n                with open(metadata_file, 'w') as f:\n                    json.dump(metadata.to_dict(), f, indent=2)\n            \n            # Clean up backup if successful\n            if os.path.exists(backup_file):\n                os.remove(backup_file)\n            \n            logger.info(f\"Saved {len(table)} entries to {filepath}\")\n            \n        except Exception as e:\n            logger.error(f\"Error saving VOT file: {e}\")\n            \n            # Restore from backup if available\n            if os.path.exists(backup_file):\n                shutil.copy2(backup_file, filepath)\n                logger.info(\"Restored from backup after save failure\")\n            \n            # Clean up temp file\n            if os.path.exists(temp_file):\n                try:\n                    os.remove(temp_file)\n                except:\n                    pass\n            raise\n    \n    def merge_vot_incremental(self, existing_table: Table, new_table: Table, \n                             mode: str = 'distance') -> Table:\n        \"\"\"\n        Merge new VOT data with existing cache.\n        Similar to incremental cache updates for PKL files.\n        \"\"\"\n        if existing_table is None:\n            return new_table\n        if new_table is None or len(new_table) == 0:\n            return existing_table\n        \n        # Identify unique column based on catalog\n        if 'HIP' in existing_table.colnames:\n            id_col = 'HIP'\n        elif 'Source' in existing_table.colnames:\n            id_col = 'Source'\n        else:\n            # Fall back to simple concatenation\n            logger.warning(\"No ID column found, concatenating tables\")\n            from astropy.table import vstack\n            return vstack([existing_table, new_table])\n        \n        # Get existing IDs\n        existing_ids = set(existing_table[id_col])\n        \n        # Filter new data to only include non-duplicates\n        new_mask = [id_val not in existing_ids for id_val in new_table[id_col]]\n        unique_new = new_table[new_mask]\n        \n        if len(unique_new) > 0:\n            from astropy.table import vstack\n            merged = vstack([existing_table, unique_new])\n            logger.info(f\"Added {len(unique_new)} new entries to cache\")\n            return merged\n        else:\n            logger.info(\"No new unique entries to add\")\n            return existing_table\n    \n    def rebuild_pkl_from_caches(self, properties_file: str, \n                               vot_files: Dict[str, str],\n                               simbad_manager_instance: Any) -> Dict:\n        \"\"\"\n        Rebuild PKL properties file from existing VOT and PKL caches.\n        This merges VizieR catalog data with SIMBAD properties.\n        \"\"\"\n        logger.info(f\"Rebuilding {properties_file} from VOT and existing caches...\")\n        \n        all_properties = {}\n        \n        # Load data from each VOT file\n        for catalog, vot_file in vot_files.items():\n            if not os.path.exists(vot_file):\n                logger.warning(f\"VOT file not found: {vot_file}\")\n                continue\n            \n            table = self.safe_load_vot(vot_file)\n            if table is None:\n                continue\n            \n            logger.info(f\"Processing {len(table)} entries from {catalog}\")\n            \n            # Extract star identifiers and basic properties\n            if 'hipparcos' in catalog.lower():\n                for row in table:\n                    hip_id = f\"HIP {row['HIP']}\"\n                    \n                    # Initialize property dict\n                    props = {\n                        'unique_id': hip_id,\n                        'Source_Catalog': 'Hipparcos',\n                        'distance_pc': 1000.0 / row['Plx'] if row['Plx'] > 0 else None,\n                        'distance_ly': (1000.0 / row['Plx']) * 3.26156 if row['Plx'] > 0 else None\n                    }\n                    \n                    # Add magnitude data if available\n                    if 'Vmag' in row.colnames and not np.isnan(row['Vmag']):\n                        props['V_magnitude'] = float(row['Vmag'])\n                    if 'B-V' in row.colnames and not np.isnan(row['B-V']):\n                        props['B_magnitude'] = float(row['Vmag'] + row['B-V'])\n                    \n                    all_properties[hip_id] = props\n            \n            elif 'gaia' in catalog.lower():\n                for row in table:\n                    gaia_id = f\"Gaia DR3 {row['Source']}\"\n                    \n                    props = {\n                        'unique_id': gaia_id,\n                        'Source_Catalog': 'Gaia',\n                        'distance_pc': 1000.0 / row['Plx'] if row['Plx'] > 0 else None,\n                        'distance_ly': (1000.0 / row['Plx']) * 3.26156 if row['Plx'] > 0 else None\n                    }\n                    \n                    # Convert Gaia magnitude to V magnitude (approximate)\n                    if 'Gmag' in row.colnames and not np.isnan(row['Gmag']):\n                        # Rough conversion: V ~ G - 0.2\n                        props['V_magnitude'] = float(row['Gmag']) - 0.2\n                    \n                    all_properties[gaia_id] = props\n        \n        # Now query SIMBAD for additional properties\n        missing_ids = list(all_properties.keys())\n        \n        if missing_ids and simbad_manager_instance:\n            logger.info(f\"Querying SIMBAD for {len(missing_ids)} stars...\")\n            \n            # Use existing SIMBAD query function with rate limiting\n            updated_properties = simbad_manager_instance.query_simbad_for_star_properties(\n                missing_ids, \n                all_properties, \n                properties_file\n            )\n            \n            return updated_properties\n        \n        # Save properties even without SIMBAD data\n        if all_properties:\n            simbad_manager_instance.safe_save_properties(all_properties, properties_file)\n        \n        return all_properties",
    "start_line": 44,
    "end_line": 380,
    "has_docstring": true,
    "docstring": "Manager for safe VOT cache file operations",
    "parameters": null,
    "node_type": "class",
    "base_classes": null,
    "class_name": null,
    "display_name": "class VOTCacheManager",
    "component_id": "vot_cache_manager.VOTCacheManager"
  },
  "vot_cache_manager.integrate_vot_protection_with_simbad_manager": {
    "id": "vot_cache_manager.integrate_vot_protection_with_simbad_manager",
    "name": "integrate_vot_protection_with_simbad_manager",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\vot_cache_manager.py",
    "relative_path": "vot_cache_manager.py",
    "depends_on": [
      "vot_cache_manager.VOTCacheManager"
    ],
    "source_code": "def integrate_vot_protection_with_simbad_manager(simbad_manager):\n    \"\"\"\n    Add VOT cache management methods to existing SimbadQueryManager.\n    \"\"\"\n    # Create VOT manager instance\n    vot_manager = VOTCacheManager()\n    \n    # Add as attribute to SimbadQueryManager\n    simbad_manager.vot_manager = vot_manager\n    \n    # Add convenience methods\n    def protect_vot_caches(self):\n        \"\"\"Protect all base VOT cache files\"\"\"\n        protected_count = 0\n        for vot_file in self.vot_manager.protected_files.keys():\n            filepath = os.path.join(self.vot_manager.cache_dir, vot_file)\n            if os.path.exists(filepath):\n                if self.vot_manager.protect_base_file(filepath):\n                    protected_count += 1\n        logger.info(f\"Protected {protected_count} VOT cache files\")\n        return protected_count\n    \n    def rebuild_properties_from_all_caches(self, mode='distance'):\n        \"\"\"Rebuild PKL properties from VOT and existing caches\"\"\"\n        if mode == 'distance':\n            properties_file = 'star_data/star_properties_distance.pkl'\n            vot_files = {\n                'hipparcos': 'hipparcos_data_distance.vot',\n                'gaia': 'gaia_data_distance.vot'\n            }\n        else:  # magnitude\n            properties_file = 'star_data/star_properties_magnitude.pkl'\n            vot_files = {\n                'hipparcos': 'hipparcos_data_magnitude.vot',\n                'gaia': 'gaia_data_magnitude.vot'\n            }\n        \n        return self.vot_manager.rebuild_pkl_from_caches(\n            properties_file, vot_files, self\n        )\n    \n    # Bind methods to instance\n    import types\n    simbad_manager.protect_vot_caches = types.MethodType(protect_vot_caches, simbad_manager)\n    simbad_manager.rebuild_properties_from_all_caches = types.MethodType(\n        rebuild_properties_from_all_caches, simbad_manager\n    )\n    \n    return simbad_manager",
    "start_line": 384,
    "end_line": 432,
    "has_docstring": true,
    "docstring": "Add VOT cache management methods to existing SimbadQueryManager.",
    "parameters": [
      "simbad_manager"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function integrate_vot_protection_with_simbad_manager",
    "component_id": "vot_cache_manager.integrate_vot_protection_with_simbad_manager"
  },
  "vot_cache_manager.protect_vot_caches": {
    "id": "vot_cache_manager.protect_vot_caches",
    "name": "protect_vot_caches",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\vot_cache_manager.py",
    "relative_path": "vot_cache_manager.py",
    "depends_on": [],
    "source_code": "    def protect_vot_caches(self):\n        \"\"\"Protect all base VOT cache files\"\"\"\n        protected_count = 0\n        for vot_file in self.vot_manager.protected_files.keys():\n            filepath = os.path.join(self.vot_manager.cache_dir, vot_file)\n            if os.path.exists(filepath):\n                if self.vot_manager.protect_base_file(filepath):\n                    protected_count += 1\n        logger.info(f\"Protected {protected_count} VOT cache files\")\n        return protected_count",
    "start_line": 395,
    "end_line": 404,
    "has_docstring": true,
    "docstring": "Protect all base VOT cache files",
    "parameters": [
      "self"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function protect_vot_caches",
    "component_id": "vot_cache_manager.protect_vot_caches"
  },
  "vot_cache_manager.rebuild_properties_from_all_caches": {
    "id": "vot_cache_manager.rebuild_properties_from_all_caches",
    "name": "rebuild_properties_from_all_caches",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\vot_cache_manager.py",
    "relative_path": "vot_cache_manager.py",
    "depends_on": [],
    "source_code": "    def rebuild_properties_from_all_caches(self, mode='distance'):\n        \"\"\"Rebuild PKL properties from VOT and existing caches\"\"\"\n        if mode == 'distance':\n            properties_file = 'star_data/star_properties_distance.pkl'\n            vot_files = {\n                'hipparcos': 'hipparcos_data_distance.vot',\n                'gaia': 'gaia_data_distance.vot'\n            }\n        else:  # magnitude\n            properties_file = 'star_data/star_properties_magnitude.pkl'\n            vot_files = {\n                'hipparcos': 'hipparcos_data_magnitude.vot',\n                'gaia': 'gaia_data_magnitude.vot'\n            }\n        \n        return self.vot_manager.rebuild_pkl_from_caches(\n            properties_file, vot_files, self\n        )",
    "start_line": 406,
    "end_line": 423,
    "has_docstring": true,
    "docstring": "Rebuild PKL properties from VOT and existing caches",
    "parameters": [
      "self",
      "mode"
    ],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function rebuild_properties_from_all_caches",
    "component_id": "vot_cache_manager.rebuild_properties_from_all_caches"
  },
  "vot_cache_manager.verify_vot_cache_integrity": {
    "id": "vot_cache_manager.verify_vot_cache_integrity",
    "name": "verify_vot_cache_integrity",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\vot_cache_manager.py",
    "relative_path": "vot_cache_manager.py",
    "depends_on": [
      "vot_cache_manager.VOTCacheManager"
    ],
    "source_code": "def verify_vot_cache_integrity():\n    \"\"\"Verify integrity of all VOT cache files\"\"\"\n    manager = VOTCacheManager()\n    results = {}\n    \n    for vot_file in manager.protected_files.keys():\n        filepath = os.path.join(manager.cache_dir, vot_file)\n        if os.path.exists(filepath):\n            table = manager.safe_load_vot(filepath)\n            if table is not None:\n                results[vot_file] = {\n                    'status': 'valid',\n                    'entries': len(table),\n                    'columns': table.colnames[:5]  # First 5 columns\n                }\n            else:\n                results[vot_file] = {'status': 'corrupted'}\n        else:\n            results[vot_file] = {'status': 'missing'}\n    \n    return results",
    "start_line": 436,
    "end_line": 456,
    "has_docstring": true,
    "docstring": "Verify integrity of all VOT cache files",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function verify_vot_cache_integrity",
    "component_id": "vot_cache_manager.verify_vot_cache_integrity"
  },
  "vot_cache_manager.create_vot_cache_report": {
    "id": "vot_cache_manager.create_vot_cache_report",
    "name": "create_vot_cache_report",
    "component_type": "function",
    "file_path": "C:\\Users\\tonyq\\OneDrive\\Desktop\\python_work\\palomas_orrery_for_github\\vot_cache_manager.py",
    "relative_path": "vot_cache_manager.py",
    "depends_on": [
      "vot_cache_manager.VOTCacheManager"
    ],
    "source_code": "def create_vot_cache_report():\n    \"\"\"Generate detailed report of VOT cache status\"\"\"\n    manager = VOTCacheManager()\n    report = []\n    report.append(\"=\" * 60)\n    report.append(\"VOT Cache Status Report\")\n    report.append(\"=\" * 60)\n    \n    total_size = 0\n    total_entries = 0\n    \n    for vot_file, info in manager.protected_files.items():\n        filepath = os.path.join(manager.cache_dir, vot_file)\n        report.append(f\"\\n{vot_file}:\")\n        report.append(f\"  Type: {info['type']}\")\n        report.append(f\"  Limit: {info['limit']}\")\n        report.append(f\"  Catalog: {info['catalog']}\")\n        \n        if os.path.exists(filepath):\n            size_mb = os.path.getsize(filepath) / (1024 * 1024)\n            total_size += size_mb\n            report.append(f\"  Size: {size_mb:.2f} MB\")\n            \n            table = manager.safe_load_vot(filepath)\n            if table:\n                total_entries += len(table)\n                report.append(f\"  Entries: {len(table):,}\")\n                report.append(f\"  Columns: {', '.join(table.colnames[:5])}...\")\n            else:\n                report.append(\"  Status: CORRUPTED\")\n        else:\n            report.append(\"  Status: MISSING\")\n        \n        # Check for backups\n        backup_files = [\n            filepath + '.backup',\n            filepath + '.protected_*'\n        ]\n        for pattern in backup_files:\n            import glob\n            matches = glob.glob(pattern)\n            if matches:\n                report.append(f\"  Backups: {len(matches)} found\")\n    \n    report.append(f\"\\n{'-' * 40}\")\n    report.append(f\"Total cache size: {total_size:.2f} MB\")\n    report.append(f\"Total entries: {total_entries:,}\")\n    report.append(\"=\" * 60)\n    \n    return \"\\n\".join(report)",
    "start_line": 459,
    "end_line": 508,
    "has_docstring": true,
    "docstring": "Generate detailed report of VOT cache status",
    "parameters": [],
    "node_type": "function",
    "base_classes": null,
    "class_name": null,
    "display_name": "function create_vot_cache_report",
    "component_id": "vot_cache_manager.create_vot_cache_report"
  }
}